/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/
// clang-format off
// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.
#include "uic_mqtt.h"
#include "sl_log.h"
#include "sl_status.h"
#include "json_helpers.hpp"

#include <iostream>
#include <sstream>
#include <string>
#include <string.h>
#include <unordered_map>
#include <vector>
#include <set>
#include <inttypes.h>
#include <stdexcept>

#include <boost/algorithm/string.hpp>

#include "dotdot_mqtt.h"
#include "dotdot_mqtt.hpp"
#include "dotdot_bitmap.hpp"
#include "dotdot_mqtt_command_helpers.hpp"
#include "dotdot_mqtt_parsing_helpers.hpp"
#include "dotdot_mqtt_attributes.h"
#include "dotdot_mqtt_translators.h"
#include "dotdot_mqtt_additional_value_names.hpp"

#include <nlohmann/json.hpp>

static constexpr char LOG_TAG[] = "dotdot_mqtt";
static constexpr char LOG_FMT_JSON_PARSE_FAIL[]
  = "by-unid %s::%s: Unable to parse JSON payload: check payload syntax";
static constexpr char LOG_FMT_JSON_ERROR[]
  = "by-unid %s::%s: Unable to parse JSON payload: %s";
static constexpr char EMPTY_VALUE_ARRAY[] = "{\"value\": []}";


// Callbacks pointers
static std::set<uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t> uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback;
static std::set<uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t> uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback;
static std::set<uic_mqtt_dotdot_basic_write_attributes_callback_t> uic_mqtt_dotdot_basic_write_attributes_callback;
static std::set<uic_mqtt_dotdot_basic_force_read_attributes_callback_t> uic_mqtt_dotdot_basic_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_set(const uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_unset(const uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t callback)
{
  uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback.erase(callback);
}
void uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_clear()
{
  uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback.clear();
}
std::set<uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t>& get_uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback()
{
  return uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback;
}

void uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback_set(const uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback_unset(const uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_t callback)
{
  uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback.erase(callback);
}
void uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback_clear()
{
  uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback.clear();
}

void uic_mqtt_dotdot_set_basic_write_attributes_callback(
  const uic_mqtt_dotdot_basic_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_basic_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_basic_write_attributes_callback(
  const uic_mqtt_dotdot_basic_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_basic_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_basic_write_attributes_callbacks()
{
  uic_mqtt_dotdot_basic_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_basic_write_attributes_callback_t>& get_uic_mqtt_dotdot_basic_write_attributes_callback()
{
  return uic_mqtt_dotdot_basic_write_attributes_callback;
}

void uic_mqtt_dotdot_set_basic_force_read_attributes_callback(
  const uic_mqtt_dotdot_basic_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_basic_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_basic_force_read_attributes_callback(
  const uic_mqtt_dotdot_basic_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_basic_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_basic_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_basic_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Basic/Commands/ResetToFactoryDefaults
void uic_mqtt_dotdot_on_basic_reset_to_factory_defaults(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Basic", "ResetToFactoryDefaults");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "ResetToFactoryDefaults", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "ResetToFactoryDefaults", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Basic/GeneratedCommands/ResetToFactoryDefaults
static void uic_mqtt_dotdot_on_generated_basic_reset_to_factory_defaults(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Basic", "ResetToFactoryDefaults");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "ResetToFactoryDefaults", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "ResetToFactoryDefaults", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Basic/Commands/WriteAttributes
void uic_mqtt_dotdot_on_basic_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_basic_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_basic_state_t new_state = {};
  uic_mqtt_dotdot_basic_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_basic_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Basic", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_basic_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_basic_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_basic_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_basic_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.zcl_version = true;
      force_update.application_version = true;
      force_update.stack_version = true;
      force_update.hw_version = true;
      force_update.manufacturer_name = true;
      force_update.model_identifier = true;
      force_update.date_code = true;
      force_update.power_source = true;
      force_update.generic_device_class = true;
      force_update.generic_device_type = true;
      force_update.product_code = true;
      force_update.producturl = true;
      force_update.manufacturer_version_details = true;
      force_update.serial_number = true;
      force_update.product_label = true;
      force_update.location_description = true;
      force_update.physical_environment = true;
      force_update.device_enabled = true;
      force_update.alarm_mask = true;
      force_update.disable_local_config = true;
      force_update.sw_buildid = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"ZCLVersion", &force_update.zcl_version },
        {"ApplicationVersion", &force_update.application_version },
        {"StackVersion", &force_update.stack_version },
        {"HWVersion", &force_update.hw_version },
        {"ManufacturerName", &force_update.manufacturer_name },
        {"ModelIdentifier", &force_update.model_identifier },
        {"DateCode", &force_update.date_code },
        {"PowerSource", &force_update.power_source },
        {"GenericDevice-Class", &force_update.generic_device_class },
        {"GenericDevice-Type", &force_update.generic_device_type },
        {"ProductCode", &force_update.product_code },
        {"ProductURL", &force_update.producturl },
        {"ManufacturerVersionDetails", &force_update.manufacturer_version_details },
        {"SerialNumber", &force_update.serial_number },
        {"ProductLabel", &force_update.product_label },
        {"LocationDescription", &force_update.location_description },
        {"PhysicalEnvironment", &force_update.physical_environment },
        {"DeviceEnabled", &force_update.device_enabled },
        {"AlarmMask", &force_update.alarm_mask },
        {"DisableLocalConfig", &force_update.disable_local_config },
        {"SWBuildID", &force_update.sw_buildid },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_basic_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Basic/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_basic_zcl_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(0,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(0,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ZCLVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ZCLVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_zcl_version_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/ZCLVersion";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_application_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(0,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(0,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ApplicationVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ApplicationVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_application_version_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/ApplicationVersion";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_stack_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(0,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(0,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/StackVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/StackVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_stack_version_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/StackVersion";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_hw_version_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(0,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(0,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/HWVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/HWVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_hw_version_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/HWVersion";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_manufacturer_name_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ManufacturerName", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ManufacturerName";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_manufacturer_name_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/ManufacturerName";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_model_identifier_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ModelIdentifier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ModelIdentifier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_model_identifier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/ModelIdentifier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_date_code_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/DateCode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/DateCode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_date_code_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/DateCode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_power_source_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef BASIC_POWER_SOURCE_ENUM_NAME_AVAILABLE
  jsn["value"] = basic_power_source_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for BASIC_POWER_SOURCE. Using number instead.");
  jsn["value"] = static_cast<BasicPowerSource>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/PowerSource", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/PowerSource";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_power_source_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/PowerSource";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_generic_device_class_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef BASIC_GENERIC_DEVICE_CLASS_ENUM_NAME_AVAILABLE
  jsn["value"] = basic_generic_device_class_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for BASIC_GENERIC_DEVICE_CLASS. Using number instead.");
  jsn["value"] = static_cast<BasicGenericDeviceClass>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/GenericDevice-Class", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/GenericDevice-Class";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_generic_device_class_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/GenericDevice-Class";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_generic_device_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef BASIC_GENERIC_DEVICE_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = basic_generic_device_type_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for BASIC_GENERIC_DEVICE_TYPE. Using number instead.");
  jsn["value"] = static_cast<BasicGenericDeviceType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/GenericDevice-Type", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/GenericDevice-Type";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_generic_device_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/GenericDevice-Type";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_product_code_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ProductCode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ProductCode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_product_code_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/ProductCode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_producturl_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ProductURL", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ProductURL";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_producturl_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/ProductURL";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_manufacturer_version_details_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ManufacturerVersionDetails", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ManufacturerVersionDetails";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_manufacturer_version_details_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/ManufacturerVersionDetails";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_serial_number_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/SerialNumber", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/SerialNumber";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_serial_number_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/SerialNumber";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_product_label_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/ProductLabel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/ProductLabel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_product_label_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/ProductLabel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_location_description_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/LocationDescription", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/LocationDescription";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_location_description_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/LocationDescription";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_physical_environment_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef BASIC_PHYSICAL_ENVIRONMENT_ENUM_NAME_AVAILABLE
  jsn["value"] = basic_physical_environment_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for BASIC_PHYSICAL_ENVIRONMENT. Using number instead.");
  jsn["value"] = static_cast<BasicPhysicalEnvironment>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/PhysicalEnvironment", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/PhysicalEnvironment";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_physical_environment_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/PhysicalEnvironment";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_device_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(0,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(0,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/DeviceEnabled", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/DeviceEnabled";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_device_enabled_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/DeviceEnabled";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BasicAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Basic/Attributes/AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_alarm_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/AlarmMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_disable_local_config_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BasicDisableLocalConfig.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/DisableLocalConfig", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Basic/Attributes/DisableLocalConfig";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_disable_local_config_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/DisableLocalConfig";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_basic_sw_buildid_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Basic/Attributes/SWBuildID", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Basic/Attributes/SWBuildID";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_basic_sw_buildid_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Basic/Attributes/SWBuildID";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_basic_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_basic_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Basic/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_basic_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_basic_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Basic/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_basic_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback.empty()) {
    subscription_topic = base_topic + "Basic/Commands/ResetToFactoryDefaults";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_basic_reset_to_factory_defaults);
  }
  if (!uic_mqtt_dotdot_basic_generated_reset_to_factory_defaults_callback.empty()) {
    subscription_topic = base_topic + "Basic/GeneratedCommands/ResetToFactoryDefaults";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_basic_reset_to_factory_defaults);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_basic_attributes_init();

  uic_mqtt_dotdot_by_group_basic_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_power_configuration_write_attributes_callback_t> uic_mqtt_dotdot_power_configuration_write_attributes_callback;
static std::set<uic_mqtt_dotdot_power_configuration_force_read_attributes_callback_t> uic_mqtt_dotdot_power_configuration_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_power_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_power_configuration_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_power_configuration_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_power_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_power_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_power_configuration_write_attributes_callbacks()
{
  uic_mqtt_dotdot_power_configuration_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_power_configuration_write_attributes_callback_t>& get_uic_mqtt_dotdot_power_configuration_write_attributes_callback()
{
  return uic_mqtt_dotdot_power_configuration_write_attributes_callback;
}

void uic_mqtt_dotdot_set_power_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_power_configuration_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_power_configuration_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_power_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_power_configuration_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_power_configuration_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_power_configuration_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_power_configuration_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/PowerConfiguration/Commands/WriteAttributes
void uic_mqtt_dotdot_on_power_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_power_configuration_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_power_configuration_state_t new_state = {};
  uic_mqtt_dotdot_power_configuration_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_power_configuration_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PowerConfiguration", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_power_configuration_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_power_configuration_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_power_configuration_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_power_configuration_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.mains_voltage = true;
      force_update.mains_frequency = true;
      force_update.mains_alarm_mask = true;
      force_update.mains_voltage_min_threshold = true;
      force_update.mains_voltage_max_threshold = true;
      force_update.mains_voltage_dwell_trip_point = true;
      force_update.battery_voltage = true;
      force_update.battery_percentage_remaining = true;
      force_update.battery_manufacturer = true;
      force_update.battery_size = true;
      force_update.batterya_hr_rating = true;
      force_update.battery_quantity = true;
      force_update.battery_rated_voltage = true;
      force_update.battery_alarm_mask = true;
      force_update.battery_voltage_min_threshold = true;
      force_update.battery_voltage_threshold1 = true;
      force_update.battery_voltage_threshold2 = true;
      force_update.battery_voltage_threshold3 = true;
      force_update.battery_percentage_min_threshold = true;
      force_update.battery_percentage_threshold1 = true;
      force_update.battery_percentage_threshold2 = true;
      force_update.battery_percentage_threshold3 = true;
      force_update.battery_alarm_state = true;
      force_update.battery2_voltage = true;
      force_update.battery2_percentage_remaining = true;
      force_update.battery2_manufacturer = true;
      force_update.battery2_size = true;
      force_update.battery2a_hr_rating = true;
      force_update.battery2_quantity = true;
      force_update.battery2_rated_voltage = true;
      force_update.battery2_alarm_mask = true;
      force_update.battery2_voltage_min_threshold = true;
      force_update.battery2_voltage_threshold1 = true;
      force_update.battery2_voltage_threshold2 = true;
      force_update.battery2_voltage_threshold3 = true;
      force_update.battery2_percentage_min_threshold = true;
      force_update.battery2_percentage_threshold1 = true;
      force_update.battery2_percentage_threshold2 = true;
      force_update.battery2_percentage_threshold3 = true;
      force_update.battery2_alarm_state = true;
      force_update.battery3_voltage = true;
      force_update.battery3_percentage_remaining = true;
      force_update.battery3_manufacturer = true;
      force_update.battery3_size = true;
      force_update.battery3a_hr_rating = true;
      force_update.battery3_quantity = true;
      force_update.battery3_rated_voltage = true;
      force_update.battery3_alarm_mask = true;
      force_update.battery3_voltage_min_threshold = true;
      force_update.battery3_voltage_threshold1 = true;
      force_update.battery3_voltage_threshold2 = true;
      force_update.battery3_voltage_threshold3 = true;
      force_update.battery3_percentage_min_threshold = true;
      force_update.battery3_percentage_threshold1 = true;
      force_update.battery3_percentage_threshold2 = true;
      force_update.battery3_percentage_threshold3 = true;
      force_update.battery3_alarm_state = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MainsVoltage", &force_update.mains_voltage },
        {"MainsFrequency", &force_update.mains_frequency },
        {"MainsAlarmMask", &force_update.mains_alarm_mask },
        {"MainsVoltageMinThreshold", &force_update.mains_voltage_min_threshold },
        {"MainsVoltageMaxThreshold", &force_update.mains_voltage_max_threshold },
        {"MainsVoltageDwellTripPoint", &force_update.mains_voltage_dwell_trip_point },
        {"BatteryVoltage", &force_update.battery_voltage },
        {"BatteryPercentageRemaining", &force_update.battery_percentage_remaining },
        {"BatteryManufacturer", &force_update.battery_manufacturer },
        {"BatterySize", &force_update.battery_size },
        {"BatteryAHrRating", &force_update.batterya_hr_rating },
        {"BatteryQuantity", &force_update.battery_quantity },
        {"BatteryRatedVoltage", &force_update.battery_rated_voltage },
        {"BatteryAlarmMask", &force_update.battery_alarm_mask },
        {"BatteryVoltageMinThreshold", &force_update.battery_voltage_min_threshold },
        {"BatteryVoltageThreshold1", &force_update.battery_voltage_threshold1 },
        {"BatteryVoltageThreshold2", &force_update.battery_voltage_threshold2 },
        {"BatteryVoltageThreshold3", &force_update.battery_voltage_threshold3 },
        {"BatteryPercentageMinThreshold", &force_update.battery_percentage_min_threshold },
        {"BatteryPercentageThreshold1", &force_update.battery_percentage_threshold1 },
        {"BatteryPercentageThreshold2", &force_update.battery_percentage_threshold2 },
        {"BatteryPercentageThreshold3", &force_update.battery_percentage_threshold3 },
        {"BatteryAlarmState", &force_update.battery_alarm_state },
        {"Battery2Voltage", &force_update.battery2_voltage },
        {"Battery2PercentageRemaining", &force_update.battery2_percentage_remaining },
        {"Battery2Manufacturer", &force_update.battery2_manufacturer },
        {"Battery2Size", &force_update.battery2_size },
        {"Battery2AHrRating", &force_update.battery2a_hr_rating },
        {"Battery2Quantity", &force_update.battery2_quantity },
        {"Battery2RatedVoltage", &force_update.battery2_rated_voltage },
        {"Battery2AlarmMask", &force_update.battery2_alarm_mask },
        {"Battery2VoltageMinThreshold", &force_update.battery2_voltage_min_threshold },
        {"Battery2VoltageThreshold1", &force_update.battery2_voltage_threshold1 },
        {"Battery2VoltageThreshold2", &force_update.battery2_voltage_threshold2 },
        {"Battery2VoltageThreshold3", &force_update.battery2_voltage_threshold3 },
        {"Battery2PercentageMinThreshold", &force_update.battery2_percentage_min_threshold },
        {"Battery2PercentageThreshold1", &force_update.battery2_percentage_threshold1 },
        {"Battery2PercentageThreshold2", &force_update.battery2_percentage_threshold2 },
        {"Battery2PercentageThreshold3", &force_update.battery2_percentage_threshold3 },
        {"Battery2AlarmState", &force_update.battery2_alarm_state },
        {"Battery3Voltage", &force_update.battery3_voltage },
        {"Battery3PercentageRemaining", &force_update.battery3_percentage_remaining },
        {"Battery3Manufacturer", &force_update.battery3_manufacturer },
        {"Battery3Size", &force_update.battery3_size },
        {"Battery3AHrRating", &force_update.battery3a_hr_rating },
        {"Battery3Quantity", &force_update.battery3_quantity },
        {"Battery3RatedVoltage", &force_update.battery3_rated_voltage },
        {"Battery3AlarmMask", &force_update.battery3_alarm_mask },
        {"Battery3VoltageMinThreshold", &force_update.battery3_voltage_min_threshold },
        {"Battery3VoltageThreshold1", &force_update.battery3_voltage_threshold1 },
        {"Battery3VoltageThreshold2", &force_update.battery3_voltage_threshold2 },
        {"Battery3VoltageThreshold3", &force_update.battery3_voltage_threshold3 },
        {"Battery3PercentageMinThreshold", &force_update.battery3_percentage_min_threshold },
        {"Battery3PercentageThreshold1", &force_update.battery3_percentage_threshold1 },
        {"Battery3PercentageThreshold2", &force_update.battery3_percentage_threshold2 },
        {"Battery3PercentageThreshold3", &force_update.battery3_percentage_threshold3 },
        {"Battery3AlarmState", &force_update.battery3_alarm_state },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_power_configuration_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "PowerConfiguration/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/MainsVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_mains_frequency_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsFrequency", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsFrequency";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_mains_frequency_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/MainsFrequency";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_mains_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = PowerConfigurationMainsAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsAlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsAlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_mains_alarm_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/MainsAlarmMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_min_threshold_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsVoltageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsVoltageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_min_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/MainsVoltageMinThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_max_threshold_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsVoltageMaxThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsVoltageMaxThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_max_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/MainsVoltageMaxThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_dwell_trip_point_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/MainsVoltageDwellTripPoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/MainsVoltageDwellTripPoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_mains_voltage_dwell_trip_point_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/MainsVoltageDwellTripPoint";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,32,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,32,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_remaining_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,33,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,33,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryPercentageRemaining", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryPercentageRemaining";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_remaining_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryPercentageRemaining";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryManufacturer", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryManufacturer";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_manufacturer_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryManufacturer";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_size_publish(
  const char *base_topic,
  BatterySize value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef POWER_CONFIGURATION_BATTERY_SIZE_ENUM_NAME_AVAILABLE
  jsn["value"] = power_configuration_battery_size_get_enum_value_name((uint32_t)value);
  #elif defined(BATTERY_SIZE_ENUM_NAME_AVAILABLE)
  jsn["value"] = battery_size_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for POWER_CONFIGURATION_BATTERY_SIZE. Using number instead.");
  jsn["value"] = static_cast<BatterySize>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatterySize", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatterySize";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_size_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatterySize";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_batterya_hr_rating_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,50,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,50,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryAHrRating", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryAHrRating";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_batterya_hr_rating_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryAHrRating";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,51,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,51,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryQuantity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryQuantity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_quantity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryQuantity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_rated_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,52,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,52,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryRatedVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryRatedVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_rated_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryRatedVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryAlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryAlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_alarm_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryAlarmMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,54,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,54,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryVoltageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryVoltageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_min_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryVoltageMinThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,55,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,55,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryVoltageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryVoltageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold1_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryVoltageThreshold1";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,56,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,56,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryVoltageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryVoltageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold2_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryVoltageThreshold2";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,57,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,57,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryVoltageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryVoltageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_voltage_threshold3_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryVoltageThreshold3";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,58,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,58,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryPercentageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryPercentageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_min_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryPercentageMinThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,59,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,59,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryPercentageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryPercentageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold1_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryPercentageThreshold1";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,60,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,60,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryPercentageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryPercentageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold2_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryPercentageThreshold2";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,61,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,61,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryPercentageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryPercentageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_percentage_threshold3_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryPercentageThreshold3";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery_alarm_state_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmState.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/BatteryAlarmState", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/BatteryAlarmState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery_alarm_state_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/BatteryAlarmState";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,64,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,64,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2Voltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2Voltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2Voltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_remaining_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,65,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,65,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2PercentageRemaining", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2PercentageRemaining";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_remaining_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2PercentageRemaining";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2Manufacturer", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2Manufacturer";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_manufacturer_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2Manufacturer";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_size_publish(
  const char *base_topic,
  BatterySize value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef POWER_CONFIGURATION_BATTERY2_SIZE_ENUM_NAME_AVAILABLE
  jsn["value"] = power_configuration_battery2_size_get_enum_value_name((uint32_t)value);
  #elif defined(BATTERY_SIZE_ENUM_NAME_AVAILABLE)
  jsn["value"] = battery_size_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for POWER_CONFIGURATION_BATTERY2_SIZE. Using number instead.");
  jsn["value"] = static_cast<BatterySize>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2Size", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2Size";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_size_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2Size";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2a_hr_rating_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,82,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,82,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2AHrRating", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2AHrRating";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2a_hr_rating_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2AHrRating";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,83,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,83,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2Quantity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2Quantity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_quantity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2Quantity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_rated_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,84,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,84,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2RatedVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2RatedVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_rated_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2RatedVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_alarm_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2AlarmMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,86,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,86,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2VoltageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2VoltageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_min_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2VoltageMinThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,87,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,87,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2VoltageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2VoltageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold1_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2VoltageThreshold1";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,88,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,88,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2VoltageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2VoltageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold2_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2VoltageThreshold2";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,89,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,89,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2VoltageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2VoltageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold3_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2VoltageThreshold3";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,90,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,90,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2PercentageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2PercentageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_min_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2PercentageMinThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,91,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,91,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2PercentageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2PercentageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold1_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2PercentageThreshold1";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,92,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,92,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2PercentageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2PercentageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold2_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2PercentageThreshold2";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,93,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,93,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2PercentageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2PercentageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold3_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2PercentageThreshold3";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_alarm_state_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmState.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery2AlarmState", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery2AlarmState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery2_alarm_state_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery2AlarmState";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,96,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,96,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3Voltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3Voltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3Voltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_remaining_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,97,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,97,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3PercentageRemaining", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3PercentageRemaining";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_remaining_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3PercentageRemaining";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3Manufacturer", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3Manufacturer";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_manufacturer_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3Manufacturer";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_size_publish(
  const char *base_topic,
  BatterySize value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef POWER_CONFIGURATION_BATTERY3_SIZE_ENUM_NAME_AVAILABLE
  jsn["value"] = power_configuration_battery3_size_get_enum_value_name((uint32_t)value);
  #elif defined(BATTERY_SIZE_ENUM_NAME_AVAILABLE)
  jsn["value"] = battery_size_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for POWER_CONFIGURATION_BATTERY3_SIZE. Using number instead.");
  jsn["value"] = static_cast<BatterySize>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3Size", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3Size";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_size_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3Size";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3a_hr_rating_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,114,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,114,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3AHrRating", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3AHrRating";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3a_hr_rating_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3AHrRating";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,115,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,115,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3Quantity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3Quantity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_quantity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3Quantity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_rated_voltage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,116,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,116,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3RatedVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3RatedVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_rated_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3RatedVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_alarm_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3AlarmMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,118,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,118,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3VoltageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3VoltageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_min_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3VoltageMinThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,119,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,119,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3VoltageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3VoltageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold1_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3VoltageThreshold1";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,120,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,120,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3VoltageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3VoltageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold2_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3VoltageThreshold2";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,121,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,121,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3VoltageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3VoltageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold3_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3VoltageThreshold3";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_min_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,122,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,122,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3PercentageMinThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3PercentageMinThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_min_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3PercentageMinThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold1_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,123,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,123,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3PercentageThreshold1", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3PercentageThreshold1";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold1_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3PercentageThreshold1";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold2_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,124,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,124,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3PercentageThreshold2", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3PercentageThreshold2";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold2_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3PercentageThreshold2";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold3_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1,125,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1,125,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3PercentageThreshold3", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3PercentageThreshold3";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold3_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3PercentageThreshold3";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_alarm_state_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BatteryAlarmState.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PowerConfiguration/Attributes/Battery3AlarmState", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PowerConfiguration/Attributes/Battery3AlarmState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_power_configuration_battery3_alarm_state_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/Battery3AlarmState";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_power_configuration_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_power_configuration_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "PowerConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_power_configuration_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_power_configuration_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "PowerConfiguration/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_power_configuration_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_power_configuration_attributes_init();

  uic_mqtt_dotdot_by_group_power_configuration_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback_t> uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback;
static std::set<uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback_t> uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_device_temperature_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_device_temperature_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_device_temperature_configuration_write_attributes_callbacks()
{
  uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback_t>& get_uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback()
{
  return uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback;
}

void uic_mqtt_dotdot_set_device_temperature_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_device_temperature_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_device_temperature_configuration_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/DeviceTemperatureConfiguration/Commands/WriteAttributes
void uic_mqtt_dotdot_on_device_temperature_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_device_temperature_configuration_state_t new_state = {};
  uic_mqtt_dotdot_device_temperature_configuration_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_device_temperature_configuration_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DeviceTemperatureConfiguration", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_device_temperature_configuration_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_device_temperature_configuration_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.current_temperature = true;
      force_update.min_temp_experienced = true;
      force_update.max_temp_experienced = true;
      force_update.over_temp_total_dwell = true;
      force_update.device_temp_alarm_mask = true;
      force_update.low_temp_threshold = true;
      force_update.high_temp_threshold = true;
      force_update.low_temp_dwell_trip_point = true;
      force_update.high_temp_dwell_trip_point = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"CurrentTemperature", &force_update.current_temperature },
        {"MinTempExperienced", &force_update.min_temp_experienced },
        {"MaxTempExperienced", &force_update.max_temp_experienced },
        {"OverTempTotalDwell", &force_update.over_temp_total_dwell },
        {"DeviceTempAlarmMask", &force_update.device_temp_alarm_mask },
        {"LowTempThreshold", &force_update.low_temp_threshold },
        {"HighTempThreshold", &force_update.high_temp_threshold },
        {"LowTempDwellTripPoint", &force_update.low_temp_dwell_trip_point },
        {"HighTempDwellTripPoint", &force_update.high_temp_dwell_trip_point },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "DeviceTemperatureConfiguration/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_current_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/CurrentTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/CurrentTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_current_temperature_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DeviceTemperatureConfiguration/Attributes/CurrentTemperature";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_min_temp_experienced_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/MinTempExperienced", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/MinTempExperienced";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_min_temp_experienced_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DeviceTemperatureConfiguration/Attributes/MinTempExperienced";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_max_temp_experienced_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/MaxTempExperienced", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/MaxTempExperienced";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_max_temp_experienced_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DeviceTemperatureConfiguration/Attributes/MaxTempExperienced";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_over_temp_total_dwell_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/OverTempTotalDwell", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/OverTempTotalDwell";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_over_temp_total_dwell_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DeviceTemperatureConfiguration/Attributes/OverTempTotalDwell";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_device_temp_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DeviceTemperatureConfigurationDeviceTempAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/DeviceTempAlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/DeviceTempAlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_device_temp_alarm_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DeviceTemperatureConfiguration/Attributes/DeviceTempAlarmMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_low_temp_threshold_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/LowTempThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/LowTempThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_low_temp_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DeviceTemperatureConfiguration/Attributes/LowTempThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_high_temp_threshold_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/HighTempThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/HighTempThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_high_temp_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DeviceTemperatureConfiguration/Attributes/HighTempThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_low_temp_dwell_trip_point_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/LowTempDwellTripPoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/LowTempDwellTripPoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_low_temp_dwell_trip_point_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DeviceTemperatureConfiguration/Attributes/LowTempDwellTripPoint";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_high_temp_dwell_trip_point_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2,20,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2,20,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DeviceTemperatureConfiguration/Attributes/HighTempDwellTripPoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/HighTempDwellTripPoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_device_temperature_configuration_high_temp_dwell_trip_point_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DeviceTemperatureConfiguration/Attributes/HighTempDwellTripPoint";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_device_temperature_configuration_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_device_temperature_configuration_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "DeviceTemperatureConfiguration/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_device_temperature_configuration_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_device_temperature_configuration_attributes_init();

  uic_mqtt_dotdot_by_group_device_temperature_configuration_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_identify_identify_callback_t> uic_mqtt_dotdot_identify_identify_callback;
static std::set<uic_mqtt_dotdot_identify_identify_callback_t> uic_mqtt_dotdot_identify_generated_identify_callback;
static std::set<uic_mqtt_dotdot_identify_identify_query_response_callback_t> uic_mqtt_dotdot_identify_identify_query_response_callback;
static std::set<uic_mqtt_dotdot_identify_identify_query_response_callback_t> uic_mqtt_dotdot_identify_generated_identify_query_response_callback;
static std::set<uic_mqtt_dotdot_identify_identify_query_callback_t> uic_mqtt_dotdot_identify_identify_query_callback;
static std::set<uic_mqtt_dotdot_identify_identify_query_callback_t> uic_mqtt_dotdot_identify_generated_identify_query_callback;
static std::set<uic_mqtt_dotdot_identify_trigger_effect_callback_t> uic_mqtt_dotdot_identify_trigger_effect_callback;
static std::set<uic_mqtt_dotdot_identify_trigger_effect_callback_t> uic_mqtt_dotdot_identify_generated_trigger_effect_callback;
static std::set<uic_mqtt_dotdot_identify_write_attributes_callback_t> uic_mqtt_dotdot_identify_write_attributes_callback;
static std::set<uic_mqtt_dotdot_identify_force_read_attributes_callback_t> uic_mqtt_dotdot_identify_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_identify_identify_callback_set(const uic_mqtt_dotdot_identify_identify_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_identify_identify_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_identify_identify_callback_unset(const uic_mqtt_dotdot_identify_identify_callback_t callback)
{
  uic_mqtt_dotdot_identify_identify_callback.erase(callback);
}
void uic_mqtt_dotdot_identify_identify_callback_clear()
{
  uic_mqtt_dotdot_identify_identify_callback.clear();
}
std::set<uic_mqtt_dotdot_identify_identify_callback_t>& get_uic_mqtt_dotdot_identify_identify_callback()
{
  return uic_mqtt_dotdot_identify_identify_callback;
}

void uic_mqtt_dotdot_identify_generated_identify_callback_set(const uic_mqtt_dotdot_identify_identify_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_identify_generated_identify_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_identify_generated_identify_callback_unset(const uic_mqtt_dotdot_identify_identify_callback_t callback)
{
  uic_mqtt_dotdot_identify_generated_identify_callback.erase(callback);
}
void uic_mqtt_dotdot_identify_generated_identify_callback_clear()
{
  uic_mqtt_dotdot_identify_generated_identify_callback.clear();
}
void uic_mqtt_dotdot_identify_identify_query_response_callback_set(const uic_mqtt_dotdot_identify_identify_query_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_identify_identify_query_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_identify_identify_query_response_callback_unset(const uic_mqtt_dotdot_identify_identify_query_response_callback_t callback)
{
  uic_mqtt_dotdot_identify_identify_query_response_callback.erase(callback);
}
void uic_mqtt_dotdot_identify_identify_query_response_callback_clear()
{
  uic_mqtt_dotdot_identify_identify_query_response_callback.clear();
}
std::set<uic_mqtt_dotdot_identify_identify_query_response_callback_t>& get_uic_mqtt_dotdot_identify_identify_query_response_callback()
{
  return uic_mqtt_dotdot_identify_identify_query_response_callback;
}

void uic_mqtt_dotdot_identify_generated_identify_query_response_callback_set(const uic_mqtt_dotdot_identify_identify_query_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_identify_generated_identify_query_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_identify_generated_identify_query_response_callback_unset(const uic_mqtt_dotdot_identify_identify_query_response_callback_t callback)
{
  uic_mqtt_dotdot_identify_generated_identify_query_response_callback.erase(callback);
}
void uic_mqtt_dotdot_identify_generated_identify_query_response_callback_clear()
{
  uic_mqtt_dotdot_identify_generated_identify_query_response_callback.clear();
}
void uic_mqtt_dotdot_identify_identify_query_callback_set(const uic_mqtt_dotdot_identify_identify_query_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_identify_identify_query_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_identify_identify_query_callback_unset(const uic_mqtt_dotdot_identify_identify_query_callback_t callback)
{
  uic_mqtt_dotdot_identify_identify_query_callback.erase(callback);
}
void uic_mqtt_dotdot_identify_identify_query_callback_clear()
{
  uic_mqtt_dotdot_identify_identify_query_callback.clear();
}
std::set<uic_mqtt_dotdot_identify_identify_query_callback_t>& get_uic_mqtt_dotdot_identify_identify_query_callback()
{
  return uic_mqtt_dotdot_identify_identify_query_callback;
}

void uic_mqtt_dotdot_identify_generated_identify_query_callback_set(const uic_mqtt_dotdot_identify_identify_query_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_identify_generated_identify_query_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_identify_generated_identify_query_callback_unset(const uic_mqtt_dotdot_identify_identify_query_callback_t callback)
{
  uic_mqtt_dotdot_identify_generated_identify_query_callback.erase(callback);
}
void uic_mqtt_dotdot_identify_generated_identify_query_callback_clear()
{
  uic_mqtt_dotdot_identify_generated_identify_query_callback.clear();
}
void uic_mqtt_dotdot_identify_trigger_effect_callback_set(const uic_mqtt_dotdot_identify_trigger_effect_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_identify_trigger_effect_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_identify_trigger_effect_callback_unset(const uic_mqtt_dotdot_identify_trigger_effect_callback_t callback)
{
  uic_mqtt_dotdot_identify_trigger_effect_callback.erase(callback);
}
void uic_mqtt_dotdot_identify_trigger_effect_callback_clear()
{
  uic_mqtt_dotdot_identify_trigger_effect_callback.clear();
}
std::set<uic_mqtt_dotdot_identify_trigger_effect_callback_t>& get_uic_mqtt_dotdot_identify_trigger_effect_callback()
{
  return uic_mqtt_dotdot_identify_trigger_effect_callback;
}

void uic_mqtt_dotdot_identify_generated_trigger_effect_callback_set(const uic_mqtt_dotdot_identify_trigger_effect_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_identify_generated_trigger_effect_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_identify_generated_trigger_effect_callback_unset(const uic_mqtt_dotdot_identify_trigger_effect_callback_t callback)
{
  uic_mqtt_dotdot_identify_generated_trigger_effect_callback.erase(callback);
}
void uic_mqtt_dotdot_identify_generated_trigger_effect_callback_clear()
{
  uic_mqtt_dotdot_identify_generated_trigger_effect_callback.clear();
}

void uic_mqtt_dotdot_set_identify_write_attributes_callback(
  const uic_mqtt_dotdot_identify_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_identify_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_identify_write_attributes_callback(
  const uic_mqtt_dotdot_identify_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_identify_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_identify_write_attributes_callbacks()
{
  uic_mqtt_dotdot_identify_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_identify_write_attributes_callback_t>& get_uic_mqtt_dotdot_identify_write_attributes_callback()
{
  return uic_mqtt_dotdot_identify_write_attributes_callback;
}

void uic_mqtt_dotdot_set_identify_force_read_attributes_callback(
  const uic_mqtt_dotdot_identify_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_identify_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_identify_force_read_attributes_callback(
  const uic_mqtt_dotdot_identify_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_identify_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_identify_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_identify_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Identify/Commands/Identify
void uic_mqtt_dotdot_on_identify_identify(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_identify_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t identify_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_identify(
      jsn,
      identify_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "Identify");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "Identify", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "Identify", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_identify_identify_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      identify_time
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Identify/GeneratedCommands/Identify
static void uic_mqtt_dotdot_on_generated_identify_identify(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_generated_identify_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t identify_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_identify(
      jsn,
      identify_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "Identify");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "Identify", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "Identify", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_identify_generated_identify_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      identify_time
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Identify/Commands/IdentifyQueryResponse
void uic_mqtt_dotdot_on_identify_identify_query_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_identify_query_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t timeout = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_identify_query_response(
      jsn,
      timeout
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "IdentifyQueryResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQueryResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQueryResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_identify_identify_query_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      timeout
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Identify/GeneratedCommands/IdentifyQueryResponse
static void uic_mqtt_dotdot_on_generated_identify_identify_query_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_generated_identify_query_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t timeout = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_identify_query_response(
      jsn,
      timeout
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "IdentifyQueryResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQueryResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQueryResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_identify_generated_identify_query_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      timeout
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Identify/Commands/IdentifyQuery
void uic_mqtt_dotdot_on_identify_identify_query(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_identify_query_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "IdentifyQuery");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQuery", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQuery", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_identify_identify_query_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Identify/GeneratedCommands/IdentifyQuery
static void uic_mqtt_dotdot_on_generated_identify_identify_query(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_generated_identify_query_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "IdentifyQuery");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQuery", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "IdentifyQuery", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_identify_generated_identify_query_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Identify/Commands/TriggerEffect
void uic_mqtt_dotdot_on_identify_trigger_effect(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_trigger_effect_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  TriggerEffectEffectIdentifier effect_identifier = {};
  TriggerEffectEffectVariant effect_variant = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_trigger_effect(
      jsn,
      effect_identifier,

      effect_variant
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "TriggerEffect");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "TriggerEffect", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "TriggerEffect", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_identify_trigger_effect_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      effect_identifier,
  
      effect_variant
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Identify/GeneratedCommands/TriggerEffect
static void uic_mqtt_dotdot_on_generated_identify_trigger_effect(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_identify_generated_trigger_effect_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  TriggerEffectEffectIdentifier effect_identifier = {};
  TriggerEffectEffectVariant effect_variant = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_identify_trigger_effect(
      jsn,
      effect_identifier,

      effect_variant
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "TriggerEffect");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "TriggerEffect", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "TriggerEffect", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_identify_generated_trigger_effect_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      effect_identifier,
  
      effect_variant
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Identify/Commands/WriteAttributes
void uic_mqtt_dotdot_on_identify_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_identify_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_identify_state_t new_state = {};
  uic_mqtt_dotdot_identify_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_identify_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Identify", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_identify_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_identify_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_identify_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_identify_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.identify_time = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"IdentifyTime", &force_update.identify_time },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_identify_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Identify/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_identify_identify_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(3,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(3,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Identify/Attributes/IdentifyTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Identify/Attributes/IdentifyTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_identify_identify_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Identify/Attributes/IdentifyTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_identify_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_identify_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Identify/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_identify_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Identify/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_identify_identify_callback.empty()) {
    subscription_topic = base_topic + "Identify/Commands/Identify";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_identify);
  }
  if (!uic_mqtt_dotdot_identify_generated_identify_callback.empty()) {
    subscription_topic = base_topic + "Identify/GeneratedCommands/Identify";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_identify_identify);
  }
  if (!uic_mqtt_dotdot_identify_identify_query_response_callback.empty()) {
    subscription_topic = base_topic + "Identify/Commands/IdentifyQueryResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_identify_query_response);
  }
  if (!uic_mqtt_dotdot_identify_generated_identify_query_response_callback.empty()) {
    subscription_topic = base_topic + "Identify/GeneratedCommands/IdentifyQueryResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_identify_identify_query_response);
  }
  if (!uic_mqtt_dotdot_identify_identify_query_callback.empty()) {
    subscription_topic = base_topic + "Identify/Commands/IdentifyQuery";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_identify_query);
  }
  if (!uic_mqtt_dotdot_identify_generated_identify_query_callback.empty()) {
    subscription_topic = base_topic + "Identify/GeneratedCommands/IdentifyQuery";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_identify_identify_query);
  }
  if (!uic_mqtt_dotdot_identify_trigger_effect_callback.empty()) {
    subscription_topic = base_topic + "Identify/Commands/TriggerEffect";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_identify_trigger_effect);
  }
  if (!uic_mqtt_dotdot_identify_generated_trigger_effect_callback.empty()) {
    subscription_topic = base_topic + "Identify/GeneratedCommands/TriggerEffect";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_identify_trigger_effect);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_identify_attributes_init();

  uic_mqtt_dotdot_by_group_identify_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_groups_add_group_callback_t> uic_mqtt_dotdot_groups_add_group_callback;
static std::set<uic_mqtt_dotdot_groups_add_group_callback_t> uic_mqtt_dotdot_groups_generated_add_group_callback;
static std::set<uic_mqtt_dotdot_groups_add_group_response_callback_t> uic_mqtt_dotdot_groups_add_group_response_callback;
static std::set<uic_mqtt_dotdot_groups_add_group_response_callback_t> uic_mqtt_dotdot_groups_generated_add_group_response_callback;
static std::set<uic_mqtt_dotdot_groups_view_group_callback_t> uic_mqtt_dotdot_groups_view_group_callback;
static std::set<uic_mqtt_dotdot_groups_view_group_callback_t> uic_mqtt_dotdot_groups_generated_view_group_callback;
static std::set<uic_mqtt_dotdot_groups_view_group_response_callback_t> uic_mqtt_dotdot_groups_view_group_response_callback;
static std::set<uic_mqtt_dotdot_groups_view_group_response_callback_t> uic_mqtt_dotdot_groups_generated_view_group_response_callback;
static std::set<uic_mqtt_dotdot_groups_get_group_membership_callback_t> uic_mqtt_dotdot_groups_get_group_membership_callback;
static std::set<uic_mqtt_dotdot_groups_get_group_membership_callback_t> uic_mqtt_dotdot_groups_generated_get_group_membership_callback;
static std::set<uic_mqtt_dotdot_groups_get_group_membership_response_callback_t> uic_mqtt_dotdot_groups_get_group_membership_response_callback;
static std::set<uic_mqtt_dotdot_groups_get_group_membership_response_callback_t> uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback;
static std::set<uic_mqtt_dotdot_groups_remove_group_callback_t> uic_mqtt_dotdot_groups_remove_group_callback;
static std::set<uic_mqtt_dotdot_groups_remove_group_callback_t> uic_mqtt_dotdot_groups_generated_remove_group_callback;
static std::set<uic_mqtt_dotdot_groups_remove_group_response_callback_t> uic_mqtt_dotdot_groups_remove_group_response_callback;
static std::set<uic_mqtt_dotdot_groups_remove_group_response_callback_t> uic_mqtt_dotdot_groups_generated_remove_group_response_callback;
static std::set<uic_mqtt_dotdot_groups_remove_all_groups_callback_t> uic_mqtt_dotdot_groups_remove_all_groups_callback;
static std::set<uic_mqtt_dotdot_groups_remove_all_groups_callback_t> uic_mqtt_dotdot_groups_generated_remove_all_groups_callback;
static std::set<uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t> uic_mqtt_dotdot_groups_add_group_if_identifying_callback;
static std::set<uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t> uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback;
static std::set<uic_mqtt_dotdot_groups_write_attributes_callback_t> uic_mqtt_dotdot_groups_write_attributes_callback;
static std::set<uic_mqtt_dotdot_groups_force_read_attributes_callback_t> uic_mqtt_dotdot_groups_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_groups_add_group_callback_set(const uic_mqtt_dotdot_groups_add_group_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_add_group_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_add_group_callback_unset(const uic_mqtt_dotdot_groups_add_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_add_group_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_add_group_callback_clear()
{
  uic_mqtt_dotdot_groups_add_group_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_add_group_callback_t>& get_uic_mqtt_dotdot_groups_add_group_callback()
{
  return uic_mqtt_dotdot_groups_add_group_callback;
}

void uic_mqtt_dotdot_groups_generated_add_group_callback_set(const uic_mqtt_dotdot_groups_add_group_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_generated_add_group_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_generated_add_group_callback_unset(const uic_mqtt_dotdot_groups_add_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_add_group_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_generated_add_group_callback_clear()
{
  uic_mqtt_dotdot_groups_generated_add_group_callback.clear();
}
void uic_mqtt_dotdot_groups_add_group_response_callback_set(const uic_mqtt_dotdot_groups_add_group_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_add_group_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_add_group_response_callback_unset(const uic_mqtt_dotdot_groups_add_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_add_group_response_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_add_group_response_callback_clear()
{
  uic_mqtt_dotdot_groups_add_group_response_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_add_group_response_callback_t>& get_uic_mqtt_dotdot_groups_add_group_response_callback()
{
  return uic_mqtt_dotdot_groups_add_group_response_callback;
}

void uic_mqtt_dotdot_groups_generated_add_group_response_callback_set(const uic_mqtt_dotdot_groups_add_group_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_generated_add_group_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_generated_add_group_response_callback_unset(const uic_mqtt_dotdot_groups_add_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_add_group_response_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_generated_add_group_response_callback_clear()
{
  uic_mqtt_dotdot_groups_generated_add_group_response_callback.clear();
}
void uic_mqtt_dotdot_groups_view_group_callback_set(const uic_mqtt_dotdot_groups_view_group_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_view_group_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_view_group_callback_unset(const uic_mqtt_dotdot_groups_view_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_view_group_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_view_group_callback_clear()
{
  uic_mqtt_dotdot_groups_view_group_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_view_group_callback_t>& get_uic_mqtt_dotdot_groups_view_group_callback()
{
  return uic_mqtt_dotdot_groups_view_group_callback;
}

void uic_mqtt_dotdot_groups_generated_view_group_callback_set(const uic_mqtt_dotdot_groups_view_group_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_generated_view_group_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_generated_view_group_callback_unset(const uic_mqtt_dotdot_groups_view_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_view_group_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_generated_view_group_callback_clear()
{
  uic_mqtt_dotdot_groups_generated_view_group_callback.clear();
}
void uic_mqtt_dotdot_groups_view_group_response_callback_set(const uic_mqtt_dotdot_groups_view_group_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_view_group_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_view_group_response_callback_unset(const uic_mqtt_dotdot_groups_view_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_view_group_response_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_view_group_response_callback_clear()
{
  uic_mqtt_dotdot_groups_view_group_response_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_view_group_response_callback_t>& get_uic_mqtt_dotdot_groups_view_group_response_callback()
{
  return uic_mqtt_dotdot_groups_view_group_response_callback;
}

void uic_mqtt_dotdot_groups_generated_view_group_response_callback_set(const uic_mqtt_dotdot_groups_view_group_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_generated_view_group_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_generated_view_group_response_callback_unset(const uic_mqtt_dotdot_groups_view_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_view_group_response_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_generated_view_group_response_callback_clear()
{
  uic_mqtt_dotdot_groups_generated_view_group_response_callback.clear();
}
void uic_mqtt_dotdot_groups_get_group_membership_callback_set(const uic_mqtt_dotdot_groups_get_group_membership_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_get_group_membership_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_get_group_membership_callback_unset(const uic_mqtt_dotdot_groups_get_group_membership_callback_t callback)
{
  uic_mqtt_dotdot_groups_get_group_membership_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_get_group_membership_callback_clear()
{
  uic_mqtt_dotdot_groups_get_group_membership_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_get_group_membership_callback_t>& get_uic_mqtt_dotdot_groups_get_group_membership_callback()
{
  return uic_mqtt_dotdot_groups_get_group_membership_callback;
}

void uic_mqtt_dotdot_groups_generated_get_group_membership_callback_set(const uic_mqtt_dotdot_groups_get_group_membership_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_generated_get_group_membership_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_generated_get_group_membership_callback_unset(const uic_mqtt_dotdot_groups_get_group_membership_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_get_group_membership_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_generated_get_group_membership_callback_clear()
{
  uic_mqtt_dotdot_groups_generated_get_group_membership_callback.clear();
}
void uic_mqtt_dotdot_groups_get_group_membership_response_callback_set(const uic_mqtt_dotdot_groups_get_group_membership_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_get_group_membership_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_get_group_membership_response_callback_unset(const uic_mqtt_dotdot_groups_get_group_membership_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_get_group_membership_response_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_get_group_membership_response_callback_clear()
{
  uic_mqtt_dotdot_groups_get_group_membership_response_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_get_group_membership_response_callback_t>& get_uic_mqtt_dotdot_groups_get_group_membership_response_callback()
{
  return uic_mqtt_dotdot_groups_get_group_membership_response_callback;
}

void uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback_set(const uic_mqtt_dotdot_groups_get_group_membership_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback_unset(const uic_mqtt_dotdot_groups_get_group_membership_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback_clear()
{
  uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback.clear();
}
void uic_mqtt_dotdot_groups_remove_group_callback_set(const uic_mqtt_dotdot_groups_remove_group_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_remove_group_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_remove_group_callback_unset(const uic_mqtt_dotdot_groups_remove_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_remove_group_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_remove_group_callback_clear()
{
  uic_mqtt_dotdot_groups_remove_group_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_remove_group_callback_t>& get_uic_mqtt_dotdot_groups_remove_group_callback()
{
  return uic_mqtt_dotdot_groups_remove_group_callback;
}

void uic_mqtt_dotdot_groups_generated_remove_group_callback_set(const uic_mqtt_dotdot_groups_remove_group_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_generated_remove_group_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_generated_remove_group_callback_unset(const uic_mqtt_dotdot_groups_remove_group_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_remove_group_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_generated_remove_group_callback_clear()
{
  uic_mqtt_dotdot_groups_generated_remove_group_callback.clear();
}
void uic_mqtt_dotdot_groups_remove_group_response_callback_set(const uic_mqtt_dotdot_groups_remove_group_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_remove_group_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_remove_group_response_callback_unset(const uic_mqtt_dotdot_groups_remove_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_remove_group_response_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_remove_group_response_callback_clear()
{
  uic_mqtt_dotdot_groups_remove_group_response_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_remove_group_response_callback_t>& get_uic_mqtt_dotdot_groups_remove_group_response_callback()
{
  return uic_mqtt_dotdot_groups_remove_group_response_callback;
}

void uic_mqtt_dotdot_groups_generated_remove_group_response_callback_set(const uic_mqtt_dotdot_groups_remove_group_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_generated_remove_group_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_generated_remove_group_response_callback_unset(const uic_mqtt_dotdot_groups_remove_group_response_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_remove_group_response_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_generated_remove_group_response_callback_clear()
{
  uic_mqtt_dotdot_groups_generated_remove_group_response_callback.clear();
}
void uic_mqtt_dotdot_groups_remove_all_groups_callback_set(const uic_mqtt_dotdot_groups_remove_all_groups_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_remove_all_groups_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_remove_all_groups_callback_unset(const uic_mqtt_dotdot_groups_remove_all_groups_callback_t callback)
{
  uic_mqtt_dotdot_groups_remove_all_groups_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_remove_all_groups_callback_clear()
{
  uic_mqtt_dotdot_groups_remove_all_groups_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_remove_all_groups_callback_t>& get_uic_mqtt_dotdot_groups_remove_all_groups_callback()
{
  return uic_mqtt_dotdot_groups_remove_all_groups_callback;
}

void uic_mqtt_dotdot_groups_generated_remove_all_groups_callback_set(const uic_mqtt_dotdot_groups_remove_all_groups_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_generated_remove_all_groups_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_generated_remove_all_groups_callback_unset(const uic_mqtt_dotdot_groups_remove_all_groups_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_remove_all_groups_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_generated_remove_all_groups_callback_clear()
{
  uic_mqtt_dotdot_groups_generated_remove_all_groups_callback.clear();
}
void uic_mqtt_dotdot_groups_add_group_if_identifying_callback_set(const uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_add_group_if_identifying_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_add_group_if_identifying_callback_unset(const uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t callback)
{
  uic_mqtt_dotdot_groups_add_group_if_identifying_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_add_group_if_identifying_callback_clear()
{
  uic_mqtt_dotdot_groups_add_group_if_identifying_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t>& get_uic_mqtt_dotdot_groups_add_group_if_identifying_callback()
{
  return uic_mqtt_dotdot_groups_add_group_if_identifying_callback;
}

void uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback_set(const uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback_unset(const uic_mqtt_dotdot_groups_add_group_if_identifying_callback_t callback)
{
  uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback.erase(callback);
}
void uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback_clear()
{
  uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback.clear();
}

void uic_mqtt_dotdot_set_groups_write_attributes_callback(
  const uic_mqtt_dotdot_groups_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_groups_write_attributes_callback(
  const uic_mqtt_dotdot_groups_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_groups_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_groups_write_attributes_callbacks()
{
  uic_mqtt_dotdot_groups_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_groups_write_attributes_callback_t>& get_uic_mqtt_dotdot_groups_write_attributes_callback()
{
  return uic_mqtt_dotdot_groups_write_attributes_callback;
}

void uic_mqtt_dotdot_set_groups_force_read_attributes_callback(
  const uic_mqtt_dotdot_groups_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_groups_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_groups_force_read_attributes_callback(
  const uic_mqtt_dotdot_groups_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_groups_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_groups_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_groups_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/AddGroup
void uic_mqtt_dotdot_on_groups_add_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_add_group_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};
  std::string group_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group(
      jsn,
      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroup", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_groups_add_group_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      group_id,
  
      group_name.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/AddGroup
static void uic_mqtt_dotdot_on_generated_groups_add_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_add_group_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};
  std::string group_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group(
      jsn,
      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroup", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_groups_generated_add_group_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      group_id,
  
      group_name.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/AddGroupResponse
void uic_mqtt_dotdot_on_groups_add_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_add_group_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status = {};
  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group_response(
      jsn,
      status,

      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_groups_add_group_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      group_id
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/AddGroupResponse
static void uic_mqtt_dotdot_on_generated_groups_add_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_add_group_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status = {};
  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group_response(
      jsn,
      status,

      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_groups_generated_add_group_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      group_id
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/ViewGroup
void uic_mqtt_dotdot_on_groups_view_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_view_group_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_view_group(
      jsn,
      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "ViewGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroup", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_groups_view_group_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      group_id
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/ViewGroup
static void uic_mqtt_dotdot_on_generated_groups_view_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_view_group_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_view_group(
      jsn,
      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "ViewGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroup", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_groups_generated_view_group_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      group_id
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/ViewGroupResponse
void uic_mqtt_dotdot_on_groups_view_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_view_group_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status = {};
  uint16_t group_id = {};
  std::string group_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_view_group_response(
      jsn,
      status,

      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "ViewGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroupResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_groups_view_group_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      group_id,
  
      group_name.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/ViewGroupResponse
static void uic_mqtt_dotdot_on_generated_groups_view_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_view_group_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status = {};
  uint16_t group_id = {};
  std::string group_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_view_group_response(
      jsn,
      status,

      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "ViewGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "ViewGroupResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_groups_generated_view_group_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      group_id,
  
      group_name.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/GetGroupMembership
void uic_mqtt_dotdot_on_groups_get_group_membership(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_get_group_membership_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::vector<uint16_t> group_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_get_group_membership(
      jsn,
      group_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "GetGroupMembership");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembership", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembership", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_groups_get_group_membership_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      group_list.size(),
      group_list.data()

    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/GetGroupMembership
static void uic_mqtt_dotdot_on_generated_groups_get_group_membership(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_get_group_membership_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::vector<uint16_t> group_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_get_group_membership(
      jsn,
      group_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "GetGroupMembership");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembership", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembership", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_groups_generated_get_group_membership_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      group_list.size(),
      group_list.data()

    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/GetGroupMembershipResponse
void uic_mqtt_dotdot_on_groups_get_group_membership_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_get_group_membership_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t capacity = {};
  std::vector<uint16_t> group_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_get_group_membership_response(
      jsn,
      capacity,

      group_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "GetGroupMembershipResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembershipResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembershipResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_groups_get_group_membership_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      capacity,
  
      group_list.size(),
      group_list.data()

    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/GetGroupMembershipResponse
static void uic_mqtt_dotdot_on_generated_groups_get_group_membership_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t capacity = {};
  std::vector<uint16_t> group_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_get_group_membership_response(
      jsn,
      capacity,

      group_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "GetGroupMembershipResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembershipResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "GetGroupMembershipResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      capacity,
  
      group_list.size(),
      group_list.data()

    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/RemoveGroup
void uic_mqtt_dotdot_on_groups_remove_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_remove_group_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_remove_group(
      jsn,
      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroup", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_groups_remove_group_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      group_id
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/RemoveGroup
static void uic_mqtt_dotdot_on_generated_groups_remove_group(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_remove_group_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_remove_group(
      jsn,
      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveGroup");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroup", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroup", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_groups_generated_remove_group_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      group_id
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/RemoveGroupResponse
void uic_mqtt_dotdot_on_groups_remove_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_remove_group_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status = {};
  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_remove_group_response(
      jsn,
      status,

      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroupResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_groups_remove_group_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      group_id
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/RemoveGroupResponse
static void uic_mqtt_dotdot_on_generated_groups_remove_group_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_remove_group_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t status = {};
  uint16_t group_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_remove_group_response(
      jsn,
      status,

      group_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveGroupResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroupResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveGroupResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_groups_generated_remove_group_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      group_id
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/RemoveAllGroups
void uic_mqtt_dotdot_on_groups_remove_all_groups(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_remove_all_groups_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveAllGroups");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveAllGroups", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveAllGroups", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_groups_remove_all_groups_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/RemoveAllGroups
static void uic_mqtt_dotdot_on_generated_groups_remove_all_groups(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_remove_all_groups_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "RemoveAllGroups");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveAllGroups", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "RemoveAllGroups", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_groups_generated_remove_all_groups_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/AddGroupIfIdentifying
void uic_mqtt_dotdot_on_groups_add_group_if_identifying(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_add_group_if_identifying_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};
  std::string group_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group_if_identifying(
      jsn,
      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroupIfIdentifying");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupIfIdentifying", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupIfIdentifying", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_groups_add_group_if_identifying_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      group_id,
  
      group_name.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Groups/GeneratedCommands/AddGroupIfIdentifying
static void uic_mqtt_dotdot_on_generated_groups_add_group_if_identifying(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t group_id = {};
  std::string group_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_groups_add_group_if_identifying(
      jsn,
      group_id,

      group_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "AddGroupIfIdentifying");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupIfIdentifying", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "AddGroupIfIdentifying", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      group_id,
  
      group_name.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Groups/Commands/WriteAttributes
void uic_mqtt_dotdot_on_groups_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_groups_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_groups_state_t new_state = {};
  uic_mqtt_dotdot_groups_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_groups_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Groups", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_groups_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_groups_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_groups_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_groups_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.name_support = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"NameSupport", &force_update.name_support },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_groups_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Groups/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_groups_name_support_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = GroupsNameSupport.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Groups/Attributes/NameSupport", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Groups/Attributes/NameSupport";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_groups_name_support_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Groups/Attributes/NameSupport";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_groups_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_groups_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_groups_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_groups_add_group_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/AddGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_add_group);
  }
  if (!uic_mqtt_dotdot_groups_generated_add_group_callback.empty()) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/AddGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_add_group);
  }
  if (!uic_mqtt_dotdot_groups_add_group_response_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/AddGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_add_group_response);
  }
  if (!uic_mqtt_dotdot_groups_generated_add_group_response_callback.empty()) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/AddGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_add_group_response);
  }
  if (!uic_mqtt_dotdot_groups_view_group_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/ViewGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_view_group);
  }
  if (!uic_mqtt_dotdot_groups_generated_view_group_callback.empty()) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/ViewGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_view_group);
  }
  if (!uic_mqtt_dotdot_groups_view_group_response_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/ViewGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_view_group_response);
  }
  if (!uic_mqtt_dotdot_groups_generated_view_group_response_callback.empty()) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/ViewGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_view_group_response);
  }
  if (!uic_mqtt_dotdot_groups_get_group_membership_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/GetGroupMembership";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_get_group_membership);
  }
  if (!uic_mqtt_dotdot_groups_generated_get_group_membership_callback.empty()) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/GetGroupMembership";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_get_group_membership);
  }
  if (!uic_mqtt_dotdot_groups_get_group_membership_response_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/GetGroupMembershipResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_get_group_membership_response);
  }
  if (!uic_mqtt_dotdot_groups_generated_get_group_membership_response_callback.empty()) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/GetGroupMembershipResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_get_group_membership_response);
  }
  if (!uic_mqtt_dotdot_groups_remove_group_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/RemoveGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_remove_group);
  }
  if (!uic_mqtt_dotdot_groups_generated_remove_group_callback.empty()) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/RemoveGroup";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_remove_group);
  }
  if (!uic_mqtt_dotdot_groups_remove_group_response_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/RemoveGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_remove_group_response);
  }
  if (!uic_mqtt_dotdot_groups_generated_remove_group_response_callback.empty()) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/RemoveGroupResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_remove_group_response);
  }
  if (!uic_mqtt_dotdot_groups_remove_all_groups_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/RemoveAllGroups";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_remove_all_groups);
  }
  if (!uic_mqtt_dotdot_groups_generated_remove_all_groups_callback.empty()) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/RemoveAllGroups";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_remove_all_groups);
  }
  if (!uic_mqtt_dotdot_groups_add_group_if_identifying_callback.empty()) {
    subscription_topic = base_topic + "Groups/Commands/AddGroupIfIdentifying";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_groups_add_group_if_identifying);
  }
  if (!uic_mqtt_dotdot_groups_generated_add_group_if_identifying_callback.empty()) {
    subscription_topic = base_topic + "Groups/GeneratedCommands/AddGroupIfIdentifying";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_groups_add_group_if_identifying);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_groups_attributes_init();

  uic_mqtt_dotdot_by_group_groups_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_scenes_add_scene_callback_t> uic_mqtt_dotdot_scenes_add_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_add_scene_callback_t> uic_mqtt_dotdot_scenes_generated_add_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_add_scene_response_callback_t> uic_mqtt_dotdot_scenes_add_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_add_scene_response_callback_t> uic_mqtt_dotdot_scenes_generated_add_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_view_scene_callback_t> uic_mqtt_dotdot_scenes_view_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_view_scene_callback_t> uic_mqtt_dotdot_scenes_generated_view_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_view_scene_response_callback_t> uic_mqtt_dotdot_scenes_view_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_view_scene_response_callback_t> uic_mqtt_dotdot_scenes_generated_view_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_remove_scene_callback_t> uic_mqtt_dotdot_scenes_remove_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_remove_scene_callback_t> uic_mqtt_dotdot_scenes_generated_remove_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_remove_scene_response_callback_t> uic_mqtt_dotdot_scenes_remove_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_remove_scene_response_callback_t> uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t> uic_mqtt_dotdot_scenes_remove_all_scenes_callback;
static std::set<uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t> uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback;
static std::set<uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t> uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback;
static std::set<uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t> uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback;
static std::set<uic_mqtt_dotdot_scenes_store_scene_callback_t> uic_mqtt_dotdot_scenes_store_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_store_scene_callback_t> uic_mqtt_dotdot_scenes_generated_store_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_store_scene_response_callback_t> uic_mqtt_dotdot_scenes_store_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_store_scene_response_callback_t> uic_mqtt_dotdot_scenes_generated_store_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_recall_scene_callback_t> uic_mqtt_dotdot_scenes_recall_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_recall_scene_callback_t> uic_mqtt_dotdot_scenes_generated_recall_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_get_scene_membership_callback_t> uic_mqtt_dotdot_scenes_get_scene_membership_callback;
static std::set<uic_mqtt_dotdot_scenes_get_scene_membership_callback_t> uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback;
static std::set<uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t> uic_mqtt_dotdot_scenes_get_scene_membership_response_callback;
static std::set<uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t> uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback;
static std::set<uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t> uic_mqtt_dotdot_scenes_enhanced_add_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t> uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t> uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t> uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t> uic_mqtt_dotdot_scenes_enhanced_view_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t> uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t> uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t> uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_copy_scene_callback_t> uic_mqtt_dotdot_scenes_copy_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_copy_scene_callback_t> uic_mqtt_dotdot_scenes_generated_copy_scene_callback;
static std::set<uic_mqtt_dotdot_scenes_copy_scene_response_callback_t> uic_mqtt_dotdot_scenes_copy_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_copy_scene_response_callback_t> uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback;
static std::set<uic_mqtt_dotdot_scenes_write_attributes_callback_t> uic_mqtt_dotdot_scenes_write_attributes_callback;
static std::set<uic_mqtt_dotdot_scenes_force_read_attributes_callback_t> uic_mqtt_dotdot_scenes_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_scenes_add_scene_callback_set(const uic_mqtt_dotdot_scenes_add_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_add_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_add_scene_callback_unset(const uic_mqtt_dotdot_scenes_add_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_add_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_add_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_add_scene_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_add_scene_callback_t>& get_uic_mqtt_dotdot_scenes_add_scene_callback()
{
  return uic_mqtt_dotdot_scenes_add_scene_callback;
}

void uic_mqtt_dotdot_scenes_generated_add_scene_callback_set(const uic_mqtt_dotdot_scenes_add_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_add_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_add_scene_callback_unset(const uic_mqtt_dotdot_scenes_add_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_add_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_add_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_add_scene_callback.clear();
}
void uic_mqtt_dotdot_scenes_add_scene_response_callback_set(const uic_mqtt_dotdot_scenes_add_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_add_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_add_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_add_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_add_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_add_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_add_scene_response_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_add_scene_response_callback_t>& get_uic_mqtt_dotdot_scenes_add_scene_response_callback()
{
  return uic_mqtt_dotdot_scenes_add_scene_response_callback;
}

void uic_mqtt_dotdot_scenes_generated_add_scene_response_callback_set(const uic_mqtt_dotdot_scenes_add_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_add_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_add_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_add_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_add_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_add_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_add_scene_response_callback.clear();
}
void uic_mqtt_dotdot_scenes_view_scene_callback_set(const uic_mqtt_dotdot_scenes_view_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_view_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_view_scene_callback_unset(const uic_mqtt_dotdot_scenes_view_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_view_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_view_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_view_scene_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_view_scene_callback_t>& get_uic_mqtt_dotdot_scenes_view_scene_callback()
{
  return uic_mqtt_dotdot_scenes_view_scene_callback;
}

void uic_mqtt_dotdot_scenes_generated_view_scene_callback_set(const uic_mqtt_dotdot_scenes_view_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_view_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_view_scene_callback_unset(const uic_mqtt_dotdot_scenes_view_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_view_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_view_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_view_scene_callback.clear();
}
void uic_mqtt_dotdot_scenes_view_scene_response_callback_set(const uic_mqtt_dotdot_scenes_view_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_view_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_view_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_view_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_view_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_view_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_view_scene_response_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_view_scene_response_callback_t>& get_uic_mqtt_dotdot_scenes_view_scene_response_callback()
{
  return uic_mqtt_dotdot_scenes_view_scene_response_callback;
}

void uic_mqtt_dotdot_scenes_generated_view_scene_response_callback_set(const uic_mqtt_dotdot_scenes_view_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_view_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_view_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_view_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_view_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_view_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_view_scene_response_callback.clear();
}
void uic_mqtt_dotdot_scenes_remove_scene_callback_set(const uic_mqtt_dotdot_scenes_remove_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_remove_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_remove_scene_callback_unset(const uic_mqtt_dotdot_scenes_remove_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_remove_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_remove_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_remove_scene_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_remove_scene_callback_t>& get_uic_mqtt_dotdot_scenes_remove_scene_callback()
{
  return uic_mqtt_dotdot_scenes_remove_scene_callback;
}

void uic_mqtt_dotdot_scenes_generated_remove_scene_callback_set(const uic_mqtt_dotdot_scenes_remove_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_remove_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_remove_scene_callback_unset(const uic_mqtt_dotdot_scenes_remove_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_remove_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_remove_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_remove_scene_callback.clear();
}
void uic_mqtt_dotdot_scenes_remove_scene_response_callback_set(const uic_mqtt_dotdot_scenes_remove_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_remove_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_remove_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_remove_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_remove_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_remove_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_remove_scene_response_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_remove_scene_response_callback_t>& get_uic_mqtt_dotdot_scenes_remove_scene_response_callback()
{
  return uic_mqtt_dotdot_scenes_remove_scene_response_callback;
}

void uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback_set(const uic_mqtt_dotdot_scenes_remove_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_remove_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback.clear();
}
void uic_mqtt_dotdot_scenes_remove_all_scenes_callback_set(const uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_remove_all_scenes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_remove_all_scenes_callback_unset(const uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t callback)
{
  uic_mqtt_dotdot_scenes_remove_all_scenes_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_remove_all_scenes_callback_clear()
{
  uic_mqtt_dotdot_scenes_remove_all_scenes_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t>& get_uic_mqtt_dotdot_scenes_remove_all_scenes_callback()
{
  return uic_mqtt_dotdot_scenes_remove_all_scenes_callback;
}

void uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback_set(const uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback_unset(const uic_mqtt_dotdot_scenes_remove_all_scenes_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback.clear();
}
void uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_set(const uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_unset(const uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t>& get_uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback()
{
  return uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback;
}

void uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback_set(const uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback_unset(const uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback.clear();
}
void uic_mqtt_dotdot_scenes_store_scene_callback_set(const uic_mqtt_dotdot_scenes_store_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_store_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_store_scene_callback_unset(const uic_mqtt_dotdot_scenes_store_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_store_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_store_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_store_scene_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_store_scene_callback_t>& get_uic_mqtt_dotdot_scenes_store_scene_callback()
{
  return uic_mqtt_dotdot_scenes_store_scene_callback;
}

void uic_mqtt_dotdot_scenes_generated_store_scene_callback_set(const uic_mqtt_dotdot_scenes_store_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_store_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_store_scene_callback_unset(const uic_mqtt_dotdot_scenes_store_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_store_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_store_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_store_scene_callback.clear();
}
void uic_mqtt_dotdot_scenes_store_scene_response_callback_set(const uic_mqtt_dotdot_scenes_store_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_store_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_store_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_store_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_store_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_store_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_store_scene_response_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_store_scene_response_callback_t>& get_uic_mqtt_dotdot_scenes_store_scene_response_callback()
{
  return uic_mqtt_dotdot_scenes_store_scene_response_callback;
}

void uic_mqtt_dotdot_scenes_generated_store_scene_response_callback_set(const uic_mqtt_dotdot_scenes_store_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_store_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_store_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_store_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_store_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_store_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_store_scene_response_callback.clear();
}
void uic_mqtt_dotdot_scenes_recall_scene_callback_set(const uic_mqtt_dotdot_scenes_recall_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_recall_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_recall_scene_callback_unset(const uic_mqtt_dotdot_scenes_recall_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_recall_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_recall_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_recall_scene_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_recall_scene_callback_t>& get_uic_mqtt_dotdot_scenes_recall_scene_callback()
{
  return uic_mqtt_dotdot_scenes_recall_scene_callback;
}

void uic_mqtt_dotdot_scenes_generated_recall_scene_callback_set(const uic_mqtt_dotdot_scenes_recall_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_recall_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_recall_scene_callback_unset(const uic_mqtt_dotdot_scenes_recall_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_recall_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_recall_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_recall_scene_callback.clear();
}
void uic_mqtt_dotdot_scenes_get_scene_membership_callback_set(const uic_mqtt_dotdot_scenes_get_scene_membership_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_get_scene_membership_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_get_scene_membership_callback_unset(const uic_mqtt_dotdot_scenes_get_scene_membership_callback_t callback)
{
  uic_mqtt_dotdot_scenes_get_scene_membership_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_get_scene_membership_callback_clear()
{
  uic_mqtt_dotdot_scenes_get_scene_membership_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_get_scene_membership_callback_t>& get_uic_mqtt_dotdot_scenes_get_scene_membership_callback()
{
  return uic_mqtt_dotdot_scenes_get_scene_membership_callback;
}

void uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback_set(const uic_mqtt_dotdot_scenes_get_scene_membership_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback_unset(const uic_mqtt_dotdot_scenes_get_scene_membership_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback.clear();
}
void uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_set(const uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_get_scene_membership_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_unset(const uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_get_scene_membership_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_get_scene_membership_response_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t>& get_uic_mqtt_dotdot_scenes_get_scene_membership_response_callback()
{
  return uic_mqtt_dotdot_scenes_get_scene_membership_response_callback;
}

void uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback_set(const uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback_unset(const uic_mqtt_dotdot_scenes_get_scene_membership_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback.clear();
}
void uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_set(const uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_enhanced_add_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_unset(const uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_enhanced_add_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_enhanced_add_scene_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t>& get_uic_mqtt_dotdot_scenes_enhanced_add_scene_callback()
{
  return uic_mqtt_dotdot_scenes_enhanced_add_scene_callback;
}

void uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback_set(const uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback_unset(const uic_mqtt_dotdot_scenes_enhanced_add_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback.clear();
}
void uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_set(const uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t>& get_uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback()
{
  return uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback;
}

void uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback_set(const uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback.clear();
}
void uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_set(const uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_enhanced_view_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_unset(const uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_enhanced_view_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_enhanced_view_scene_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t>& get_uic_mqtt_dotdot_scenes_enhanced_view_scene_callback()
{
  return uic_mqtt_dotdot_scenes_enhanced_view_scene_callback;
}

void uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback_set(const uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback_unset(const uic_mqtt_dotdot_scenes_enhanced_view_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback.clear();
}
void uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_set(const uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t>& get_uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback()
{
  return uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback;
}

void uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback_set(const uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback.clear();
}
void uic_mqtt_dotdot_scenes_copy_scene_callback_set(const uic_mqtt_dotdot_scenes_copy_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_copy_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_copy_scene_callback_unset(const uic_mqtt_dotdot_scenes_copy_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_copy_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_copy_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_copy_scene_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_copy_scene_callback_t>& get_uic_mqtt_dotdot_scenes_copy_scene_callback()
{
  return uic_mqtt_dotdot_scenes_copy_scene_callback;
}

void uic_mqtt_dotdot_scenes_generated_copy_scene_callback_set(const uic_mqtt_dotdot_scenes_copy_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_copy_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_copy_scene_callback_unset(const uic_mqtt_dotdot_scenes_copy_scene_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_copy_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_copy_scene_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_copy_scene_callback.clear();
}
void uic_mqtt_dotdot_scenes_copy_scene_response_callback_set(const uic_mqtt_dotdot_scenes_copy_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_copy_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_copy_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_copy_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_copy_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_copy_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_copy_scene_response_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_copy_scene_response_callback_t>& get_uic_mqtt_dotdot_scenes_copy_scene_response_callback()
{
  return uic_mqtt_dotdot_scenes_copy_scene_response_callback;
}

void uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback_set(const uic_mqtt_dotdot_scenes_copy_scene_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback_unset(const uic_mqtt_dotdot_scenes_copy_scene_response_callback_t callback)
{
  uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback.erase(callback);
}
void uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback_clear()
{
  uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback.clear();
}

void uic_mqtt_dotdot_set_scenes_write_attributes_callback(
  const uic_mqtt_dotdot_scenes_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_scenes_write_attributes_callback(
  const uic_mqtt_dotdot_scenes_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_scenes_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_scenes_write_attributes_callbacks()
{
  uic_mqtt_dotdot_scenes_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_scenes_write_attributes_callback_t>& get_uic_mqtt_dotdot_scenes_write_attributes_callback()
{
  return uic_mqtt_dotdot_scenes_write_attributes_callback;
}

void uic_mqtt_dotdot_set_scenes_force_read_attributes_callback(
  const uic_mqtt_dotdot_scenes_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_scenes_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_scenes_force_read_attributes_callback(
  const uic_mqtt_dotdot_scenes_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_scenes_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_scenes_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_scenes_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/AddScene
void uic_mqtt_dotdot_on_scenes_add_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_add_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  std::string scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;
  uint8_t transition_time100ms = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_add_scene(
      jsn,
      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets,

      transition_time100ms
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "AddScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddScene", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_add_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid,
  
      transition_time,
  
      scene_name.c_str(),
  
      extension_field_sets.size(),
      extension_field_sets.data(),

      transition_time100ms
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/AddScene
static void uic_mqtt_dotdot_on_generated_scenes_add_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_add_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  std::string scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;
  uint8_t transition_time100ms = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_add_scene(
      jsn,
      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets,

      transition_time100ms
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "AddScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddScene", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_add_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid,
  
      transition_time,
  
      scene_name.c_str(),
  
      extension_field_sets.size(),
      extension_field_sets.data(),

      transition_time100ms
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/AddSceneResponse
void uic_mqtt_dotdot_on_scenes_add_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_add_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_add_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "AddSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddSceneResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_add_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/AddSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_add_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_add_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_add_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "AddSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "AddSceneResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_add_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/ViewScene
void uic_mqtt_dotdot_on_scenes_view_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_view_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_view_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "ViewScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewScene", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_view_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/ViewScene
static void uic_mqtt_dotdot_on_generated_scenes_view_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_view_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_view_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "ViewScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewScene", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_view_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/ViewSceneResponse
void uic_mqtt_dotdot_on_scenes_view_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_view_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  std::string scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_view_scene_response(
      jsn,
      status,

      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "ViewSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewSceneResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_view_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid,
  
      transition_time,
  
      scene_name.c_str(),
  
      extension_field_sets.size(),
      extension_field_sets.data()

    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/ViewSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_view_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_view_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  std::string scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_view_scene_response(
      jsn,
      status,

      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "ViewSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "ViewSceneResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_view_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid,
  
      transition_time,
  
      scene_name.c_str(),
  
      extension_field_sets.size(),
      extension_field_sets.data()

    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/RemoveScene
void uic_mqtt_dotdot_on_scenes_remove_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_remove_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveScene", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_remove_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/RemoveScene
static void uic_mqtt_dotdot_on_generated_scenes_remove_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_remove_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveScene", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_remove_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/RemoveSceneResponse
void uic_mqtt_dotdot_on_scenes_remove_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_remove_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveSceneResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_remove_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/RemoveSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_remove_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveSceneResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/RemoveAllScenes
void uic_mqtt_dotdot_on_scenes_remove_all_scenes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_remove_all_scenes_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_all_scenes(
      jsn,
      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveAllScenes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenes", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_remove_all_scenes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/RemoveAllScenes
static void uic_mqtt_dotdot_on_generated_scenes_remove_all_scenes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_all_scenes(
      jsn,
      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveAllScenes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenes", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/RemoveAllScenesResponse
void uic_mqtt_dotdot_on_scenes_remove_all_scenes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_all_scenes_response(
      jsn,
      status,

      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveAllScenesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenesResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/RemoveAllScenesResponse
static void uic_mqtt_dotdot_on_generated_scenes_remove_all_scenes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_remove_all_scenes_response(
      jsn,
      status,

      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RemoveAllScenesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RemoveAllScenesResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/StoreScene
void uic_mqtt_dotdot_on_scenes_store_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_store_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_store_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "StoreScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreScene", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_store_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/StoreScene
static void uic_mqtt_dotdot_on_generated_scenes_store_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_store_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_store_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "StoreScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreScene", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_store_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/StoreSceneResponse
void uic_mqtt_dotdot_on_scenes_store_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_store_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_store_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "StoreSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreSceneResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_store_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/StoreSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_store_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_store_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_store_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "StoreSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "StoreSceneResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_store_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/RecallScene
void uic_mqtt_dotdot_on_scenes_recall_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_recall_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_recall_scene(
      jsn,
      groupid,

      sceneid,

      transition_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RecallScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RecallScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RecallScene", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_recall_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid,
  
      transition_time
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/RecallScene
static void uic_mqtt_dotdot_on_generated_scenes_recall_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_recall_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_recall_scene(
      jsn,
      groupid,

      sceneid,

      transition_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "RecallScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RecallScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "RecallScene", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_recall_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid,
  
      transition_time
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/GetSceneMembership
void uic_mqtt_dotdot_on_scenes_get_scene_membership(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_get_scene_membership_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_get_scene_membership(
      jsn,
      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "GetSceneMembership");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembership", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembership", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_get_scene_membership_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/GetSceneMembership
static void uic_mqtt_dotdot_on_generated_scenes_get_scene_membership(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_get_scene_membership(
      jsn,
      groupid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "GetSceneMembership");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembership", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembership", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/GetSceneMembershipResponse
void uic_mqtt_dotdot_on_scenes_get_scene_membership_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_get_scene_membership_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  uint8_t capacity = {};
  SGroupId groupid = {};
  std::vector<uint8_t> scene_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_get_scene_membership_response(
      jsn,
      status,

      capacity,

      groupid,

      scene_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "GetSceneMembershipResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembershipResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembershipResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_get_scene_membership_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      capacity,
  
      groupid,
  
      scene_list.size(),
      scene_list.data()

    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/GetSceneMembershipResponse
static void uic_mqtt_dotdot_on_generated_scenes_get_scene_membership_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  uint8_t capacity = {};
  SGroupId groupid = {};
  std::vector<uint8_t> scene_list;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_get_scene_membership_response(
      jsn,
      status,

      capacity,

      groupid,

      scene_list
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "GetSceneMembershipResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembershipResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "GetSceneMembershipResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      capacity,
  
      groupid,
  
      scene_list.size(),
      scene_list.data()

    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/EnhancedAddScene
void uic_mqtt_dotdot_on_scenes_enhanced_add_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_enhanced_add_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  std::string scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_add_scene(
      jsn,
      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedAddScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddScene", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_enhanced_add_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid,
  
      transition_time,
  
      scene_name.c_str(),
  
      extension_field_sets.size(),
      extension_field_sets.data()

    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/EnhancedAddScene
static void uic_mqtt_dotdot_on_generated_scenes_enhanced_add_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  std::string scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_add_scene(
      jsn,
      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedAddScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddScene", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid,
  
      transition_time,
  
      scene_name.c_str(),
  
      extension_field_sets.size(),
      extension_field_sets.data()

    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/EnhancedAddSceneResponse
void uic_mqtt_dotdot_on_scenes_enhanced_add_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_add_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedAddSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddSceneResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/EnhancedAddSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_enhanced_add_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_add_scene_response(
      jsn,
      status,

      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedAddSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedAddSceneResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/EnhancedViewScene
void uic_mqtt_dotdot_on_scenes_enhanced_view_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_enhanced_view_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_view_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedViewScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewScene", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_enhanced_view_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/EnhancedViewScene
static void uic_mqtt_dotdot_on_generated_scenes_enhanced_view_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SGroupId groupid = {};
  uint8_t sceneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_view_scene(
      jsn,
      groupid,

      sceneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedViewScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewScene", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      groupid,
  
      sceneid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/EnhancedViewSceneResponse
void uic_mqtt_dotdot_on_scenes_enhanced_view_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  std::string scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_view_scene_response(
      jsn,
      status,

      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedViewSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewSceneResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid,
  
      transition_time,
  
      scene_name.c_str(),
  
      extension_field_sets.size(),
      extension_field_sets.data()

    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/EnhancedViewSceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_enhanced_view_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId groupid = {};
  uint8_t sceneid = {};
  uint16_t transition_time = {};
  std::string scene_name;
  std::vector<SExtensionFieldSetList> extension_field_sets;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_enhanced_view_scene_response(
      jsn,
      status,

      groupid,

      sceneid,

      transition_time,

      scene_name,

      extension_field_sets
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "EnhancedViewSceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewSceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "EnhancedViewSceneResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      groupid,
  
      sceneid,
  
      transition_time,
  
      scene_name.c_str(),
  
      extension_field_sets.size(),
      extension_field_sets.data()

    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/CopyScene
void uic_mqtt_dotdot_on_scenes_copy_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_copy_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t mode = {};
  SGroupId group_identifier_from = {};
  uint8_t scene_identifier_from = {};
  SGroupId group_identifier_to = {};
  uint8_t scene_identifier_to = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_copy_scene(
      jsn,
      mode,

      group_identifier_from,

      scene_identifier_from,

      group_identifier_to,

      scene_identifier_to
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "CopyScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopyScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopyScene", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_copy_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      mode,
  
      group_identifier_from,
  
      scene_identifier_from,
  
      group_identifier_to,
  
      scene_identifier_to
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/CopyScene
static void uic_mqtt_dotdot_on_generated_scenes_copy_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_copy_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t mode = {};
  SGroupId group_identifier_from = {};
  uint8_t scene_identifier_from = {};
  SGroupId group_identifier_to = {};
  uint8_t scene_identifier_to = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_copy_scene(
      jsn,
      mode,

      group_identifier_from,

      scene_identifier_from,

      group_identifier_to,

      scene_identifier_to
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "CopyScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopyScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopyScene", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_copy_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      mode,
  
      group_identifier_from,
  
      scene_identifier_from,
  
      group_identifier_to,
  
      scene_identifier_to
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/CopySceneResponse
void uic_mqtt_dotdot_on_scenes_copy_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_copy_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId group_identifier_from = {};
  uint8_t scene_identifier_from = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_copy_scene_response(
      jsn,
      status,

      group_identifier_from,

      scene_identifier_from
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "CopySceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopySceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopySceneResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_scenes_copy_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      group_identifier_from,
  
      scene_identifier_from
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/GeneratedCommands/CopySceneResponse
static void uic_mqtt_dotdot_on_generated_scenes_copy_scene_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  SGroupId group_identifier_from = {};
  uint8_t scene_identifier_from = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_scenes_copy_scene_response(
      jsn,
      status,

      group_identifier_from,

      scene_identifier_from
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "CopySceneResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopySceneResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "CopySceneResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      group_identifier_from,
  
      scene_identifier_from
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Scenes/Commands/WriteAttributes
void uic_mqtt_dotdot_on_scenes_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_scenes_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_scenes_state_t new_state = {};
  uic_mqtt_dotdot_scenes_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_scenes_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Scenes", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_scenes_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_scenes_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_scenes_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_scenes_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.scene_count = true;
      force_update.current_scene = true;
      force_update.current_group = true;
      force_update.scene_valid = true;
      force_update.name_support = true;
      force_update.last_configured_by = true;
      force_update.scene_table = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"SceneCount", &force_update.scene_count },
        {"CurrentScene", &force_update.current_scene },
        {"CurrentGroup", &force_update.current_group },
        {"SceneValid", &force_update.scene_valid },
        {"NameSupport", &force_update.name_support },
        {"LastConfiguredBy", &force_update.last_configured_by },
        {"SceneTable", &force_update.scene_table },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_scenes_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Scenes/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_scenes_scene_count_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(5,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(5,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/SceneCount", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/SceneCount";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_scenes_scene_count_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Scenes/Attributes/SceneCount";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_scenes_current_scene_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(5,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(5,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/CurrentScene", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/CurrentScene";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_scenes_current_scene_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Scenes/Attributes/CurrentScene";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_scenes_current_group_publish(
  const char *base_topic,
  SGroupId value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(5,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(5,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/CurrentGroup", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/CurrentGroup";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_scenes_current_group_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Scenes/Attributes/CurrentGroup";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_scenes_scene_valid_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(5,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(5,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/SceneValid", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/SceneValid";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_scenes_scene_valid_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Scenes/Attributes/SceneValid";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_scenes_name_support_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ScenesNameSupport.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/NameSupport", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Scenes/Attributes/NameSupport";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_scenes_name_support_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Scenes/Attributes/NameSupport";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_scenes_last_configured_by_publish(
  const char *base_topic,
  EUI64 value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(5,5,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(5,5,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/LastConfiguredBy", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/LastConfiguredBy";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_scenes_last_configured_by_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Scenes/Attributes/LastConfiguredBy";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_scenes_scene_table_publish(
  const char *base_topic,
  size_t value_count,
  const SSceneTable* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["SceneID"] = value[i].SceneID;
    json_object["GroupID"] = value[i].GroupID;
    json_object["SceneName"] = value[i].SceneName;
    json_object["TransitionTime"] = value[i].TransitionTime;
    json_object["TransitionTime100ms"] = value[i].TransitionTime100ms;
    json_object["SceneTableExtensions"] = value[i].SceneTableExtensions;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Scenes/Attributes/SceneTable", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Scenes/Attributes/SceneTable";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_scenes_scene_table_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Scenes/Attributes/SceneTable";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_scenes_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_scenes_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_scenes_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_scenes_add_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/AddScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_add_scene);
  }
  if (!uic_mqtt_dotdot_scenes_generated_add_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/AddScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_add_scene);
  }
  if (!uic_mqtt_dotdot_scenes_add_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/AddSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_add_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_generated_add_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/AddSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_add_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_view_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/ViewScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_view_scene);
  }
  if (!uic_mqtt_dotdot_scenes_generated_view_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/ViewScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_view_scene);
  }
  if (!uic_mqtt_dotdot_scenes_view_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/ViewSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_view_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_generated_view_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/ViewSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_view_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_remove_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/RemoveScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_remove_scene);
  }
  if (!uic_mqtt_dotdot_scenes_generated_remove_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/RemoveScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_remove_scene);
  }
  if (!uic_mqtt_dotdot_scenes_remove_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/RemoveSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_remove_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_generated_remove_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/RemoveSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_remove_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_remove_all_scenes_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/RemoveAllScenes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_remove_all_scenes);
  }
  if (!uic_mqtt_dotdot_scenes_generated_remove_all_scenes_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/RemoveAllScenes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_remove_all_scenes);
  }
  if (!uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/RemoveAllScenesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_remove_all_scenes_response);
  }
  if (!uic_mqtt_dotdot_scenes_generated_remove_all_scenes_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/RemoveAllScenesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_remove_all_scenes_response);
  }
  if (!uic_mqtt_dotdot_scenes_store_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/StoreScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_store_scene);
  }
  if (!uic_mqtt_dotdot_scenes_generated_store_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/StoreScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_store_scene);
  }
  if (!uic_mqtt_dotdot_scenes_store_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/StoreSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_store_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_generated_store_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/StoreSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_store_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_recall_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/RecallScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_recall_scene);
  }
  if (!uic_mqtt_dotdot_scenes_generated_recall_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/RecallScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_recall_scene);
  }
  if (!uic_mqtt_dotdot_scenes_get_scene_membership_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/GetSceneMembership";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_get_scene_membership);
  }
  if (!uic_mqtt_dotdot_scenes_generated_get_scene_membership_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/GetSceneMembership";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_get_scene_membership);
  }
  if (!uic_mqtt_dotdot_scenes_get_scene_membership_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/GetSceneMembershipResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_get_scene_membership_response);
  }
  if (!uic_mqtt_dotdot_scenes_generated_get_scene_membership_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/GetSceneMembershipResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_get_scene_membership_response);
  }
  if (!uic_mqtt_dotdot_scenes_enhanced_add_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/EnhancedAddScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_enhanced_add_scene);
  }
  if (!uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/EnhancedAddScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_enhanced_add_scene);
  }
  if (!uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/EnhancedAddSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_enhanced_add_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_generated_enhanced_add_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/EnhancedAddSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_enhanced_add_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_enhanced_view_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/EnhancedViewScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_enhanced_view_scene);
  }
  if (!uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/EnhancedViewScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_enhanced_view_scene);
  }
  if (!uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/EnhancedViewSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_enhanced_view_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_generated_enhanced_view_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/EnhancedViewSceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_enhanced_view_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_copy_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/CopyScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_copy_scene);
  }
  if (!uic_mqtt_dotdot_scenes_generated_copy_scene_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/CopyScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_copy_scene);
  }
  if (!uic_mqtt_dotdot_scenes_copy_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/Commands/CopySceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_scenes_copy_scene_response);
  }
  if (!uic_mqtt_dotdot_scenes_generated_copy_scene_response_callback.empty()) {
    subscription_topic = base_topic + "Scenes/GeneratedCommands/CopySceneResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_scenes_copy_scene_response);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_scenes_attributes_init();

  uic_mqtt_dotdot_by_group_scenes_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_on_off_off_callback_t> uic_mqtt_dotdot_on_off_off_callback;
static std::set<uic_mqtt_dotdot_on_off_off_callback_t> uic_mqtt_dotdot_on_off_generated_off_callback;
static std::set<uic_mqtt_dotdot_on_off_on_callback_t> uic_mqtt_dotdot_on_off_on_callback;
static std::set<uic_mqtt_dotdot_on_off_on_callback_t> uic_mqtt_dotdot_on_off_generated_on_callback;
static std::set<uic_mqtt_dotdot_on_off_toggle_callback_t> uic_mqtt_dotdot_on_off_toggle_callback;
static std::set<uic_mqtt_dotdot_on_off_toggle_callback_t> uic_mqtt_dotdot_on_off_generated_toggle_callback;
static std::set<uic_mqtt_dotdot_on_off_off_with_effect_callback_t> uic_mqtt_dotdot_on_off_off_with_effect_callback;
static std::set<uic_mqtt_dotdot_on_off_off_with_effect_callback_t> uic_mqtt_dotdot_on_off_generated_off_with_effect_callback;
static std::set<uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t> uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback;
static std::set<uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t> uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback;
static std::set<uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t> uic_mqtt_dotdot_on_off_on_with_timed_off_callback;
static std::set<uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t> uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback;
static std::set<uic_mqtt_dotdot_on_off_write_attributes_callback_t> uic_mqtt_dotdot_on_off_write_attributes_callback;
static std::set<uic_mqtt_dotdot_on_off_force_read_attributes_callback_t> uic_mqtt_dotdot_on_off_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_on_off_off_callback_set(const uic_mqtt_dotdot_on_off_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_off_callback_unset(const uic_mqtt_dotdot_on_off_off_callback_t callback)
{
  uic_mqtt_dotdot_on_off_off_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_off_callback_clear()
{
  uic_mqtt_dotdot_on_off_off_callback.clear();
}
std::set<uic_mqtt_dotdot_on_off_off_callback_t>& get_uic_mqtt_dotdot_on_off_off_callback()
{
  return uic_mqtt_dotdot_on_off_off_callback;
}

void uic_mqtt_dotdot_on_off_generated_off_callback_set(const uic_mqtt_dotdot_on_off_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_generated_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_generated_off_callback_unset(const uic_mqtt_dotdot_on_off_off_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_off_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_generated_off_callback_clear()
{
  uic_mqtt_dotdot_on_off_generated_off_callback.clear();
}
void uic_mqtt_dotdot_on_off_on_callback_set(const uic_mqtt_dotdot_on_off_on_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_on_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_on_callback_unset(const uic_mqtt_dotdot_on_off_on_callback_t callback)
{
  uic_mqtt_dotdot_on_off_on_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_on_callback_clear()
{
  uic_mqtt_dotdot_on_off_on_callback.clear();
}
std::set<uic_mqtt_dotdot_on_off_on_callback_t>& get_uic_mqtt_dotdot_on_off_on_callback()
{
  return uic_mqtt_dotdot_on_off_on_callback;
}

void uic_mqtt_dotdot_on_off_generated_on_callback_set(const uic_mqtt_dotdot_on_off_on_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_generated_on_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_generated_on_callback_unset(const uic_mqtt_dotdot_on_off_on_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_on_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_generated_on_callback_clear()
{
  uic_mqtt_dotdot_on_off_generated_on_callback.clear();
}
void uic_mqtt_dotdot_on_off_toggle_callback_set(const uic_mqtt_dotdot_on_off_toggle_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_toggle_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_toggle_callback_unset(const uic_mqtt_dotdot_on_off_toggle_callback_t callback)
{
  uic_mqtt_dotdot_on_off_toggle_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_toggle_callback_clear()
{
  uic_mqtt_dotdot_on_off_toggle_callback.clear();
}
std::set<uic_mqtt_dotdot_on_off_toggle_callback_t>& get_uic_mqtt_dotdot_on_off_toggle_callback()
{
  return uic_mqtt_dotdot_on_off_toggle_callback;
}

void uic_mqtt_dotdot_on_off_generated_toggle_callback_set(const uic_mqtt_dotdot_on_off_toggle_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_generated_toggle_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_generated_toggle_callback_unset(const uic_mqtt_dotdot_on_off_toggle_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_toggle_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_generated_toggle_callback_clear()
{
  uic_mqtt_dotdot_on_off_generated_toggle_callback.clear();
}
void uic_mqtt_dotdot_on_off_off_with_effect_callback_set(const uic_mqtt_dotdot_on_off_off_with_effect_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_off_with_effect_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_off_with_effect_callback_unset(const uic_mqtt_dotdot_on_off_off_with_effect_callback_t callback)
{
  uic_mqtt_dotdot_on_off_off_with_effect_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_off_with_effect_callback_clear()
{
  uic_mqtt_dotdot_on_off_off_with_effect_callback.clear();
}
std::set<uic_mqtt_dotdot_on_off_off_with_effect_callback_t>& get_uic_mqtt_dotdot_on_off_off_with_effect_callback()
{
  return uic_mqtt_dotdot_on_off_off_with_effect_callback;
}

void uic_mqtt_dotdot_on_off_generated_off_with_effect_callback_set(const uic_mqtt_dotdot_on_off_off_with_effect_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_generated_off_with_effect_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_generated_off_with_effect_callback_unset(const uic_mqtt_dotdot_on_off_off_with_effect_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_off_with_effect_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_generated_off_with_effect_callback_clear()
{
  uic_mqtt_dotdot_on_off_generated_off_with_effect_callback.clear();
}
void uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_set(const uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_unset(const uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t callback)
{
  uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_clear()
{
  uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback.clear();
}
std::set<uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t>& get_uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback()
{
  return uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback;
}

void uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback_set(const uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback_unset(const uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback_clear()
{
  uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback.clear();
}
void uic_mqtt_dotdot_on_off_on_with_timed_off_callback_set(const uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_on_with_timed_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_on_with_timed_off_callback_unset(const uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t callback)
{
  uic_mqtt_dotdot_on_off_on_with_timed_off_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_on_with_timed_off_callback_clear()
{
  uic_mqtt_dotdot_on_off_on_with_timed_off_callback.clear();
}
std::set<uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t>& get_uic_mqtt_dotdot_on_off_on_with_timed_off_callback()
{
  return uic_mqtt_dotdot_on_off_on_with_timed_off_callback;
}

void uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback_set(const uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback_unset(const uic_mqtt_dotdot_on_off_on_with_timed_off_callback_t callback)
{
  uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback.erase(callback);
}
void uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback_clear()
{
  uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback.clear();
}

void uic_mqtt_dotdot_set_on_off_write_attributes_callback(
  const uic_mqtt_dotdot_on_off_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_on_off_write_attributes_callback(
  const uic_mqtt_dotdot_on_off_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_on_off_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_on_off_write_attributes_callbacks()
{
  uic_mqtt_dotdot_on_off_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_on_off_write_attributes_callback_t>& get_uic_mqtt_dotdot_on_off_write_attributes_callback()
{
  return uic_mqtt_dotdot_on_off_write_attributes_callback;
}

void uic_mqtt_dotdot_set_on_off_force_read_attributes_callback(
  const uic_mqtt_dotdot_on_off_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_on_off_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_on_off_force_read_attributes_callback(
  const uic_mqtt_dotdot_on_off_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_on_off_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_on_off_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_on_off_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/Off
void uic_mqtt_dotdot_on_on_off_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "Off");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Off", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Off", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_on_off_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/Off
static void uic_mqtt_dotdot_on_generated_on_off_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "Off");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Off", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Off", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_on_off_generated_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/On
void uic_mqtt_dotdot_on_on_off_on(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_on_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "On");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "On", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "On", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_on_off_on_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/On
static void uic_mqtt_dotdot_on_generated_on_off_on(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_on_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "On");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "On", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "On", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_on_off_generated_on_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/Toggle
void uic_mqtt_dotdot_on_on_off_toggle(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_toggle_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "Toggle");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Toggle", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Toggle", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_on_off_toggle_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/Toggle
static void uic_mqtt_dotdot_on_generated_on_off_toggle(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_toggle_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "Toggle");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Toggle", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "Toggle", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_on_off_generated_toggle_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/OffWithEffect
void uic_mqtt_dotdot_on_on_off_off_with_effect(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_off_with_effect_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  OffWithEffectEffectIdentifier effect_identifier = {};
  uint8_t effect_variant = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_on_off_off_with_effect(
      jsn,
      effect_identifier,

      effect_variant
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OffWithEffect");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OffWithEffect", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OffWithEffect", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_on_off_off_with_effect_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      effect_identifier,
  
      effect_variant
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/OffWithEffect
static void uic_mqtt_dotdot_on_generated_on_off_off_with_effect(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_off_with_effect_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  OffWithEffectEffectIdentifier effect_identifier = {};
  uint8_t effect_variant = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_on_off_off_with_effect(
      jsn,
      effect_identifier,

      effect_variant
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OffWithEffect");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OffWithEffect", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OffWithEffect", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_on_off_generated_off_with_effect_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      effect_identifier,
  
      effect_variant
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/OnWithRecallGlobalScene
void uic_mqtt_dotdot_on_on_off_on_with_recall_global_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OnWithRecallGlobalScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithRecallGlobalScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithRecallGlobalScene", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/OnWithRecallGlobalScene
static void uic_mqtt_dotdot_on_generated_on_off_on_with_recall_global_scene(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OnWithRecallGlobalScene");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithRecallGlobalScene", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithRecallGlobalScene", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/OnWithTimedOff
void uic_mqtt_dotdot_on_on_off_on_with_timed_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_on_with_timed_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t on_off_control = {};
  uint16_t on_time = {};
  uint16_t off_wait_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_on_off_on_with_timed_off(
      jsn,
      on_off_control,

      on_time,

      off_wait_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OnWithTimedOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithTimedOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithTimedOff", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_on_off_on_with_timed_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      on_off_control,
  
      on_time,
  
      off_wait_time
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/GeneratedCommands/OnWithTimedOff
static void uic_mqtt_dotdot_on_generated_on_off_on_with_timed_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t on_off_control = {};
  uint16_t on_time = {};
  uint16_t off_wait_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_on_off_on_with_timed_off(
      jsn,
      on_off_control,

      on_time,

      off_wait_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "OnWithTimedOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithTimedOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "OnWithTimedOff", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      on_off_control,
  
      on_time,
  
      off_wait_time
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/OnOff/Commands/WriteAttributes
void uic_mqtt_dotdot_on_on_off_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_on_off_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_on_off_state_t new_state = {};
  uic_mqtt_dotdot_on_off_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_on_off_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OnOff", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_on_off_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_on_off_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_on_off_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_on_off_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.on_off = true;
      force_update.global_scene_control = true;
      force_update.on_time = true;
      force_update.off_wait_time = true;
      force_update.start_up_on_off = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"OnOff", &force_update.on_off },
        {"GlobalSceneControl", &force_update.global_scene_control },
        {"OnTime", &force_update.on_time },
        {"OffWaitTime", &force_update.off_wait_time },
        {"StartUpOnOff", &force_update.start_up_on_off },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_on_off_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "OnOff/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_on_off_on_off_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(6,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(6,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff/Attributes/OnOff", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OnOff/Attributes/OnOff";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_on_off_on_off_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OnOff/Attributes/OnOff";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_on_off_global_scene_control_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(6,16384,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(6,16384,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff/Attributes/GlobalSceneControl", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OnOff/Attributes/GlobalSceneControl";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_on_off_global_scene_control_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OnOff/Attributes/GlobalSceneControl";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_on_off_on_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(6,16385,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(6,16385,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff/Attributes/OnTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OnOff/Attributes/OnTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_on_off_on_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OnOff/Attributes/OnTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_on_off_off_wait_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(6,16386,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(6,16386,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff/Attributes/OffWaitTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OnOff/Attributes/OffWaitTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_on_off_off_wait_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OnOff/Attributes/OffWaitTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_on_off_start_up_on_off_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef ON_OFF_START_UP_ON_OFF_ENUM_NAME_AVAILABLE
  jsn["value"] = on_off_start_up_on_off_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for ON_OFF_START_UP_ON_OFF. Using number instead.");
  jsn["value"] = static_cast<OnOffStartUpOnOff>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OnOff/Attributes/StartUpOnOff", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OnOff/Attributes/StartUpOnOff";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_on_off_start_up_on_off_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OnOff/Attributes/StartUpOnOff";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_on_off_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_on_off_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "OnOff/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_on_off_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "OnOff/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_on_off_off_callback.empty()) {
    subscription_topic = base_topic + "OnOff/Commands/Off";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_off);
  }
  if (!uic_mqtt_dotdot_on_off_generated_off_callback.empty()) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/Off";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_off);
  }
  if (!uic_mqtt_dotdot_on_off_on_callback.empty()) {
    subscription_topic = base_topic + "OnOff/Commands/On";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_on);
  }
  if (!uic_mqtt_dotdot_on_off_generated_on_callback.empty()) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/On";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_on);
  }
  if (!uic_mqtt_dotdot_on_off_toggle_callback.empty()) {
    subscription_topic = base_topic + "OnOff/Commands/Toggle";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_toggle);
  }
  if (!uic_mqtt_dotdot_on_off_generated_toggle_callback.empty()) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/Toggle";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_toggle);
  }
  if (!uic_mqtt_dotdot_on_off_off_with_effect_callback.empty()) {
    subscription_topic = base_topic + "OnOff/Commands/OffWithEffect";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_off_with_effect);
  }
  if (!uic_mqtt_dotdot_on_off_generated_off_with_effect_callback.empty()) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/OffWithEffect";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_off_with_effect);
  }
  if (!uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback.empty()) {
    subscription_topic = base_topic + "OnOff/Commands/OnWithRecallGlobalScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_on_with_recall_global_scene);
  }
  if (!uic_mqtt_dotdot_on_off_generated_on_with_recall_global_scene_callback.empty()) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/OnWithRecallGlobalScene";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_on_with_recall_global_scene);
  }
  if (!uic_mqtt_dotdot_on_off_on_with_timed_off_callback.empty()) {
    subscription_topic = base_topic + "OnOff/Commands/OnWithTimedOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_on_off_on_with_timed_off);
  }
  if (!uic_mqtt_dotdot_on_off_generated_on_with_timed_off_callback.empty()) {
    subscription_topic = base_topic + "OnOff/GeneratedCommands/OnWithTimedOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_on_off_on_with_timed_off);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_on_off_attributes_init();

  uic_mqtt_dotdot_by_group_on_off_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_level_move_to_level_callback_t> uic_mqtt_dotdot_level_move_to_level_callback;
static std::set<uic_mqtt_dotdot_level_move_to_level_callback_t> uic_mqtt_dotdot_level_generated_move_to_level_callback;
static std::set<uic_mqtt_dotdot_level_move_callback_t> uic_mqtt_dotdot_level_move_callback;
static std::set<uic_mqtt_dotdot_level_move_callback_t> uic_mqtt_dotdot_level_generated_move_callback;
static std::set<uic_mqtt_dotdot_level_step_callback_t> uic_mqtt_dotdot_level_step_callback;
static std::set<uic_mqtt_dotdot_level_step_callback_t> uic_mqtt_dotdot_level_generated_step_callback;
static std::set<uic_mqtt_dotdot_level_stop_callback_t> uic_mqtt_dotdot_level_stop_callback;
static std::set<uic_mqtt_dotdot_level_stop_callback_t> uic_mqtt_dotdot_level_generated_stop_callback;
static std::set<uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t> uic_mqtt_dotdot_level_move_to_level_with_on_off_callback;
static std::set<uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t> uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback;
static std::set<uic_mqtt_dotdot_level_move_with_on_off_callback_t> uic_mqtt_dotdot_level_move_with_on_off_callback;
static std::set<uic_mqtt_dotdot_level_move_with_on_off_callback_t> uic_mqtt_dotdot_level_generated_move_with_on_off_callback;
static std::set<uic_mqtt_dotdot_level_step_with_on_off_callback_t> uic_mqtt_dotdot_level_step_with_on_off_callback;
static std::set<uic_mqtt_dotdot_level_step_with_on_off_callback_t> uic_mqtt_dotdot_level_generated_step_with_on_off_callback;
static std::set<uic_mqtt_dotdot_level_stop_with_on_off_callback_t> uic_mqtt_dotdot_level_stop_with_on_off_callback;
static std::set<uic_mqtt_dotdot_level_stop_with_on_off_callback_t> uic_mqtt_dotdot_level_generated_stop_with_on_off_callback;
static std::set<uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t> uic_mqtt_dotdot_level_move_to_closest_frequency_callback;
static std::set<uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t> uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback;
static std::set<uic_mqtt_dotdot_level_write_attributes_callback_t> uic_mqtt_dotdot_level_write_attributes_callback;
static std::set<uic_mqtt_dotdot_level_force_read_attributes_callback_t> uic_mqtt_dotdot_level_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_level_move_to_level_callback_set(const uic_mqtt_dotdot_level_move_to_level_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_move_to_level_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_move_to_level_callback_unset(const uic_mqtt_dotdot_level_move_to_level_callback_t callback)
{
  uic_mqtt_dotdot_level_move_to_level_callback.erase(callback);
}
void uic_mqtt_dotdot_level_move_to_level_callback_clear()
{
  uic_mqtt_dotdot_level_move_to_level_callback.clear();
}
std::set<uic_mqtt_dotdot_level_move_to_level_callback_t>& get_uic_mqtt_dotdot_level_move_to_level_callback()
{
  return uic_mqtt_dotdot_level_move_to_level_callback;
}

void uic_mqtt_dotdot_level_generated_move_to_level_callback_set(const uic_mqtt_dotdot_level_move_to_level_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_generated_move_to_level_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_generated_move_to_level_callback_unset(const uic_mqtt_dotdot_level_move_to_level_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_move_to_level_callback.erase(callback);
}
void uic_mqtt_dotdot_level_generated_move_to_level_callback_clear()
{
  uic_mqtt_dotdot_level_generated_move_to_level_callback.clear();
}
void uic_mqtt_dotdot_level_move_callback_set(const uic_mqtt_dotdot_level_move_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_move_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_move_callback_unset(const uic_mqtt_dotdot_level_move_callback_t callback)
{
  uic_mqtt_dotdot_level_move_callback.erase(callback);
}
void uic_mqtt_dotdot_level_move_callback_clear()
{
  uic_mqtt_dotdot_level_move_callback.clear();
}
std::set<uic_mqtt_dotdot_level_move_callback_t>& get_uic_mqtt_dotdot_level_move_callback()
{
  return uic_mqtt_dotdot_level_move_callback;
}

void uic_mqtt_dotdot_level_generated_move_callback_set(const uic_mqtt_dotdot_level_move_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_generated_move_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_generated_move_callback_unset(const uic_mqtt_dotdot_level_move_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_move_callback.erase(callback);
}
void uic_mqtt_dotdot_level_generated_move_callback_clear()
{
  uic_mqtt_dotdot_level_generated_move_callback.clear();
}
void uic_mqtt_dotdot_level_step_callback_set(const uic_mqtt_dotdot_level_step_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_step_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_step_callback_unset(const uic_mqtt_dotdot_level_step_callback_t callback)
{
  uic_mqtt_dotdot_level_step_callback.erase(callback);
}
void uic_mqtt_dotdot_level_step_callback_clear()
{
  uic_mqtt_dotdot_level_step_callback.clear();
}
std::set<uic_mqtt_dotdot_level_step_callback_t>& get_uic_mqtt_dotdot_level_step_callback()
{
  return uic_mqtt_dotdot_level_step_callback;
}

void uic_mqtt_dotdot_level_generated_step_callback_set(const uic_mqtt_dotdot_level_step_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_generated_step_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_generated_step_callback_unset(const uic_mqtt_dotdot_level_step_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_step_callback.erase(callback);
}
void uic_mqtt_dotdot_level_generated_step_callback_clear()
{
  uic_mqtt_dotdot_level_generated_step_callback.clear();
}
void uic_mqtt_dotdot_level_stop_callback_set(const uic_mqtt_dotdot_level_stop_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_stop_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_stop_callback_unset(const uic_mqtt_dotdot_level_stop_callback_t callback)
{
  uic_mqtt_dotdot_level_stop_callback.erase(callback);
}
void uic_mqtt_dotdot_level_stop_callback_clear()
{
  uic_mqtt_dotdot_level_stop_callback.clear();
}
std::set<uic_mqtt_dotdot_level_stop_callback_t>& get_uic_mqtt_dotdot_level_stop_callback()
{
  return uic_mqtt_dotdot_level_stop_callback;
}

void uic_mqtt_dotdot_level_generated_stop_callback_set(const uic_mqtt_dotdot_level_stop_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_generated_stop_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_generated_stop_callback_unset(const uic_mqtt_dotdot_level_stop_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_stop_callback.erase(callback);
}
void uic_mqtt_dotdot_level_generated_stop_callback_clear()
{
  uic_mqtt_dotdot_level_generated_stop_callback.clear();
}
void uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_set(const uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_move_to_level_with_on_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_unset(const uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_move_to_level_with_on_off_callback.erase(callback);
}
void uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_clear()
{
  uic_mqtt_dotdot_level_move_to_level_with_on_off_callback.clear();
}
std::set<uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t>& get_uic_mqtt_dotdot_level_move_to_level_with_on_off_callback()
{
  return uic_mqtt_dotdot_level_move_to_level_with_on_off_callback;
}

void uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback_set(const uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback_unset(const uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback.erase(callback);
}
void uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback_clear()
{
  uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback.clear();
}
void uic_mqtt_dotdot_level_move_with_on_off_callback_set(const uic_mqtt_dotdot_level_move_with_on_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_move_with_on_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_move_with_on_off_callback_unset(const uic_mqtt_dotdot_level_move_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_move_with_on_off_callback.erase(callback);
}
void uic_mqtt_dotdot_level_move_with_on_off_callback_clear()
{
  uic_mqtt_dotdot_level_move_with_on_off_callback.clear();
}
std::set<uic_mqtt_dotdot_level_move_with_on_off_callback_t>& get_uic_mqtt_dotdot_level_move_with_on_off_callback()
{
  return uic_mqtt_dotdot_level_move_with_on_off_callback;
}

void uic_mqtt_dotdot_level_generated_move_with_on_off_callback_set(const uic_mqtt_dotdot_level_move_with_on_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_generated_move_with_on_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_generated_move_with_on_off_callback_unset(const uic_mqtt_dotdot_level_move_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_move_with_on_off_callback.erase(callback);
}
void uic_mqtt_dotdot_level_generated_move_with_on_off_callback_clear()
{
  uic_mqtt_dotdot_level_generated_move_with_on_off_callback.clear();
}
void uic_mqtt_dotdot_level_step_with_on_off_callback_set(const uic_mqtt_dotdot_level_step_with_on_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_step_with_on_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_step_with_on_off_callback_unset(const uic_mqtt_dotdot_level_step_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_step_with_on_off_callback.erase(callback);
}
void uic_mqtt_dotdot_level_step_with_on_off_callback_clear()
{
  uic_mqtt_dotdot_level_step_with_on_off_callback.clear();
}
std::set<uic_mqtt_dotdot_level_step_with_on_off_callback_t>& get_uic_mqtt_dotdot_level_step_with_on_off_callback()
{
  return uic_mqtt_dotdot_level_step_with_on_off_callback;
}

void uic_mqtt_dotdot_level_generated_step_with_on_off_callback_set(const uic_mqtt_dotdot_level_step_with_on_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_generated_step_with_on_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_generated_step_with_on_off_callback_unset(const uic_mqtt_dotdot_level_step_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_step_with_on_off_callback.erase(callback);
}
void uic_mqtt_dotdot_level_generated_step_with_on_off_callback_clear()
{
  uic_mqtt_dotdot_level_generated_step_with_on_off_callback.clear();
}
void uic_mqtt_dotdot_level_stop_with_on_off_callback_set(const uic_mqtt_dotdot_level_stop_with_on_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_stop_with_on_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_stop_with_on_off_callback_unset(const uic_mqtt_dotdot_level_stop_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_stop_with_on_off_callback.erase(callback);
}
void uic_mqtt_dotdot_level_stop_with_on_off_callback_clear()
{
  uic_mqtt_dotdot_level_stop_with_on_off_callback.clear();
}
std::set<uic_mqtt_dotdot_level_stop_with_on_off_callback_t>& get_uic_mqtt_dotdot_level_stop_with_on_off_callback()
{
  return uic_mqtt_dotdot_level_stop_with_on_off_callback;
}

void uic_mqtt_dotdot_level_generated_stop_with_on_off_callback_set(const uic_mqtt_dotdot_level_stop_with_on_off_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_generated_stop_with_on_off_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_generated_stop_with_on_off_callback_unset(const uic_mqtt_dotdot_level_stop_with_on_off_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_stop_with_on_off_callback.erase(callback);
}
void uic_mqtt_dotdot_level_generated_stop_with_on_off_callback_clear()
{
  uic_mqtt_dotdot_level_generated_stop_with_on_off_callback.clear();
}
void uic_mqtt_dotdot_level_move_to_closest_frequency_callback_set(const uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_move_to_closest_frequency_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_move_to_closest_frequency_callback_unset(const uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t callback)
{
  uic_mqtt_dotdot_level_move_to_closest_frequency_callback.erase(callback);
}
void uic_mqtt_dotdot_level_move_to_closest_frequency_callback_clear()
{
  uic_mqtt_dotdot_level_move_to_closest_frequency_callback.clear();
}
std::set<uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t>& get_uic_mqtt_dotdot_level_move_to_closest_frequency_callback()
{
  return uic_mqtt_dotdot_level_move_to_closest_frequency_callback;
}

void uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback_set(const uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback_unset(const uic_mqtt_dotdot_level_move_to_closest_frequency_callback_t callback)
{
  uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback.erase(callback);
}
void uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback_clear()
{
  uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback.clear();
}

void uic_mqtt_dotdot_set_level_write_attributes_callback(
  const uic_mqtt_dotdot_level_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_level_write_attributes_callback(
  const uic_mqtt_dotdot_level_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_level_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_level_write_attributes_callbacks()
{
  uic_mqtt_dotdot_level_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_level_write_attributes_callback_t>& get_uic_mqtt_dotdot_level_write_attributes_callback()
{
  return uic_mqtt_dotdot_level_write_attributes_callback;
}

void uic_mqtt_dotdot_set_level_force_read_attributes_callback(
  const uic_mqtt_dotdot_level_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_level_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_level_force_read_attributes_callback(
  const uic_mqtt_dotdot_level_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_level_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_level_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_level_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/MoveToLevel
void uic_mqtt_dotdot_on_level_move_to_level(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_move_to_level_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t level = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_level(
      jsn,
      level,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToLevel");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevel", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevel", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_level_move_to_level_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      level,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/MoveToLevel
static void uic_mqtt_dotdot_on_generated_level_move_to_level(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_move_to_level_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t level = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_level(
      jsn,
      level,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToLevel");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevel", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevel", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_level_generated_move_to_level_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      level,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/Move
void uic_mqtt_dotdot_on_level_move(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_move_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Move");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Move", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Move", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_level_move_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/Move
static void uic_mqtt_dotdot_on_generated_level_move(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_move_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Move");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Move", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Move", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_level_generated_move_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/Step
void uic_mqtt_dotdot_on_level_step(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_step_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode step_mode = {};
  uint8_t step_size = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_step(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Step");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Step", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Step", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_level_step_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/Step
static void uic_mqtt_dotdot_on_generated_level_step(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_step_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode step_mode = {};
  uint8_t step_size = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_step(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Step");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Step", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Step", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_level_generated_step_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/Stop
void uic_mqtt_dotdot_on_level_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_stop_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_stop(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Stop", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_level_stop_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/Stop
static void uic_mqtt_dotdot_on_generated_level_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_stop_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_stop(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "Stop", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_level_generated_stop_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/MoveToLevelWithOnOff
void uic_mqtt_dotdot_on_level_move_to_level_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_move_to_level_with_on_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t level = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_level_with_on_off(
      jsn,
      level,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToLevelWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevelWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevelWithOnOff", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_level_move_to_level_with_on_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      level,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/MoveToLevelWithOnOff
static void uic_mqtt_dotdot_on_generated_level_move_to_level_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t level = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_level_with_on_off(
      jsn,
      level,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToLevelWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevelWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToLevelWithOnOff", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      level,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/MoveWithOnOff
void uic_mqtt_dotdot_on_level_move_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_move_with_on_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_with_on_off(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveWithOnOff", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_level_move_with_on_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/MoveWithOnOff
static void uic_mqtt_dotdot_on_generated_level_move_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_move_with_on_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_with_on_off(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveWithOnOff", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_level_generated_move_with_on_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/StepWithOnOff
void uic_mqtt_dotdot_on_level_step_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_step_with_on_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode step_mode = {};
  uint8_t step_size = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_step_with_on_off(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "StepWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StepWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StepWithOnOff", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_level_step_with_on_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/StepWithOnOff
static void uic_mqtt_dotdot_on_generated_level_step_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_step_with_on_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  MoveStepMode step_mode = {};
  uint8_t step_size = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_step_with_on_off(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "StepWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StepWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StepWithOnOff", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_level_generated_step_with_on_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/StopWithOnOff
void uic_mqtt_dotdot_on_level_stop_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_stop_with_on_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_stop_with_on_off(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "StopWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StopWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StopWithOnOff", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_level_stop_with_on_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/StopWithOnOff
static void uic_mqtt_dotdot_on_generated_level_stop_with_on_off(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_stop_with_on_off_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_stop_with_on_off(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "StopWithOnOff");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StopWithOnOff", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "StopWithOnOff", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_level_generated_stop_with_on_off_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/MoveToClosestFrequency
void uic_mqtt_dotdot_on_level_move_to_closest_frequency(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_move_to_closest_frequency_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t frequency = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_closest_frequency(
      jsn,
      frequency
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToClosestFrequency");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToClosestFrequency", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToClosestFrequency", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_level_move_to_closest_frequency_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      frequency
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Level/GeneratedCommands/MoveToClosestFrequency
static void uic_mqtt_dotdot_on_generated_level_move_to_closest_frequency(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t frequency = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_level_move_to_closest_frequency(
      jsn,
      frequency
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "MoveToClosestFrequency");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToClosestFrequency", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "MoveToClosestFrequency", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      frequency
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Level/Commands/WriteAttributes
void uic_mqtt_dotdot_on_level_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_level_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_level_state_t new_state = {};
  uic_mqtt_dotdot_level_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_level_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Level", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_level_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_level_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_level_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_level_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.current_level = true;
      force_update.remaining_time = true;
      force_update.min_level = true;
      force_update.max_level = true;
      force_update.current_frequency = true;
      force_update.min_frequency = true;
      force_update.max_frequency = true;
      force_update.options = true;
      force_update.on_off_transition_time = true;
      force_update.on_level = true;
      force_update.on_transition_time = true;
      force_update.off_transition_time = true;
      force_update.default_move_rate = true;
      force_update.start_up_current_level = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"CurrentLevel", &force_update.current_level },
        {"RemainingTime", &force_update.remaining_time },
        {"MinLevel", &force_update.min_level },
        {"MaxLevel", &force_update.max_level },
        {"CurrentFrequency", &force_update.current_frequency },
        {"MinFrequency", &force_update.min_frequency },
        {"MaxFrequency", &force_update.max_frequency },
        {"Options", &force_update.options },
        {"OnOffTransitionTime", &force_update.on_off_transition_time },
        {"OnLevel", &force_update.on_level },
        {"OnTransitionTime", &force_update.on_transition_time },
        {"OffTransitionTime", &force_update.off_transition_time },
        {"DefaultMoveRate", &force_update.default_move_rate },
        {"StartUpCurrentLevel", &force_update.start_up_current_level },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_level_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Level/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_level_current_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/CurrentLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/CurrentLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_current_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/CurrentLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_remaining_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/RemainingTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/RemainingTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_remaining_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/RemainingTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_min_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/MinLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/MinLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_min_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/MinLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_max_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/MaxLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/MaxLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_max_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/MaxLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_current_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,4,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,4,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/CurrentFrequency", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/CurrentFrequency";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_current_frequency_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/CurrentFrequency";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_min_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,5,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,5,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/MinFrequency", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/MinFrequency";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_min_frequency_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/MinFrequency";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_max_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,6,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,6,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/MaxFrequency", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/MaxFrequency";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_max_frequency_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/MaxFrequency";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_options_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = LevelOptions.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/Options", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Level/Attributes/Options";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_options_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/Options";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_on_off_transition_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/OnOffTransitionTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/OnOffTransitionTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_on_off_transition_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/OnOffTransitionTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_on_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/OnLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/OnLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_on_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/OnLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_on_transition_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/OnTransitionTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/OnTransitionTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_on_transition_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/OnTransitionTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_off_transition_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/OffTransitionTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/OffTransitionTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_off_transition_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/OffTransitionTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_default_move_rate_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,20,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,20,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/DefaultMoveRate", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/DefaultMoveRate";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_default_move_rate_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/DefaultMoveRate";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_level_start_up_current_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(8,16384,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(8,16384,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Level/Attributes/StartUpCurrentLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Level/Attributes/StartUpCurrentLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_level_start_up_current_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Level/Attributes/StartUpCurrentLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_level_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_level_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_level_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_level_move_to_level_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/MoveToLevel";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_move_to_level);
  }
  if (!uic_mqtt_dotdot_level_generated_move_to_level_callback.empty()) {
    subscription_topic = base_topic + "Level/GeneratedCommands/MoveToLevel";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_move_to_level);
  }
  if (!uic_mqtt_dotdot_level_move_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/Move";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_move);
  }
  if (!uic_mqtt_dotdot_level_generated_move_callback.empty()) {
    subscription_topic = base_topic + "Level/GeneratedCommands/Move";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_move);
  }
  if (!uic_mqtt_dotdot_level_step_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/Step";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_step);
  }
  if (!uic_mqtt_dotdot_level_generated_step_callback.empty()) {
    subscription_topic = base_topic + "Level/GeneratedCommands/Step";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_step);
  }
  if (!uic_mqtt_dotdot_level_stop_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_stop);
  }
  if (!uic_mqtt_dotdot_level_generated_stop_callback.empty()) {
    subscription_topic = base_topic + "Level/GeneratedCommands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_stop);
  }
  if (!uic_mqtt_dotdot_level_move_to_level_with_on_off_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/MoveToLevelWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_move_to_level_with_on_off);
  }
  if (!uic_mqtt_dotdot_level_generated_move_to_level_with_on_off_callback.empty()) {
    subscription_topic = base_topic + "Level/GeneratedCommands/MoveToLevelWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_move_to_level_with_on_off);
  }
  if (!uic_mqtt_dotdot_level_move_with_on_off_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/MoveWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_move_with_on_off);
  }
  if (!uic_mqtt_dotdot_level_generated_move_with_on_off_callback.empty()) {
    subscription_topic = base_topic + "Level/GeneratedCommands/MoveWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_move_with_on_off);
  }
  if (!uic_mqtt_dotdot_level_step_with_on_off_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/StepWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_step_with_on_off);
  }
  if (!uic_mqtt_dotdot_level_generated_step_with_on_off_callback.empty()) {
    subscription_topic = base_topic + "Level/GeneratedCommands/StepWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_step_with_on_off);
  }
  if (!uic_mqtt_dotdot_level_stop_with_on_off_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/StopWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_stop_with_on_off);
  }
  if (!uic_mqtt_dotdot_level_generated_stop_with_on_off_callback.empty()) {
    subscription_topic = base_topic + "Level/GeneratedCommands/StopWithOnOff";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_stop_with_on_off);
  }
  if (!uic_mqtt_dotdot_level_move_to_closest_frequency_callback.empty()) {
    subscription_topic = base_topic + "Level/Commands/MoveToClosestFrequency";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_level_move_to_closest_frequency);
  }
  if (!uic_mqtt_dotdot_level_generated_move_to_closest_frequency_callback.empty()) {
    subscription_topic = base_topic + "Level/GeneratedCommands/MoveToClosestFrequency";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_level_move_to_closest_frequency);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_level_attributes_init();

  uic_mqtt_dotdot_by_group_level_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_alarms_reset_alarm_callback_t> uic_mqtt_dotdot_alarms_reset_alarm_callback;
static std::set<uic_mqtt_dotdot_alarms_reset_alarm_callback_t> uic_mqtt_dotdot_alarms_generated_reset_alarm_callback;
static std::set<uic_mqtt_dotdot_alarms_alarm_callback_t> uic_mqtt_dotdot_alarms_alarm_callback;
static std::set<uic_mqtt_dotdot_alarms_alarm_callback_t> uic_mqtt_dotdot_alarms_generated_alarm_callback;
static std::set<uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t> uic_mqtt_dotdot_alarms_reset_all_alarms_callback;
static std::set<uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t> uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback;
static std::set<uic_mqtt_dotdot_alarms_get_alarm_response_callback_t> uic_mqtt_dotdot_alarms_get_alarm_response_callback;
static std::set<uic_mqtt_dotdot_alarms_get_alarm_response_callback_t> uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback;
static std::set<uic_mqtt_dotdot_alarms_get_alarm_callback_t> uic_mqtt_dotdot_alarms_get_alarm_callback;
static std::set<uic_mqtt_dotdot_alarms_get_alarm_callback_t> uic_mqtt_dotdot_alarms_generated_get_alarm_callback;
static std::set<uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t> uic_mqtt_dotdot_alarms_reset_alarm_log_callback;
static std::set<uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t> uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback;
static std::set<uic_mqtt_dotdot_alarms_write_attributes_callback_t> uic_mqtt_dotdot_alarms_write_attributes_callback;
static std::set<uic_mqtt_dotdot_alarms_force_read_attributes_callback_t> uic_mqtt_dotdot_alarms_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_alarms_reset_alarm_callback_set(const uic_mqtt_dotdot_alarms_reset_alarm_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_reset_alarm_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_reset_alarm_callback_unset(const uic_mqtt_dotdot_alarms_reset_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_reset_alarm_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_reset_alarm_callback_clear()
{
  uic_mqtt_dotdot_alarms_reset_alarm_callback.clear();
}
std::set<uic_mqtt_dotdot_alarms_reset_alarm_callback_t>& get_uic_mqtt_dotdot_alarms_reset_alarm_callback()
{
  return uic_mqtt_dotdot_alarms_reset_alarm_callback;
}

void uic_mqtt_dotdot_alarms_generated_reset_alarm_callback_set(const uic_mqtt_dotdot_alarms_reset_alarm_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_generated_reset_alarm_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_generated_reset_alarm_callback_unset(const uic_mqtt_dotdot_alarms_reset_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_reset_alarm_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_generated_reset_alarm_callback_clear()
{
  uic_mqtt_dotdot_alarms_generated_reset_alarm_callback.clear();
}
void uic_mqtt_dotdot_alarms_alarm_callback_set(const uic_mqtt_dotdot_alarms_alarm_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_alarm_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_alarm_callback_unset(const uic_mqtt_dotdot_alarms_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_alarm_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_alarm_callback_clear()
{
  uic_mqtt_dotdot_alarms_alarm_callback.clear();
}
std::set<uic_mqtt_dotdot_alarms_alarm_callback_t>& get_uic_mqtt_dotdot_alarms_alarm_callback()
{
  return uic_mqtt_dotdot_alarms_alarm_callback;
}

void uic_mqtt_dotdot_alarms_generated_alarm_callback_set(const uic_mqtt_dotdot_alarms_alarm_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_generated_alarm_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_generated_alarm_callback_unset(const uic_mqtt_dotdot_alarms_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_alarm_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_generated_alarm_callback_clear()
{
  uic_mqtt_dotdot_alarms_generated_alarm_callback.clear();
}
void uic_mqtt_dotdot_alarms_reset_all_alarms_callback_set(const uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_reset_all_alarms_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_reset_all_alarms_callback_unset(const uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t callback)
{
  uic_mqtt_dotdot_alarms_reset_all_alarms_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_reset_all_alarms_callback_clear()
{
  uic_mqtt_dotdot_alarms_reset_all_alarms_callback.clear();
}
std::set<uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t>& get_uic_mqtt_dotdot_alarms_reset_all_alarms_callback()
{
  return uic_mqtt_dotdot_alarms_reset_all_alarms_callback;
}

void uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback_set(const uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback_unset(const uic_mqtt_dotdot_alarms_reset_all_alarms_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback_clear()
{
  uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback.clear();
}
void uic_mqtt_dotdot_alarms_get_alarm_response_callback_set(const uic_mqtt_dotdot_alarms_get_alarm_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_get_alarm_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_get_alarm_response_callback_unset(const uic_mqtt_dotdot_alarms_get_alarm_response_callback_t callback)
{
  uic_mqtt_dotdot_alarms_get_alarm_response_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_get_alarm_response_callback_clear()
{
  uic_mqtt_dotdot_alarms_get_alarm_response_callback.clear();
}
std::set<uic_mqtt_dotdot_alarms_get_alarm_response_callback_t>& get_uic_mqtt_dotdot_alarms_get_alarm_response_callback()
{
  return uic_mqtt_dotdot_alarms_get_alarm_response_callback;
}

void uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback_set(const uic_mqtt_dotdot_alarms_get_alarm_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback_unset(const uic_mqtt_dotdot_alarms_get_alarm_response_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback_clear()
{
  uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback.clear();
}
void uic_mqtt_dotdot_alarms_get_alarm_callback_set(const uic_mqtt_dotdot_alarms_get_alarm_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_get_alarm_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_get_alarm_callback_unset(const uic_mqtt_dotdot_alarms_get_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_get_alarm_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_get_alarm_callback_clear()
{
  uic_mqtt_dotdot_alarms_get_alarm_callback.clear();
}
std::set<uic_mqtt_dotdot_alarms_get_alarm_callback_t>& get_uic_mqtt_dotdot_alarms_get_alarm_callback()
{
  return uic_mqtt_dotdot_alarms_get_alarm_callback;
}

void uic_mqtt_dotdot_alarms_generated_get_alarm_callback_set(const uic_mqtt_dotdot_alarms_get_alarm_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_generated_get_alarm_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_generated_get_alarm_callback_unset(const uic_mqtt_dotdot_alarms_get_alarm_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_get_alarm_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_generated_get_alarm_callback_clear()
{
  uic_mqtt_dotdot_alarms_generated_get_alarm_callback.clear();
}
void uic_mqtt_dotdot_alarms_reset_alarm_log_callback_set(const uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_reset_alarm_log_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_reset_alarm_log_callback_unset(const uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t callback)
{
  uic_mqtt_dotdot_alarms_reset_alarm_log_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_reset_alarm_log_callback_clear()
{
  uic_mqtt_dotdot_alarms_reset_alarm_log_callback.clear();
}
std::set<uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t>& get_uic_mqtt_dotdot_alarms_reset_alarm_log_callback()
{
  return uic_mqtt_dotdot_alarms_reset_alarm_log_callback;
}

void uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback_set(const uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback_unset(const uic_mqtt_dotdot_alarms_reset_alarm_log_callback_t callback)
{
  uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback.erase(callback);
}
void uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback_clear()
{
  uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback.clear();
}

void uic_mqtt_dotdot_set_alarms_write_attributes_callback(
  const uic_mqtt_dotdot_alarms_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_alarms_write_attributes_callback(
  const uic_mqtt_dotdot_alarms_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_alarms_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_alarms_write_attributes_callbacks()
{
  uic_mqtt_dotdot_alarms_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_alarms_write_attributes_callback_t>& get_uic_mqtt_dotdot_alarms_write_attributes_callback()
{
  return uic_mqtt_dotdot_alarms_write_attributes_callback;
}

void uic_mqtt_dotdot_set_alarms_force_read_attributes_callback(
  const uic_mqtt_dotdot_alarms_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_alarms_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_alarms_force_read_attributes_callback(
  const uic_mqtt_dotdot_alarms_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_alarms_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_alarms_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_alarms_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/ResetAlarm
void uic_mqtt_dotdot_on_alarms_reset_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_reset_alarm_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t alarm_code = {};
  clusterId cluster_identifier = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_reset_alarm(
      jsn,
      alarm_code,

      cluster_identifier
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAlarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarm", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_alarms_reset_alarm_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      alarm_code,
  
      cluster_identifier
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/ResetAlarm
static void uic_mqtt_dotdot_on_generated_alarms_reset_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_reset_alarm_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t alarm_code = {};
  clusterId cluster_identifier = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_reset_alarm(
      jsn,
      alarm_code,

      cluster_identifier
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAlarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarm", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_alarms_generated_reset_alarm_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      alarm_code,
  
      cluster_identifier
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/Alarm
void uic_mqtt_dotdot_on_alarms_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_alarm_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t alarm_code = {};
  clusterId cluster_identifier = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_alarm(
      jsn,
      alarm_code,

      cluster_identifier
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "Alarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "Alarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "Alarm", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_alarms_alarm_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      alarm_code,
  
      cluster_identifier
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/Alarm
static void uic_mqtt_dotdot_on_generated_alarms_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_alarm_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t alarm_code = {};
  clusterId cluster_identifier = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_alarm(
      jsn,
      alarm_code,

      cluster_identifier
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "Alarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "Alarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "Alarm", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_alarms_generated_alarm_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      alarm_code,
  
      cluster_identifier
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/ResetAllAlarms
void uic_mqtt_dotdot_on_alarms_reset_all_alarms(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_reset_all_alarms_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAllAlarms");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAllAlarms", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAllAlarms", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_alarms_reset_all_alarms_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/ResetAllAlarms
static void uic_mqtt_dotdot_on_generated_alarms_reset_all_alarms(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAllAlarms");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAllAlarms", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAllAlarms", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/GetAlarmResponse
void uic_mqtt_dotdot_on_alarms_get_alarm_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_get_alarm_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  uint8_t alarm_code = {};
  clusterId cluster_identifier = {};
  uint32_t time_stamp = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_get_alarm_response(
      jsn,
      status,

      alarm_code,

      cluster_identifier,

      time_stamp
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "GetAlarmResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarmResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarmResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_alarms_get_alarm_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      alarm_code,
  
      cluster_identifier,
  
      time_stamp
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/GetAlarmResponse
static void uic_mqtt_dotdot_on_generated_alarms_get_alarm_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};
  uint8_t alarm_code = {};
  clusterId cluster_identifier = {};
  uint32_t time_stamp = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_alarms_get_alarm_response(
      jsn,
      status,

      alarm_code,

      cluster_identifier,

      time_stamp
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "GetAlarmResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarmResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarmResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status,
  
      alarm_code,
  
      cluster_identifier,
  
      time_stamp
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/GetAlarm
void uic_mqtt_dotdot_on_alarms_get_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_get_alarm_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "GetAlarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarm", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_alarms_get_alarm_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/GetAlarm
static void uic_mqtt_dotdot_on_generated_alarms_get_alarm(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_get_alarm_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "GetAlarm");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarm", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "GetAlarm", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_alarms_generated_get_alarm_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/ResetAlarmLog
void uic_mqtt_dotdot_on_alarms_reset_alarm_log(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_reset_alarm_log_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAlarmLog");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarmLog", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarmLog", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_alarms_reset_alarm_log_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/GeneratedCommands/ResetAlarmLog
static void uic_mqtt_dotdot_on_generated_alarms_reset_alarm_log(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "ResetAlarmLog");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarmLog", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "ResetAlarmLog", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Alarms/Commands/WriteAttributes
void uic_mqtt_dotdot_on_alarms_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_alarms_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_alarms_state_t new_state = {};
  uic_mqtt_dotdot_alarms_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_alarms_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Alarms", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_alarms_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_alarms_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_alarms_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_alarms_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.alarm_count = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"AlarmCount", &force_update.alarm_count },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_alarms_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Alarms/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_alarms_alarm_count_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(9,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(9,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Alarms/Attributes/AlarmCount", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Alarms/Attributes/AlarmCount";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_alarms_alarm_count_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Alarms/Attributes/AlarmCount";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_alarms_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_alarms_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Alarms/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_alarms_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Alarms/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_alarms_reset_alarm_callback.empty()) {
    subscription_topic = base_topic + "Alarms/Commands/ResetAlarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_reset_alarm);
  }
  if (!uic_mqtt_dotdot_alarms_generated_reset_alarm_callback.empty()) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/ResetAlarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_reset_alarm);
  }
  if (!uic_mqtt_dotdot_alarms_alarm_callback.empty()) {
    subscription_topic = base_topic + "Alarms/Commands/Alarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_alarm);
  }
  if (!uic_mqtt_dotdot_alarms_generated_alarm_callback.empty()) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/Alarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_alarm);
  }
  if (!uic_mqtt_dotdot_alarms_reset_all_alarms_callback.empty()) {
    subscription_topic = base_topic + "Alarms/Commands/ResetAllAlarms";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_reset_all_alarms);
  }
  if (!uic_mqtt_dotdot_alarms_generated_reset_all_alarms_callback.empty()) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/ResetAllAlarms";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_reset_all_alarms);
  }
  if (!uic_mqtt_dotdot_alarms_get_alarm_response_callback.empty()) {
    subscription_topic = base_topic + "Alarms/Commands/GetAlarmResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_get_alarm_response);
  }
  if (!uic_mqtt_dotdot_alarms_generated_get_alarm_response_callback.empty()) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/GetAlarmResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_get_alarm_response);
  }
  if (!uic_mqtt_dotdot_alarms_get_alarm_callback.empty()) {
    subscription_topic = base_topic + "Alarms/Commands/GetAlarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_get_alarm);
  }
  if (!uic_mqtt_dotdot_alarms_generated_get_alarm_callback.empty()) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/GetAlarm";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_get_alarm);
  }
  if (!uic_mqtt_dotdot_alarms_reset_alarm_log_callback.empty()) {
    subscription_topic = base_topic + "Alarms/Commands/ResetAlarmLog";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_alarms_reset_alarm_log);
  }
  if (!uic_mqtt_dotdot_alarms_generated_reset_alarm_log_callback.empty()) {
    subscription_topic = base_topic + "Alarms/GeneratedCommands/ResetAlarmLog";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_alarms_reset_alarm_log);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_alarms_attributes_init();

  uic_mqtt_dotdot_by_group_alarms_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_time_write_attributes_callback_t> uic_mqtt_dotdot_time_write_attributes_callback;
static std::set<uic_mqtt_dotdot_time_force_read_attributes_callback_t> uic_mqtt_dotdot_time_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_time_write_attributes_callback(
  const uic_mqtt_dotdot_time_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_time_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_time_write_attributes_callback(
  const uic_mqtt_dotdot_time_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_time_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_time_write_attributes_callbacks()
{
  uic_mqtt_dotdot_time_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_time_write_attributes_callback_t>& get_uic_mqtt_dotdot_time_write_attributes_callback()
{
  return uic_mqtt_dotdot_time_write_attributes_callback;
}

void uic_mqtt_dotdot_set_time_force_read_attributes_callback(
  const uic_mqtt_dotdot_time_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_time_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_time_force_read_attributes_callback(
  const uic_mqtt_dotdot_time_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_time_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_time_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_time_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Time/Commands/WriteAttributes
void uic_mqtt_dotdot_on_time_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_time_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_time_state_t new_state = {};
  uic_mqtt_dotdot_time_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_time_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Time", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_time_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_time_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_time_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_time_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.time = true;
      force_update.time_status = true;
      force_update.time_zone = true;
      force_update.dst_start = true;
      force_update.dst_end = true;
      force_update.dst_shift = true;
      force_update.standard_time = true;
      force_update.local_time = true;
      force_update.last_set_time = true;
      force_update.valid_until_time = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"Time", &force_update.time },
        {"TimeStatus", &force_update.time_status },
        {"TimeZone", &force_update.time_zone },
        {"DstStart", &force_update.dst_start },
        {"DstEnd", &force_update.dst_end },
        {"DstShift", &force_update.dst_shift },
        {"StandardTime", &force_update.standard_time },
        {"LocalTime", &force_update.local_time },
        {"LastSetTime", &force_update.last_set_time },
        {"ValidUntilTime", &force_update.valid_until_time },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_time_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Time/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_time_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(10,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(10,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/Time", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/Time";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Time/Attributes/Time";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_time_time_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = TimeTimeStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/TimeStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Time/Attributes/TimeStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_time_status_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Time/Attributes/TimeStatus";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_time_time_zone_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(10,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(10,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/TimeZone", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/TimeZone";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_time_zone_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Time/Attributes/TimeZone";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_time_dst_start_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(10,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(10,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/DstStart", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/DstStart";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_dst_start_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Time/Attributes/DstStart";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_time_dst_end_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(10,4,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(10,4,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/DstEnd", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/DstEnd";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_dst_end_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Time/Attributes/DstEnd";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_time_dst_shift_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(10,5,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(10,5,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/DstShift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/DstShift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_dst_shift_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Time/Attributes/DstShift";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_time_standard_time_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(10,6,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(10,6,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/StandardTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/StandardTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_standard_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Time/Attributes/StandardTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_time_local_time_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(10,7,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(10,7,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/LocalTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/LocalTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_local_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Time/Attributes/LocalTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_time_last_set_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(10,8,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(10,8,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/LastSetTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/LastSetTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_last_set_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Time/Attributes/LastSetTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_time_valid_until_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(10,9,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(10,9,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Time/Attributes/ValidUntilTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Time/Attributes/ValidUntilTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_time_valid_until_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Time/Attributes/ValidUntilTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_time_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_time_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Time/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_time_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_time_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Time/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_time_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_time_attributes_init();

  uic_mqtt_dotdot_by_group_time_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_poll_control_check_in_callback_t> uic_mqtt_dotdot_poll_control_check_in_callback;
static std::set<uic_mqtt_dotdot_poll_control_check_in_callback_t> uic_mqtt_dotdot_poll_control_generated_check_in_callback;
static std::set<uic_mqtt_dotdot_poll_control_check_in_response_callback_t> uic_mqtt_dotdot_poll_control_check_in_response_callback;
static std::set<uic_mqtt_dotdot_poll_control_check_in_response_callback_t> uic_mqtt_dotdot_poll_control_generated_check_in_response_callback;
static std::set<uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t> uic_mqtt_dotdot_poll_control_fast_poll_stop_callback;
static std::set<uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t> uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback;
static std::set<uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t> uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback;
static std::set<uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t> uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback;
static std::set<uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t> uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback;
static std::set<uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t> uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback;
static std::set<uic_mqtt_dotdot_poll_control_write_attributes_callback_t> uic_mqtt_dotdot_poll_control_write_attributes_callback;
static std::set<uic_mqtt_dotdot_poll_control_force_read_attributes_callback_t> uic_mqtt_dotdot_poll_control_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_poll_control_check_in_callback_set(const uic_mqtt_dotdot_poll_control_check_in_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_check_in_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_poll_control_check_in_callback_unset(const uic_mqtt_dotdot_poll_control_check_in_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_check_in_callback.erase(callback);
}
void uic_mqtt_dotdot_poll_control_check_in_callback_clear()
{
  uic_mqtt_dotdot_poll_control_check_in_callback.clear();
}
std::set<uic_mqtt_dotdot_poll_control_check_in_callback_t>& get_uic_mqtt_dotdot_poll_control_check_in_callback()
{
  return uic_mqtt_dotdot_poll_control_check_in_callback;
}

void uic_mqtt_dotdot_poll_control_generated_check_in_callback_set(const uic_mqtt_dotdot_poll_control_check_in_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_generated_check_in_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_poll_control_generated_check_in_callback_unset(const uic_mqtt_dotdot_poll_control_check_in_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_generated_check_in_callback.erase(callback);
}
void uic_mqtt_dotdot_poll_control_generated_check_in_callback_clear()
{
  uic_mqtt_dotdot_poll_control_generated_check_in_callback.clear();
}
void uic_mqtt_dotdot_poll_control_check_in_response_callback_set(const uic_mqtt_dotdot_poll_control_check_in_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_check_in_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_poll_control_check_in_response_callback_unset(const uic_mqtt_dotdot_poll_control_check_in_response_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_check_in_response_callback.erase(callback);
}
void uic_mqtt_dotdot_poll_control_check_in_response_callback_clear()
{
  uic_mqtt_dotdot_poll_control_check_in_response_callback.clear();
}
std::set<uic_mqtt_dotdot_poll_control_check_in_response_callback_t>& get_uic_mqtt_dotdot_poll_control_check_in_response_callback()
{
  return uic_mqtt_dotdot_poll_control_check_in_response_callback;
}

void uic_mqtt_dotdot_poll_control_generated_check_in_response_callback_set(const uic_mqtt_dotdot_poll_control_check_in_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_generated_check_in_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_poll_control_generated_check_in_response_callback_unset(const uic_mqtt_dotdot_poll_control_check_in_response_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_generated_check_in_response_callback.erase(callback);
}
void uic_mqtt_dotdot_poll_control_generated_check_in_response_callback_clear()
{
  uic_mqtt_dotdot_poll_control_generated_check_in_response_callback.clear();
}
void uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_set(const uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_fast_poll_stop_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_unset(const uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_fast_poll_stop_callback.erase(callback);
}
void uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_clear()
{
  uic_mqtt_dotdot_poll_control_fast_poll_stop_callback.clear();
}
std::set<uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t>& get_uic_mqtt_dotdot_poll_control_fast_poll_stop_callback()
{
  return uic_mqtt_dotdot_poll_control_fast_poll_stop_callback;
}

void uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback_set(const uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback_unset(const uic_mqtt_dotdot_poll_control_fast_poll_stop_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback.erase(callback);
}
void uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback_clear()
{
  uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback.clear();
}
void uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_unset(const uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback.erase(callback);
}
void uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_clear()
{
  uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback.clear();
}
std::set<uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t>& get_uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback()
{
  return uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback;
}

void uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback_unset(const uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback.erase(callback);
}
void uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback_clear()
{
  uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback.clear();
}
void uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_unset(const uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback.erase(callback);
}
void uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_clear()
{
  uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback.clear();
}
std::set<uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t>& get_uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback()
{
  return uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback;
}

void uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback_set(const uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback_unset(const uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback.erase(callback);
}
void uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback_clear()
{
  uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback.clear();
}

void uic_mqtt_dotdot_set_poll_control_write_attributes_callback(
  const uic_mqtt_dotdot_poll_control_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_poll_control_write_attributes_callback(
  const uic_mqtt_dotdot_poll_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_poll_control_write_attributes_callbacks()
{
  uic_mqtt_dotdot_poll_control_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_poll_control_write_attributes_callback_t>& get_uic_mqtt_dotdot_poll_control_write_attributes_callback()
{
  return uic_mqtt_dotdot_poll_control_write_attributes_callback;
}

void uic_mqtt_dotdot_set_poll_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_poll_control_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_poll_control_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_poll_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_poll_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_poll_control_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_poll_control_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_poll_control_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/CheckIn
void uic_mqtt_dotdot_on_poll_control_check_in(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_check_in_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "CheckIn");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckIn", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckIn", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_poll_control_check_in_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/GeneratedCommands/CheckIn
static void uic_mqtt_dotdot_on_generated_poll_control_check_in(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_generated_check_in_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "CheckIn");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckIn", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckIn", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_poll_control_generated_check_in_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/CheckInResponse
void uic_mqtt_dotdot_on_poll_control_check_in_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_check_in_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  bool start_fast_polling = {};
  uint16_t fast_poll_timeout = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_check_in_response(
      jsn,
      start_fast_polling,

      fast_poll_timeout
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "CheckInResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckInResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckInResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_poll_control_check_in_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      start_fast_polling,
  
      fast_poll_timeout
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/GeneratedCommands/CheckInResponse
static void uic_mqtt_dotdot_on_generated_poll_control_check_in_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_generated_check_in_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  bool start_fast_polling = {};
  uint16_t fast_poll_timeout = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_check_in_response(
      jsn,
      start_fast_polling,

      fast_poll_timeout
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "CheckInResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckInResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "CheckInResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_poll_control_generated_check_in_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      start_fast_polling,
  
      fast_poll_timeout
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/FastPollStop
void uic_mqtt_dotdot_on_poll_control_fast_poll_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_fast_poll_stop_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "FastPollStop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "FastPollStop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "FastPollStop", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_poll_control_fast_poll_stop_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/GeneratedCommands/FastPollStop
static void uic_mqtt_dotdot_on_generated_poll_control_fast_poll_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "FastPollStop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "FastPollStop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "FastPollStop", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/SetLongPollInterval
void uic_mqtt_dotdot_on_poll_control_set_long_poll_interval(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint32_t new_long_poll_interval = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_set_long_poll_interval(
      jsn,
      new_long_poll_interval
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "SetLongPollInterval");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetLongPollInterval", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetLongPollInterval", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_long_poll_interval
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/GeneratedCommands/SetLongPollInterval
static void uic_mqtt_dotdot_on_generated_poll_control_set_long_poll_interval(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint32_t new_long_poll_interval = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_set_long_poll_interval(
      jsn,
      new_long_poll_interval
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "SetLongPollInterval");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetLongPollInterval", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetLongPollInterval", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_long_poll_interval
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/SetShortPollInterval
void uic_mqtt_dotdot_on_poll_control_set_short_poll_interval(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t new_short_poll_interval = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_set_short_poll_interval(
      jsn,
      new_short_poll_interval
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "SetShortPollInterval");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetShortPollInterval", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetShortPollInterval", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_short_poll_interval
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/GeneratedCommands/SetShortPollInterval
static void uic_mqtt_dotdot_on_generated_poll_control_set_short_poll_interval(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t new_short_poll_interval = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_poll_control_set_short_poll_interval(
      jsn,
      new_short_poll_interval
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "SetShortPollInterval");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetShortPollInterval", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "SetShortPollInterval", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_short_poll_interval
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/PollControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_poll_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_poll_control_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_poll_control_state_t new_state = {};
  uic_mqtt_dotdot_poll_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_poll_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PollControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_poll_control_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_poll_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_poll_control_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_poll_control_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.check_in_interval = true;
      force_update.long_poll_interval = true;
      force_update.short_poll_interval = true;
      force_update.fast_poll_timeout = true;
      force_update.check_in_interval_min = true;
      force_update.long_poll_interval_min = true;
      force_update.fast_poll_timeout_max = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"CheckInInterval", &force_update.check_in_interval },
        {"LongPollInterval", &force_update.long_poll_interval },
        {"ShortPollInterval", &force_update.short_poll_interval },
        {"FastPollTimeout", &force_update.fast_poll_timeout },
        {"CheckInIntervalMin", &force_update.check_in_interval_min },
        {"LongPollIntervalMin", &force_update.long_poll_interval_min },
        {"FastPollTimeoutMax", &force_update.fast_poll_timeout_max },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_poll_control_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "PollControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_poll_control_check_in_interval_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(32,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(32,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/CheckInInterval", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/CheckInInterval";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_poll_control_check_in_interval_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PollControl/Attributes/CheckInInterval";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_poll_control_long_poll_interval_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(32,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(32,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/LongPollInterval", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/LongPollInterval";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_poll_control_long_poll_interval_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PollControl/Attributes/LongPollInterval";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_poll_control_short_poll_interval_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(32,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(32,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/ShortPollInterval", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/ShortPollInterval";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_poll_control_short_poll_interval_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PollControl/Attributes/ShortPollInterval";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_poll_control_fast_poll_timeout_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(32,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(32,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/FastPollTimeout", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/FastPollTimeout";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_poll_control_fast_poll_timeout_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PollControl/Attributes/FastPollTimeout";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_poll_control_check_in_interval_min_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(32,4,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(32,4,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/CheckInIntervalMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/CheckInIntervalMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_poll_control_check_in_interval_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PollControl/Attributes/CheckInIntervalMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_poll_control_long_poll_interval_min_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(32,5,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(32,5,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/LongPollIntervalMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/LongPollIntervalMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_poll_control_long_poll_interval_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PollControl/Attributes/LongPollIntervalMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(32,6,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(32,6,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PollControl/Attributes/FastPollTimeoutMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PollControl/Attributes/FastPollTimeoutMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PollControl/Attributes/FastPollTimeoutMax";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_poll_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_poll_control_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "PollControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_poll_control_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "PollControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_poll_control_check_in_callback.empty()) {
    subscription_topic = base_topic + "PollControl/Commands/CheckIn";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_check_in);
  }
  if (!uic_mqtt_dotdot_poll_control_generated_check_in_callback.empty()) {
    subscription_topic = base_topic + "PollControl/GeneratedCommands/CheckIn";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_poll_control_check_in);
  }
  if (!uic_mqtt_dotdot_poll_control_check_in_response_callback.empty()) {
    subscription_topic = base_topic + "PollControl/Commands/CheckInResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_check_in_response);
  }
  if (!uic_mqtt_dotdot_poll_control_generated_check_in_response_callback.empty()) {
    subscription_topic = base_topic + "PollControl/GeneratedCommands/CheckInResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_poll_control_check_in_response);
  }
  if (!uic_mqtt_dotdot_poll_control_fast_poll_stop_callback.empty()) {
    subscription_topic = base_topic + "PollControl/Commands/FastPollStop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_fast_poll_stop);
  }
  if (!uic_mqtt_dotdot_poll_control_generated_fast_poll_stop_callback.empty()) {
    subscription_topic = base_topic + "PollControl/GeneratedCommands/FastPollStop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_poll_control_fast_poll_stop);
  }
  if (!uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback.empty()) {
    subscription_topic = base_topic + "PollControl/Commands/SetLongPollInterval";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_set_long_poll_interval);
  }
  if (!uic_mqtt_dotdot_poll_control_generated_set_long_poll_interval_callback.empty()) {
    subscription_topic = base_topic + "PollControl/GeneratedCommands/SetLongPollInterval";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_poll_control_set_long_poll_interval);
  }
  if (!uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback.empty()) {
    subscription_topic = base_topic + "PollControl/Commands/SetShortPollInterval";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_poll_control_set_short_poll_interval);
  }
  if (!uic_mqtt_dotdot_poll_control_generated_set_short_poll_interval_callback.empty()) {
    subscription_topic = base_topic + "PollControl/GeneratedCommands/SetShortPollInterval";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_poll_control_set_short_poll_interval);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_poll_control_attributes_init();

  uic_mqtt_dotdot_by_group_poll_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_shade_configuration_write_attributes_callback_t> uic_mqtt_dotdot_shade_configuration_write_attributes_callback;
static std::set<uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback_t> uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_shade_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_shade_configuration_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_shade_configuration_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_shade_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_shade_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_shade_configuration_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_shade_configuration_write_attributes_callbacks()
{
  uic_mqtt_dotdot_shade_configuration_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_shade_configuration_write_attributes_callback_t>& get_uic_mqtt_dotdot_shade_configuration_write_attributes_callback()
{
  return uic_mqtt_dotdot_shade_configuration_write_attributes_callback;
}

void uic_mqtt_dotdot_set_shade_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_shade_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_shade_configuration_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/ShadeConfiguration/Commands/WriteAttributes
void uic_mqtt_dotdot_on_shade_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_shade_configuration_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_shade_configuration_state_t new_state = {};
  uic_mqtt_dotdot_shade_configuration_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_shade_configuration_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ShadeConfiguration", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_shade_configuration_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_shade_configuration_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_shade_configuration_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.physical_closed_limit = true;
      force_update.motor_step_size = true;
      force_update.status = true;
      force_update.closed_limit = true;
      force_update.mode = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"PhysicalClosedLimit", &force_update.physical_closed_limit },
        {"MotorStepSize", &force_update.motor_step_size },
        {"Status", &force_update.status },
        {"ClosedLimit", &force_update.closed_limit },
        {"Mode", &force_update.mode },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "ShadeConfiguration/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_shade_configuration_physical_closed_limit_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(256,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(256,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration/Attributes/PhysicalClosedLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/PhysicalClosedLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_shade_configuration_physical_closed_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ShadeConfiguration/Attributes/PhysicalClosedLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_shade_configuration_motor_step_size_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(256,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(256,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration/Attributes/MotorStepSize", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/MotorStepSize";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_shade_configuration_motor_step_size_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ShadeConfiguration/Attributes/MotorStepSize";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_shade_configuration_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ShadeConfigurationStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration/Attributes/Status", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/Status";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_shade_configuration_status_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ShadeConfiguration/Attributes/Status";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_shade_configuration_closed_limit_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(256,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(256,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration/Attributes/ClosedLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/ClosedLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_shade_configuration_closed_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ShadeConfiguration/Attributes/ClosedLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_shade_configuration_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef SHADE_CONFIGURATION_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = shade_configuration_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for SHADE_CONFIGURATION_MODE. Using number instead.");
  jsn["value"] = static_cast<ShadeConfigurationMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ShadeConfiguration/Attributes/Mode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/Mode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_shade_configuration_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ShadeConfiguration/Attributes/Mode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_shade_configuration_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_shade_configuration_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "ShadeConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_shade_configuration_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "ShadeConfiguration/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_shade_configuration_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_shade_configuration_attributes_init();

  uic_mqtt_dotdot_by_group_shade_configuration_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_door_lock_lock_door_callback_t> uic_mqtt_dotdot_door_lock_lock_door_callback;
static std::set<uic_mqtt_dotdot_door_lock_lock_door_callback_t> uic_mqtt_dotdot_door_lock_generated_lock_door_callback;
static std::set<uic_mqtt_dotdot_door_lock_lock_door_response_callback_t> uic_mqtt_dotdot_door_lock_lock_door_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_lock_door_response_callback_t> uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_unlock_door_callback_t> uic_mqtt_dotdot_door_lock_unlock_door_callback;
static std::set<uic_mqtt_dotdot_door_lock_unlock_door_callback_t> uic_mqtt_dotdot_door_lock_generated_unlock_door_callback;
static std::set<uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t> uic_mqtt_dotdot_door_lock_unlock_door_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t> uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_toggle_callback_t> uic_mqtt_dotdot_door_lock_toggle_callback;
static std::set<uic_mqtt_dotdot_door_lock_toggle_callback_t> uic_mqtt_dotdot_door_lock_generated_toggle_callback;
static std::set<uic_mqtt_dotdot_door_lock_toggle_response_callback_t> uic_mqtt_dotdot_door_lock_toggle_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_toggle_response_callback_t> uic_mqtt_dotdot_door_lock_generated_toggle_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t> uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback;
static std::set<uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t> uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback;
static std::set<uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t> uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t> uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_log_record_callback_t> uic_mqtt_dotdot_door_lock_get_log_record_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_log_record_callback_t> uic_mqtt_dotdot_door_lock_generated_get_log_record_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t> uic_mqtt_dotdot_door_lock_get_log_record_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t> uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_pin_code_callback_t> uic_mqtt_dotdot_door_lock_set_pin_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_pin_code_callback_t> uic_mqtt_dotdot_door_lock_generated_set_pin_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_pin_code_response_callback_t> uic_mqtt_dotdot_door_lock_set_pin_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_pin_code_response_callback_t> uic_mqtt_dotdot_door_lock_generated_set_pin_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_pin_code_callback_t> uic_mqtt_dotdot_door_lock_get_pin_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_pin_code_callback_t> uic_mqtt_dotdot_door_lock_generated_get_pin_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_pin_code_response_callback_t> uic_mqtt_dotdot_door_lock_get_pin_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_pin_code_response_callback_t> uic_mqtt_dotdot_door_lock_generated_get_pin_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_pin_code_callback_t> uic_mqtt_dotdot_door_lock_clear_pin_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_pin_code_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_pin_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback_t> uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_pin_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_t> uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback_t> uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_user_status_callback_t> uic_mqtt_dotdot_door_lock_set_user_status_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_user_status_callback_t> uic_mqtt_dotdot_door_lock_generated_set_user_status_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t> uic_mqtt_dotdot_door_lock_set_user_status_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t> uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_status_callback_t> uic_mqtt_dotdot_door_lock_get_user_status_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_status_callback_t> uic_mqtt_dotdot_door_lock_generated_get_user_status_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t> uic_mqtt_dotdot_door_lock_get_user_status_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t> uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t> uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t> uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t> uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t> uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t> uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t> uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t> uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t> uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t> uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t> uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t> uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t> uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t> uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t> uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t> uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_user_type_callback_t> uic_mqtt_dotdot_door_lock_set_user_type_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_user_type_callback_t> uic_mqtt_dotdot_door_lock_generated_set_user_type_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t> uic_mqtt_dotdot_door_lock_set_user_type_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t> uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_type_callback_t> uic_mqtt_dotdot_door_lock_get_user_type_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_type_callback_t> uic_mqtt_dotdot_door_lock_generated_get_user_type_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t> uic_mqtt_dotdot_door_lock_get_user_type_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t> uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_rfid_code_callback_t> uic_mqtt_dotdot_door_lock_set_rfid_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_rfid_code_callback_t> uic_mqtt_dotdot_door_lock_generated_set_rfid_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback_t> uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback_t> uic_mqtt_dotdot_door_lock_generated_set_rfid_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_rfid_code_callback_t> uic_mqtt_dotdot_door_lock_get_rfid_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_rfid_code_callback_t> uic_mqtt_dotdot_door_lock_generated_get_rfid_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback_t> uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback_t> uic_mqtt_dotdot_door_lock_generated_get_rfid_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_t> uic_mqtt_dotdot_door_lock_clear_rfid_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback_t> uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_t> uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback_t> uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_user_callback_t> uic_mqtt_dotdot_door_lock_set_user_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_user_callback_t> uic_mqtt_dotdot_door_lock_generated_set_user_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_callback_t> uic_mqtt_dotdot_door_lock_get_user_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_callback_t> uic_mqtt_dotdot_door_lock_generated_get_user_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_response_callback_t> uic_mqtt_dotdot_door_lock_get_user_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_user_response_callback_t> uic_mqtt_dotdot_door_lock_generated_get_user_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_user_callback_t> uic_mqtt_dotdot_door_lock_clear_user_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_user_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_user_callback;
static std::set<uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t> uic_mqtt_dotdot_door_lock_operating_event_notification_callback;
static std::set<uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t> uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback;
static std::set<uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t> uic_mqtt_dotdot_door_lock_programming_event_notification_callback;
static std::set<uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t> uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_credential_callback_t> uic_mqtt_dotdot_door_lock_set_credential_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_credential_callback_t> uic_mqtt_dotdot_door_lock_generated_set_credential_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_credential_response_callback_t> uic_mqtt_dotdot_door_lock_set_credential_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_set_credential_response_callback_t> uic_mqtt_dotdot_door_lock_generated_set_credential_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_credential_status_callback_t> uic_mqtt_dotdot_door_lock_get_credential_status_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_credential_status_callback_t> uic_mqtt_dotdot_door_lock_generated_get_credential_status_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_credential_status_response_callback_t> uic_mqtt_dotdot_door_lock_get_credential_status_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_get_credential_status_response_callback_t> uic_mqtt_dotdot_door_lock_generated_get_credential_status_response_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_credential_callback_t> uic_mqtt_dotdot_door_lock_clear_credential_callback;
static std::set<uic_mqtt_dotdot_door_lock_clear_credential_callback_t> uic_mqtt_dotdot_door_lock_generated_clear_credential_callback;
static std::set<uic_mqtt_dotdot_door_lock_unbolt_door_callback_t> uic_mqtt_dotdot_door_lock_unbolt_door_callback;
static std::set<uic_mqtt_dotdot_door_lock_unbolt_door_callback_t> uic_mqtt_dotdot_door_lock_generated_unbolt_door_callback;
static std::set<uic_mqtt_dotdot_door_lock_write_attributes_callback_t> uic_mqtt_dotdot_door_lock_write_attributes_callback;
static std::set<uic_mqtt_dotdot_door_lock_force_read_attributes_callback_t> uic_mqtt_dotdot_door_lock_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_door_lock_lock_door_callback_set(const uic_mqtt_dotdot_door_lock_lock_door_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_lock_door_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_lock_door_callback_unset(const uic_mqtt_dotdot_door_lock_lock_door_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_lock_door_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_lock_door_callback_clear()
{
  uic_mqtt_dotdot_door_lock_lock_door_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_lock_door_callback_t>& get_uic_mqtt_dotdot_door_lock_lock_door_callback()
{
  return uic_mqtt_dotdot_door_lock_lock_door_callback;
}

void uic_mqtt_dotdot_door_lock_generated_lock_door_callback_set(const uic_mqtt_dotdot_door_lock_lock_door_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_lock_door_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_lock_door_callback_unset(const uic_mqtt_dotdot_door_lock_lock_door_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_lock_door_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_lock_door_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_lock_door_callback.clear();
}
void uic_mqtt_dotdot_door_lock_lock_door_response_callback_set(const uic_mqtt_dotdot_door_lock_lock_door_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_lock_door_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_lock_door_response_callback_unset(const uic_mqtt_dotdot_door_lock_lock_door_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_lock_door_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_lock_door_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_lock_door_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_lock_door_response_callback_t>& get_uic_mqtt_dotdot_door_lock_lock_door_response_callback()
{
  return uic_mqtt_dotdot_door_lock_lock_door_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback_set(const uic_mqtt_dotdot_door_lock_lock_door_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback_unset(const uic_mqtt_dotdot_door_lock_lock_door_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_unlock_door_callback_set(const uic_mqtt_dotdot_door_lock_unlock_door_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_unlock_door_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_unlock_door_callback_unset(const uic_mqtt_dotdot_door_lock_unlock_door_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_unlock_door_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_unlock_door_callback_clear()
{
  uic_mqtt_dotdot_door_lock_unlock_door_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_unlock_door_callback_t>& get_uic_mqtt_dotdot_door_lock_unlock_door_callback()
{
  return uic_mqtt_dotdot_door_lock_unlock_door_callback;
}

void uic_mqtt_dotdot_door_lock_generated_unlock_door_callback_set(const uic_mqtt_dotdot_door_lock_unlock_door_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_unlock_door_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_unlock_door_callback_unset(const uic_mqtt_dotdot_door_lock_unlock_door_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_unlock_door_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_unlock_door_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_unlock_door_callback.clear();
}
void uic_mqtt_dotdot_door_lock_unlock_door_response_callback_set(const uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_unlock_door_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_unlock_door_response_callback_unset(const uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_unlock_door_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_unlock_door_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_unlock_door_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t>& get_uic_mqtt_dotdot_door_lock_unlock_door_response_callback()
{
  return uic_mqtt_dotdot_door_lock_unlock_door_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback_set(const uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback_unset(const uic_mqtt_dotdot_door_lock_unlock_door_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_toggle_callback_set(const uic_mqtt_dotdot_door_lock_toggle_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_toggle_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_toggle_callback_unset(const uic_mqtt_dotdot_door_lock_toggle_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_toggle_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_toggle_callback_clear()
{
  uic_mqtt_dotdot_door_lock_toggle_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_toggle_callback_t>& get_uic_mqtt_dotdot_door_lock_toggle_callback()
{
  return uic_mqtt_dotdot_door_lock_toggle_callback;
}

void uic_mqtt_dotdot_door_lock_generated_toggle_callback_set(const uic_mqtt_dotdot_door_lock_toggle_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_toggle_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_toggle_callback_unset(const uic_mqtt_dotdot_door_lock_toggle_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_toggle_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_toggle_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_toggle_callback.clear();
}
void uic_mqtt_dotdot_door_lock_toggle_response_callback_set(const uic_mqtt_dotdot_door_lock_toggle_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_toggle_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_toggle_response_callback_unset(const uic_mqtt_dotdot_door_lock_toggle_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_toggle_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_toggle_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_toggle_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_toggle_response_callback_t>& get_uic_mqtt_dotdot_door_lock_toggle_response_callback()
{
  return uic_mqtt_dotdot_door_lock_toggle_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_toggle_response_callback_set(const uic_mqtt_dotdot_door_lock_toggle_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_toggle_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_toggle_response_callback_unset(const uic_mqtt_dotdot_door_lock_toggle_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_toggle_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_toggle_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_toggle_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_set(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_unset(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_clear()
{
  uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t>& get_uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback()
{
  return uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback;
}

void uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback_set(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback_unset(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback.clear();
}
void uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_set(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_unset(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t>& get_uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback()
{
  return uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback_set(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback_unset(const uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_log_record_callback_set(const uic_mqtt_dotdot_door_lock_get_log_record_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_log_record_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_log_record_callback_unset(const uic_mqtt_dotdot_door_lock_get_log_record_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_log_record_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_log_record_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_log_record_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_log_record_callback_t>& get_uic_mqtt_dotdot_door_lock_get_log_record_callback()
{
  return uic_mqtt_dotdot_door_lock_get_log_record_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_log_record_callback_set(const uic_mqtt_dotdot_door_lock_get_log_record_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_log_record_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_log_record_callback_unset(const uic_mqtt_dotdot_door_lock_get_log_record_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_log_record_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_log_record_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_log_record_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_log_record_response_callback_set(const uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_log_record_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_log_record_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_log_record_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_log_record_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_log_record_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t>& get_uic_mqtt_dotdot_door_lock_get_log_record_response_callback()
{
  return uic_mqtt_dotdot_door_lock_get_log_record_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback_set(const uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_log_record_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_pin_code_callback_set(const uic_mqtt_dotdot_door_lock_set_pin_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_pin_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_pin_code_callback_unset(const uic_mqtt_dotdot_door_lock_set_pin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_pin_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_pin_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_pin_code_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_pin_code_callback_t>& get_uic_mqtt_dotdot_door_lock_set_pin_code_callback()
{
  return uic_mqtt_dotdot_door_lock_set_pin_code_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_pin_code_callback_set(const uic_mqtt_dotdot_door_lock_set_pin_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_pin_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_pin_code_callback_unset(const uic_mqtt_dotdot_door_lock_set_pin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_pin_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_pin_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_pin_code_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_pin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_set_pin_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_pin_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_pin_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_pin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_pin_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_pin_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_pin_code_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_pin_code_response_callback_t>& get_uic_mqtt_dotdot_door_lock_set_pin_code_response_callback()
{
  return uic_mqtt_dotdot_door_lock_set_pin_code_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_pin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_set_pin_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_pin_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_pin_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_pin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_pin_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_pin_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_pin_code_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_pin_code_callback_set(const uic_mqtt_dotdot_door_lock_get_pin_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_pin_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_pin_code_callback_unset(const uic_mqtt_dotdot_door_lock_get_pin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_pin_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_pin_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_pin_code_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_pin_code_callback_t>& get_uic_mqtt_dotdot_door_lock_get_pin_code_callback()
{
  return uic_mqtt_dotdot_door_lock_get_pin_code_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_pin_code_callback_set(const uic_mqtt_dotdot_door_lock_get_pin_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_pin_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_pin_code_callback_unset(const uic_mqtt_dotdot_door_lock_get_pin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_pin_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_pin_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_pin_code_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_pin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_get_pin_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_pin_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_pin_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_pin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_pin_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_pin_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_pin_code_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_pin_code_response_callback_t>& get_uic_mqtt_dotdot_door_lock_get_pin_code_response_callback()
{
  return uic_mqtt_dotdot_door_lock_get_pin_code_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_pin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_get_pin_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_pin_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_pin_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_pin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_pin_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_pin_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_pin_code_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_pin_code_callback_set(const uic_mqtt_dotdot_door_lock_clear_pin_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_pin_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_pin_code_callback_unset(const uic_mqtt_dotdot_door_lock_clear_pin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_pin_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_pin_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_pin_code_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_pin_code_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_pin_code_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_pin_code_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_pin_code_callback_set(const uic_mqtt_dotdot_door_lock_clear_pin_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_pin_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_pin_code_callback_unset(const uic_mqtt_dotdot_door_lock_clear_pin_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_pin_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_pin_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_pin_code_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_pin_code_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_pin_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_pin_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_pin_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_pin_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_pin_code_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_set(const uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_unset(const uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_callback_set(const uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_callback_unset(const uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_user_status_callback_set(const uic_mqtt_dotdot_door_lock_set_user_status_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_user_status_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_user_status_callback_unset(const uic_mqtt_dotdot_door_lock_set_user_status_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_user_status_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_user_status_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_user_status_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_user_status_callback_t>& get_uic_mqtt_dotdot_door_lock_set_user_status_callback()
{
  return uic_mqtt_dotdot_door_lock_set_user_status_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_user_status_callback_set(const uic_mqtt_dotdot_door_lock_set_user_status_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_user_status_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_user_status_callback_unset(const uic_mqtt_dotdot_door_lock_set_user_status_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_user_status_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_user_status_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_user_status_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_user_status_response_callback_set(const uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_user_status_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_user_status_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_user_status_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_user_status_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_user_status_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t>& get_uic_mqtt_dotdot_door_lock_set_user_status_response_callback()
{
  return uic_mqtt_dotdot_door_lock_set_user_status_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback_set(const uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_user_status_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_user_status_callback_set(const uic_mqtt_dotdot_door_lock_get_user_status_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_user_status_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_user_status_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_status_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_user_status_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_user_status_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_user_status_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_user_status_callback_t>& get_uic_mqtt_dotdot_door_lock_get_user_status_callback()
{
  return uic_mqtt_dotdot_door_lock_get_user_status_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_user_status_callback_set(const uic_mqtt_dotdot_door_lock_get_user_status_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_user_status_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_user_status_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_status_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_user_status_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_user_status_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_user_status_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_user_status_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_user_status_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_user_status_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_user_status_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_user_status_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_user_status_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t>& get_uic_mqtt_dotdot_door_lock_get_user_status_response_callback()
{
  return uic_mqtt_dotdot_door_lock_get_user_status_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_status_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t>& get_uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback()
{
  return uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t>& get_uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback()
{
  return uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t>& get_uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback()
{
  return uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t>& get_uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback()
{
  return uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t>& get_uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback()
{
  return uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t>& get_uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback()
{
  return uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t>& get_uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback()
{
  return uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t>& get_uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback()
{
  return uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t>& get_uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback()
{
  return uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t>& get_uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback()
{
  return uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t>& get_uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback()
{
  return uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t>& get_uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback()
{
  return uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback_set(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback_unset(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_user_type_callback_set(const uic_mqtt_dotdot_door_lock_set_user_type_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_user_type_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_user_type_callback_unset(const uic_mqtt_dotdot_door_lock_set_user_type_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_user_type_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_user_type_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_user_type_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_user_type_callback_t>& get_uic_mqtt_dotdot_door_lock_set_user_type_callback()
{
  return uic_mqtt_dotdot_door_lock_set_user_type_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_user_type_callback_set(const uic_mqtt_dotdot_door_lock_set_user_type_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_user_type_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_user_type_callback_unset(const uic_mqtt_dotdot_door_lock_set_user_type_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_user_type_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_user_type_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_user_type_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_user_type_response_callback_set(const uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_user_type_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_user_type_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_user_type_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_user_type_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_user_type_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t>& get_uic_mqtt_dotdot_door_lock_set_user_type_response_callback()
{
  return uic_mqtt_dotdot_door_lock_set_user_type_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback_set(const uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_user_type_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_user_type_callback_set(const uic_mqtt_dotdot_door_lock_get_user_type_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_user_type_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_user_type_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_type_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_user_type_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_user_type_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_user_type_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_user_type_callback_t>& get_uic_mqtt_dotdot_door_lock_get_user_type_callback()
{
  return uic_mqtt_dotdot_door_lock_get_user_type_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_user_type_callback_set(const uic_mqtt_dotdot_door_lock_get_user_type_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_user_type_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_user_type_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_type_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_user_type_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_user_type_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_user_type_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_user_type_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_user_type_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_user_type_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_user_type_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_user_type_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_user_type_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t>& get_uic_mqtt_dotdot_door_lock_get_user_type_response_callback()
{
  return uic_mqtt_dotdot_door_lock_get_user_type_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_type_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_rfid_code_callback_set(const uic_mqtt_dotdot_door_lock_set_rfid_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_rfid_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_rfid_code_callback_unset(const uic_mqtt_dotdot_door_lock_set_rfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_rfid_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_rfid_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_rfid_code_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_rfid_code_callback_t>& get_uic_mqtt_dotdot_door_lock_set_rfid_code_callback()
{
  return uic_mqtt_dotdot_door_lock_set_rfid_code_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_rfid_code_callback_set(const uic_mqtt_dotdot_door_lock_set_rfid_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_rfid_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_rfid_code_callback_unset(const uic_mqtt_dotdot_door_lock_set_rfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_rfid_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_rfid_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_rfid_code_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback_t>& get_uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback()
{
  return uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_rfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_rfid_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_rfid_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_rfid_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_rfid_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_rfid_code_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_rfid_code_callback_set(const uic_mqtt_dotdot_door_lock_get_rfid_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_rfid_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_rfid_code_callback_unset(const uic_mqtt_dotdot_door_lock_get_rfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_rfid_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_rfid_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_rfid_code_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_rfid_code_callback_t>& get_uic_mqtt_dotdot_door_lock_get_rfid_code_callback()
{
  return uic_mqtt_dotdot_door_lock_get_rfid_code_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_rfid_code_callback_set(const uic_mqtt_dotdot_door_lock_get_rfid_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_rfid_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_rfid_code_callback_unset(const uic_mqtt_dotdot_door_lock_get_rfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_rfid_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_rfid_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_rfid_code_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback_t>& get_uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback()
{
  return uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_rfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_rfid_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_rfid_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_rfid_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_rfid_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_rfid_code_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_set(const uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_rfid_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_unset(const uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_rfid_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_rfid_code_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_rfid_code_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_rfid_code_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_callback_set(const uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_callback_unset(const uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_set(const uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_unset(const uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_callback_set(const uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_callback_unset(const uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_response_callback_set(const uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_response_callback_unset(const uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_user_callback_set(const uic_mqtt_dotdot_door_lock_set_user_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_user_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_user_callback_unset(const uic_mqtt_dotdot_door_lock_set_user_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_user_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_user_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_user_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_user_callback_t>& get_uic_mqtt_dotdot_door_lock_set_user_callback()
{
  return uic_mqtt_dotdot_door_lock_set_user_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_user_callback_set(const uic_mqtt_dotdot_door_lock_set_user_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_user_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_user_callback_unset(const uic_mqtt_dotdot_door_lock_set_user_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_user_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_user_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_user_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_user_callback_set(const uic_mqtt_dotdot_door_lock_get_user_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_user_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_user_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_user_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_user_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_user_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_user_callback_t>& get_uic_mqtt_dotdot_door_lock_get_user_callback()
{
  return uic_mqtt_dotdot_door_lock_get_user_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_user_callback_set(const uic_mqtt_dotdot_door_lock_get_user_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_user_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_user_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_user_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_user_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_user_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_user_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_user_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_user_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_user_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_user_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_user_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_user_response_callback_t>& get_uic_mqtt_dotdot_door_lock_get_user_response_callback()
{
  return uic_mqtt_dotdot_door_lock_get_user_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_user_response_callback_set(const uic_mqtt_dotdot_door_lock_get_user_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_user_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_user_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_user_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_user_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_user_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_user_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_user_callback_set(const uic_mqtt_dotdot_door_lock_clear_user_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_user_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_user_callback_unset(const uic_mqtt_dotdot_door_lock_clear_user_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_user_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_user_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_user_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_user_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_user_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_user_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_user_callback_set(const uic_mqtt_dotdot_door_lock_clear_user_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_user_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_user_callback_unset(const uic_mqtt_dotdot_door_lock_clear_user_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_user_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_user_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_user_callback.clear();
}
void uic_mqtt_dotdot_door_lock_operating_event_notification_callback_set(const uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_operating_event_notification_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_operating_event_notification_callback_unset(const uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_operating_event_notification_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_operating_event_notification_callback_clear()
{
  uic_mqtt_dotdot_door_lock_operating_event_notification_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t>& get_uic_mqtt_dotdot_door_lock_operating_event_notification_callback()
{
  return uic_mqtt_dotdot_door_lock_operating_event_notification_callback;
}

void uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback_set(const uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback_unset(const uic_mqtt_dotdot_door_lock_operating_event_notification_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback.clear();
}
void uic_mqtt_dotdot_door_lock_programming_event_notification_callback_set(const uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_programming_event_notification_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_programming_event_notification_callback_unset(const uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_programming_event_notification_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_programming_event_notification_callback_clear()
{
  uic_mqtt_dotdot_door_lock_programming_event_notification_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t>& get_uic_mqtt_dotdot_door_lock_programming_event_notification_callback()
{
  return uic_mqtt_dotdot_door_lock_programming_event_notification_callback;
}

void uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback_set(const uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback_unset(const uic_mqtt_dotdot_door_lock_programming_event_notification_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_credential_callback_set(const uic_mqtt_dotdot_door_lock_set_credential_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_credential_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_credential_callback_unset(const uic_mqtt_dotdot_door_lock_set_credential_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_credential_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_credential_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_credential_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_credential_callback_t>& get_uic_mqtt_dotdot_door_lock_set_credential_callback()
{
  return uic_mqtt_dotdot_door_lock_set_credential_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_credential_callback_set(const uic_mqtt_dotdot_door_lock_set_credential_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_credential_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_credential_callback_unset(const uic_mqtt_dotdot_door_lock_set_credential_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_credential_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_credential_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_credential_callback.clear();
}
void uic_mqtt_dotdot_door_lock_set_credential_response_callback_set(const uic_mqtt_dotdot_door_lock_set_credential_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_set_credential_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_set_credential_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_credential_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_set_credential_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_set_credential_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_set_credential_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_set_credential_response_callback_t>& get_uic_mqtt_dotdot_door_lock_set_credential_response_callback()
{
  return uic_mqtt_dotdot_door_lock_set_credential_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_set_credential_response_callback_set(const uic_mqtt_dotdot_door_lock_set_credential_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_set_credential_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_set_credential_response_callback_unset(const uic_mqtt_dotdot_door_lock_set_credential_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_set_credential_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_set_credential_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_set_credential_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_credential_status_callback_set(const uic_mqtt_dotdot_door_lock_get_credential_status_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_credential_status_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_credential_status_callback_unset(const uic_mqtt_dotdot_door_lock_get_credential_status_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_credential_status_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_credential_status_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_credential_status_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_credential_status_callback_t>& get_uic_mqtt_dotdot_door_lock_get_credential_status_callback()
{
  return uic_mqtt_dotdot_door_lock_get_credential_status_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_credential_status_callback_set(const uic_mqtt_dotdot_door_lock_get_credential_status_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_credential_status_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_credential_status_callback_unset(const uic_mqtt_dotdot_door_lock_get_credential_status_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_credential_status_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_credential_status_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_credential_status_callback.clear();
}
void uic_mqtt_dotdot_door_lock_get_credential_status_response_callback_set(const uic_mqtt_dotdot_door_lock_get_credential_status_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_get_credential_status_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_get_credential_status_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_credential_status_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_get_credential_status_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_get_credential_status_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_get_credential_status_response_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_get_credential_status_response_callback_t>& get_uic_mqtt_dotdot_door_lock_get_credential_status_response_callback()
{
  return uic_mqtt_dotdot_door_lock_get_credential_status_response_callback;
}

void uic_mqtt_dotdot_door_lock_generated_get_credential_status_response_callback_set(const uic_mqtt_dotdot_door_lock_get_credential_status_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_get_credential_status_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_get_credential_status_response_callback_unset(const uic_mqtt_dotdot_door_lock_get_credential_status_response_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_get_credential_status_response_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_get_credential_status_response_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_get_credential_status_response_callback.clear();
}
void uic_mqtt_dotdot_door_lock_clear_credential_callback_set(const uic_mqtt_dotdot_door_lock_clear_credential_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_clear_credential_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_clear_credential_callback_unset(const uic_mqtt_dotdot_door_lock_clear_credential_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_clear_credential_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_clear_credential_callback_clear()
{
  uic_mqtt_dotdot_door_lock_clear_credential_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_clear_credential_callback_t>& get_uic_mqtt_dotdot_door_lock_clear_credential_callback()
{
  return uic_mqtt_dotdot_door_lock_clear_credential_callback;
}

void uic_mqtt_dotdot_door_lock_generated_clear_credential_callback_set(const uic_mqtt_dotdot_door_lock_clear_credential_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_clear_credential_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_clear_credential_callback_unset(const uic_mqtt_dotdot_door_lock_clear_credential_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_clear_credential_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_clear_credential_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_clear_credential_callback.clear();
}
void uic_mqtt_dotdot_door_lock_unbolt_door_callback_set(const uic_mqtt_dotdot_door_lock_unbolt_door_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_unbolt_door_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_unbolt_door_callback_unset(const uic_mqtt_dotdot_door_lock_unbolt_door_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_unbolt_door_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_unbolt_door_callback_clear()
{
  uic_mqtt_dotdot_door_lock_unbolt_door_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_unbolt_door_callback_t>& get_uic_mqtt_dotdot_door_lock_unbolt_door_callback()
{
  return uic_mqtt_dotdot_door_lock_unbolt_door_callback;
}

void uic_mqtt_dotdot_door_lock_generated_unbolt_door_callback_set(const uic_mqtt_dotdot_door_lock_unbolt_door_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_generated_unbolt_door_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_door_lock_generated_unbolt_door_callback_unset(const uic_mqtt_dotdot_door_lock_unbolt_door_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_generated_unbolt_door_callback.erase(callback);
}
void uic_mqtt_dotdot_door_lock_generated_unbolt_door_callback_clear()
{
  uic_mqtt_dotdot_door_lock_generated_unbolt_door_callback.clear();
}

void uic_mqtt_dotdot_set_door_lock_write_attributes_callback(
  const uic_mqtt_dotdot_door_lock_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_door_lock_write_attributes_callback(
  const uic_mqtt_dotdot_door_lock_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_door_lock_write_attributes_callbacks()
{
  uic_mqtt_dotdot_door_lock_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_door_lock_write_attributes_callback_t>& get_uic_mqtt_dotdot_door_lock_write_attributes_callback()
{
  return uic_mqtt_dotdot_door_lock_write_attributes_callback;
}

void uic_mqtt_dotdot_set_door_lock_force_read_attributes_callback(
  const uic_mqtt_dotdot_door_lock_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_door_lock_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_door_lock_force_read_attributes_callback(
  const uic_mqtt_dotdot_door_lock_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_door_lock_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_door_lock_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_door_lock_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/LockDoor
void uic_mqtt_dotdot_on_door_lock_lock_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_lock_door_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string pin_or_rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_lock_door(
      jsn,
      pin_or_rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "LockDoor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoor", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_lock_door_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      pin_or_rfid_code.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/LockDoor
static void uic_mqtt_dotdot_on_generated_door_lock_lock_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_lock_door_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string pin_or_rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_lock_door(
      jsn,
      pin_or_rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "LockDoor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoor", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_lock_door_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      pin_or_rfid_code.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/LockDoorResponse
void uic_mqtt_dotdot_on_door_lock_lock_door_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_lock_door_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_lock_door_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "LockDoorResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoorResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoorResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_lock_door_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/LockDoorResponse
static void uic_mqtt_dotdot_on_generated_door_lock_lock_door_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_lock_door_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "LockDoorResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoorResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "LockDoorResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/UnlockDoor
void uic_mqtt_dotdot_on_door_lock_unlock_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_unlock_door_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string pin_or_rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_door(
      jsn,
      pin_or_rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockDoor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoor", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_unlock_door_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      pin_or_rfid_code.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/UnlockDoor
static void uic_mqtt_dotdot_on_generated_door_lock_unlock_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_unlock_door_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string pin_or_rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_door(
      jsn,
      pin_or_rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockDoor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoor", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_unlock_door_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      pin_or_rfid_code.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/UnlockDoorResponse
void uic_mqtt_dotdot_on_door_lock_unlock_door_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_unlock_door_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_door_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockDoorResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoorResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoorResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_unlock_door_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/UnlockDoorResponse
static void uic_mqtt_dotdot_on_generated_door_lock_unlock_door_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_door_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockDoorResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoorResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockDoorResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/Toggle
void uic_mqtt_dotdot_on_door_lock_toggle(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_toggle_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string pin_or_rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_toggle(
      jsn,
      pin_or_rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "Toggle");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "Toggle", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "Toggle", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_toggle_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      pin_or_rfid_code.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/Toggle
static void uic_mqtt_dotdot_on_generated_door_lock_toggle(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_toggle_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string pin_or_rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_toggle(
      jsn,
      pin_or_rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "Toggle");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "Toggle", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "Toggle", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_toggle_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      pin_or_rfid_code.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ToggleResponse
void uic_mqtt_dotdot_on_door_lock_toggle_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_toggle_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_toggle_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ToggleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ToggleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ToggleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_toggle_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ToggleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_toggle_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_toggle_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_toggle_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ToggleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ToggleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ToggleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_toggle_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/UnlockWithTimeout
void uic_mqtt_dotdot_on_door_lock_unlock_with_timeout(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t timeout_in_seconds = {};
  std::string pin_or_rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout(
      jsn,
      timeout_in_seconds,

      pin_or_rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockWithTimeout");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeout", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeout", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      timeout_in_seconds,
  
      pin_or_rfid_code.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/UnlockWithTimeout
static void uic_mqtt_dotdot_on_generated_door_lock_unlock_with_timeout(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t timeout_in_seconds = {};
  std::string pin_or_rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout(
      jsn,
      timeout_in_seconds,

      pin_or_rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockWithTimeout");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeout", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeout", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      timeout_in_seconds,
  
      pin_or_rfid_code.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/UnlockWithTimeoutResponse
void uic_mqtt_dotdot_on_door_lock_unlock_with_timeout_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockWithTimeoutResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeoutResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeoutResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/UnlockWithTimeoutResponse
static void uic_mqtt_dotdot_on_generated_door_lock_unlock_with_timeout_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  zclStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unlock_with_timeout_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnlockWithTimeoutResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeoutResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnlockWithTimeoutResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetLogRecord
void uic_mqtt_dotdot_on_door_lock_get_log_record(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_log_record_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t log_index = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_log_record(
      jsn,
      log_index
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetLogRecord");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecord", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecord", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_log_record_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      log_index
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetLogRecord
static void uic_mqtt_dotdot_on_generated_door_lock_get_log_record(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_log_record_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t log_index = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_log_record(
      jsn,
      log_index
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetLogRecord");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecord", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecord", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_log_record_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      log_index
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetLogRecordResponse
void uic_mqtt_dotdot_on_door_lock_get_log_record_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_log_record_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t log_entryid = {};
  uint32_t timestamp = {};
  GetLogRecordResponseEventType event_type = {};
  DrlkOperEventSource source_operation_event = {};
  uint8_t event_id_or_alarm_code = {};
  uint16_t userid = {};
  std::string pin;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_log_record_response(
      jsn,
      log_entryid,

      timestamp,

      event_type,

      source_operation_event,

      event_id_or_alarm_code,

      userid,

      pin
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetLogRecordResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecordResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecordResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_log_record_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      log_entryid,
  
      timestamp,
  
      event_type,
  
      source_operation_event,
  
      event_id_or_alarm_code,
  
      userid,
  
      pin.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetLogRecordResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_log_record_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t log_entryid = {};
  uint32_t timestamp = {};
  GetLogRecordResponseEventType event_type = {};
  DrlkOperEventSource source_operation_event = {};
  uint8_t event_id_or_alarm_code = {};
  uint16_t userid = {};
  std::string pin;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_log_record_response(
      jsn,
      log_entryid,

      timestamp,

      event_type,

      source_operation_event,

      event_id_or_alarm_code,

      userid,

      pin
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetLogRecordResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecordResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetLogRecordResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      log_entryid,
  
      timestamp,
  
      event_type,
  
      source_operation_event,
  
      event_id_or_alarm_code,
  
      userid,
  
      pin.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetPINCode
void uic_mqtt_dotdot_on_door_lock_set_pin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_pin_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid = {};
  DrlkSettableUserStatus user_status = {};
  DrlkUserType user_type = {};
  std::string pin;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_pin_code(
      jsn,
      userid,

      user_status,

      user_type,

      pin
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCode", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_pin_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status,
  
      user_type,
  
      pin.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetPINCode
static void uic_mqtt_dotdot_on_generated_door_lock_set_pin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_pin_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid = {};
  DrlkSettableUserStatus user_status = {};
  DrlkUserType user_type = {};
  std::string pin;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_pin_code(
      jsn,
      userid,

      user_status,

      user_type,

      pin
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCode", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_pin_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status,
  
      user_type,
  
      pin.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetPINCodeResponse
void uic_mqtt_dotdot_on_door_lock_set_pin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_pin_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkSetCodeStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_pin_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCodeResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_pin_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetPINCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_pin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_pin_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkSetCodeStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_pin_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetPINCodeResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_pin_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetPINCode
void uic_mqtt_dotdot_on_door_lock_get_pin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_pin_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_pin_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCode", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_pin_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetPINCode
static void uic_mqtt_dotdot_on_generated_door_lock_get_pin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_pin_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_pin_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCode", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_pin_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetPINCodeResponse
void uic_mqtt_dotdot_on_door_lock_get_pin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_pin_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserStatus user_status = {};
  DrlkUserType user_type = {};
  std::string code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_pin_code_response(
      jsn,
      userid,

      user_status,

      user_type,

      code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCodeResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_pin_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status,
  
      user_type,
  
      code.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetPINCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_pin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_pin_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserStatus user_status = {};
  DrlkUserType user_type = {};
  std::string code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_pin_code_response(
      jsn,
      userid,

      user_status,

      user_type,

      code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetPINCodeResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_pin_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status,
  
      user_type,
  
      code.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearPINCode
void uic_mqtt_dotdot_on_door_lock_clear_pin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_pin_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_pin_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCode", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_pin_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearPINCode
static void uic_mqtt_dotdot_on_generated_door_lock_clear_pin_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_pin_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPINUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_pin_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearPINCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCode", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_pin_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearPINCodeResponse
void uic_mqtt_dotdot_on_door_lock_clear_pin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_pin_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCodeResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearPINCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_pin_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_pin_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_pin_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearPINCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearPINCodeResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_pin_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearAllPINCodes
void uic_mqtt_dotdot_on_door_lock_clear_all_pin_codes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllPINCodes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodes", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearAllPINCodes
static void uic_mqtt_dotdot_on_generated_door_lock_clear_all_pin_codes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllPINCodes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodes", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearAllPINCodesResponse
void uic_mqtt_dotdot_on_door_lock_clear_all_pin_codes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_all_pin_codes_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllPINCodesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodesResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearAllPINCodesResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_all_pin_codes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_all_pin_codes_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllPINCodesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllPINCodesResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetUserStatus
void uic_mqtt_dotdot_on_door_lock_set_user_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_user_status_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};
  DrlkSettableUserStatus user_status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_status(
      jsn,
      userid,

      user_status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserStatus");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatus", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatus", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_user_status_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetUserStatus
static void uic_mqtt_dotdot_on_generated_door_lock_set_user_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_user_status_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};
  DrlkSettableUserStatus user_status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_status(
      jsn,
      userid,

      user_status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserStatus");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatus", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatus", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_user_status_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetUserStatusResponse
void uic_mqtt_dotdot_on_door_lock_set_user_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_user_status_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_status_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserStatusResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatusResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatusResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_user_status_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetUserStatusResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_user_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_status_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserStatusResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatusResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserStatusResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetUserStatus
void uic_mqtt_dotdot_on_door_lock_get_user_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_user_status_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_status(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserStatus");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatus", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatus", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_status_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetUserStatus
static void uic_mqtt_dotdot_on_generated_door_lock_get_user_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_user_status_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_status(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserStatus");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatus", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatus", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_user_status_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetUserStatusResponse
void uic_mqtt_dotdot_on_door_lock_get_user_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_user_status_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserStatus user_status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_status_response(
      jsn,
      userid,

      user_status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserStatusResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatusResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatusResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_status_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetUserStatusResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_user_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserStatus user_status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_status_response(
      jsn,
      userid,

      user_status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserStatusResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatusResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserStatusResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetWeekdaySchedule
void uic_mqtt_dotdot_on_door_lock_set_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};
  uint8_t days_mask = {};
  uint8_t start_hour = {};
  uint8_t start_minute = {};
  uint8_t end_hour = {};
  uint8_t end_minute = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule(
      jsn,
      scheduleid,

      userid,

      days_mask,

      start_hour,

      start_minute,

      end_hour,

      end_minute
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdaySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid,
  
      days_mask,
  
      start_hour,
  
      start_minute,
  
      end_hour,
  
      end_minute
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetWeekdaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_set_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};
  uint8_t days_mask = {};
  uint8_t start_hour = {};
  uint8_t start_minute = {};
  uint8_t end_hour = {};
  uint8_t end_minute = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule(
      jsn,
      scheduleid,

      userid,

      days_mask,

      start_hour,

      start_minute,

      end_hour,

      end_minute
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdaySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid,
  
      days_mask,
  
      start_hour,
  
      start_minute,
  
      end_hour,
  
      end_minute
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetWeekdayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_set_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdayScheduleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetWeekdayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_weekday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetWeekdayScheduleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetWeekdaySchedule
void uic_mqtt_dotdot_on_door_lock_get_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdaySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetWeekdaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_get_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdaySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetWeekdayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_get_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t scheduleid = {};
  uint16_t userid = {};
  zclStatus status = {};
  uint8_t days_mask = {};
  uint8_t start_hour = {};
  uint8_t start_minute = {};
  uint8_t end_hour = {};
  uint8_t end_minute = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule_response(
      jsn,
      scheduleid,

      userid,

      status,

      days_mask,

      start_hour,

      start_minute,

      end_hour,

      end_minute
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdayScheduleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid,
  
      status,
  
      days_mask,
  
      start_hour,
  
      start_minute,
  
      end_hour,
  
      end_minute
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetWeekdayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t scheduleid = {};
  uint16_t userid = {};
  zclStatus status = {};
  uint8_t days_mask = {};
  uint8_t start_hour = {};
  uint8_t start_minute = {};
  uint8_t end_hour = {};
  uint8_t end_minute = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_weekday_schedule_response(
      jsn,
      scheduleid,

      userid,

      status,

      days_mask,

      start_hour,

      start_minute,

      end_hour,

      end_minute
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetWeekdayScheduleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid,
  
      status,
  
      days_mask,
  
      start_hour,
  
      start_minute,
  
      end_hour,
  
      end_minute
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearWeekdaySchedule
void uic_mqtt_dotdot_on_door_lock_clear_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdaySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearWeekdaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_clear_weekday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkWeekDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearWeekdaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdaySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearWeekdayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_clear_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdayScheduleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearWeekdayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_weekday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_weekday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearWeekdayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearWeekdayScheduleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetYearDaySchedule
void uic_mqtt_dotdot_on_door_lock_set_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule(
      jsn,
      scheduleid,

      userid,

      local_start_time,

      local_end_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDaySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid,
  
      local_start_time,
  
      local_end_time
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetYearDaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_set_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule(
      jsn,
      scheduleid,

      userid,

      local_start_time,

      local_end_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDaySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid,
  
      local_start_time,
  
      local_end_time
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetYearDayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_set_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDayScheduleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetYearDayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_year_day_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetYearDayScheduleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetYearDaySchedule
void uic_mqtt_dotdot_on_door_lock_get_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDaySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetYearDaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_get_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDaySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetYearDayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_get_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t scheduleid = {};
  uint16_t userid = {};
  zclStatus status = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule_response(
      jsn,
      scheduleid,

      userid,

      status,

      local_start_time,

      local_end_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDayScheduleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid,
  
      status,
  
      local_start_time,
  
      local_end_time
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetYearDayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t scheduleid = {};
  uint16_t userid = {};
  zclStatus status = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_year_day_schedule_response(
      jsn,
      scheduleid,

      userid,

      status,

      local_start_time,

      local_end_time
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetYearDayScheduleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid,
  
      status,
  
      local_start_time,
  
      local_end_time
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearYearDaySchedule
void uic_mqtt_dotdot_on_door_lock_clear_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDaySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearYearDaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_clear_year_day_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkYearDayScheduleID scheduleid = {};
  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule(
      jsn,
      scheduleid,

      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearYearDaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDaySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      scheduleid,
  
      userid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearYearDayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_clear_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDayScheduleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearYearDayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_year_day_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_year_day_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearYearDayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearYearDayScheduleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetHolidaySchedule
void uic_mqtt_dotdot_on_door_lock_set_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};
  DrlkOperMode operating_mode_during_holiday = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule(
      jsn,
      holiday_scheduleid,

      local_start_time,

      local_end_time,

      operating_mode_during_holiday
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidaySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      holiday_scheduleid,
  
      local_start_time,
  
      local_end_time,
  
      operating_mode_during_holiday
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetHolidaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_set_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};
  DrlkOperMode operating_mode_during_holiday = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule(
      jsn,
      holiday_scheduleid,

      local_start_time,

      local_end_time,

      operating_mode_during_holiday
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidaySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      holiday_scheduleid,
  
      local_start_time,
  
      local_end_time,
  
      operating_mode_during_holiday
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetHolidayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_set_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidayScheduleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetHolidayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_holiday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetHolidayScheduleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetHolidaySchedule
void uic_mqtt_dotdot_on_door_lock_get_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule(
      jsn,
      holiday_scheduleid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidaySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      holiday_scheduleid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetHolidaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_get_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule(
      jsn,
      holiday_scheduleid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidaySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      holiday_scheduleid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetHolidayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_get_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t holiday_scheduleid = {};
  zclStatus status = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};
  DrlkOperMode operating_mode_during_holiday = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule_response(
      jsn,
      holiday_scheduleid,

      status,

      local_start_time,

      local_end_time,

      operating_mode_during_holiday
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidayScheduleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      holiday_scheduleid,
  
      status,
  
      local_start_time,
  
      local_end_time,
  
      operating_mode_during_holiday
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetHolidayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t holiday_scheduleid = {};
  zclStatus status = {};
  uint32_t local_start_time = {};
  uint32_t local_end_time = {};
  DrlkOperMode operating_mode_during_holiday = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_holiday_schedule_response(
      jsn,
      holiday_scheduleid,

      status,

      local_start_time,

      local_end_time,

      operating_mode_during_holiday
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetHolidayScheduleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      holiday_scheduleid,
  
      status,
  
      local_start_time,
  
      local_end_time,
  
      operating_mode_during_holiday
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearHolidaySchedule
void uic_mqtt_dotdot_on_door_lock_clear_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule(
      jsn,
      holiday_scheduleid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidaySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      holiday_scheduleid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearHolidaySchedule
static void uic_mqtt_dotdot_on_generated_door_lock_clear_holiday_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkHolidayScheduleID holiday_scheduleid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule(
      jsn,
      holiday_scheduleid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearHolidaySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidaySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidaySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      holiday_scheduleid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearHolidayScheduleResponse
void uic_mqtt_dotdot_on_door_lock_clear_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidayScheduleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearHolidayScheduleResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_holiday_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_holiday_schedule_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearHolidayScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidayScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearHolidayScheduleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetUserType
void uic_mqtt_dotdot_on_door_lock_set_user_type(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_user_type_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};
  DrlkUserType user_type = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_type(
      jsn,
      userid,

      user_type
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserType");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserType", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserType", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_user_type_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_type
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetUserType
static void uic_mqtt_dotdot_on_generated_door_lock_set_user_type(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_user_type_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};
  DrlkUserType user_type = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_type(
      jsn,
      userid,

      user_type
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserType");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserType", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserType", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_user_type_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_type
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetUserTypeResponse
void uic_mqtt_dotdot_on_door_lock_set_user_type_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_user_type_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_type_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserTypeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserTypeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserTypeResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_user_type_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetUserTypeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_user_type_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user_type_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUserTypeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserTypeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUserTypeResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetUserType
void uic_mqtt_dotdot_on_door_lock_get_user_type(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_user_type_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_type(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserType");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserType", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserType", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_type_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetUserType
static void uic_mqtt_dotdot_on_generated_door_lock_get_user_type(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_user_type_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkTotalUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_type(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserType");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserType", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserType", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_user_type_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetUserTypeResponse
void uic_mqtt_dotdot_on_door_lock_get_user_type_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_user_type_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserType user_type = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_type_response(
      jsn,
      userid,

      user_type
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserTypeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserTypeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserTypeResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_type_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_type
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetUserTypeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_user_type_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserType user_type = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user_type_response(
      jsn,
      userid,

      user_type
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserTypeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserTypeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserTypeResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_type
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetRFIDCode
void uic_mqtt_dotdot_on_door_lock_set_rfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_rfid_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid = {};
  DrlkSettableUserStatus user_status = {};
  DrlkUserType user_type = {};
  std::string rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_rfid_code(
      jsn,
      userid,

      user_status,

      user_type,

      rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCode", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_rfid_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status,
  
      user_type,
  
      rfid_code.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetRFIDCode
static void uic_mqtt_dotdot_on_generated_door_lock_set_rfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_rfid_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid = {};
  DrlkSettableUserStatus user_status = {};
  DrlkUserType user_type = {};
  std::string rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_rfid_code(
      jsn,
      userid,

      user_status,

      user_type,

      rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCode", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_rfid_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status,
  
      user_type,
  
      rfid_code.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetRFIDCodeResponse
void uic_mqtt_dotdot_on_door_lock_set_rfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkSetCodeStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_rfid_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCodeResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetRFIDCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_rfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_rfid_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkSetCodeStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_rfid_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetRFIDCodeResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_rfid_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetRFIDCode
void uic_mqtt_dotdot_on_door_lock_get_rfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_rfid_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_rfid_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCode", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_rfid_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetRFIDCode
static void uic_mqtt_dotdot_on_generated_door_lock_get_rfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_rfid_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_rfid_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCode", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_rfid_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetRFIDCodeResponse
void uic_mqtt_dotdot_on_door_lock_get_rfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserStatus user_status = {};
  DrlkUserType user_type = {};
  std::string rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_rfid_code_response(
      jsn,
      userid,

      user_status,

      user_type,

      rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCodeResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status,
  
      user_type,
  
      rfid_code.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetRFIDCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_rfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_rfid_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t userid = {};
  DrlkUserStatus user_status = {};
  DrlkUserType user_type = {};
  std::string rfid_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_rfid_code_response(
      jsn,
      userid,

      user_status,

      user_type,

      rfid_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetRFIDCodeResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_rfid_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid,
  
      user_status,
  
      user_type,
  
      rfid_code.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearRFIDCode
void uic_mqtt_dotdot_on_door_lock_clear_rfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_rfid_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_rfid_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCode", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_rfid_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearRFIDCode
static void uic_mqtt_dotdot_on_generated_door_lock_clear_rfid_code(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkRFIDUserID userid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_rfid_code(
      jsn,
      userid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearRFIDCode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCode", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      userid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearRFIDCodeResponse
void uic_mqtt_dotdot_on_door_lock_clear_rfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_rfid_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCodeResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearRFIDCodeResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_rfid_code_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_rfid_code_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearRFIDCodeResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCodeResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearRFIDCodeResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearAllRFIDCodes
void uic_mqtt_dotdot_on_door_lock_clear_all_rfid_codes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllRFIDCodes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodes", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearAllRFIDCodes
static void uic_mqtt_dotdot_on_generated_door_lock_clear_all_rfid_codes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllRFIDCodes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodes", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearAllRFIDCodesResponse
void uic_mqtt_dotdot_on_door_lock_clear_all_rfid_codes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_all_rfid_codes_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllRFIDCodesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodesResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearAllRFIDCodesResponse
static void uic_mqtt_dotdot_on_generated_door_lock_clear_all_rfid_codes_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkPassFailStatus status = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_all_rfid_codes_response(
      jsn,
      status
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearAllRFIDCodesResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodesResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearAllRFIDCodesResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      status
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetUser
void uic_mqtt_dotdot_on_door_lock_set_user(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_user_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DataOperationTypeEnum operation_type = {};
  uint16_t user_index = {};
  std::string user_name;
  uint32_t user_uniqueid = {};
  DrlkUserStatus user_status = {};
  DrlkUserType user_type = {};
  CredentialRuleEnum credential_rule = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user(
      jsn,
      operation_type,

      user_index,

      user_name,

      user_uniqueid,

      user_status,

      user_type,

      credential_rule
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUser");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUser", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUser", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_user_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      operation_type,
  
      user_index,
  
      user_name.c_str(),
  
      user_uniqueid,
  
      user_status,
  
      user_type,
  
      credential_rule
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetUser
static void uic_mqtt_dotdot_on_generated_door_lock_set_user(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_user_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DataOperationTypeEnum operation_type = {};
  uint16_t user_index = {};
  std::string user_name;
  uint32_t user_uniqueid = {};
  DrlkUserStatus user_status = {};
  DrlkUserType user_type = {};
  CredentialRuleEnum credential_rule = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_user(
      jsn,
      operation_type,

      user_index,

      user_name,

      user_uniqueid,

      user_status,

      user_type,

      credential_rule
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetUser");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUser", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetUser", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_user_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      operation_type,
  
      user_index,
  
      user_name.c_str(),
  
      user_uniqueid,
  
      user_status,
  
      user_type,
  
      credential_rule
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetUser
void uic_mqtt_dotdot_on_door_lock_get_user(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_user_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t user_index = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user(
      jsn,
      user_index
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUser");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUser", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUser", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      user_index
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetUser
static void uic_mqtt_dotdot_on_generated_door_lock_get_user(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_user_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t user_index = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_user(
      jsn,
      user_index
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUser");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUser", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUser", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_user_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      user_index
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetUserResponse
void uic_mqtt_dotdot_on_door_lock_get_user_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_user_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetUserResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_user_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_user_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetUserResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetUserResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_user_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearUser
void uic_mqtt_dotdot_on_door_lock_clear_user(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_user_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t user_index = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_user(
      jsn,
      user_index
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearUser");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearUser", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearUser", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_user_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      user_index
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearUser
static void uic_mqtt_dotdot_on_generated_door_lock_clear_user(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_user_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t user_index = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_user(
      jsn,
      user_index
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearUser");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearUser", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearUser", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_user_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      user_index
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/OperatingEventNotification
void uic_mqtt_dotdot_on_door_lock_operating_event_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_operating_event_notification_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkOperEventSource operation_event_source = {};
  OperatingEventNotificationOperationEventCode operation_event_code = {};
  uint16_t userid = {};
  std::string pin;
  uint32_t local_time = {};
  std::string data;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_operating_event_notification(
      jsn,
      operation_event_source,

      operation_event_code,

      userid,

      pin,

      local_time,

      data
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "OperatingEventNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "OperatingEventNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "OperatingEventNotification", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_operating_event_notification_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      operation_event_source,
  
      operation_event_code,
  
      userid,
  
      pin.c_str(),
  
      local_time,
  
      data.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/OperatingEventNotification
static void uic_mqtt_dotdot_on_generated_door_lock_operating_event_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DrlkOperEventSource operation_event_source = {};
  OperatingEventNotificationOperationEventCode operation_event_code = {};
  uint16_t userid = {};
  std::string pin;
  uint32_t local_time = {};
  std::string data;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_operating_event_notification(
      jsn,
      operation_event_source,

      operation_event_code,

      userid,

      pin,

      local_time,

      data
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "OperatingEventNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "OperatingEventNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "OperatingEventNotification", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      operation_event_source,
  
      operation_event_code,
  
      userid,
  
      pin.c_str(),
  
      local_time,
  
      data.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ProgrammingEventNotification
void uic_mqtt_dotdot_on_door_lock_programming_event_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_programming_event_notification_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  ProgrammingEventNotificationProgramEventSource program_event_source = {};
  ProgrammingEventNotificationProgramEventCode program_event_code = {};
  uint16_t userid = {};
  std::string pin;
  DrlkUserType user_type = {};
  DrlkUserStatus user_status = {};
  uint32_t local_time = {};
  std::string data;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_programming_event_notification(
      jsn,
      program_event_source,

      program_event_code,

      userid,

      pin,

      user_type,

      user_status,

      local_time,

      data
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ProgrammingEventNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ProgrammingEventNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ProgrammingEventNotification", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_programming_event_notification_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      program_event_source,
  
      program_event_code,
  
      userid,
  
      pin.c_str(),
  
      user_type,
  
      user_status,
  
      local_time,
  
      data.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ProgrammingEventNotification
static void uic_mqtt_dotdot_on_generated_door_lock_programming_event_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  ProgrammingEventNotificationProgramEventSource program_event_source = {};
  ProgrammingEventNotificationProgramEventCode program_event_code = {};
  uint16_t userid = {};
  std::string pin;
  DrlkUserType user_type = {};
  DrlkUserStatus user_status = {};
  uint32_t local_time = {};
  std::string data;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_programming_event_notification(
      jsn,
      program_event_source,

      program_event_code,

      userid,

      pin,

      user_type,

      user_status,

      local_time,

      data
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ProgrammingEventNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ProgrammingEventNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ProgrammingEventNotification", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      program_event_source,
  
      program_event_code,
  
      userid,
  
      pin.c_str(),
  
      user_type,
  
      user_status,
  
      local_time,
  
      data.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetCredential
void uic_mqtt_dotdot_on_door_lock_set_credential(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_credential_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DataOperationTypeEnum operation_type = {};
  CredentialStruct credential = {};
  std::string credential_data;
  uint16_t user_index = {};
  DrlkUserStatus user_status = {};
  DrlkUserType user_type = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_credential(
      jsn,
      operation_type,

      credential,

      credential_data,

      user_index,

      user_status,

      user_type
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetCredential");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetCredential", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetCredential", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_credential_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      operation_type,
  
      credential,
  
      credential_data.c_str(),
  
      user_index,
  
      user_status,
  
      user_type
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetCredential
static void uic_mqtt_dotdot_on_generated_door_lock_set_credential(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_credential_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  DataOperationTypeEnum operation_type = {};
  CredentialStruct credential = {};
  std::string credential_data;
  uint16_t user_index = {};
  DrlkUserStatus user_status = {};
  DrlkUserType user_type = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_set_credential(
      jsn,
      operation_type,

      credential,

      credential_data,

      user_index,

      user_status,

      user_type
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetCredential");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetCredential", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetCredential", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_credential_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      operation_type,
  
      credential,
  
      credential_data.c_str(),
  
      user_index,
  
      user_status,
  
      user_type
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/SetCredentialResponse
void uic_mqtt_dotdot_on_door_lock_set_credential_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_set_credential_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetCredentialResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetCredentialResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetCredentialResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_set_credential_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/SetCredentialResponse
static void uic_mqtt_dotdot_on_generated_door_lock_set_credential_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_set_credential_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "SetCredentialResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetCredentialResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "SetCredentialResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_set_credential_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetCredentialStatus
void uic_mqtt_dotdot_on_door_lock_get_credential_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_credential_status_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CredentialStruct credential = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_credential_status(
      jsn,
      credential
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetCredentialStatus");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetCredentialStatus", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetCredentialStatus", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_credential_status_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      credential
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetCredentialStatus
static void uic_mqtt_dotdot_on_generated_door_lock_get_credential_status(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_credential_status_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CredentialStruct credential = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_get_credential_status(
      jsn,
      credential
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetCredentialStatus");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetCredentialStatus", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetCredentialStatus", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_credential_status_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      credential
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/GetCredentialStatusResponse
void uic_mqtt_dotdot_on_door_lock_get_credential_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_get_credential_status_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetCredentialStatusResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetCredentialStatusResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetCredentialStatusResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_get_credential_status_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/GetCredentialStatusResponse
static void uic_mqtt_dotdot_on_generated_door_lock_get_credential_status_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_get_credential_status_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "GetCredentialStatusResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetCredentialStatusResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "GetCredentialStatusResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_get_credential_status_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/ClearCredential
void uic_mqtt_dotdot_on_door_lock_clear_credential(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_clear_credential_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CredentialStruct credential = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_credential(
      jsn,
      credential
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearCredential");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearCredential", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearCredential", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_credential_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      credential
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/ClearCredential
static void uic_mqtt_dotdot_on_generated_door_lock_clear_credential(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_clear_credential_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CredentialStruct credential = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_clear_credential(
      jsn,
      credential
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "ClearCredential");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearCredential", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "ClearCredential", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_clear_credential_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      credential
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/UnboltDoor
void uic_mqtt_dotdot_on_door_lock_unbolt_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_unbolt_door_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string pin_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unbolt_door(
      jsn,
      pin_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnboltDoor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnboltDoor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnboltDoor", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_door_lock_unbolt_door_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      pin_code.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/GeneratedCommands/UnboltDoor
static void uic_mqtt_dotdot_on_generated_door_lock_unbolt_door(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_door_lock_generated_unbolt_door_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string pin_code;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_door_lock_unbolt_door(
      jsn,
      pin_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "UnboltDoor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnboltDoor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "UnboltDoor", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_door_lock_generated_unbolt_door_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      pin_code.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/DoorLock/Commands/WriteAttributes
void uic_mqtt_dotdot_on_door_lock_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_door_lock_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_door_lock_state_t new_state = {};
  uic_mqtt_dotdot_door_lock_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_door_lock_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DoorLock", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_door_lock_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_door_lock_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_door_lock_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_door_lock_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.lock_state = true;
      force_update.lock_type = true;
      force_update.actuator_enabled = true;
      force_update.door_state = true;
      force_update.door_open_events = true;
      force_update.door_closed_events = true;
      force_update.open_period = true;
      force_update.number_of_log_records_supported = true;
      force_update.number_of_total_users_supported = true;
      force_update.number_of_pin_users_supported = true;
      force_update.number_of_rfid_users_supported = true;
      force_update.number_of_week_day_schedules_supported_per_user = true;
      force_update.number_of_year_day_schedules_supported_per_user = true;
      force_update.number_of_holiday_schedules_supported = true;
      force_update.max_pin_code_length = true;
      force_update.min_pin_code_length = true;
      force_update.max_rfid_code_length = true;
      force_update.min_rfid_code_length = true;
      force_update.credential_rules_support = true;
      force_update.number_of_credentials_supported_per_user = true;
      force_update.enable_logging = true;
      force_update.language = true;
      force_update.led_settings = true;
      force_update.auto_relock_time = true;
      force_update.sound_volume = true;
      force_update.operating_mode = true;
      force_update.supported_operating_modes = true;
      force_update.default_configuration_register = true;
      force_update.enable_local_programming = true;
      force_update.enable_one_touch_locking = true;
      force_update.enable_inside_statusled = true;
      force_update.enable_privacy_mode_button = true;
      force_update.local_programming_features = true;
      force_update.wrong_code_entry_limit = true;
      force_update.user_code_temporary_disable_time = true;
      force_update.send_pin_over_the_air = true;
      force_update.require_pi_nfor_rf_operation = true;
      force_update.security_level = true;
      force_update.expiring_user_timeout = true;
      force_update.alarm_mask = true;
      force_update.keypad_operation_event_mask = true;
      force_update.rf_operation_event_mask = true;
      force_update.manual_operation_event_mask = true;
      force_update.rfid_operation_event_mask = true;
      force_update.keypad_programming_event_mask = true;
      force_update.rf_programming_event_mask = true;
      force_update.rfid_programming_event_mask = true;
      force_update.feature_map = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"LockState", &force_update.lock_state },
        {"LockType", &force_update.lock_type },
        {"ActuatorEnabled", &force_update.actuator_enabled },
        {"DoorState", &force_update.door_state },
        {"DoorOpenEvents", &force_update.door_open_events },
        {"DoorClosedEvents", &force_update.door_closed_events },
        {"OpenPeriod", &force_update.open_period },
        {"NumberOfLogRecordsSupported", &force_update.number_of_log_records_supported },
        {"NumberOfTotalUsersSupported", &force_update.number_of_total_users_supported },
        {"NumberOfPINUsersSupported", &force_update.number_of_pin_users_supported },
        {"NumberOfRFIDUsersSupported", &force_update.number_of_rfid_users_supported },
        {"NumberOfWeekDaySchedulesSupportedPerUser", &force_update.number_of_week_day_schedules_supported_per_user },
        {"NumberOfYearDaySchedulesSupportedPerUser", &force_update.number_of_year_day_schedules_supported_per_user },
        {"NumberOfHolidaySchedulesSupported", &force_update.number_of_holiday_schedules_supported },
        {"MaxPINCodeLength", &force_update.max_pin_code_length },
        {"MinPINCodeLength", &force_update.min_pin_code_length },
        {"MaxRFIDCodeLength", &force_update.max_rfid_code_length },
        {"MinRFIDCodeLength", &force_update.min_rfid_code_length },
        {"CredentialRulesSupport", &force_update.credential_rules_support },
        {"NumberOfCredentialsSupportedPerUser", &force_update.number_of_credentials_supported_per_user },
        {"EnableLogging", &force_update.enable_logging },
        {"Language", &force_update.language },
        {"LEDSettings", &force_update.led_settings },
        {"AutoRelockTime", &force_update.auto_relock_time },
        {"SoundVolume", &force_update.sound_volume },
        {"OperatingMode", &force_update.operating_mode },
        {"SupportedOperatingModes", &force_update.supported_operating_modes },
        {"DefaultConfigurationRegister", &force_update.default_configuration_register },
        {"EnableLocalProgramming", &force_update.enable_local_programming },
        {"EnableOneTouchLocking", &force_update.enable_one_touch_locking },
        {"EnableInsideStatusLED", &force_update.enable_inside_statusled },
        {"EnablePrivacyModeButton", &force_update.enable_privacy_mode_button },
        {"LocalProgrammingFeatures", &force_update.local_programming_features },
        {"WrongCodeEntryLimit", &force_update.wrong_code_entry_limit },
        {"UserCodeTemporaryDisableTime", &force_update.user_code_temporary_disable_time },
        {"SendPINOverTheAir", &force_update.send_pin_over_the_air },
        {"RequirePINforRFOperation", &force_update.require_pi_nfor_rf_operation },
        {"SecurityLevel", &force_update.security_level },
        {"ExpiringUserTimeout", &force_update.expiring_user_timeout },
        {"AlarmMask", &force_update.alarm_mask },
        {"KeypadOperationEventMask", &force_update.keypad_operation_event_mask },
        {"RFOperationEventMask", &force_update.rf_operation_event_mask },
        {"ManualOperationEventMask", &force_update.manual_operation_event_mask },
        {"RFIDOperationEventMask", &force_update.rfid_operation_event_mask },
        {"KeypadProgrammingEventMask", &force_update.keypad_programming_event_mask },
        {"RFProgrammingEventMask", &force_update.rf_programming_event_mask },
        {"RFIDProgrammingEventMask", &force_update.rfid_programming_event_mask },
        {"FeatureMap", &force_update.feature_map },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_door_lock_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "DoorLock/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_door_lock_lock_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DOOR_LOCK_LOCK_STATE_ENUM_NAME_AVAILABLE
  jsn["value"] = door_lock_lock_state_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for DOOR_LOCK_LOCK_STATE. Using number instead.");
  jsn["value"] = static_cast<DoorLockLockState>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/LockState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/LockState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_lock_state_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/LockState";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_lock_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DOOR_LOCK_LOCK_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = door_lock_lock_type_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for DOOR_LOCK_LOCK_TYPE. Using number instead.");
  jsn["value"] = static_cast<DoorLockLockType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/LockType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/LockType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_lock_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/LockType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_actuator_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/ActuatorEnabled", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/ActuatorEnabled";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_actuator_enabled_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/ActuatorEnabled";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_door_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DOOR_LOCK_DOOR_STATE_ENUM_NAME_AVAILABLE
  jsn["value"] = door_lock_door_state_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for DOOR_LOCK_DOOR_STATE. Using number instead.");
  jsn["value"] = static_cast<DoorLockDoorState>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/DoorState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/DoorState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_door_state_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/DoorState";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_door_open_events_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,4,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,4,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/DoorOpenEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/DoorOpenEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_door_open_events_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/DoorOpenEvents";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_door_closed_events_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,5,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,5,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/DoorClosedEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/DoorClosedEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_door_closed_events_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/DoorClosedEvents";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_open_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,6,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,6,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/OpenPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/OpenPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_open_period_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/OpenPeriod";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_number_of_log_records_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfLogRecordsSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfLogRecordsSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_number_of_log_records_supported_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/NumberOfLogRecordsSupported";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_number_of_total_users_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfTotalUsersSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfTotalUsersSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_number_of_total_users_supported_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/NumberOfTotalUsersSupported";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_number_of_pin_users_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfPINUsersSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfPINUsersSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_number_of_pin_users_supported_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/NumberOfPINUsersSupported";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_number_of_rfid_users_supported_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfRFIDUsersSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfRFIDUsersSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_number_of_rfid_users_supported_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/NumberOfRFIDUsersSupported";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,20,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,20,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfWeekDaySchedulesSupportedPerUser", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfWeekDaySchedulesSupportedPerUser";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/NumberOfWeekDaySchedulesSupportedPerUser";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,21,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,21,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfYearDaySchedulesSupportedPerUser", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfYearDaySchedulesSupportedPerUser";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/NumberOfYearDaySchedulesSupportedPerUser";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,22,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,22,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfHolidaySchedulesSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfHolidaySchedulesSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/NumberOfHolidaySchedulesSupported";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_max_pin_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,23,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,23,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/MaxPINCodeLength", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/MaxPINCodeLength";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_max_pin_code_length_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/MaxPINCodeLength";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_min_pin_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,24,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,24,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/MinPINCodeLength", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/MinPINCodeLength";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_min_pin_code_length_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/MinPINCodeLength";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_max_rfid_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,25,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,25,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/MaxRFIDCodeLength", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/MaxRFIDCodeLength";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_max_rfid_code_length_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/MaxRFIDCodeLength";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_min_rfid_code_length_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,26,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,26,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/MinRFIDCodeLength", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/MinRFIDCodeLength";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_min_rfid_code_length_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/MinRFIDCodeLength";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_credential_rules_support_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockCredentialRulesSupport.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/CredentialRulesSupport", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/CredentialRulesSupport";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_credential_rules_support_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/CredentialRulesSupport";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_number_of_credentials_supported_per_user_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,28,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,28,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/NumberOfCredentialsSupportedPerUser", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/NumberOfCredentialsSupportedPerUser";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_number_of_credentials_supported_per_user_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/NumberOfCredentialsSupportedPerUser";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_enable_logging_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,32,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,32,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/EnableLogging", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/EnableLogging";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_enable_logging_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/EnableLogging";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_language_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/Language", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/Language";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_language_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/Language";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_led_settings_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,34,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,34,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/LEDSettings", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/LEDSettings";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_led_settings_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/LEDSettings";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_auto_relock_time_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,35,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,35,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/AutoRelockTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/AutoRelockTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_auto_relock_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/AutoRelockTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_sound_volume_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,36,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,36,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/SoundVolume", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/SoundVolume";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_sound_volume_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/SoundVolume";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_operating_mode_publish(
  const char *base_topic,
  DrlkOperMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DOOR_LOCK_OPERATING_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = door_lock_operating_mode_get_enum_value_name((uint32_t)value);
  #elif defined(DRLK_OPER_MODE_ENUM_NAME_AVAILABLE)
  jsn["value"] = drlk_oper_mode_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for DOOR_LOCK_OPERATING_MODE. Using number instead.");
  jsn["value"] = static_cast<DrlkOperMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/OperatingMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/OperatingMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_operating_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/OperatingMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_supported_operating_modes_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockSupportedOperatingModes.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/SupportedOperatingModes", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/SupportedOperatingModes";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_supported_operating_modes_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/SupportedOperatingModes";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_default_configuration_register_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockDefaultConfigurationRegister.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/DefaultConfigurationRegister", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/DefaultConfigurationRegister";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_default_configuration_register_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/DefaultConfigurationRegister";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_enable_local_programming_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,40,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,40,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/EnableLocalProgramming", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/EnableLocalProgramming";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_enable_local_programming_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/EnableLocalProgramming";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_enable_one_touch_locking_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,41,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,41,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/EnableOneTouchLocking", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/EnableOneTouchLocking";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_enable_one_touch_locking_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/EnableOneTouchLocking";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_enable_inside_statusled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,42,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,42,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/EnableInsideStatusLED", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/EnableInsideStatusLED";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_enable_inside_statusled_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/EnableInsideStatusLED";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,43,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,43,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/EnablePrivacyModeButton", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/EnablePrivacyModeButton";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/EnablePrivacyModeButton";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_local_programming_features_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockLocalProgrammingFeatures.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/LocalProgrammingFeatures", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/LocalProgrammingFeatures";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_local_programming_features_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/LocalProgrammingFeatures";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,48,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,48,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/WrongCodeEntryLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/WrongCodeEntryLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/WrongCodeEntryLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,49,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,49,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/UserCodeTemporaryDisableTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/UserCodeTemporaryDisableTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/UserCodeTemporaryDisableTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_send_pin_over_the_air_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,50,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,50,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/SendPINOverTheAir", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/SendPINOverTheAir";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_send_pin_over_the_air_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/SendPINOverTheAir";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_require_pi_nfor_rf_operation_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,51,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,51,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/RequirePINforRFOperation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/RequirePINforRFOperation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_require_pi_nfor_rf_operation_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/RequirePINforRFOperation";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_security_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DOOR_LOCK_SECURITY_LEVEL_ENUM_NAME_AVAILABLE
  jsn["value"] = door_lock_security_level_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for DOOR_LOCK_SECURITY_LEVEL. Using number instead.");
  jsn["value"] = static_cast<DoorLockSecurityLevel>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/SecurityLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/SecurityLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_security_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/SecurityLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_expiring_user_timeout_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(257,53,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(257,53,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/ExpiringUserTimeout", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/ExpiringUserTimeout";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_expiring_user_timeout_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/ExpiringUserTimeout";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_alarm_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_alarm_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/AlarmMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockKeypadOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/KeypadOperationEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/KeypadOperationEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/KeypadOperationEventMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_rf_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/RFOperationEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/RFOperationEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_rf_operation_event_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/RFOperationEventMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_manual_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockManualOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/ManualOperationEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/ManualOperationEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_manual_operation_event_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/ManualOperationEventMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFIDOperationEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/RFIDOperationEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/RFIDOperationEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/RFIDOperationEventMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockKeypadProgrammingEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/KeypadProgrammingEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/KeypadProgrammingEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/KeypadProgrammingEventMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_rf_programming_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFProgrammingEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/RFProgrammingEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/RFProgrammingEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_rf_programming_event_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/RFProgrammingEventMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockRFIDProgrammingEventMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/RFIDProgrammingEventMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/RFIDProgrammingEventMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/RFIDProgrammingEventMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_door_lock_feature_map_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = DoorLockFeatureMap.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DoorLock/Attributes/FeatureMap", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/DoorLock/Attributes/FeatureMap";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_door_lock_feature_map_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/FeatureMap";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_door_lock_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_door_lock_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_door_lock_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_door_lock_lock_door_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/LockDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_lock_door);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_lock_door_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/LockDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_lock_door);
  }
  if (!uic_mqtt_dotdot_door_lock_lock_door_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/LockDoorResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_lock_door_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_lock_door_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/LockDoorResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_lock_door_response);
  }
  if (!uic_mqtt_dotdot_door_lock_unlock_door_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/UnlockDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_unlock_door);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_unlock_door_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/UnlockDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_unlock_door);
  }
  if (!uic_mqtt_dotdot_door_lock_unlock_door_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/UnlockDoorResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_unlock_door_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_unlock_door_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/UnlockDoorResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_unlock_door_response);
  }
  if (!uic_mqtt_dotdot_door_lock_toggle_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/Toggle";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_toggle);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_toggle_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/Toggle";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_toggle);
  }
  if (!uic_mqtt_dotdot_door_lock_toggle_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ToggleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_toggle_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_toggle_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ToggleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_toggle_response);
  }
  if (!uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/UnlockWithTimeout";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_unlock_with_timeout);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/UnlockWithTimeout";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_unlock_with_timeout);
  }
  if (!uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/UnlockWithTimeoutResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_unlock_with_timeout_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_unlock_with_timeout_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/UnlockWithTimeoutResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_unlock_with_timeout_response);
  }
  if (!uic_mqtt_dotdot_door_lock_get_log_record_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetLogRecord";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_log_record);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_log_record_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetLogRecord";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_log_record);
  }
  if (!uic_mqtt_dotdot_door_lock_get_log_record_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetLogRecordResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_log_record_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_log_record_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetLogRecordResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_log_record_response);
  }
  if (!uic_mqtt_dotdot_door_lock_set_pin_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_pin_code);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_pin_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_pin_code);
  }
  if (!uic_mqtt_dotdot_door_lock_set_pin_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_pin_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_pin_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_pin_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_get_pin_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_pin_code);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_pin_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_pin_code);
  }
  if (!uic_mqtt_dotdot_door_lock_get_pin_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_pin_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_pin_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_pin_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_pin_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_pin_code);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_pin_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearPINCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_pin_code);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_pin_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_pin_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearPINCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_pin_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearAllPINCodes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_all_pin_codes);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearAllPINCodes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_all_pin_codes);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearAllPINCodesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_all_pin_codes_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_all_pin_codes_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearAllPINCodesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_all_pin_codes_response);
  }
  if (!uic_mqtt_dotdot_door_lock_set_user_status_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetUserStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_user_status);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_user_status_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetUserStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_user_status);
  }
  if (!uic_mqtt_dotdot_door_lock_set_user_status_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetUserStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_user_status_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_user_status_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetUserStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_user_status_response);
  }
  if (!uic_mqtt_dotdot_door_lock_get_user_status_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetUserStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_user_status);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_user_status_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetUserStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_user_status);
  }
  if (!uic_mqtt_dotdot_door_lock_get_user_status_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetUserStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_user_status_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_user_status_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetUserStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_user_status_response);
  }
  if (!uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_weekday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_weekday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_weekday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_weekday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_weekday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_weekday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_weekday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_weekday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_weekday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_weekday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_weekday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearWeekdaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_weekday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_weekday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_weekday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearWeekdayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_weekday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_year_day_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_year_day_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_year_day_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_year_day_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_year_day_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_year_day_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_year_day_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_year_day_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_year_day_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_year_day_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_year_day_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearYearDaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_year_day_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_year_day_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_year_day_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearYearDayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_year_day_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_holiday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_holiday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_holiday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_holiday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_holiday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_holiday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_holiday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_holiday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_holiday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_holiday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_holiday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearHolidaySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_holiday_schedule);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_holiday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_holiday_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearHolidayScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_holiday_schedule_response);
  }
  if (!uic_mqtt_dotdot_door_lock_set_user_type_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetUserType";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_user_type);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_user_type_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetUserType";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_user_type);
  }
  if (!uic_mqtt_dotdot_door_lock_set_user_type_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetUserTypeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_user_type_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_user_type_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetUserTypeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_user_type_response);
  }
  if (!uic_mqtt_dotdot_door_lock_get_user_type_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetUserType";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_user_type);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_user_type_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetUserType";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_user_type);
  }
  if (!uic_mqtt_dotdot_door_lock_get_user_type_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetUserTypeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_user_type_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_user_type_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetUserTypeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_user_type_response);
  }
  if (!uic_mqtt_dotdot_door_lock_set_rfid_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_rfid_code);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_rfid_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_rfid_code);
  }
  if (!uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_rfid_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_rfid_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_rfid_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_get_rfid_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_rfid_code);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_rfid_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_rfid_code);
  }
  if (!uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_rfid_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_rfid_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_rfid_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_rfid_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_rfid_code);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearRFIDCode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_rfid_code);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_rfid_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_rfid_code_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearRFIDCodeResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_rfid_code_response);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearAllRFIDCodes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_all_rfid_codes);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearAllRFIDCodes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_all_rfid_codes);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearAllRFIDCodesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_all_rfid_codes_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_all_rfid_codes_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearAllRFIDCodesResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_all_rfid_codes_response);
  }
  if (!uic_mqtt_dotdot_door_lock_set_user_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetUser";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_user);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_user_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetUser";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_user);
  }
  if (!uic_mqtt_dotdot_door_lock_get_user_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetUser";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_user);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_user_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetUser";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_user);
  }
  if (!uic_mqtt_dotdot_door_lock_get_user_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetUserResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_user_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_user_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetUserResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_user_response);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_user_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearUser";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_user);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_user_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearUser";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_user);
  }
  if (!uic_mqtt_dotdot_door_lock_operating_event_notification_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/OperatingEventNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_operating_event_notification);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_operating_event_notification_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/OperatingEventNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_operating_event_notification);
  }
  if (!uic_mqtt_dotdot_door_lock_programming_event_notification_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ProgrammingEventNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_programming_event_notification);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_programming_event_notification_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ProgrammingEventNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_programming_event_notification);
  }
  if (!uic_mqtt_dotdot_door_lock_set_credential_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetCredential";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_credential);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_credential_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetCredential";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_credential);
  }
  if (!uic_mqtt_dotdot_door_lock_set_credential_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/SetCredentialResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_set_credential_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_set_credential_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/SetCredentialResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_set_credential_response);
  }
  if (!uic_mqtt_dotdot_door_lock_get_credential_status_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetCredentialStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_credential_status);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_credential_status_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetCredentialStatus";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_credential_status);
  }
  if (!uic_mqtt_dotdot_door_lock_get_credential_status_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/GetCredentialStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_get_credential_status_response);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_get_credential_status_response_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/GetCredentialStatusResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_get_credential_status_response);
  }
  if (!uic_mqtt_dotdot_door_lock_clear_credential_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/ClearCredential";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_clear_credential);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_clear_credential_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/ClearCredential";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_clear_credential);
  }
  if (!uic_mqtt_dotdot_door_lock_unbolt_door_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/Commands/UnboltDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_door_lock_unbolt_door);
  }
  if (!uic_mqtt_dotdot_door_lock_generated_unbolt_door_callback.empty()) {
    subscription_topic = base_topic + "DoorLock/GeneratedCommands/UnboltDoor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_door_lock_unbolt_door);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_door_lock_attributes_init();

  uic_mqtt_dotdot_by_group_door_lock_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_window_covering_up_or_open_callback_t> uic_mqtt_dotdot_window_covering_up_or_open_callback;
static std::set<uic_mqtt_dotdot_window_covering_up_or_open_callback_t> uic_mqtt_dotdot_window_covering_generated_up_or_open_callback;
static std::set<uic_mqtt_dotdot_window_covering_down_or_close_callback_t> uic_mqtt_dotdot_window_covering_down_or_close_callback;
static std::set<uic_mqtt_dotdot_window_covering_down_or_close_callback_t> uic_mqtt_dotdot_window_covering_generated_down_or_close_callback;
static std::set<uic_mqtt_dotdot_window_covering_stop_callback_t> uic_mqtt_dotdot_window_covering_stop_callback;
static std::set<uic_mqtt_dotdot_window_covering_stop_callback_t> uic_mqtt_dotdot_window_covering_generated_stop_callback;
static std::set<uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t> uic_mqtt_dotdot_window_covering_go_to_lift_value_callback;
static std::set<uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t> uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback;
static std::set<uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t> uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback;
static std::set<uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t> uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback;
static std::set<uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t> uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback;
static std::set<uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t> uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback;
static std::set<uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t> uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback;
static std::set<uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t> uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback;
static std::set<uic_mqtt_dotdot_window_covering_write_attributes_callback_t> uic_mqtt_dotdot_window_covering_write_attributes_callback;
static std::set<uic_mqtt_dotdot_window_covering_force_read_attributes_callback_t> uic_mqtt_dotdot_window_covering_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_window_covering_up_or_open_callback_set(const uic_mqtt_dotdot_window_covering_up_or_open_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_up_or_open_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_up_or_open_callback_unset(const uic_mqtt_dotdot_window_covering_up_or_open_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_up_or_open_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_up_or_open_callback_clear()
{
  uic_mqtt_dotdot_window_covering_up_or_open_callback.clear();
}
std::set<uic_mqtt_dotdot_window_covering_up_or_open_callback_t>& get_uic_mqtt_dotdot_window_covering_up_or_open_callback()
{
  return uic_mqtt_dotdot_window_covering_up_or_open_callback;
}

void uic_mqtt_dotdot_window_covering_generated_up_or_open_callback_set(const uic_mqtt_dotdot_window_covering_up_or_open_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_generated_up_or_open_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_generated_up_or_open_callback_unset(const uic_mqtt_dotdot_window_covering_up_or_open_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_up_or_open_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_generated_up_or_open_callback_clear()
{
  uic_mqtt_dotdot_window_covering_generated_up_or_open_callback.clear();
}
void uic_mqtt_dotdot_window_covering_down_or_close_callback_set(const uic_mqtt_dotdot_window_covering_down_or_close_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_down_or_close_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_down_or_close_callback_unset(const uic_mqtt_dotdot_window_covering_down_or_close_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_down_or_close_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_down_or_close_callback_clear()
{
  uic_mqtt_dotdot_window_covering_down_or_close_callback.clear();
}
std::set<uic_mqtt_dotdot_window_covering_down_or_close_callback_t>& get_uic_mqtt_dotdot_window_covering_down_or_close_callback()
{
  return uic_mqtt_dotdot_window_covering_down_or_close_callback;
}

void uic_mqtt_dotdot_window_covering_generated_down_or_close_callback_set(const uic_mqtt_dotdot_window_covering_down_or_close_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_generated_down_or_close_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_generated_down_or_close_callback_unset(const uic_mqtt_dotdot_window_covering_down_or_close_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_down_or_close_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_generated_down_or_close_callback_clear()
{
  uic_mqtt_dotdot_window_covering_generated_down_or_close_callback.clear();
}
void uic_mqtt_dotdot_window_covering_stop_callback_set(const uic_mqtt_dotdot_window_covering_stop_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_stop_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_stop_callback_unset(const uic_mqtt_dotdot_window_covering_stop_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_stop_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_stop_callback_clear()
{
  uic_mqtt_dotdot_window_covering_stop_callback.clear();
}
std::set<uic_mqtt_dotdot_window_covering_stop_callback_t>& get_uic_mqtt_dotdot_window_covering_stop_callback()
{
  return uic_mqtt_dotdot_window_covering_stop_callback;
}

void uic_mqtt_dotdot_window_covering_generated_stop_callback_set(const uic_mqtt_dotdot_window_covering_stop_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_generated_stop_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_generated_stop_callback_unset(const uic_mqtt_dotdot_window_covering_stop_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_stop_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_generated_stop_callback_clear()
{
  uic_mqtt_dotdot_window_covering_generated_stop_callback.clear();
}
void uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_set(const uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_go_to_lift_value_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_unset(const uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_go_to_lift_value_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_clear()
{
  uic_mqtt_dotdot_window_covering_go_to_lift_value_callback.clear();
}
std::set<uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t>& get_uic_mqtt_dotdot_window_covering_go_to_lift_value_callback()
{
  return uic_mqtt_dotdot_window_covering_go_to_lift_value_callback;
}

void uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback_set(const uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback_unset(const uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback_clear()
{
  uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback.clear();
}
void uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_set(const uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_unset(const uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_clear()
{
  uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback.clear();
}
std::set<uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t>& get_uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback()
{
  return uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback;
}

void uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback_set(const uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback_unset(const uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback_clear()
{
  uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback.clear();
}
void uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_set(const uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_unset(const uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_clear()
{
  uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback.clear();
}
std::set<uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t>& get_uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback()
{
  return uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback;
}

void uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback_set(const uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback_unset(const uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback_clear()
{
  uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback.clear();
}
void uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_set(const uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_unset(const uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_clear()
{
  uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback.clear();
}
std::set<uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t>& get_uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback()
{
  return uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback;
}

void uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback_set(const uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback_unset(const uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback.erase(callback);
}
void uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback_clear()
{
  uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback.clear();
}

void uic_mqtt_dotdot_set_window_covering_write_attributes_callback(
  const uic_mqtt_dotdot_window_covering_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_window_covering_write_attributes_callback(
  const uic_mqtt_dotdot_window_covering_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_window_covering_write_attributes_callbacks()
{
  uic_mqtt_dotdot_window_covering_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_window_covering_write_attributes_callback_t>& get_uic_mqtt_dotdot_window_covering_write_attributes_callback()
{
  return uic_mqtt_dotdot_window_covering_write_attributes_callback;
}

void uic_mqtt_dotdot_set_window_covering_force_read_attributes_callback(
  const uic_mqtt_dotdot_window_covering_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_window_covering_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_window_covering_force_read_attributes_callback(
  const uic_mqtt_dotdot_window_covering_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_window_covering_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_window_covering_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_window_covering_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/UpOrOpen
void uic_mqtt_dotdot_on_window_covering_up_or_open(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_up_or_open_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "UpOrOpen");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "UpOrOpen", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "UpOrOpen", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_window_covering_up_or_open_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/UpOrOpen
static void uic_mqtt_dotdot_on_generated_window_covering_up_or_open(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_up_or_open_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "UpOrOpen");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "UpOrOpen", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "UpOrOpen", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_window_covering_generated_up_or_open_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/DownOrClose
void uic_mqtt_dotdot_on_window_covering_down_or_close(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_down_or_close_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "DownOrClose");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "DownOrClose", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "DownOrClose", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_window_covering_down_or_close_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/DownOrClose
static void uic_mqtt_dotdot_on_generated_window_covering_down_or_close(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_down_or_close_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "DownOrClose");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "DownOrClose", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "DownOrClose", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_window_covering_generated_down_or_close_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/Stop
void uic_mqtt_dotdot_on_window_covering_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_stop_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "Stop", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_window_covering_stop_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/Stop
static void uic_mqtt_dotdot_on_generated_window_covering_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_stop_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "Stop", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_window_covering_generated_stop_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/GoToLiftValue
void uic_mqtt_dotdot_on_window_covering_go_to_lift_value(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_go_to_lift_value_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t lift_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_lift_value(
      jsn,
      lift_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToLiftValue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftValue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftValue", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_window_covering_go_to_lift_value_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      lift_value
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/GoToLiftValue
static void uic_mqtt_dotdot_on_generated_window_covering_go_to_lift_value(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t lift_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_lift_value(
      jsn,
      lift_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToLiftValue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftValue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftValue", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      lift_value
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/GoToLiftPercentage
void uic_mqtt_dotdot_on_window_covering_go_to_lift_percentage(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percentage_lift_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_lift_percentage(
      jsn,
      percentage_lift_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToLiftPercentage");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftPercentage", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftPercentage", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      percentage_lift_value
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/GoToLiftPercentage
static void uic_mqtt_dotdot_on_generated_window_covering_go_to_lift_percentage(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percentage_lift_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_lift_percentage(
      jsn,
      percentage_lift_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToLiftPercentage");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftPercentage", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToLiftPercentage", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      percentage_lift_value
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/GoToTiltValue
void uic_mqtt_dotdot_on_window_covering_go_to_tilt_value(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t tilt_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_tilt_value(
      jsn,
      tilt_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToTiltValue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltValue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltValue", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      tilt_value
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/GoToTiltValue
static void uic_mqtt_dotdot_on_generated_window_covering_go_to_tilt_value(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t tilt_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_tilt_value(
      jsn,
      tilt_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToTiltValue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltValue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltValue", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      tilt_value
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/GoToTiltPercentage
void uic_mqtt_dotdot_on_window_covering_go_to_tilt_percentage(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percentage_tilt_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_tilt_percentage(
      jsn,
      percentage_tilt_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToTiltPercentage");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltPercentage", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltPercentage", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      percentage_tilt_value
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/GeneratedCommands/GoToTiltPercentage
static void uic_mqtt_dotdot_on_generated_window_covering_go_to_tilt_percentage(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percentage_tilt_value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_window_covering_go_to_tilt_percentage(
      jsn,
      percentage_tilt_value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "GoToTiltPercentage");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltPercentage", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "GoToTiltPercentage", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      percentage_tilt_value
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindowCovering/Commands/WriteAttributes
void uic_mqtt_dotdot_on_window_covering_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_window_covering_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_window_covering_state_t new_state = {};
  uic_mqtt_dotdot_window_covering_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_window_covering_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindowCovering", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_window_covering_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_window_covering_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_window_covering_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_window_covering_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.window_covering_type = true;
      force_update.physical_closed_limit_lift = true;
      force_update.physical_closed_limit_tilt = true;
      force_update.current_position_lift = true;
      force_update.current_position_tilt = true;
      force_update.number_of_actuations_lift = true;
      force_update.number_of_actuations_tilt = true;
      force_update.config_or_status = true;
      force_update.current_position_lift_percentage = true;
      force_update.current_position_tilt_percentage = true;
      force_update.installed_open_limit_lift = true;
      force_update.installed_closed_limit_lift = true;
      force_update.installed_open_limit_tilt = true;
      force_update.installed_closed_limit_tilt = true;
      force_update.velocity_lift = true;
      force_update.acceleration_time_lift = true;
      force_update.deceleration_time_lift = true;
      force_update.mode = true;
      force_update.intermediate_setpoints_lift = true;
      force_update.intermediate_setpoints_tilt = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"WindowCoveringType", &force_update.window_covering_type },
        {"PhysicalClosedLimitLift", &force_update.physical_closed_limit_lift },
        {"PhysicalClosedLimitTilt", &force_update.physical_closed_limit_tilt },
        {"CurrentPositionLift", &force_update.current_position_lift },
        {"CurrentPositionTilt", &force_update.current_position_tilt },
        {"NumberOfActuationsLift", &force_update.number_of_actuations_lift },
        {"NumberOfActuationsTilt", &force_update.number_of_actuations_tilt },
        {"ConfigOrStatus", &force_update.config_or_status },
        {"CurrentPositionLiftPercentage", &force_update.current_position_lift_percentage },
        {"CurrentPositionTiltPercentage", &force_update.current_position_tilt_percentage },
        {"InstalledOpenLimitLift", &force_update.installed_open_limit_lift },
        {"InstalledClosedLimitLift", &force_update.installed_closed_limit_lift },
        {"InstalledOpenLimitTilt", &force_update.installed_open_limit_tilt },
        {"InstalledClosedLimitTilt", &force_update.installed_closed_limit_tilt },
        {"VelocityLift", &force_update.velocity_lift },
        {"AccelerationTimeLift", &force_update.acceleration_time_lift },
        {"DecelerationTimeLift", &force_update.deceleration_time_lift },
        {"Mode", &force_update.mode },
        {"IntermediateSetpointsLift", &force_update.intermediate_setpoints_lift },
        {"IntermediateSetpointsTilt", &force_update.intermediate_setpoints_tilt },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_window_covering_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "WindowCovering/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_window_covering_window_covering_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef WINDOW_COVERING_WINDOW_COVERING_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = window_covering_window_covering_type_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for WINDOW_COVERING_WINDOW_COVERING_TYPE. Using number instead.");
  jsn["value"] = static_cast<WindowCoveringWindowCoveringType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/WindowCoveringType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/WindowCoveringType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_window_covering_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/WindowCoveringType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_physical_closed_limit_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/PhysicalClosedLimitLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/PhysicalClosedLimitLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_physical_closed_limit_lift_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/PhysicalClosedLimitLift";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_physical_closed_limit_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/PhysicalClosedLimitTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/PhysicalClosedLimitTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_physical_closed_limit_tilt_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/PhysicalClosedLimitTilt";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_current_position_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/CurrentPositionLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/CurrentPositionLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_current_position_lift_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/CurrentPositionLift";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_current_position_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,4,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,4,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/CurrentPositionTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/CurrentPositionTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_current_position_tilt_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/CurrentPositionTilt";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_number_of_actuations_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,5,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,5,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/NumberOfActuationsLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/NumberOfActuationsLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_number_of_actuations_lift_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/NumberOfActuationsLift";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_number_of_actuations_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,6,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,6,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/NumberOfActuationsTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/NumberOfActuationsTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_number_of_actuations_tilt_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/NumberOfActuationsTilt";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_config_or_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = WindowCoveringConfigOrStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/ConfigOrStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/ConfigOrStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_config_or_status_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/ConfigOrStatus";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_current_position_lift_percentage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,8,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,8,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/CurrentPositionLiftPercentage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/CurrentPositionLiftPercentage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_current_position_lift_percentage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/CurrentPositionLiftPercentage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_current_position_tilt_percentage_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,9,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,9,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/CurrentPositionTiltPercentage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/CurrentPositionTiltPercentage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_current_position_tilt_percentage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/CurrentPositionTiltPercentage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_installed_open_limit_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,256,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,256,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/InstalledOpenLimitLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/InstalledOpenLimitLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_installed_open_limit_lift_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/InstalledOpenLimitLift";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_installed_closed_limit_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,257,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,257,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/InstalledClosedLimitLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/InstalledClosedLimitLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_installed_closed_limit_lift_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/InstalledClosedLimitLift";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_installed_open_limit_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,258,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,258,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/InstalledOpenLimitTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/InstalledOpenLimitTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_installed_open_limit_tilt_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/InstalledOpenLimitTilt";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_installed_closed_limit_tilt_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,259,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,259,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/InstalledClosedLimitTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/InstalledClosedLimitTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_installed_closed_limit_tilt_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/InstalledClosedLimitTilt";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_velocity_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,260,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,260,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/VelocityLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/VelocityLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_velocity_lift_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/VelocityLift";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_acceleration_time_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,261,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,261,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/AccelerationTimeLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/AccelerationTimeLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_acceleration_time_lift_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/AccelerationTimeLift";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_deceleration_time_lift_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(258,262,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(258,262,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/DecelerationTimeLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/DecelerationTimeLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_deceleration_time_lift_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/DecelerationTimeLift";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = WindowCoveringMode.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/Mode", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/Mode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/Mode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_intermediate_setpoints_lift_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/IntermediateSetpointsLift", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/IntermediateSetpointsLift";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_intermediate_setpoints_lift_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/IntermediateSetpointsLift";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_window_covering_intermediate_setpoints_tilt_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindowCovering/Attributes/IntermediateSetpointsTilt", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindowCovering/Attributes/IntermediateSetpointsTilt";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_window_covering_intermediate_setpoints_tilt_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/IntermediateSetpointsTilt";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_window_covering_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_window_covering_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_window_covering_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_window_covering_up_or_open_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/Commands/UpOrOpen";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_up_or_open);
  }
  if (!uic_mqtt_dotdot_window_covering_generated_up_or_open_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/UpOrOpen";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_up_or_open);
  }
  if (!uic_mqtt_dotdot_window_covering_down_or_close_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/Commands/DownOrClose";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_down_or_close);
  }
  if (!uic_mqtt_dotdot_window_covering_generated_down_or_close_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/DownOrClose";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_down_or_close);
  }
  if (!uic_mqtt_dotdot_window_covering_stop_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/Commands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_stop);
  }
  if (!uic_mqtt_dotdot_window_covering_generated_stop_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_stop);
  }
  if (!uic_mqtt_dotdot_window_covering_go_to_lift_value_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/Commands/GoToLiftValue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_go_to_lift_value);
  }
  if (!uic_mqtt_dotdot_window_covering_generated_go_to_lift_value_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/GoToLiftValue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_go_to_lift_value);
  }
  if (!uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/Commands/GoToLiftPercentage";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_go_to_lift_percentage);
  }
  if (!uic_mqtt_dotdot_window_covering_generated_go_to_lift_percentage_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/GoToLiftPercentage";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_go_to_lift_percentage);
  }
  if (!uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/Commands/GoToTiltValue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_go_to_tilt_value);
  }
  if (!uic_mqtt_dotdot_window_covering_generated_go_to_tilt_value_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/GoToTiltValue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_go_to_tilt_value);
  }
  if (!uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/Commands/GoToTiltPercentage";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_window_covering_go_to_tilt_percentage);
  }
  if (!uic_mqtt_dotdot_window_covering_generated_go_to_tilt_percentage_callback.empty()) {
    subscription_topic = base_topic + "WindowCovering/GeneratedCommands/GoToTiltPercentage";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_window_covering_go_to_tilt_percentage);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_window_covering_attributes_init();

  uic_mqtt_dotdot_by_group_window_covering_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t> uic_mqtt_dotdot_barrier_control_go_to_percent_callback;
static std::set<uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t> uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback;
static std::set<uic_mqtt_dotdot_barrier_control_stop_callback_t> uic_mqtt_dotdot_barrier_control_stop_callback;
static std::set<uic_mqtt_dotdot_barrier_control_stop_callback_t> uic_mqtt_dotdot_barrier_control_generated_stop_callback;
static std::set<uic_mqtt_dotdot_barrier_control_write_attributes_callback_t> uic_mqtt_dotdot_barrier_control_write_attributes_callback;
static std::set<uic_mqtt_dotdot_barrier_control_force_read_attributes_callback_t> uic_mqtt_dotdot_barrier_control_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_barrier_control_go_to_percent_callback_set(const uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_barrier_control_go_to_percent_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_barrier_control_go_to_percent_callback_unset(const uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_go_to_percent_callback.erase(callback);
}
void uic_mqtt_dotdot_barrier_control_go_to_percent_callback_clear()
{
  uic_mqtt_dotdot_barrier_control_go_to_percent_callback.clear();
}
std::set<uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t>& get_uic_mqtt_dotdot_barrier_control_go_to_percent_callback()
{
  return uic_mqtt_dotdot_barrier_control_go_to_percent_callback;
}

void uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback_set(const uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback_unset(const uic_mqtt_dotdot_barrier_control_go_to_percent_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback.erase(callback);
}
void uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback_clear()
{
  uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback.clear();
}
void uic_mqtt_dotdot_barrier_control_stop_callback_set(const uic_mqtt_dotdot_barrier_control_stop_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_barrier_control_stop_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_barrier_control_stop_callback_unset(const uic_mqtt_dotdot_barrier_control_stop_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_stop_callback.erase(callback);
}
void uic_mqtt_dotdot_barrier_control_stop_callback_clear()
{
  uic_mqtt_dotdot_barrier_control_stop_callback.clear();
}
std::set<uic_mqtt_dotdot_barrier_control_stop_callback_t>& get_uic_mqtt_dotdot_barrier_control_stop_callback()
{
  return uic_mqtt_dotdot_barrier_control_stop_callback;
}

void uic_mqtt_dotdot_barrier_control_generated_stop_callback_set(const uic_mqtt_dotdot_barrier_control_stop_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_barrier_control_generated_stop_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_barrier_control_generated_stop_callback_unset(const uic_mqtt_dotdot_barrier_control_stop_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_generated_stop_callback.erase(callback);
}
void uic_mqtt_dotdot_barrier_control_generated_stop_callback_clear()
{
  uic_mqtt_dotdot_barrier_control_generated_stop_callback.clear();
}

void uic_mqtt_dotdot_set_barrier_control_write_attributes_callback(
  const uic_mqtt_dotdot_barrier_control_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_barrier_control_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_barrier_control_write_attributes_callback(
  const uic_mqtt_dotdot_barrier_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_barrier_control_write_attributes_callbacks()
{
  uic_mqtt_dotdot_barrier_control_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_barrier_control_write_attributes_callback_t>& get_uic_mqtt_dotdot_barrier_control_write_attributes_callback()
{
  return uic_mqtt_dotdot_barrier_control_write_attributes_callback;
}

void uic_mqtt_dotdot_set_barrier_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_barrier_control_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_barrier_control_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_barrier_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_barrier_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_barrier_control_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_barrier_control_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_barrier_control_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/BarrierControl/Commands/GoToPercent
void uic_mqtt_dotdot_on_barrier_control_go_to_percent(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_barrier_control_go_to_percent_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percent_open = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_barrier_control_go_to_percent(
      jsn,
      percent_open
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "GoToPercent");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "GoToPercent", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "GoToPercent", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_barrier_control_go_to_percent_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      percent_open
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/BarrierControl/GeneratedCommands/GoToPercent
static void uic_mqtt_dotdot_on_generated_barrier_control_go_to_percent(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t percent_open = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_barrier_control_go_to_percent(
      jsn,
      percent_open
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "GoToPercent");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "GoToPercent", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "GoToPercent", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      percent_open
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/BarrierControl/Commands/Stop
void uic_mqtt_dotdot_on_barrier_control_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_barrier_control_stop_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "Stop", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_barrier_control_stop_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/BarrierControl/GeneratedCommands/Stop
static void uic_mqtt_dotdot_on_generated_barrier_control_stop(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_barrier_control_generated_stop_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "Stop");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "Stop", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "Stop", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_barrier_control_generated_stop_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/BarrierControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_barrier_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_barrier_control_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_barrier_control_state_t new_state = {};
  uic_mqtt_dotdot_barrier_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_barrier_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BarrierControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_barrier_control_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_barrier_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_barrier_control_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_barrier_control_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.moving_state = true;
      force_update.safety_status = true;
      force_update.capabilities = true;
      force_update.open_events = true;
      force_update.close_events = true;
      force_update.command_open_events = true;
      force_update.command_close_events = true;
      force_update.open_period = true;
      force_update.close_period = true;
      force_update.barrier_position = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MovingState", &force_update.moving_state },
        {"SafetyStatus", &force_update.safety_status },
        {"Capabilities", &force_update.capabilities },
        {"OpenEvents", &force_update.open_events },
        {"CloseEvents", &force_update.close_events },
        {"CommandOpenEvents", &force_update.command_open_events },
        {"CommandCloseEvents", &force_update.command_close_events },
        {"OpenPeriod", &force_update.open_period },
        {"ClosePeriod", &force_update.close_period },
        {"BarrierPosition", &force_update.barrier_position },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_barrier_control_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "BarrierControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_barrier_control_moving_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef BARRIER_CONTROL_MOVING_STATE_ENUM_NAME_AVAILABLE
  jsn["value"] = barrier_control_moving_state_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for BARRIER_CONTROL_MOVING_STATE. Using number instead.");
  jsn["value"] = static_cast<BarrierControlMovingState>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/MovingState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/MovingState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_moving_state_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/MovingState";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_barrier_control_safety_status_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BarrierControlSafetyStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/SafetyStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/SafetyStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_safety_status_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/SafetyStatus";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_barrier_control_capabilities_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BarrierControlCapabilities.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/Capabilities", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/Capabilities";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_capabilities_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/Capabilities";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_barrier_control_open_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(259,4,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(259,4,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/OpenEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/OpenEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_open_events_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/OpenEvents";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_barrier_control_close_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(259,5,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(259,5,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/CloseEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/CloseEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_close_events_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/CloseEvents";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_barrier_control_command_open_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(259,6,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(259,6,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/CommandOpenEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/CommandOpenEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_command_open_events_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/CommandOpenEvents";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_barrier_control_command_close_events_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(259,7,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(259,7,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/CommandCloseEvents", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/CommandCloseEvents";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_command_close_events_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/CommandCloseEvents";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_barrier_control_open_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(259,8,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(259,8,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/OpenPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/OpenPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_open_period_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/OpenPeriod";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_barrier_control_close_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(259,9,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(259,9,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/ClosePeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/ClosePeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_close_period_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/ClosePeriod";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_barrier_control_barrier_position_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(259,10,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(259,10,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BarrierControl/Attributes/BarrierPosition", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BarrierControl/Attributes/BarrierPosition";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_barrier_control_barrier_position_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/BarrierPosition";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_barrier_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_barrier_control_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "BarrierControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_barrier_control_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_barrier_control_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "BarrierControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_barrier_control_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_barrier_control_go_to_percent_callback.empty()) {
    subscription_topic = base_topic + "BarrierControl/Commands/GoToPercent";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_barrier_control_go_to_percent);
  }
  if (!uic_mqtt_dotdot_barrier_control_generated_go_to_percent_callback.empty()) {
    subscription_topic = base_topic + "BarrierControl/GeneratedCommands/GoToPercent";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_barrier_control_go_to_percent);
  }
  if (!uic_mqtt_dotdot_barrier_control_stop_callback.empty()) {
    subscription_topic = base_topic + "BarrierControl/Commands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_barrier_control_stop);
  }
  if (!uic_mqtt_dotdot_barrier_control_generated_stop_callback.empty()) {
    subscription_topic = base_topic + "BarrierControl/GeneratedCommands/Stop";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_barrier_control_stop);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_barrier_control_attributes_init();

  uic_mqtt_dotdot_by_group_barrier_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback_t> uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback;
static std::set<uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback_t> uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_pump_configuration_and_control_write_attributes_callback(
  const uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_pump_configuration_and_control_write_attributes_callback(
  const uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_pump_configuration_and_control_write_attributes_callbacks()
{
  uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback_t>& get_uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback()
{
  return uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback;
}

void uic_mqtt_dotdot_set_pump_configuration_and_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_pump_configuration_and_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_pump_configuration_and_control_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/PumpConfigurationAndControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_pump_configuration_and_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_pump_configuration_and_control_state_t new_state = {};
  uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_pump_configuration_and_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PumpConfigurationAndControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_pump_configuration_and_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.max_pressure = true;
      force_update.max_speed = true;
      force_update.max_flow = true;
      force_update.min_const_pressure = true;
      force_update.max_const_pressure = true;
      force_update.min_comp_pressure = true;
      force_update.max_comp_pressure = true;
      force_update.min_const_speed = true;
      force_update.max_const_speed = true;
      force_update.min_const_flow = true;
      force_update.max_const_flow = true;
      force_update.min_const_temp = true;
      force_update.max_const_temp = true;
      force_update.pump_status = true;
      force_update.effective_operation_mode = true;
      force_update.effective_control_mode = true;
      force_update.capacity = true;
      force_update.speed = true;
      force_update.lifetime_running_hours = true;
      force_update.power = true;
      force_update.lifetime_energy_consumed = true;
      force_update.operation_mode = true;
      force_update.control_mode = true;
      force_update.alarm_mask = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MaxPressure", &force_update.max_pressure },
        {"MaxSpeed", &force_update.max_speed },
        {"MaxFlow", &force_update.max_flow },
        {"MinConstPressure", &force_update.min_const_pressure },
        {"MaxConstPressure", &force_update.max_const_pressure },
        {"MinCompPressure", &force_update.min_comp_pressure },
        {"MaxCompPressure", &force_update.max_comp_pressure },
        {"MinConstSpeed", &force_update.min_const_speed },
        {"MaxConstSpeed", &force_update.max_const_speed },
        {"MinConstFlow", &force_update.min_const_flow },
        {"MaxConstFlow", &force_update.max_const_flow },
        {"MinConstTemp", &force_update.min_const_temp },
        {"MaxConstTemp", &force_update.max_const_temp },
        {"PumpStatus", &force_update.pump_status },
        {"EffectiveOperationMode", &force_update.effective_operation_mode },
        {"EffectiveControlMode", &force_update.effective_control_mode },
        {"Capacity", &force_update.capacity },
        {"Speed", &force_update.speed },
        {"LifetimeRunningHours", &force_update.lifetime_running_hours },
        {"Power", &force_update.power },
        {"LifetimeEnergyConsumed", &force_update.lifetime_energy_consumed },
        {"OperationMode", &force_update.operation_mode },
        {"ControlMode", &force_update.control_mode },
        {"AlarmMask", &force_update.alarm_mask },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "PumpConfigurationAndControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxPressure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxPressure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_pressure_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MaxPressure";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxSpeed", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxSpeed";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_speed_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MaxSpeed";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_flow_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxFlow", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxFlow";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_flow_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MaxFlow";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MinConstPressure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MinConstPressure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_pressure_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MinConstPressure";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,4,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,4,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxConstPressure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxConstPressure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_pressure_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MaxConstPressure";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_comp_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,5,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,5,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MinCompPressure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MinCompPressure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_comp_pressure_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MinCompPressure";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_comp_pressure_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,6,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,6,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxCompPressure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxCompPressure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_comp_pressure_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MaxCompPressure";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,7,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,7,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MinConstSpeed", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MinConstSpeed";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_speed_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MinConstSpeed";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,8,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,8,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxConstSpeed", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxConstSpeed";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_speed_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MaxConstSpeed";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_flow_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,9,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,9,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MinConstFlow", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MinConstFlow";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_flow_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MinConstFlow";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_flow_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,10,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,10,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxConstFlow", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxConstFlow";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_flow_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MaxConstFlow";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_temp_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,11,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,11,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MinConstTemp", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MinConstTemp";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_min_const_temp_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MinConstTemp";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_temp_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,12,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,12,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/MaxConstTemp", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/MaxConstTemp";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_max_const_temp_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/MaxConstTemp";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_pump_status_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = PumpConfigurationAndControlPumpStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/PumpStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/PumpStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_pump_status_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/PumpStatus";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_effective_operation_mode_publish(
  const char *base_topic,
  PumpOperationMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = pump_configuration_and_control_effective_operation_mode_get_enum_value_name((uint32_t)value);
  #elif defined(PUMP_OPERATION_MODE_ENUM_NAME_AVAILABLE)
  jsn["value"] = pump_operation_mode_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE. Using number instead.");
  jsn["value"] = static_cast<PumpOperationMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/EffectiveOperationMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/EffectiveOperationMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_effective_operation_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/EffectiveOperationMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_effective_control_mode_publish(
  const char *base_topic,
  PumpControlMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = pump_configuration_and_control_effective_control_mode_get_enum_value_name((uint32_t)value);
  #elif defined(PUMP_CONTROL_MODE_ENUM_NAME_AVAILABLE)
  jsn["value"] = pump_control_mode_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE. Using number instead.");
  jsn["value"] = static_cast<PumpControlMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/EffectiveControlMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/EffectiveControlMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_effective_control_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/EffectiveControlMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_capacity_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/Capacity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/Capacity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_capacity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/Capacity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_speed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,20,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,20,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/Speed", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/Speed";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_speed_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/Speed";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_lifetime_running_hours_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,21,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,21,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/LifetimeRunningHours", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/LifetimeRunningHours";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_lifetime_running_hours_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/LifetimeRunningHours";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_power_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,22,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,22,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/Power", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/Power";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_power_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/Power";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_lifetime_energy_consumed_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(512,23,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(512,23,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/LifetimeEnergyConsumed", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/LifetimeEnergyConsumed";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_lifetime_energy_consumed_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/LifetimeEnergyConsumed";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_operation_mode_publish(
  const char *base_topic,
  PumpOperationMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = pump_configuration_and_control_operation_mode_get_enum_value_name((uint32_t)value);
  #elif defined(PUMP_OPERATION_MODE_ENUM_NAME_AVAILABLE)
  jsn["value"] = pump_operation_mode_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE. Using number instead.");
  jsn["value"] = static_cast<PumpOperationMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/OperationMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/OperationMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_operation_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/OperationMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_control_mode_publish(
  const char *base_topic,
  PumpControlMode value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = pump_configuration_and_control_control_mode_get_enum_value_name((uint32_t)value);
  #elif defined(PUMP_CONTROL_MODE_ENUM_NAME_AVAILABLE)
  jsn["value"] = pump_control_mode_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE. Using number instead.");
  jsn["value"] = static_cast<PumpControlMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/ControlMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/ControlMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_control_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/ControlMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_alarm_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = PumpConfigurationAndControlAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PumpConfigurationAndControl/Attributes/AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_alarm_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/AlarmMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_pump_configuration_and_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_pump_configuration_and_control_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "PumpConfigurationAndControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_pump_configuration_and_control_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_pump_configuration_and_control_attributes_init();

  uic_mqtt_dotdot_by_group_pump_configuration_and_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t> uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback;
static std::set<uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t> uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback;
static std::set<uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t> uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback;
static std::set<uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t> uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback;
static std::set<uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t> uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback;
static std::set<uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t> uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback;
static std::set<uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t> uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback;
static std::set<uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t> uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback;
static std::set<uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t> uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback;
static std::set<uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t> uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback;
static std::set<uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t> uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback;
static std::set<uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t> uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback;
static std::set<uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t> uic_mqtt_dotdot_thermostat_get_relay_status_log_callback;
static std::set<uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t> uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback;
static std::set<uic_mqtt_dotdot_thermostat_write_attributes_callback_t> uic_mqtt_dotdot_thermostat_write_attributes_callback;
static std::set<uic_mqtt_dotdot_thermostat_force_read_attributes_callback_t> uic_mqtt_dotdot_thermostat_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_set(const uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_unset(const uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_clear()
{
  uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback.clear();
}
std::set<uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t>& get_uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback()
{
  return uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback;
}

void uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback_set(const uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback_unset(const uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback_clear()
{
  uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback.clear();
}
void uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_set(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_unset(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback.clear();
}
std::set<uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t>& get_uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback()
{
  return uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback;
}

void uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback_set(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback_unset(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback_clear()
{
  uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback.clear();
}
void uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_unset(const uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_clear()
{
  uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t>& get_uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback()
{
  return uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback;
}

void uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback_unset(const uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback_clear()
{
  uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback.clear();
}
void uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_set(const uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_unset(const uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_clear()
{
  uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback.clear();
}
std::set<uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t>& get_uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback()
{
  return uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback;
}

void uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback_set(const uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback_unset(const uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback_clear()
{
  uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback.clear();
}
void uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_unset(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_clear()
{
  uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t>& get_uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback()
{
  return uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback;
}

void uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback_unset(const uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback_clear()
{
  uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback.clear();
}
void uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_unset(const uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_clear()
{
  uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback.clear();
}
std::set<uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t>& get_uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback()
{
  return uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback;
}

void uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback_set(const uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback_unset(const uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback_clear()
{
  uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback.clear();
}
void uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_set(const uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_get_relay_status_log_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_unset(const uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_get_relay_status_log_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_clear()
{
  uic_mqtt_dotdot_thermostat_get_relay_status_log_callback.clear();
}
std::set<uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t>& get_uic_mqtt_dotdot_thermostat_get_relay_status_log_callback()
{
  return uic_mqtt_dotdot_thermostat_get_relay_status_log_callback;
}

void uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback_set(const uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback_unset(const uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback.erase(callback);
}
void uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback_clear()
{
  uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback.clear();
}

void uic_mqtt_dotdot_set_thermostat_write_attributes_callback(
  const uic_mqtt_dotdot_thermostat_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_thermostat_write_attributes_callback(
  const uic_mqtt_dotdot_thermostat_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_thermostat_write_attributes_callbacks()
{
  uic_mqtt_dotdot_thermostat_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_thermostat_write_attributes_callback_t>& get_uic_mqtt_dotdot_thermostat_write_attributes_callback()
{
  return uic_mqtt_dotdot_thermostat_write_attributes_callback;
}

void uic_mqtt_dotdot_set_thermostat_force_read_attributes_callback(
  const uic_mqtt_dotdot_thermostat_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_thermostat_force_read_attributes_callback(
  const uic_mqtt_dotdot_thermostat_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_thermostat_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_thermostat_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/SetpointRaiseOrLower
void uic_mqtt_dotdot_on_thermostat_setpoint_raise_or_lower(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SetpointRaiseOrLowerMode mode = {};
  int8_t amount = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_setpoint_raise_or_lower(
      jsn,
      mode,

      amount
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "SetpointRaiseOrLower");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetpointRaiseOrLower", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetpointRaiseOrLower", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      mode,
  
      amount
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/SetpointRaiseOrLower
static void uic_mqtt_dotdot_on_generated_thermostat_setpoint_raise_or_lower(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  SetpointRaiseOrLowerMode mode = {};
  int8_t amount = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_setpoint_raise_or_lower(
      jsn,
      mode,

      amount
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "SetpointRaiseOrLower");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetpointRaiseOrLower", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetpointRaiseOrLower", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      mode,
  
      amount
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/GetWeeklyScheduleResponse
void uic_mqtt_dotdot_on_thermostat_get_weekly_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t number_of_transitions = {};
  uint8_t day_of_week = {};
  uint8_t mode = {};
  std::vector<TransitionType> transitions;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule_response(
      jsn,
      number_of_transitions,

      day_of_week,

      mode,

      transitions
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetWeeklyScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklyScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklyScheduleResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      number_of_transitions,
  
      day_of_week,
  
      mode,
  
      transitions.size(),
      transitions.data()

    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/GetWeeklyScheduleResponse
static void uic_mqtt_dotdot_on_generated_thermostat_get_weekly_schedule_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t number_of_transitions = {};
  uint8_t day_of_week = {};
  uint8_t mode = {};
  std::vector<TransitionType> transitions;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule_response(
      jsn,
      number_of_transitions,

      day_of_week,

      mode,

      transitions
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetWeeklyScheduleResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklyScheduleResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklyScheduleResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      number_of_transitions,
  
      day_of_week,
  
      mode,
  
      transitions.size(),
      transitions.data()

    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/SetWeeklySchedule
void uic_mqtt_dotdot_on_thermostat_set_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t number_of_transitions = {};
  uint8_t day_of_week = {};
  uint8_t mode = {};
  std::vector<TransitionType> transitions;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_set_weekly_schedule(
      jsn,
      number_of_transitions,

      day_of_week,

      mode,

      transitions
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "SetWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetWeeklySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      number_of_transitions,
  
      day_of_week,
  
      mode,
  
      transitions.size(),
      transitions.data()

    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/SetWeeklySchedule
static void uic_mqtt_dotdot_on_generated_thermostat_set_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t number_of_transitions = {};
  uint8_t day_of_week = {};
  uint8_t mode = {};
  std::vector<TransitionType> transitions;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_set_weekly_schedule(
      jsn,
      number_of_transitions,

      day_of_week,

      mode,

      transitions
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "SetWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "SetWeeklySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      number_of_transitions,
  
      day_of_week,
  
      mode,
  
      transitions.size(),
      transitions.data()

    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/GetRelayStatusLogResponse
void uic_mqtt_dotdot_on_thermostat_get_relay_status_log_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t time_of_day = {};
  uint8_t relay_status = {};
  int16_t local_temperature = {};
  uint8_t humidity_percentage = {};
  int16_t set_point = {};
  uint16_t unread_entries = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_relay_status_log_response(
      jsn,
      time_of_day,

      relay_status,

      local_temperature,

      humidity_percentage,

      set_point,

      unread_entries
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetRelayStatusLogResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLogResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLogResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      time_of_day,
  
      relay_status,
  
      local_temperature,
  
      humidity_percentage,
  
      set_point,
  
      unread_entries
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/GetRelayStatusLogResponse
static void uic_mqtt_dotdot_on_generated_thermostat_get_relay_status_log_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t time_of_day = {};
  uint8_t relay_status = {};
  int16_t local_temperature = {};
  uint8_t humidity_percentage = {};
  int16_t set_point = {};
  uint16_t unread_entries = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_relay_status_log_response(
      jsn,
      time_of_day,

      relay_status,

      local_temperature,

      humidity_percentage,

      set_point,

      unread_entries
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetRelayStatusLogResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLogResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLogResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      time_of_day,
  
      relay_status,
  
      local_temperature,
  
      humidity_percentage,
  
      set_point,
  
      unread_entries
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/GetWeeklySchedule
void uic_mqtt_dotdot_on_thermostat_get_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t days_to_return = {};
  uint8_t mode_to_return = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule(
      jsn,
      days_to_return,

      mode_to_return
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      days_to_return,
  
      mode_to_return
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/GetWeeklySchedule
static void uic_mqtt_dotdot_on_generated_thermostat_get_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t days_to_return = {};
  uint8_t mode_to_return = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_thermostat_get_weekly_schedule(
      jsn,
      days_to_return,

      mode_to_return
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetWeeklySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      days_to_return,
  
      mode_to_return
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/ClearWeeklySchedule
void uic_mqtt_dotdot_on_thermostat_clear_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "ClearWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "ClearWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "ClearWeeklySchedule", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/ClearWeeklySchedule
static void uic_mqtt_dotdot_on_generated_thermostat_clear_weekly_schedule(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "ClearWeeklySchedule");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "ClearWeeklySchedule", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "ClearWeeklySchedule", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/GetRelayStatusLog
void uic_mqtt_dotdot_on_thermostat_get_relay_status_log(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_get_relay_status_log_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetRelayStatusLog");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLog", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLog", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_thermostat_get_relay_status_log_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/GeneratedCommands/GetRelayStatusLog
static void uic_mqtt_dotdot_on_generated_thermostat_get_relay_status_log(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "GetRelayStatusLog");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLog", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "GetRelayStatusLog", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Thermostat/Commands/WriteAttributes
void uic_mqtt_dotdot_on_thermostat_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_thermostat_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_thermostat_state_t new_state = {};
  uic_mqtt_dotdot_thermostat_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_thermostat_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Thermostat", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_thermostat_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_thermostat_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_thermostat_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_thermostat_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.local_temperature = true;
      force_update.outdoor_temperature = true;
      force_update.occupancy = true;
      force_update.abs_min_heat_setpoint_limit = true;
      force_update.abs_max_heat_setpoint_limit = true;
      force_update.abs_min_cool_setpoint_limit = true;
      force_update.abs_max_cool_setpoint_limit = true;
      force_update.pi_cooling_demand = true;
      force_update.pi_heating_demand = true;
      force_update.hvac_system_type_configuration = true;
      force_update.local_temperature_calibration = true;
      force_update.occupied_cooling_setpoint = true;
      force_update.occupied_heating_setpoint = true;
      force_update.unoccupied_cooling_setpoint = true;
      force_update.unoccupied_heating_setpoint = true;
      force_update.min_heat_setpoint_limit = true;
      force_update.max_heat_setpoint_limit = true;
      force_update.min_cool_setpoint_limit = true;
      force_update.max_cool_setpoint_limit = true;
      force_update.min_setpoint_dead_band = true;
      force_update.remote_sensing = true;
      force_update.control_sequence_of_operation = true;
      force_update.system_mode = true;
      force_update.alarm_mask = true;
      force_update.thermostat_running_mode = true;
      force_update.start_of_week = true;
      force_update.number_of_weekly_transitions = true;
      force_update.number_of_daily_transitions = true;
      force_update.temperature_setpoint_hold = true;
      force_update.temperature_setpoint_hold_duration = true;
      force_update.thermostat_programming_operation_mode = true;
      force_update.thermostat_running_state = true;
      force_update.setpoint_change_source = true;
      force_update.setpoint_change_amount = true;
      force_update.setpoint_change_source_timestamp = true;
      force_update.occupied_setback = true;
      force_update.occupied_setback_min = true;
      force_update.occupied_setback_max = true;
      force_update.unoccupied_setback = true;
      force_update.unoccupied_setback_min = true;
      force_update.unoccupied_setback_max = true;
      force_update.emergency_heat_delta = true;
      force_update.ac_type = true;
      force_update.ac_capacity = true;
      force_update.ac_refrigerant_type = true;
      force_update.ac_compressor_type = true;
      force_update.ac_error_code = true;
      force_update.ac_louver_position = true;
      force_update.ac_coil_temperature = true;
      force_update.ac_capacity_format = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"LocalTemperature", &force_update.local_temperature },
        {"OutdoorTemperature", &force_update.outdoor_temperature },
        {"Occupancy", &force_update.occupancy },
        {"AbsMinHeatSetpointLimit", &force_update.abs_min_heat_setpoint_limit },
        {"AbsMaxHeatSetpointLimit", &force_update.abs_max_heat_setpoint_limit },
        {"AbsMinCoolSetpointLimit", &force_update.abs_min_cool_setpoint_limit },
        {"AbsMaxCoolSetpointLimit", &force_update.abs_max_cool_setpoint_limit },
        {"PICoolingDemand", &force_update.pi_cooling_demand },
        {"PIHeatingDemand", &force_update.pi_heating_demand },
        {"HVACSystemTypeConfiguration", &force_update.hvac_system_type_configuration },
        {"LocalTemperatureCalibration", &force_update.local_temperature_calibration },
        {"OccupiedCoolingSetpoint", &force_update.occupied_cooling_setpoint },
        {"OccupiedHeatingSetpoint", &force_update.occupied_heating_setpoint },
        {"UnoccupiedCoolingSetpoint", &force_update.unoccupied_cooling_setpoint },
        {"UnoccupiedHeatingSetpoint", &force_update.unoccupied_heating_setpoint },
        {"MinHeatSetpointLimit", &force_update.min_heat_setpoint_limit },
        {"MaxHeatSetpointLimit", &force_update.max_heat_setpoint_limit },
        {"MinCoolSetpointLimit", &force_update.min_cool_setpoint_limit },
        {"MaxCoolSetpointLimit", &force_update.max_cool_setpoint_limit },
        {"MinSetpointDeadBand", &force_update.min_setpoint_dead_band },
        {"RemoteSensing", &force_update.remote_sensing },
        {"ControlSequenceOfOperation", &force_update.control_sequence_of_operation },
        {"SystemMode", &force_update.system_mode },
        {"AlarmMask", &force_update.alarm_mask },
        {"ThermostatRunningMode", &force_update.thermostat_running_mode },
        {"StartOfWeek", &force_update.start_of_week },
        {"NumberOfWeeklyTransitions", &force_update.number_of_weekly_transitions },
        {"NumberOfDailyTransitions", &force_update.number_of_daily_transitions },
        {"TemperatureSetpointHold", &force_update.temperature_setpoint_hold },
        {"TemperatureSetpointHoldDuration", &force_update.temperature_setpoint_hold_duration },
        {"ThermostatProgrammingOperationMode", &force_update.thermostat_programming_operation_mode },
        {"ThermostatRunningState", &force_update.thermostat_running_state },
        {"SetpointChangeSource", &force_update.setpoint_change_source },
        {"SetpointChangeAmount", &force_update.setpoint_change_amount },
        {"SetpointChangeSourceTimestamp", &force_update.setpoint_change_source_timestamp },
        {"OccupiedSetback", &force_update.occupied_setback },
        {"OccupiedSetbackMin", &force_update.occupied_setback_min },
        {"OccupiedSetbackMax", &force_update.occupied_setback_max },
        {"UnoccupiedSetback", &force_update.unoccupied_setback },
        {"UnoccupiedSetbackMin", &force_update.unoccupied_setback_min },
        {"UnoccupiedSetbackMax", &force_update.unoccupied_setback_max },
        {"EmergencyHeatDelta", &force_update.emergency_heat_delta },
        {"ACType", &force_update.ac_type },
        {"ACCapacity", &force_update.ac_capacity },
        {"ACRefrigerantType", &force_update.ac_refrigerant_type },
        {"ACCompressorType", &force_update.ac_compressor_type },
        {"ACErrorCode", &force_update.ac_error_code },
        {"ACLouverPosition", &force_update.ac_louver_position },
        {"ACCoilTemperature", &force_update.ac_coil_temperature },
        {"ACCapacityFormat", &force_update.ac_capacity_format },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_thermostat_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Thermostat/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_thermostat_local_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/LocalTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/LocalTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_local_temperature_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/LocalTemperature";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_outdoor_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OutdoorTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OutdoorTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_outdoor_temperature_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/OutdoorTemperature";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_occupancy_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatOccupancy.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/Occupancy", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/Occupancy";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_occupancy_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/Occupancy";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/AbsMinHeatSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/AbsMinHeatSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/AbsMinHeatSetpointLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,4,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,4,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/AbsMaxHeatSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/AbsMaxHeatSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/AbsMaxHeatSetpointLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,5,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,5,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/AbsMinCoolSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/AbsMinCoolSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/AbsMinCoolSetpointLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,6,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,6,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/AbsMaxCoolSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/AbsMaxCoolSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/AbsMaxCoolSetpointLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_pi_cooling_demand_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,7,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,7,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/PICoolingDemand", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/PICoolingDemand";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_pi_cooling_demand_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/PICoolingDemand";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_pi_heating_demand_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,8,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,8,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/PIHeatingDemand", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/PIHeatingDemand";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_pi_heating_demand_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/PIHeatingDemand";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatHVACSystemTypeConfiguration.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/HVACSystemTypeConfiguration", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/HVACSystemTypeConfiguration";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/HVACSystemTypeConfiguration";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_local_temperature_calibration_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/LocalTemperatureCalibration", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/LocalTemperatureCalibration";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_local_temperature_calibration_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/LocalTemperatureCalibration";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OccupiedCoolingSetpoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OccupiedCoolingSetpoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/OccupiedCoolingSetpoint";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OccupiedHeatingSetpoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OccupiedHeatingSetpoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/OccupiedHeatingSetpoint";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/UnoccupiedCoolingSetpoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/UnoccupiedCoolingSetpoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/UnoccupiedCoolingSetpoint";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,20,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,20,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/UnoccupiedHeatingSetpoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/UnoccupiedHeatingSetpoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/UnoccupiedHeatingSetpoint";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,21,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,21,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/MinHeatSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/MinHeatSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/MinHeatSetpointLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,22,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,22,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/MaxHeatSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/MaxHeatSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/MaxHeatSetpointLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,23,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,23,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/MinCoolSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/MinCoolSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/MinCoolSetpointLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,24,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,24,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/MaxCoolSetpointLimit", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/MaxCoolSetpointLimit";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/MaxCoolSetpointLimit";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,25,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,25,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/MinSetpointDeadBand", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/MinSetpointDeadBand";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/MinSetpointDeadBand";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_remote_sensing_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatRemoteSensing.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/RemoteSensing", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/RemoteSensing";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_remote_sensing_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/RemoteSensing";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_control_sequence_of_operation_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_control_sequence_of_operation_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION. Using number instead.");
  jsn["value"] = static_cast<ThermostatControlSequenceOfOperation>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ControlSequenceOfOperation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ControlSequenceOfOperation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_control_sequence_of_operation_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ControlSequenceOfOperation";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_system_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_SYSTEM_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_system_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_SYSTEM_MODE. Using number instead.");
  jsn["value"] = static_cast<ThermostatSystemMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/SystemMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/SystemMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_system_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/SystemMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_alarm_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatAlarmMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/AlarmMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/AlarmMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_alarm_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/AlarmMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_thermostat_running_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_THERMOSTAT_RUNNING_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_thermostat_running_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_THERMOSTAT_RUNNING_MODE. Using number instead.");
  jsn["value"] = static_cast<ThermostatThermostatRunningMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ThermostatRunningMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ThermostatRunningMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_thermostat_running_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ThermostatRunningMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_start_of_week_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_START_OF_WEEK_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_start_of_week_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_START_OF_WEEK. Using number instead.");
  jsn["value"] = static_cast<ThermostatStartOfWeek>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/StartOfWeek", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/StartOfWeek";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_start_of_week_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/StartOfWeek";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,33,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,33,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/NumberOfWeeklyTransitions", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/NumberOfWeeklyTransitions";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/NumberOfWeeklyTransitions";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_number_of_daily_transitions_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,34,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,34,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/NumberOfDailyTransitions", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/NumberOfDailyTransitions";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_number_of_daily_transitions_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/NumberOfDailyTransitions";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_temperature_setpoint_hold_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_TEMPERATURE_SETPOINT_HOLD. Using number instead.");
  jsn["value"] = static_cast<ThermostatTemperatureSetpointHold>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/TemperatureSetpointHold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/TemperatureSetpointHold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/TemperatureSetpointHold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,36,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,36,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/TemperatureSetpointHoldDuration", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/TemperatureSetpointHoldDuration";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/TemperatureSetpointHoldDuration";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatThermostatProgrammingOperationMode.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ThermostatProgrammingOperationMode", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ThermostatProgrammingOperationMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ThermostatProgrammingOperationMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_thermostat_running_state_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatThermostatRunningState.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ThermostatRunningState", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ThermostatRunningState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_thermostat_running_state_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ThermostatRunningState";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_source_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_SETPOINT_CHANGE_SOURCE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_setpoint_change_source_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_SETPOINT_CHANGE_SOURCE. Using number instead.");
  jsn["value"] = static_cast<ThermostatSetpointChangeSource>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/SetpointChangeSource", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/SetpointChangeSource";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_source_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/SetpointChangeSource";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_amount_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,49,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,49,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/SetpointChangeAmount", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/SetpointChangeAmount";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_amount_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/SetpointChangeAmount";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,50,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,50,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/SetpointChangeSourceTimestamp", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/SetpointChangeSourceTimestamp";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/SetpointChangeSourceTimestamp";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,52,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,52,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OccupiedSetback", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OccupiedSetback";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/OccupiedSetback";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_min_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,53,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,53,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OccupiedSetbackMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OccupiedSetbackMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/OccupiedSetbackMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_max_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,54,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,54,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/OccupiedSetbackMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/OccupiedSetbackMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_occupied_setback_max_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/OccupiedSetbackMax";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,55,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,55,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/UnoccupiedSetback", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/UnoccupiedSetback";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/UnoccupiedSetback";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_min_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,56,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,56,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/UnoccupiedSetbackMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/UnoccupiedSetbackMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/UnoccupiedSetbackMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_max_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,57,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,57,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/UnoccupiedSetbackMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/UnoccupiedSetbackMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_unoccupied_setback_max_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/UnoccupiedSetbackMax";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_emergency_heat_delta_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,58,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,58,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/EmergencyHeatDelta", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/EmergencyHeatDelta";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_emergency_heat_delta_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/EmergencyHeatDelta";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_ac_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_AC_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_ac_type_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_AC_TYPE. Using number instead.");
  jsn["value"] = static_cast<ThermostatACType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_ac_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ACType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_ac_capacity_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,65,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,65,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACCapacity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACCapacity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_ac_capacity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ACCapacity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_ac_refrigerant_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_AC_REFRIGERANT_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_ac_refrigerant_type_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_AC_REFRIGERANT_TYPE. Using number instead.");
  jsn["value"] = static_cast<ThermostatACRefrigerantType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACRefrigerantType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACRefrigerantType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_ac_refrigerant_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ACRefrigerantType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_ac_compressor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_AC_COMPRESSOR_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_ac_compressor_type_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_AC_COMPRESSOR_TYPE. Using number instead.");
  jsn["value"] = static_cast<ThermostatACCompressorType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACCompressorType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACCompressorType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_ac_compressor_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ACCompressorType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_ac_error_code_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ThermostatACErrorCode.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACErrorCode", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACErrorCode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_ac_error_code_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ACErrorCode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_ac_louver_position_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_AC_LOUVER_POSITION_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_ac_louver_position_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_AC_LOUVER_POSITION. Using number instead.");
  jsn["value"] = static_cast<ThermostatACLouverPosition>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACLouverPosition", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACLouverPosition";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_ac_louver_position_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ACLouverPosition";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_ac_coil_temperature_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(513,70,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(513,70,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACCoilTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACCoilTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_ac_coil_temperature_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ACCoilTemperature";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_ac_capacity_format_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_AC_CAPACITY_FORMAT_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_ac_capacity_format_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_AC_CAPACITY_FORMAT. Using number instead.");
  jsn["value"] = static_cast<ThermostatACCapacityFormat>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Thermostat/Attributes/ACCapacityFormat", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Thermostat/Attributes/ACCapacityFormat";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_ac_capacity_format_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ACCapacityFormat";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_thermostat_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_thermostat_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_thermostat_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/Commands/SetpointRaiseOrLower";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_setpoint_raise_or_lower);
  }
  if (!uic_mqtt_dotdot_thermostat_generated_setpoint_raise_or_lower_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/SetpointRaiseOrLower";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_setpoint_raise_or_lower);
  }
  if (!uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/Commands/GetWeeklyScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_get_weekly_schedule_response);
  }
  if (!uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_response_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/GetWeeklyScheduleResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_get_weekly_schedule_response);
  }
  if (!uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/Commands/SetWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_set_weekly_schedule);
  }
  if (!uic_mqtt_dotdot_thermostat_generated_set_weekly_schedule_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/SetWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_set_weekly_schedule);
  }
  if (!uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/Commands/GetRelayStatusLogResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_get_relay_status_log_response);
  }
  if (!uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_response_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/GetRelayStatusLogResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_get_relay_status_log_response);
  }
  if (!uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/Commands/GetWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_get_weekly_schedule);
  }
  if (!uic_mqtt_dotdot_thermostat_generated_get_weekly_schedule_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/GetWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_get_weekly_schedule);
  }
  if (!uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/Commands/ClearWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_clear_weekly_schedule);
  }
  if (!uic_mqtt_dotdot_thermostat_generated_clear_weekly_schedule_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/ClearWeeklySchedule";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_clear_weekly_schedule);
  }
  if (!uic_mqtt_dotdot_thermostat_get_relay_status_log_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/Commands/GetRelayStatusLog";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_get_relay_status_log);
  }
  if (!uic_mqtt_dotdot_thermostat_generated_get_relay_status_log_callback.empty()) {
    subscription_topic = base_topic + "Thermostat/GeneratedCommands/GetRelayStatusLog";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_thermostat_get_relay_status_log);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_thermostat_attributes_init();

  uic_mqtt_dotdot_by_group_thermostat_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_fan_control_write_attributes_callback_t> uic_mqtt_dotdot_fan_control_write_attributes_callback;
static std::set<uic_mqtt_dotdot_fan_control_force_read_attributes_callback_t> uic_mqtt_dotdot_fan_control_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_fan_control_write_attributes_callback(
  const uic_mqtt_dotdot_fan_control_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_fan_control_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_fan_control_write_attributes_callback(
  const uic_mqtt_dotdot_fan_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_fan_control_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_fan_control_write_attributes_callbacks()
{
  uic_mqtt_dotdot_fan_control_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_fan_control_write_attributes_callback_t>& get_uic_mqtt_dotdot_fan_control_write_attributes_callback()
{
  return uic_mqtt_dotdot_fan_control_write_attributes_callback;
}

void uic_mqtt_dotdot_set_fan_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_fan_control_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_fan_control_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_fan_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_fan_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_fan_control_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_fan_control_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_fan_control_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/FanControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_fan_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_fan_control_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_fan_control_state_t new_state = {};
  uic_mqtt_dotdot_fan_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_fan_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "FanControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FanControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FanControl", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_fan_control_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_fan_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_fan_control_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_fan_control_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.fan_mode = true;
      force_update.fan_mode_sequence = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"FanMode", &force_update.fan_mode },
        {"FanModeSequence", &force_update.fan_mode_sequence },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_fan_control_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "FanControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_fan_control_fan_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef FAN_CONTROL_FAN_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = fan_control_fan_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for FAN_CONTROL_FAN_MODE. Using number instead.");
  jsn["value"] = static_cast<FanControlFanMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FanControl/Attributes/FanMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FanControl/Attributes/FanMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_fan_control_fan_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/FanControl/Attributes/FanMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_fan_control_fan_mode_sequence_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef FAN_CONTROL_FAN_MODE_SEQUENCE_ENUM_NAME_AVAILABLE
  jsn["value"] = fan_control_fan_mode_sequence_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for FAN_CONTROL_FAN_MODE_SEQUENCE. Using number instead.");
  jsn["value"] = static_cast<FanControlFanModeSequence>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FanControl/Attributes/FanModeSequence", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FanControl/Attributes/FanModeSequence";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_fan_control_fan_mode_sequence_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/FanControl/Attributes/FanModeSequence";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_fan_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_fan_control_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "FanControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_fan_control_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_fan_control_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "FanControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_fan_control_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_fan_control_attributes_init();

  uic_mqtt_dotdot_by_group_fan_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_dehumidification_control_write_attributes_callback_t> uic_mqtt_dotdot_dehumidification_control_write_attributes_callback;
static std::set<uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback_t> uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_dehumidification_control_write_attributes_callback(
  const uic_mqtt_dotdot_dehumidification_control_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_dehumidification_control_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_dehumidification_control_write_attributes_callback(
  const uic_mqtt_dotdot_dehumidification_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_dehumidification_control_write_attributes_callbacks()
{
  uic_mqtt_dotdot_dehumidification_control_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_dehumidification_control_write_attributes_callback_t>& get_uic_mqtt_dotdot_dehumidification_control_write_attributes_callback()
{
  return uic_mqtt_dotdot_dehumidification_control_write_attributes_callback;
}

void uic_mqtt_dotdot_set_dehumidification_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_dehumidification_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_dehumidification_control_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/DehumidificationControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_dehumidification_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_dehumidification_control_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_dehumidification_control_state_t new_state = {};
  uic_mqtt_dotdot_dehumidification_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_dehumidification_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "DehumidificationControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_dehumidification_control_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_dehumidification_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_dehumidification_control_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.relative_humidity = true;
      force_update.dehumidification_cooling = true;
      force_update.rh_dehumidification_setpoint = true;
      force_update.relative_humidity_mode = true;
      force_update.dehumidification_lockout = true;
      force_update.dehumidification_hysteresis = true;
      force_update.dehumidification_max_cool = true;
      force_update.relative_humidity_display = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"RelativeHumidity", &force_update.relative_humidity },
        {"DehumidificationCooling", &force_update.dehumidification_cooling },
        {"RHDehumidificationSetpoint", &force_update.rh_dehumidification_setpoint },
        {"RelativeHumidityMode", &force_update.relative_humidity_mode },
        {"DehumidificationLockout", &force_update.dehumidification_lockout },
        {"DehumidificationHysteresis", &force_update.dehumidification_hysteresis },
        {"DehumidificationMaxCool", &force_update.dehumidification_max_cool },
        {"RelativeHumidityDisplay", &force_update.relative_humidity_display },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "DehumidificationControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(515,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(515,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/RelativeHumidity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/RelativeHumidity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DehumidificationControl/Attributes/RelativeHumidity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_cooling_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(515,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(515,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/DehumidificationCooling", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/DehumidificationCooling";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_cooling_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DehumidificationControl/Attributes/DehumidificationCooling";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_dehumidification_control_rh_dehumidification_setpoint_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(515,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(515,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/RHDehumidificationSetpoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/RHDehumidificationSetpoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_rh_dehumidification_setpoint_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DehumidificationControl/Attributes/RHDehumidificationSetpoint";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = dehumidification_control_relative_humidity_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE. Using number instead.");
  jsn["value"] = static_cast<DehumidificationControlRelativeHumidityMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/RelativeHumidityMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/RelativeHumidityMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DehumidificationControl/Attributes/RelativeHumidityMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_lockout_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT_ENUM_NAME_AVAILABLE
  jsn["value"] = dehumidification_control_dehumidification_lockout_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT. Using number instead.");
  jsn["value"] = static_cast<DehumidificationControlDehumidificationLockout>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/DehumidificationLockout", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/DehumidificationLockout";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_lockout_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DehumidificationControl/Attributes/DehumidificationLockout";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_hysteresis_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(515,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(515,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/DehumidificationHysteresis", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/DehumidificationHysteresis";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_hysteresis_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DehumidificationControl/Attributes/DehumidificationHysteresis";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_max_cool_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(515,20,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(515,20,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/DehumidificationMaxCool", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/DehumidificationMaxCool";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_dehumidification_max_cool_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DehumidificationControl/Attributes/DehumidificationMaxCool";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_display_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY_ENUM_NAME_AVAILABLE
  jsn["value"] = dehumidification_control_relative_humidity_display_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY. Using number instead.");
  jsn["value"] = static_cast<DehumidificationControlRelativeHumidityDisplay>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "DehumidificationControl/Attributes/RelativeHumidityDisplay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/DehumidificationControl/Attributes/RelativeHumidityDisplay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_dehumidification_control_relative_humidity_display_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/DehumidificationControl/Attributes/RelativeHumidityDisplay";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_dehumidification_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_dehumidification_control_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "DehumidificationControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_dehumidification_control_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "DehumidificationControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_dehumidification_control_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_dehumidification_control_attributes_init();

  uic_mqtt_dotdot_by_group_dehumidification_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback_t> uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback;
static std::set<uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback_t> uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_thermostat_user_interface_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_thermostat_user_interface_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_thermostat_user_interface_configuration_write_attributes_callbacks()
{
  uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback_t>& get_uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback()
{
  return uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback;
}

void uic_mqtt_dotdot_set_thermostat_user_interface_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_thermostat_user_interface_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_thermostat_user_interface_configuration_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/ThermostatUserInterfaceConfiguration/Commands/WriteAttributes
void uic_mqtt_dotdot_on_thermostat_user_interface_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_thermostat_user_interface_configuration_state_t new_state = {};
  uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_thermostat_user_interface_configuration_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ThermostatUserInterfaceConfiguration", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_thermostat_user_interface_configuration_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.temperature_display_mode = true;
      force_update.keypad_lockout = true;
      force_update.schedule_programming_visibility = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"TemperatureDisplayMode", &force_update.temperature_display_mode },
        {"KeypadLockout", &force_update.keypad_lockout },
        {"ScheduleProgrammingVisibility", &force_update.schedule_programming_visibility },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "ThermostatUserInterfaceConfiguration/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_temperature_display_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_user_interface_configuration_temperature_display_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE. Using number instead.");
  jsn["value"] = static_cast<ThermostatUserInterfaceConfigurationTemperatureDisplayMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration/Attributes/TemperatureDisplayMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ThermostatUserInterfaceConfiguration/Attributes/TemperatureDisplayMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_temperature_display_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ThermostatUserInterfaceConfiguration/Attributes/TemperatureDisplayMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_keypad_lockout_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_user_interface_configuration_keypad_lockout_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT. Using number instead.");
  jsn["value"] = static_cast<ThermostatUserInterfaceConfigurationKeypadLockout>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration/Attributes/KeypadLockout", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ThermostatUserInterfaceConfiguration/Attributes/KeypadLockout";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_keypad_lockout_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ThermostatUserInterfaceConfiguration/Attributes/KeypadLockout";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_schedule_programming_visibility_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY_ENUM_NAME_AVAILABLE
  jsn["value"] = thermostat_user_interface_configuration_schedule_programming_visibility_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY. Using number instead.");
  jsn["value"] = static_cast<ThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ThermostatUserInterfaceConfiguration/Attributes/ScheduleProgrammingVisibility", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ThermostatUserInterfaceConfiguration/Attributes/ScheduleProgrammingVisibility";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_schedule_programming_visibility_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ThermostatUserInterfaceConfiguration/Attributes/ScheduleProgrammingVisibility";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_thermostat_user_interface_configuration_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "ThermostatUserInterfaceConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_user_interface_configuration_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "ThermostatUserInterfaceConfiguration/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_thermostat_user_interface_configuration_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_thermostat_user_interface_configuration_attributes_init();

  uic_mqtt_dotdot_by_group_thermostat_user_interface_configuration_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_color_control_move_to_hue_callback_t> uic_mqtt_dotdot_color_control_move_to_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_move_to_hue_callback_t> uic_mqtt_dotdot_color_control_generated_move_to_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_move_hue_callback_t> uic_mqtt_dotdot_color_control_move_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_move_hue_callback_t> uic_mqtt_dotdot_color_control_generated_move_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_step_hue_callback_t> uic_mqtt_dotdot_color_control_step_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_step_hue_callback_t> uic_mqtt_dotdot_color_control_generated_step_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_move_to_saturation_callback_t> uic_mqtt_dotdot_color_control_move_to_saturation_callback;
static std::set<uic_mqtt_dotdot_color_control_move_to_saturation_callback_t> uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback;
static std::set<uic_mqtt_dotdot_color_control_move_saturation_callback_t> uic_mqtt_dotdot_color_control_move_saturation_callback;
static std::set<uic_mqtt_dotdot_color_control_move_saturation_callback_t> uic_mqtt_dotdot_color_control_generated_move_saturation_callback;
static std::set<uic_mqtt_dotdot_color_control_step_saturation_callback_t> uic_mqtt_dotdot_color_control_step_saturation_callback;
static std::set<uic_mqtt_dotdot_color_control_step_saturation_callback_t> uic_mqtt_dotdot_color_control_generated_step_saturation_callback;
static std::set<uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t> uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback;
static std::set<uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t> uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback;
static std::set<uic_mqtt_dotdot_color_control_move_to_color_callback_t> uic_mqtt_dotdot_color_control_move_to_color_callback;
static std::set<uic_mqtt_dotdot_color_control_move_to_color_callback_t> uic_mqtt_dotdot_color_control_generated_move_to_color_callback;
static std::set<uic_mqtt_dotdot_color_control_move_color_callback_t> uic_mqtt_dotdot_color_control_move_color_callback;
static std::set<uic_mqtt_dotdot_color_control_move_color_callback_t> uic_mqtt_dotdot_color_control_generated_move_color_callback;
static std::set<uic_mqtt_dotdot_color_control_step_color_callback_t> uic_mqtt_dotdot_color_control_step_color_callback;
static std::set<uic_mqtt_dotdot_color_control_step_color_callback_t> uic_mqtt_dotdot_color_control_generated_step_color_callback;
static std::set<uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t> uic_mqtt_dotdot_color_control_move_to_color_temperature_callback;
static std::set<uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t> uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback;
static std::set<uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t> uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t> uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t> uic_mqtt_dotdot_color_control_enhanced_move_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t> uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t> uic_mqtt_dotdot_color_control_enhanced_step_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t> uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback;
static std::set<uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t> uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback;
static std::set<uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t> uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback;
static std::set<uic_mqtt_dotdot_color_control_color_loop_set_callback_t> uic_mqtt_dotdot_color_control_color_loop_set_callback;
static std::set<uic_mqtt_dotdot_color_control_color_loop_set_callback_t> uic_mqtt_dotdot_color_control_generated_color_loop_set_callback;
static std::set<uic_mqtt_dotdot_color_control_stop_move_step_callback_t> uic_mqtt_dotdot_color_control_stop_move_step_callback;
static std::set<uic_mqtt_dotdot_color_control_stop_move_step_callback_t> uic_mqtt_dotdot_color_control_generated_stop_move_step_callback;
static std::set<uic_mqtt_dotdot_color_control_move_color_temperature_callback_t> uic_mqtt_dotdot_color_control_move_color_temperature_callback;
static std::set<uic_mqtt_dotdot_color_control_move_color_temperature_callback_t> uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback;
static std::set<uic_mqtt_dotdot_color_control_step_color_temperature_callback_t> uic_mqtt_dotdot_color_control_step_color_temperature_callback;
static std::set<uic_mqtt_dotdot_color_control_step_color_temperature_callback_t> uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback;
static std::set<uic_mqtt_dotdot_color_control_write_attributes_callback_t> uic_mqtt_dotdot_color_control_write_attributes_callback;
static std::set<uic_mqtt_dotdot_color_control_force_read_attributes_callback_t> uic_mqtt_dotdot_color_control_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_color_control_move_to_hue_callback_set(const uic_mqtt_dotdot_color_control_move_to_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_move_to_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_move_to_hue_callback_unset(const uic_mqtt_dotdot_color_control_move_to_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_to_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_move_to_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_move_to_hue_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_move_to_hue_callback_t>& get_uic_mqtt_dotdot_color_control_move_to_hue_callback()
{
  return uic_mqtt_dotdot_color_control_move_to_hue_callback;
}

void uic_mqtt_dotdot_color_control_generated_move_to_hue_callback_set(const uic_mqtt_dotdot_color_control_move_to_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_move_to_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_move_to_hue_callback_unset(const uic_mqtt_dotdot_color_control_move_to_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_to_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_move_to_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_move_to_hue_callback.clear();
}
void uic_mqtt_dotdot_color_control_move_hue_callback_set(const uic_mqtt_dotdot_color_control_move_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_move_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_move_hue_callback_unset(const uic_mqtt_dotdot_color_control_move_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_move_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_move_hue_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_move_hue_callback_t>& get_uic_mqtt_dotdot_color_control_move_hue_callback()
{
  return uic_mqtt_dotdot_color_control_move_hue_callback;
}

void uic_mqtt_dotdot_color_control_generated_move_hue_callback_set(const uic_mqtt_dotdot_color_control_move_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_move_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_move_hue_callback_unset(const uic_mqtt_dotdot_color_control_move_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_move_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_move_hue_callback.clear();
}
void uic_mqtt_dotdot_color_control_step_hue_callback_set(const uic_mqtt_dotdot_color_control_step_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_step_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_step_hue_callback_unset(const uic_mqtt_dotdot_color_control_step_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_step_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_step_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_step_hue_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_step_hue_callback_t>& get_uic_mqtt_dotdot_color_control_step_hue_callback()
{
  return uic_mqtt_dotdot_color_control_step_hue_callback;
}

void uic_mqtt_dotdot_color_control_generated_step_hue_callback_set(const uic_mqtt_dotdot_color_control_step_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_step_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_step_hue_callback_unset(const uic_mqtt_dotdot_color_control_step_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_step_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_step_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_step_hue_callback.clear();
}
void uic_mqtt_dotdot_color_control_move_to_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_to_saturation_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_move_to_saturation_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_move_to_saturation_callback_unset(const uic_mqtt_dotdot_color_control_move_to_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_to_saturation_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_move_to_saturation_callback_clear()
{
  uic_mqtt_dotdot_color_control_move_to_saturation_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_move_to_saturation_callback_t>& get_uic_mqtt_dotdot_color_control_move_to_saturation_callback()
{
  return uic_mqtt_dotdot_color_control_move_to_saturation_callback;
}

void uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_to_saturation_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback_unset(const uic_mqtt_dotdot_color_control_move_to_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback.clear();
}
void uic_mqtt_dotdot_color_control_move_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_saturation_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_move_saturation_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_move_saturation_callback_unset(const uic_mqtt_dotdot_color_control_move_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_saturation_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_move_saturation_callback_clear()
{
  uic_mqtt_dotdot_color_control_move_saturation_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_move_saturation_callback_t>& get_uic_mqtt_dotdot_color_control_move_saturation_callback()
{
  return uic_mqtt_dotdot_color_control_move_saturation_callback;
}

void uic_mqtt_dotdot_color_control_generated_move_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_saturation_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_move_saturation_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_move_saturation_callback_unset(const uic_mqtt_dotdot_color_control_move_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_saturation_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_move_saturation_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_move_saturation_callback.clear();
}
void uic_mqtt_dotdot_color_control_step_saturation_callback_set(const uic_mqtt_dotdot_color_control_step_saturation_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_step_saturation_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_step_saturation_callback_unset(const uic_mqtt_dotdot_color_control_step_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_step_saturation_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_step_saturation_callback_clear()
{
  uic_mqtt_dotdot_color_control_step_saturation_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_step_saturation_callback_t>& get_uic_mqtt_dotdot_color_control_step_saturation_callback()
{
  return uic_mqtt_dotdot_color_control_step_saturation_callback;
}

void uic_mqtt_dotdot_color_control_generated_step_saturation_callback_set(const uic_mqtt_dotdot_color_control_step_saturation_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_step_saturation_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_step_saturation_callback_unset(const uic_mqtt_dotdot_color_control_step_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_step_saturation_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_step_saturation_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_step_saturation_callback.clear();
}
void uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_unset(const uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_clear()
{
  uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t>& get_uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback()
{
  return uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback;
}

void uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback_unset(const uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback.clear();
}
void uic_mqtt_dotdot_color_control_move_to_color_callback_set(const uic_mqtt_dotdot_color_control_move_to_color_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_move_to_color_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_move_to_color_callback_unset(const uic_mqtt_dotdot_color_control_move_to_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_to_color_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_move_to_color_callback_clear()
{
  uic_mqtt_dotdot_color_control_move_to_color_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_move_to_color_callback_t>& get_uic_mqtt_dotdot_color_control_move_to_color_callback()
{
  return uic_mqtt_dotdot_color_control_move_to_color_callback;
}

void uic_mqtt_dotdot_color_control_generated_move_to_color_callback_set(const uic_mqtt_dotdot_color_control_move_to_color_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_move_to_color_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_move_to_color_callback_unset(const uic_mqtt_dotdot_color_control_move_to_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_to_color_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_move_to_color_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_move_to_color_callback.clear();
}
void uic_mqtt_dotdot_color_control_move_color_callback_set(const uic_mqtt_dotdot_color_control_move_color_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_move_color_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_move_color_callback_unset(const uic_mqtt_dotdot_color_control_move_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_color_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_move_color_callback_clear()
{
  uic_mqtt_dotdot_color_control_move_color_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_move_color_callback_t>& get_uic_mqtt_dotdot_color_control_move_color_callback()
{
  return uic_mqtt_dotdot_color_control_move_color_callback;
}

void uic_mqtt_dotdot_color_control_generated_move_color_callback_set(const uic_mqtt_dotdot_color_control_move_color_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_move_color_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_move_color_callback_unset(const uic_mqtt_dotdot_color_control_move_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_color_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_move_color_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_move_color_callback.clear();
}
void uic_mqtt_dotdot_color_control_step_color_callback_set(const uic_mqtt_dotdot_color_control_step_color_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_step_color_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_step_color_callback_unset(const uic_mqtt_dotdot_color_control_step_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_step_color_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_step_color_callback_clear()
{
  uic_mqtt_dotdot_color_control_step_color_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_step_color_callback_t>& get_uic_mqtt_dotdot_color_control_step_color_callback()
{
  return uic_mqtt_dotdot_color_control_step_color_callback;
}

void uic_mqtt_dotdot_color_control_generated_step_color_callback_set(const uic_mqtt_dotdot_color_control_step_color_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_step_color_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_step_color_callback_unset(const uic_mqtt_dotdot_color_control_step_color_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_step_color_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_step_color_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_step_color_callback.clear();
}
void uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_move_to_color_temperature_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_unset(const uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_to_color_temperature_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_clear()
{
  uic_mqtt_dotdot_color_control_move_to_color_temperature_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t>& get_uic_mqtt_dotdot_color_control_move_to_color_temperature_callback()
{
  return uic_mqtt_dotdot_color_control_move_to_color_temperature_callback;
}

void uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback_unset(const uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback.clear();
}
void uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_unset(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t>& get_uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback()
{
  return uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback;
}

void uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback_unset(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback.clear();
}
void uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_enhanced_move_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_unset(const uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_enhanced_move_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_enhanced_move_hue_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t>& get_uic_mqtt_dotdot_color_control_enhanced_move_hue_callback()
{
  return uic_mqtt_dotdot_color_control_enhanced_move_hue_callback;
}

void uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback_unset(const uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback.clear();
}
void uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_enhanced_step_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_unset(const uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_enhanced_step_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_enhanced_step_hue_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t>& get_uic_mqtt_dotdot_color_control_enhanced_step_hue_callback()
{
  return uic_mqtt_dotdot_color_control_enhanced_step_hue_callback;
}

void uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback_set(const uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback_unset(const uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback.clear();
}
void uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_unset(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_clear()
{
  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t>& get_uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback()
{
  return uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback;
}

void uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback_set(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback_unset(const uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback.clear();
}
void uic_mqtt_dotdot_color_control_color_loop_set_callback_set(const uic_mqtt_dotdot_color_control_color_loop_set_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_color_loop_set_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_color_loop_set_callback_unset(const uic_mqtt_dotdot_color_control_color_loop_set_callback_t callback)
{
  uic_mqtt_dotdot_color_control_color_loop_set_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_color_loop_set_callback_clear()
{
  uic_mqtt_dotdot_color_control_color_loop_set_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_color_loop_set_callback_t>& get_uic_mqtt_dotdot_color_control_color_loop_set_callback()
{
  return uic_mqtt_dotdot_color_control_color_loop_set_callback;
}

void uic_mqtt_dotdot_color_control_generated_color_loop_set_callback_set(const uic_mqtt_dotdot_color_control_color_loop_set_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_color_loop_set_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_color_loop_set_callback_unset(const uic_mqtt_dotdot_color_control_color_loop_set_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_color_loop_set_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_color_loop_set_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_color_loop_set_callback.clear();
}
void uic_mqtt_dotdot_color_control_stop_move_step_callback_set(const uic_mqtt_dotdot_color_control_stop_move_step_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_stop_move_step_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_stop_move_step_callback_unset(const uic_mqtt_dotdot_color_control_stop_move_step_callback_t callback)
{
  uic_mqtt_dotdot_color_control_stop_move_step_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_stop_move_step_callback_clear()
{
  uic_mqtt_dotdot_color_control_stop_move_step_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_stop_move_step_callback_t>& get_uic_mqtt_dotdot_color_control_stop_move_step_callback()
{
  return uic_mqtt_dotdot_color_control_stop_move_step_callback;
}

void uic_mqtt_dotdot_color_control_generated_stop_move_step_callback_set(const uic_mqtt_dotdot_color_control_stop_move_step_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_stop_move_step_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_stop_move_step_callback_unset(const uic_mqtt_dotdot_color_control_stop_move_step_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_stop_move_step_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_stop_move_step_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_stop_move_step_callback.clear();
}
void uic_mqtt_dotdot_color_control_move_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_move_color_temperature_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_move_color_temperature_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_move_color_temperature_callback_unset(const uic_mqtt_dotdot_color_control_move_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_move_color_temperature_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_move_color_temperature_callback_clear()
{
  uic_mqtt_dotdot_color_control_move_color_temperature_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_move_color_temperature_callback_t>& get_uic_mqtt_dotdot_color_control_move_color_temperature_callback()
{
  return uic_mqtt_dotdot_color_control_move_color_temperature_callback;
}

void uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_move_color_temperature_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback_unset(const uic_mqtt_dotdot_color_control_move_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback.clear();
}
void uic_mqtt_dotdot_color_control_step_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_step_color_temperature_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_step_color_temperature_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_step_color_temperature_callback_unset(const uic_mqtt_dotdot_color_control_step_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_step_color_temperature_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_step_color_temperature_callback_clear()
{
  uic_mqtt_dotdot_color_control_step_color_temperature_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_step_color_temperature_callback_t>& get_uic_mqtt_dotdot_color_control_step_color_temperature_callback()
{
  return uic_mqtt_dotdot_color_control_step_color_temperature_callback;
}

void uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback_set(const uic_mqtt_dotdot_color_control_step_color_temperature_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback_unset(const uic_mqtt_dotdot_color_control_step_color_temperature_callback_t callback)
{
  uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback.erase(callback);
}
void uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback_clear()
{
  uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback.clear();
}

void uic_mqtt_dotdot_set_color_control_write_attributes_callback(
  const uic_mqtt_dotdot_color_control_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_color_control_write_attributes_callback(
  const uic_mqtt_dotdot_color_control_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_color_control_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_color_control_write_attributes_callbacks()
{
  uic_mqtt_dotdot_color_control_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_color_control_write_attributes_callback_t>& get_uic_mqtt_dotdot_color_control_write_attributes_callback()
{
  return uic_mqtt_dotdot_color_control_write_attributes_callback;
}

void uic_mqtt_dotdot_set_color_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_color_control_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_color_control_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_color_control_force_read_attributes_callback(
  const uic_mqtt_dotdot_color_control_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_color_control_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_color_control_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_color_control_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveToHue
void uic_mqtt_dotdot_on_color_control_move_to_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_to_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t hue = {};
  CCDirection direction = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_hue(
      jsn,
      hue,

      direction,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHue", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_move_to_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      hue,
  
      direction,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveToHue
static void uic_mqtt_dotdot_on_generated_color_control_move_to_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_to_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t hue = {};
  CCDirection direction = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_hue(
      jsn,
      hue,

      direction,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHue", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_move_to_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      hue,
  
      direction,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveHue
void uic_mqtt_dotdot_on_color_control_move_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_hue(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveHue", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_move_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveHue
static void uic_mqtt_dotdot_on_generated_color_control_move_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_hue(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveHue", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_move_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/StepHue
void uic_mqtt_dotdot_on_color_control_step_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_step_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint8_t step_size = {};
  uint8_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_hue(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepHue", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_step_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/StepHue
static void uic_mqtt_dotdot_on_generated_color_control_step_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_step_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint8_t step_size = {};
  uint8_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_hue(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepHue", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_step_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveToSaturation
void uic_mqtt_dotdot_on_color_control_move_to_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_to_saturation_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t saturation = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_saturation(
      jsn,
      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToSaturation", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_move_to_saturation_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      saturation,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveToSaturation
static void uic_mqtt_dotdot_on_generated_color_control_move_to_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t saturation = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_saturation(
      jsn,
      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToSaturation", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      saturation,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveSaturation
void uic_mqtt_dotdot_on_color_control_move_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_saturation_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_saturation(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveSaturation", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_move_saturation_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveSaturation
static void uic_mqtt_dotdot_on_generated_color_control_move_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_saturation_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint8_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_saturation(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveSaturation", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_move_saturation_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/StepSaturation
void uic_mqtt_dotdot_on_color_control_step_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_step_saturation_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint8_t step_size = {};
  uint8_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_saturation(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepSaturation", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_step_saturation_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/StepSaturation
static void uic_mqtt_dotdot_on_generated_color_control_step_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_step_saturation_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint8_t step_size = {};
  uint8_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_saturation(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepSaturation", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_step_saturation_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveToHueAndSaturation
void uic_mqtt_dotdot_on_color_control_move_to_hue_and_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t hue = {};
  uint8_t saturation = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_hue_and_saturation(
      jsn,
      hue,

      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToHueAndSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHueAndSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHueAndSaturation", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      hue,
  
      saturation,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveToHueAndSaturation
static void uic_mqtt_dotdot_on_generated_color_control_move_to_hue_and_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t hue = {};
  uint8_t saturation = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_hue_and_saturation(
      jsn,
      hue,

      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToHueAndSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHueAndSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToHueAndSaturation", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      hue,
  
      saturation,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveToColor
void uic_mqtt_dotdot_on_color_control_move_to_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_to_color_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t colorx = {};
  uint16_t colory = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_color(
      jsn,
      colorx,

      colory,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColor", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_move_to_color_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      colorx,
  
      colory,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveToColor
static void uic_mqtt_dotdot_on_generated_color_control_move_to_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_to_color_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t colorx = {};
  uint16_t colory = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_color(
      jsn,
      colorx,

      colory,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColor", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_move_to_color_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      colorx,
  
      colory,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveColor
void uic_mqtt_dotdot_on_color_control_move_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_color_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  int16_t ratex = {};
  int16_t ratey = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_color(
      jsn,
      ratex,

      ratey,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColor", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_move_color_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      ratex,
  
      ratey,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveColor
static void uic_mqtt_dotdot_on_generated_color_control_move_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_color_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  int16_t ratex = {};
  int16_t ratey = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_color(
      jsn,
      ratex,

      ratey,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColor", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_move_color_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      ratex,
  
      ratey,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/StepColor
void uic_mqtt_dotdot_on_color_control_step_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_step_color_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  int16_t stepx = {};
  int16_t stepy = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_color(
      jsn,
      stepx,

      stepy,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColor", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_step_color_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      stepx,
  
      stepy,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/StepColor
static void uic_mqtt_dotdot_on_generated_color_control_step_color(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_step_color_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  int16_t stepx = {};
  int16_t stepy = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_color(
      jsn,
      stepx,

      stepy,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepColor");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColor", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColor", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_step_color_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      stepx,
  
      stepy,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveToColorTemperature
void uic_mqtt_dotdot_on_color_control_move_to_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_to_color_temperature_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t color_temperature_mireds = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_color_temperature(
      jsn,
      color_temperature_mireds,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColorTemperature", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_move_to_color_temperature_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      color_temperature_mireds,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveToColorTemperature
static void uic_mqtt_dotdot_on_generated_color_control_move_to_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t color_temperature_mireds = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_to_color_temperature(
      jsn,
      color_temperature_mireds,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveToColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveToColorTemperature", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      color_temperature_mireds,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/EnhancedMoveToHue
void uic_mqtt_dotdot_on_color_control_enhanced_move_to_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t enhanced_hue = {};
  CCDirection direction = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue(
      jsn,
      enhanced_hue,

      direction,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveToHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHue", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      enhanced_hue,
  
      direction,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/EnhancedMoveToHue
static void uic_mqtt_dotdot_on_generated_color_control_enhanced_move_to_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t enhanced_hue = {};
  CCDirection direction = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue(
      jsn,
      enhanced_hue,

      direction,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveToHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHue", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      enhanced_hue,
  
      direction,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/EnhancedMoveHue
void uic_mqtt_dotdot_on_color_control_enhanced_move_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_enhanced_move_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint16_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_hue(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveHue", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_enhanced_move_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/EnhancedMoveHue
static void uic_mqtt_dotdot_on_generated_color_control_enhanced_move_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint16_t rate = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_hue(
      jsn,
      move_mode,

      rate,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveHue", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/EnhancedStepHue
void uic_mqtt_dotdot_on_color_control_enhanced_step_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_enhanced_step_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint16_t step_size = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_step_hue(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedStepHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedStepHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedStepHue", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_enhanced_step_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/EnhancedStepHue
static void uic_mqtt_dotdot_on_generated_color_control_enhanced_step_hue(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint16_t step_size = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_step_hue(
      jsn,
      step_mode,

      step_size,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedStepHue");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedStepHue", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedStepHue", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/EnhancedMoveToHueAndSaturation
void uic_mqtt_dotdot_on_color_control_enhanced_move_to_hue_and_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t enhanced_hue = {};
  uint8_t saturation = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue_and_saturation(
      jsn,
      enhanced_hue,

      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveToHueAndSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHueAndSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHueAndSaturation", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      enhanced_hue,
  
      saturation,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/EnhancedMoveToHueAndSaturation
static void uic_mqtt_dotdot_on_generated_color_control_enhanced_move_to_hue_and_saturation(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t enhanced_hue = {};
  uint8_t saturation = {};
  uint16_t transition_time = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_enhanced_move_to_hue_and_saturation(
      jsn,
      enhanced_hue,

      saturation,

      transition_time,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "EnhancedMoveToHueAndSaturation");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHueAndSaturation", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "EnhancedMoveToHueAndSaturation", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      enhanced_hue,
  
      saturation,
  
      transition_time,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/ColorLoopSet
void uic_mqtt_dotdot_on_color_control_color_loop_set(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_color_loop_set_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t update_flags = {};
  ColorLoopSetAction action = {};
  CCColorLoopDirection direction = {};
  uint16_t time = {};
  uint16_t start_hue = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_color_loop_set(
      jsn,
      update_flags,

      action,

      direction,

      time,

      start_hue,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "ColorLoopSet");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "ColorLoopSet", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "ColorLoopSet", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_color_loop_set_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      update_flags,
  
      action,
  
      direction,
  
      time,
  
      start_hue,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/ColorLoopSet
static void uic_mqtt_dotdot_on_generated_color_control_color_loop_set(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_color_loop_set_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t update_flags = {};
  ColorLoopSetAction action = {};
  CCColorLoopDirection direction = {};
  uint16_t time = {};
  uint16_t start_hue = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_color_loop_set(
      jsn,
      update_flags,

      action,

      direction,

      time,

      start_hue,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "ColorLoopSet");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "ColorLoopSet", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "ColorLoopSet", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_color_loop_set_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      update_flags,
  
      action,
  
      direction,
  
      time,
  
      start_hue,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/StopMoveStep
void uic_mqtt_dotdot_on_color_control_stop_move_step(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_stop_move_step_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_stop_move_step(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StopMoveStep");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StopMoveStep", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StopMoveStep", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_stop_move_step_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/StopMoveStep
static void uic_mqtt_dotdot_on_generated_color_control_stop_move_step(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_stop_move_step_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_stop_move_step(
      jsn,
      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StopMoveStep");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StopMoveStep", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StopMoveStep", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_stop_move_step_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/MoveColorTemperature
void uic_mqtt_dotdot_on_color_control_move_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_move_color_temperature_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint16_t rate = {};
  CCMinMiredsField color_temperature_minimum_mireds = {};
  CCMaxMiredsField color_temperature_maximum_mireds = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_color_temperature(
      jsn,
      move_mode,

      rate,

      color_temperature_minimum_mireds,

      color_temperature_maximum_mireds,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColorTemperature", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_move_color_temperature_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      color_temperature_minimum_mireds,
  
      color_temperature_maximum_mireds,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/MoveColorTemperature
static void uic_mqtt_dotdot_on_generated_color_control_move_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCMoveMode move_mode = {};
  uint16_t rate = {};
  CCMinMiredsField color_temperature_minimum_mireds = {};
  CCMaxMiredsField color_temperature_maximum_mireds = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_move_color_temperature(
      jsn,
      move_mode,

      rate,

      color_temperature_minimum_mireds,

      color_temperature_maximum_mireds,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "MoveColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "MoveColorTemperature", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      move_mode,
  
      rate,
  
      color_temperature_minimum_mireds,
  
      color_temperature_maximum_mireds,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/StepColorTemperature
void uic_mqtt_dotdot_on_color_control_step_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_step_color_temperature_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint16_t step_size = {};
  uint16_t transition_time = {};
  CCMinMiredsField color_temperature_minimum_mireds = {};
  CCMaxMiredsField color_temperature_maximum_mireds = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_color_temperature(
      jsn,
      step_mode,

      step_size,

      transition_time,

      color_temperature_minimum_mireds,

      color_temperature_maximum_mireds,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColorTemperature", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_color_control_step_color_temperature_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      color_temperature_minimum_mireds,
  
      color_temperature_maximum_mireds,
  
      options_mask,
  
      options_override
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/GeneratedCommands/StepColorTemperature
static void uic_mqtt_dotdot_on_generated_color_control_step_color_temperature(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  CCStepMode step_mode = {};
  uint16_t step_size = {};
  uint16_t transition_time = {};
  CCMinMiredsField color_temperature_minimum_mireds = {};
  CCMaxMiredsField color_temperature_maximum_mireds = {};
  uint8_t options_mask = {};
  uint8_t options_override = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_color_control_step_color_temperature(
      jsn,
      step_mode,

      step_size,

      transition_time,

      color_temperature_minimum_mireds,

      color_temperature_maximum_mireds,

      options_mask,

      options_override
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "StepColorTemperature");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColorTemperature", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "StepColorTemperature", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      step_mode,
  
      step_size,
  
      transition_time,
  
      color_temperature_minimum_mireds,
  
      color_temperature_maximum_mireds,
  
      options_mask,
  
      options_override
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ColorControl/Commands/WriteAttributes
void uic_mqtt_dotdot_on_color_control_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_color_control_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_color_control_state_t new_state = {};
  uic_mqtt_dotdot_color_control_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_color_control_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ColorControl", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_color_control_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_color_control_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_color_control_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_color_control_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.current_hue = true;
      force_update.current_saturation = true;
      force_update.remaining_time = true;
      force_update.currentx = true;
      force_update.currenty = true;
      force_update.drift_compensation = true;
      force_update.compensation_text = true;
      force_update.color_temperature_mireds = true;
      force_update.color_mode = true;
      force_update.options = true;
      force_update.number_of_primaries = true;
      force_update.primary1x = true;
      force_update.primary1y = true;
      force_update.primary1_intensity = true;
      force_update.primary2x = true;
      force_update.primary2y = true;
      force_update.primary2_intensity = true;
      force_update.primary3x = true;
      force_update.primary3y = true;
      force_update.primary3_intensity = true;
      force_update.primary4x = true;
      force_update.primary4y = true;
      force_update.primary4_intensity = true;
      force_update.primary5x = true;
      force_update.primary5y = true;
      force_update.primary5_intensity = true;
      force_update.primary6x = true;
      force_update.primary6y = true;
      force_update.primary6_intensity = true;
      force_update.white_pointx = true;
      force_update.white_pointy = true;
      force_update.color_pointrx = true;
      force_update.color_pointry = true;
      force_update.color_pointr_intensity = true;
      force_update.color_pointgx = true;
      force_update.color_pointgy = true;
      force_update.color_pointg_intensity = true;
      force_update.color_pointbx = true;
      force_update.color_pointby = true;
      force_update.color_pointb_intensity = true;
      force_update.enhanced_current_hue = true;
      force_update.enhanced_color_mode = true;
      force_update.color_loop_active = true;
      force_update.color_loop_direction = true;
      force_update.color_loop_time = true;
      force_update.color_loop_start_enhanced_hue = true;
      force_update.color_loop_stored_enhanced_hue = true;
      force_update.color_capabilities = true;
      force_update.color_temp_physical_min_mireds = true;
      force_update.color_temp_physical_max_mireds = true;
      force_update.couple_color_temp_to_level_min_mireds = true;
      force_update.start_up_color_temperature_mireds = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"CurrentHue", &force_update.current_hue },
        {"CurrentSaturation", &force_update.current_saturation },
        {"RemainingTime", &force_update.remaining_time },
        {"CurrentX", &force_update.currentx },
        {"CurrentY", &force_update.currenty },
        {"DriftCompensation", &force_update.drift_compensation },
        {"CompensationText", &force_update.compensation_text },
        {"ColorTemperatureMireds", &force_update.color_temperature_mireds },
        {"ColorMode", &force_update.color_mode },
        {"Options", &force_update.options },
        {"NumberOfPrimaries", &force_update.number_of_primaries },
        {"Primary1X", &force_update.primary1x },
        {"Primary1Y", &force_update.primary1y },
        {"Primary1Intensity", &force_update.primary1_intensity },
        {"Primary2X", &force_update.primary2x },
        {"Primary2Y", &force_update.primary2y },
        {"Primary2Intensity", &force_update.primary2_intensity },
        {"Primary3X", &force_update.primary3x },
        {"Primary3Y", &force_update.primary3y },
        {"Primary3Intensity", &force_update.primary3_intensity },
        {"Primary4X", &force_update.primary4x },
        {"Primary4Y", &force_update.primary4y },
        {"Primary4Intensity", &force_update.primary4_intensity },
        {"Primary5X", &force_update.primary5x },
        {"Primary5Y", &force_update.primary5y },
        {"Primary5Intensity", &force_update.primary5_intensity },
        {"Primary6X", &force_update.primary6x },
        {"Primary6Y", &force_update.primary6y },
        {"Primary6Intensity", &force_update.primary6_intensity },
        {"WhitePointX", &force_update.white_pointx },
        {"WhitePointY", &force_update.white_pointy },
        {"ColorPointRX", &force_update.color_pointrx },
        {"ColorPointRY", &force_update.color_pointry },
        {"ColorPointRIntensity", &force_update.color_pointr_intensity },
        {"ColorPointGX", &force_update.color_pointgx },
        {"ColorPointGY", &force_update.color_pointgy },
        {"ColorPointGIntensity", &force_update.color_pointg_intensity },
        {"ColorPointBX", &force_update.color_pointbx },
        {"ColorPointBY", &force_update.color_pointby },
        {"ColorPointBIntensity", &force_update.color_pointb_intensity },
        {"EnhancedCurrentHue", &force_update.enhanced_current_hue },
        {"EnhancedColorMode", &force_update.enhanced_color_mode },
        {"ColorLoopActive", &force_update.color_loop_active },
        {"ColorLoopDirection", &force_update.color_loop_direction },
        {"ColorLoopTime", &force_update.color_loop_time },
        {"ColorLoopStartEnhancedHue", &force_update.color_loop_start_enhanced_hue },
        {"ColorLoopStoredEnhancedHue", &force_update.color_loop_stored_enhanced_hue },
        {"ColorCapabilities", &force_update.color_capabilities },
        {"ColorTempPhysicalMinMireds", &force_update.color_temp_physical_min_mireds },
        {"ColorTempPhysicalMaxMireds", &force_update.color_temp_physical_max_mireds },
        {"CoupleColorTempToLevelMinMireds", &force_update.couple_color_temp_to_level_min_mireds },
        {"StartUpColorTemperatureMireds", &force_update.start_up_color_temperature_mireds },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_color_control_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "ColorControl/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_color_control_current_hue_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CurrentHue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CurrentHue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_current_hue_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/CurrentHue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_current_saturation_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CurrentSaturation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CurrentSaturation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_current_saturation_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/CurrentSaturation";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_remaining_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/RemainingTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/RemainingTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_remaining_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/RemainingTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_currentx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CurrentX", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CurrentX";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_currentx_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/CurrentX";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_currenty_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,4,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,4,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CurrentY", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CurrentY";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_currenty_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/CurrentY";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_drift_compensation_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef COLOR_CONTROL_DRIFT_COMPENSATION_ENUM_NAME_AVAILABLE
  jsn["value"] = color_control_drift_compensation_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for COLOR_CONTROL_DRIFT_COMPENSATION. Using number instead.");
  jsn["value"] = static_cast<ColorControlDriftCompensation>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/DriftCompensation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/DriftCompensation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_drift_compensation_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/DriftCompensation";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_compensation_text_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CompensationText", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CompensationText";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_compensation_text_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/CompensationText";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_temperature_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,7,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,7,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorTemperatureMireds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorTemperatureMireds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_temperature_mireds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorTemperatureMireds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef COLOR_CONTROL_COLOR_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = color_control_color_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for COLOR_CONTROL_COLOR_MODE. Using number instead.");
  jsn["value"] = static_cast<ColorControlColorMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_options_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = CCColorOptions.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Options", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Options";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_options_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Options";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_number_of_primaries_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/NumberOfPrimaries", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/NumberOfPrimaries";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_number_of_primaries_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/NumberOfPrimaries";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary1x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary1X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary1X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary1x_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary1X";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary1y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary1Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary1Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary1y_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary1Y";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary1_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary1Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary1Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary1_intensity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary1Intensity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary2x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,21,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,21,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary2X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary2X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary2x_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary2X";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary2y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,22,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,22,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary2Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary2Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary2y_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary2Y";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary2_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,23,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,23,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary2Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary2Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary2_intensity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary2Intensity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary3x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,25,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,25,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary3X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary3X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary3x_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary3X";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary3y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,26,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,26,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary3Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary3Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary3y_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary3Y";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary3_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,27,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,27,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary3Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary3Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary3_intensity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary3Intensity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary4x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,32,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,32,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary4X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary4X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary4x_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary4X";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary4y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,33,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,33,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary4Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary4Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary4y_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary4Y";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary4_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,34,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,34,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary4Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary4Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary4_intensity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary4Intensity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary5x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,36,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,36,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary5X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary5X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary5x_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary5X";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary5y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,37,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,37,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary5Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary5Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary5y_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary5Y";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary5_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,38,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,38,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary5Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary5Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary5_intensity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary5Intensity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary6x_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,40,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,40,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary6X", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary6X";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary6x_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary6X";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary6y_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,41,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,41,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary6Y", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary6Y";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary6y_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary6Y";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_primary6_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,42,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,42,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/Primary6Intensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/Primary6Intensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_primary6_intensity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/Primary6Intensity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_white_pointx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,48,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,48,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/WhitePointX", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/WhitePointX";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_white_pointx_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/WhitePointX";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_white_pointy_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,49,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,49,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/WhitePointY", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/WhitePointY";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_white_pointy_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/WhitePointY";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_pointrx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,50,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,50,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointRX", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointRX";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_pointrx_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorPointRX";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_pointry_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,51,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,51,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointRY", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointRY";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_pointry_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorPointRY";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_pointr_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,52,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,52,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointRIntensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointRIntensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_pointr_intensity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorPointRIntensity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_pointgx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,54,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,54,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointGX", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointGX";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_pointgx_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorPointGX";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_pointgy_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,55,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,55,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointGY", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointGY";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_pointgy_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorPointGY";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_pointg_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,56,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,56,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointGIntensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointGIntensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_pointg_intensity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorPointGIntensity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_pointbx_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,58,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,58,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointBX", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointBX";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_pointbx_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorPointBX";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_pointby_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,59,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,59,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointBY", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointBY";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_pointby_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorPointBY";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_pointb_intensity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,60,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,60,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorPointBIntensity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorPointBIntensity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_pointb_intensity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorPointBIntensity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_enhanced_current_hue_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,16384,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,16384,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/EnhancedCurrentHue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/EnhancedCurrentHue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_enhanced_current_hue_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/EnhancedCurrentHue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_enhanced_color_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef COLOR_CONTROL_ENHANCED_COLOR_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = color_control_enhanced_color_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for COLOR_CONTROL_ENHANCED_COLOR_MODE. Using number instead.");
  jsn["value"] = static_cast<ColorControlEnhancedColorMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/EnhancedColorMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/EnhancedColorMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_enhanced_color_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/EnhancedColorMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_loop_active_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,16386,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,16386,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorLoopActive", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorLoopActive";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_loop_active_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorLoopActive";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_loop_direction_publish(
  const char *base_topic,
  CCColorLoopDirection value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef COLOR_CONTROL_COLOR_LOOP_DIRECTION_ENUM_NAME_AVAILABLE
  jsn["value"] = color_control_color_loop_direction_get_enum_value_name((uint32_t)value);
  #elif defined(CC_COLOR_LOOP_DIRECTION_ENUM_NAME_AVAILABLE)
  jsn["value"] = cc_color_loop_direction_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for COLOR_CONTROL_COLOR_LOOP_DIRECTION. Using number instead.");
  jsn["value"] = static_cast<CCColorLoopDirection>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorLoopDirection", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorLoopDirection";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_loop_direction_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorLoopDirection";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_loop_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,16388,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,16388,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorLoopTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorLoopTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_loop_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorLoopTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,16389,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,16389,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorLoopStartEnhancedHue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorLoopStartEnhancedHue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorLoopStartEnhancedHue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,16390,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,16390,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorLoopStoredEnhancedHue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorLoopStoredEnhancedHue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorLoopStoredEnhancedHue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_capabilities_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ColorControlColorCapabilities.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorCapabilities", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorCapabilities";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_capabilities_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorCapabilities";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,16395,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,16395,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorTempPhysicalMinMireds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorTempPhysicalMinMireds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorTempPhysicalMinMireds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,16396,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,16396,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/ColorTempPhysicalMaxMireds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/ColorTempPhysicalMaxMireds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ColorTempPhysicalMaxMireds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,16397,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,16397,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/CoupleColorTempToLevelMinMireds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/CoupleColorTempToLevelMinMireds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/CoupleColorTempToLevelMinMireds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(768,16400,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(768,16400,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ColorControl/Attributes/StartUpColorTemperatureMireds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ColorControl/Attributes/StartUpColorTemperatureMireds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/StartUpColorTemperatureMireds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_color_control_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_color_control_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_color_control_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_color_control_move_to_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveToHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_to_hue);
  }
  if (!uic_mqtt_dotdot_color_control_generated_move_to_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveToHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_to_hue);
  }
  if (!uic_mqtt_dotdot_color_control_move_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_hue);
  }
  if (!uic_mqtt_dotdot_color_control_generated_move_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_hue);
  }
  if (!uic_mqtt_dotdot_color_control_step_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/StepHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_step_hue);
  }
  if (!uic_mqtt_dotdot_color_control_generated_step_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/StepHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_step_hue);
  }
  if (!uic_mqtt_dotdot_color_control_move_to_saturation_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveToSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_to_saturation);
  }
  if (!uic_mqtt_dotdot_color_control_generated_move_to_saturation_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveToSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_to_saturation);
  }
  if (!uic_mqtt_dotdot_color_control_move_saturation_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_saturation);
  }
  if (!uic_mqtt_dotdot_color_control_generated_move_saturation_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_saturation);
  }
  if (!uic_mqtt_dotdot_color_control_step_saturation_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/StepSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_step_saturation);
  }
  if (!uic_mqtt_dotdot_color_control_generated_step_saturation_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/StepSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_step_saturation);
  }
  if (!uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveToHueAndSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_to_hue_and_saturation);
  }
  if (!uic_mqtt_dotdot_color_control_generated_move_to_hue_and_saturation_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveToHueAndSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_to_hue_and_saturation);
  }
  if (!uic_mqtt_dotdot_color_control_move_to_color_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveToColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_to_color);
  }
  if (!uic_mqtt_dotdot_color_control_generated_move_to_color_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveToColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_to_color);
  }
  if (!uic_mqtt_dotdot_color_control_move_color_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_color);
  }
  if (!uic_mqtt_dotdot_color_control_generated_move_color_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_color);
  }
  if (!uic_mqtt_dotdot_color_control_step_color_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/StepColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_step_color);
  }
  if (!uic_mqtt_dotdot_color_control_generated_step_color_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/StepColor";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_step_color);
  }
  if (!uic_mqtt_dotdot_color_control_move_to_color_temperature_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveToColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_to_color_temperature);
  }
  if (!uic_mqtt_dotdot_color_control_generated_move_to_color_temperature_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveToColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_to_color_temperature);
  }
  if (!uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/EnhancedMoveToHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_enhanced_move_to_hue);
  }
  if (!uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/EnhancedMoveToHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_enhanced_move_to_hue);
  }
  if (!uic_mqtt_dotdot_color_control_enhanced_move_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/EnhancedMoveHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_enhanced_move_hue);
  }
  if (!uic_mqtt_dotdot_color_control_generated_enhanced_move_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/EnhancedMoveHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_enhanced_move_hue);
  }
  if (!uic_mqtt_dotdot_color_control_enhanced_step_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/EnhancedStepHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_enhanced_step_hue);
  }
  if (!uic_mqtt_dotdot_color_control_generated_enhanced_step_hue_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/EnhancedStepHue";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_enhanced_step_hue);
  }
  if (!uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/EnhancedMoveToHueAndSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_enhanced_move_to_hue_and_saturation);
  }
  if (!uic_mqtt_dotdot_color_control_generated_enhanced_move_to_hue_and_saturation_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/EnhancedMoveToHueAndSaturation";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_enhanced_move_to_hue_and_saturation);
  }
  if (!uic_mqtt_dotdot_color_control_color_loop_set_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/ColorLoopSet";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_color_loop_set);
  }
  if (!uic_mqtt_dotdot_color_control_generated_color_loop_set_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/ColorLoopSet";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_color_loop_set);
  }
  if (!uic_mqtt_dotdot_color_control_stop_move_step_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/StopMoveStep";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_stop_move_step);
  }
  if (!uic_mqtt_dotdot_color_control_generated_stop_move_step_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/StopMoveStep";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_stop_move_step);
  }
  if (!uic_mqtt_dotdot_color_control_move_color_temperature_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/MoveColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_move_color_temperature);
  }
  if (!uic_mqtt_dotdot_color_control_generated_move_color_temperature_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/MoveColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_move_color_temperature);
  }
  if (!uic_mqtt_dotdot_color_control_step_color_temperature_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/Commands/StepColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_color_control_step_color_temperature);
  }
  if (!uic_mqtt_dotdot_color_control_generated_step_color_temperature_callback.empty()) {
    subscription_topic = base_topic + "ColorControl/GeneratedCommands/StepColorTemperature";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_color_control_step_color_temperature);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_color_control_attributes_init();

  uic_mqtt_dotdot_by_group_color_control_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_ballast_configuration_write_attributes_callback_t> uic_mqtt_dotdot_ballast_configuration_write_attributes_callback;
static std::set<uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback_t> uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_ballast_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_ballast_configuration_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ballast_configuration_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_ballast_configuration_write_attributes_callback(
  const uic_mqtt_dotdot_ballast_configuration_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_ballast_configuration_write_attributes_callbacks()
{
  uic_mqtt_dotdot_ballast_configuration_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_ballast_configuration_write_attributes_callback_t>& get_uic_mqtt_dotdot_ballast_configuration_write_attributes_callback()
{
  return uic_mqtt_dotdot_ballast_configuration_write_attributes_callback;
}

void uic_mqtt_dotdot_set_ballast_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_ballast_configuration_force_read_attributes_callback(
  const uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_ballast_configuration_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/BallastConfiguration/Commands/WriteAttributes
void uic_mqtt_dotdot_on_ballast_configuration_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_ballast_configuration_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_ballast_configuration_state_t new_state = {};
  uic_mqtt_dotdot_ballast_configuration_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_ballast_configuration_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "BallastConfiguration", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_ballast_configuration_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_ballast_configuration_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_ballast_configuration_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.physical_min_level = true;
      force_update.physical_max_level = true;
      force_update.ballast_status = true;
      force_update.min_level = true;
      force_update.max_level = true;
      force_update.power_on_level = true;
      force_update.power_on_fade_time = true;
      force_update.intrinsic_ballast_factor = true;
      force_update.ballast_factor_adjustment = true;
      force_update.lamp_quantity = true;
      force_update.lamp_type = true;
      force_update.lamp_manufacturer = true;
      force_update.lamp_rated_hours = true;
      force_update.lamp_burn_hours = true;
      force_update.lamp_alarm_mode = true;
      force_update.lamp_burn_hours_trip_point = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"PhysicalMinLevel", &force_update.physical_min_level },
        {"PhysicalMaxLevel", &force_update.physical_max_level },
        {"BallastStatus", &force_update.ballast_status },
        {"MinLevel", &force_update.min_level },
        {"MaxLevel", &force_update.max_level },
        {"PowerOnLevel", &force_update.power_on_level },
        {"PowerOnFadeTime", &force_update.power_on_fade_time },
        {"IntrinsicBallastFactor", &force_update.intrinsic_ballast_factor },
        {"BallastFactorAdjustment", &force_update.ballast_factor_adjustment },
        {"LampQuantity", &force_update.lamp_quantity },
        {"LampType", &force_update.lamp_type },
        {"LampManufacturer", &force_update.lamp_manufacturer },
        {"LampRatedHours", &force_update.lamp_rated_hours },
        {"LampBurnHours", &force_update.lamp_burn_hours },
        {"LampAlarmMode", &force_update.lamp_alarm_mode },
        {"LampBurnHoursTripPoint", &force_update.lamp_burn_hours_trip_point },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "BallastConfiguration/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_physical_min_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/PhysicalMinLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/PhysicalMinLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_physical_min_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/PhysicalMinLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_physical_max_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/PhysicalMaxLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/PhysicalMaxLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_physical_max_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/PhysicalMaxLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_ballast_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BallastConfigurationBallastStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/BallastStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/BallastStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_ballast_status_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/BallastStatus";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_min_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/MinLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/MinLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_min_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/MinLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_max_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/MaxLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/MaxLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_max_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/MaxLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_power_on_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/PowerOnLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/PowerOnLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_power_on_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/PowerOnLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_power_on_fade_time_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/PowerOnFadeTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/PowerOnFadeTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_power_on_fade_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/PowerOnFadeTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_intrinsic_ballast_factor_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,20,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,20,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/IntrinsicBallastFactor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/IntrinsicBallastFactor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_intrinsic_ballast_factor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/IntrinsicBallastFactor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_ballast_factor_adjustment_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,21,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,21,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/BallastFactorAdjustment", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/BallastFactorAdjustment";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_ballast_factor_adjustment_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/BallastFactorAdjustment";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_quantity_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,32,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,32,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampQuantity", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampQuantity";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_quantity_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/LampQuantity";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_type_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/LampType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_manufacturer_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampManufacturer", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampManufacturer";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_manufacturer_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/LampManufacturer";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_rated_hours_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,50,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,50,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampRatedHours", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampRatedHours";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_rated_hours_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/LampRatedHours";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,51,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,51,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampBurnHours", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampBurnHours";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/LampBurnHours";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_alarm_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = BallastConfigurationLampAlarmMode.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampAlarmMode", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampAlarmMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_alarm_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/LampAlarmMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_trip_point_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(769,53,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(769,53,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "BallastConfiguration/Attributes/LampBurnHoursTripPoint", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/BallastConfiguration/Attributes/LampBurnHoursTripPoint";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ballast_configuration_lamp_burn_hours_trip_point_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/LampBurnHoursTripPoint";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_ballast_configuration_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_ballast_configuration_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "BallastConfiguration/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ballast_configuration_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "BallastConfiguration/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ballast_configuration_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_ballast_configuration_attributes_init();

  uic_mqtt_dotdot_by_group_ballast_configuration_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback_t> uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback;
static std::set<uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback_t> uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_illuminance_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_illuminance_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_illuminance_measurement_write_attributes_callbacks()
{
  uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback_t>& get_uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback()
{
  return uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback;
}

void uic_mqtt_dotdot_set_illuminance_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_illuminance_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_illuminance_measurement_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/IlluminanceMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_illuminance_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_illuminance_measurement_state_t new_state = {};
  uic_mqtt_dotdot_illuminance_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_illuminance_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IlluminanceMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_illuminance_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_illuminance_measurement_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      force_update.light_sensor_type = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
        {"LightSensorType", &force_update.light_sensor_type },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "IlluminanceMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_illuminance_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1024,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1024,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_illuminance_measurement_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IlluminanceMeasurement/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_illuminance_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1024,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1024,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_illuminance_measurement_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IlluminanceMeasurement/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_illuminance_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1024,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1024,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_illuminance_measurement_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IlluminanceMeasurement/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_illuminance_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1024,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1024,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_illuminance_measurement_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IlluminanceMeasurement/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_illuminance_measurement_light_sensor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = illuminance_measurement_light_sensor_type_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE. Using number instead.");
  jsn["value"] = static_cast<IlluminanceMeasurementLightSensorType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceMeasurement/Attributes/LightSensorType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/LightSensorType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_illuminance_measurement_light_sensor_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IlluminanceMeasurement/Attributes/LightSensorType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_illuminance_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "IlluminanceMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_illuminance_measurement_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "IlluminanceMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_illuminance_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_illuminance_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_illuminance_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback_t> uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback;
static std::set<uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback_t> uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_illuminance_level_sensing_write_attributes_callback(
  const uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_illuminance_level_sensing_write_attributes_callback(
  const uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_illuminance_level_sensing_write_attributes_callbacks()
{
  uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback_t>& get_uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback()
{
  return uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback;
}

void uic_mqtt_dotdot_set_illuminance_level_sensing_force_read_attributes_callback(
  const uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_illuminance_level_sensing_force_read_attributes_callback(
  const uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_illuminance_level_sensing_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/IlluminanceLevelSensing/Commands/WriteAttributes
void uic_mqtt_dotdot_on_illuminance_level_sensing_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_illuminance_level_sensing_state_t new_state = {};
  uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_illuminance_level_sensing_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IlluminanceLevelSensing", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_illuminance_level_sensing_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.level_status = true;
      force_update.light_sensor_type = true;
      force_update.illuminance_target_level = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"LevelStatus", &force_update.level_status },
        {"LightSensorType", &force_update.light_sensor_type },
        {"IlluminanceTargetLevel", &force_update.illuminance_target_level },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "IlluminanceLevelSensing/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_level_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS_ENUM_NAME_AVAILABLE
  jsn["value"] = illuminance_level_sensing_level_status_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS. Using number instead.");
  jsn["value"] = static_cast<IlluminanceLevelSensingLevelStatus>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing/Attributes/LevelStatus", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceLevelSensing/Attributes/LevelStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_level_status_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IlluminanceLevelSensing/Attributes/LevelStatus";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_light_sensor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = illuminance_level_sensing_light_sensor_type_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE. Using number instead.");
  jsn["value"] = static_cast<IlluminanceLevelSensingLightSensorType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing/Attributes/LightSensorType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceLevelSensing/Attributes/LightSensorType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_light_sensor_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IlluminanceLevelSensing/Attributes/LightSensorType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_illuminance_target_level_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1025,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1025,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IlluminanceLevelSensing/Attributes/IlluminanceTargetLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IlluminanceLevelSensing/Attributes/IlluminanceTargetLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_illuminance_target_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IlluminanceLevelSensing/Attributes/IlluminanceTargetLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_illuminance_level_sensing_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "IlluminanceLevelSensing/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_illuminance_level_sensing_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "IlluminanceLevelSensing/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_illuminance_level_sensing_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_illuminance_level_sensing_attributes_init();

  uic_mqtt_dotdot_by_group_illuminance_level_sensing_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_temperature_measurement_write_attributes_callback_t> uic_mqtt_dotdot_temperature_measurement_write_attributes_callback;
static std::set<uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback_t> uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_temperature_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_temperature_measurement_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_temperature_measurement_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_temperature_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_temperature_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_temperature_measurement_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_temperature_measurement_write_attributes_callbacks()
{
  uic_mqtt_dotdot_temperature_measurement_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_temperature_measurement_write_attributes_callback_t>& get_uic_mqtt_dotdot_temperature_measurement_write_attributes_callback()
{
  return uic_mqtt_dotdot_temperature_measurement_write_attributes_callback;
}

void uic_mqtt_dotdot_set_temperature_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_temperature_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_temperature_measurement_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/TemperatureMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_temperature_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_temperature_measurement_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_temperature_measurement_state_t new_state = {};
  uic_mqtt_dotdot_temperature_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_temperature_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "TemperatureMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_temperature_measurement_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_temperature_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_temperature_measurement_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "TemperatureMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_temperature_measurement_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1026,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1026,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/TemperatureMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_temperature_measurement_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/TemperatureMeasurement/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_temperature_measurement_min_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1026,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1026,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/TemperatureMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_temperature_measurement_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/TemperatureMeasurement/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_temperature_measurement_max_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1026,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1026,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/TemperatureMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_temperature_measurement_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/TemperatureMeasurement/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_temperature_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1026,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1026,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "TemperatureMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/TemperatureMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_temperature_measurement_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/TemperatureMeasurement/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_temperature_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_temperature_measurement_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "TemperatureMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_temperature_measurement_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "TemperatureMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_temperature_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_temperature_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_temperature_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_pressure_measurement_write_attributes_callback_t> uic_mqtt_dotdot_pressure_measurement_write_attributes_callback;
static std::set<uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback_t> uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_pressure_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_pressure_measurement_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_pressure_measurement_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_pressure_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_pressure_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_pressure_measurement_write_attributes_callbacks()
{
  uic_mqtt_dotdot_pressure_measurement_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_pressure_measurement_write_attributes_callback_t>& get_uic_mqtt_dotdot_pressure_measurement_write_attributes_callback()
{
  return uic_mqtt_dotdot_pressure_measurement_write_attributes_callback;
}

void uic_mqtt_dotdot_set_pressure_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_pressure_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_pressure_measurement_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/PressureMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_pressure_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_pressure_measurement_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_pressure_measurement_state_t new_state = {};
  uic_mqtt_dotdot_pressure_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_pressure_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PressureMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_pressure_measurement_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_pressure_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_pressure_measurement_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      force_update.scaled_value = true;
      force_update.min_scaled_value = true;
      force_update.max_scaled_value = true;
      force_update.scaled_tolerance = true;
      force_update.scale = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
        {"ScaledValue", &force_update.scaled_value },
        {"MinScaledValue", &force_update.min_scaled_value },
        {"MaxScaledValue", &force_update.max_scaled_value },
        {"ScaledTolerance", &force_update.scaled_tolerance },
        {"Scale", &force_update.scale },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "PressureMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1027,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1027,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PressureMeasurement/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pressure_measurement_min_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1027,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1027,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PressureMeasurement/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pressure_measurement_max_measured_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1027,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1027,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PressureMeasurement/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pressure_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1027,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1027,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PressureMeasurement/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pressure_measurement_scaled_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1027,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1027,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/ScaledValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/ScaledValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_scaled_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PressureMeasurement/Attributes/ScaledValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pressure_measurement_min_scaled_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1027,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1027,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/MinScaledValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/MinScaledValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_min_scaled_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PressureMeasurement/Attributes/MinScaledValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pressure_measurement_max_scaled_value_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1027,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1027,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/MaxScaledValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/MaxScaledValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_max_scaled_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PressureMeasurement/Attributes/MaxScaledValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pressure_measurement_scaled_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1027,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1027,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/ScaledTolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/ScaledTolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_scaled_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PressureMeasurement/Attributes/ScaledTolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pressure_measurement_scale_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1027,20,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1027,20,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PressureMeasurement/Attributes/Scale", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PressureMeasurement/Attributes/Scale";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pressure_measurement_scale_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PressureMeasurement/Attributes/Scale";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_pressure_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_pressure_measurement_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "PressureMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_pressure_measurement_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "PressureMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_pressure_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_pressure_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_pressure_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_flow_measurement_write_attributes_callback_t> uic_mqtt_dotdot_flow_measurement_write_attributes_callback;
static std::set<uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback_t> uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_flow_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_flow_measurement_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_flow_measurement_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_flow_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_flow_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_flow_measurement_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_flow_measurement_write_attributes_callbacks()
{
  uic_mqtt_dotdot_flow_measurement_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_flow_measurement_write_attributes_callback_t>& get_uic_mqtt_dotdot_flow_measurement_write_attributes_callback()
{
  return uic_mqtt_dotdot_flow_measurement_write_attributes_callback;
}

void uic_mqtt_dotdot_set_flow_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_flow_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_flow_measurement_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/FlowMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_flow_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_flow_measurement_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_flow_measurement_state_t new_state = {};
  uic_mqtt_dotdot_flow_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_flow_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "FlowMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_flow_measurement_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_flow_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_flow_measurement_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "FlowMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_flow_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1028,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1028,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FlowMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_flow_measurement_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/FlowMeasurement/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_flow_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1028,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1028,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FlowMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_flow_measurement_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/FlowMeasurement/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_flow_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1028,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1028,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FlowMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_flow_measurement_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/FlowMeasurement/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_flow_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1028,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1028,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "FlowMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/FlowMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_flow_measurement_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/FlowMeasurement/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_flow_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_flow_measurement_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "FlowMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_flow_measurement_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "FlowMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_flow_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_flow_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_flow_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_relativity_humidity_write_attributes_callback_t> uic_mqtt_dotdot_relativity_humidity_write_attributes_callback;
static std::set<uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback_t> uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_relativity_humidity_write_attributes_callback(
  const uic_mqtt_dotdot_relativity_humidity_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_relativity_humidity_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_relativity_humidity_write_attributes_callback(
  const uic_mqtt_dotdot_relativity_humidity_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_relativity_humidity_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_relativity_humidity_write_attributes_callbacks()
{
  uic_mqtt_dotdot_relativity_humidity_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_relativity_humidity_write_attributes_callback_t>& get_uic_mqtt_dotdot_relativity_humidity_write_attributes_callback()
{
  return uic_mqtt_dotdot_relativity_humidity_write_attributes_callback;
}

void uic_mqtt_dotdot_set_relativity_humidity_force_read_attributes_callback(
  const uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_relativity_humidity_force_read_attributes_callback(
  const uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_relativity_humidity_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/RelativityHumidity/Commands/WriteAttributes
void uic_mqtt_dotdot_on_relativity_humidity_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_relativity_humidity_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_relativity_humidity_state_t new_state = {};
  uic_mqtt_dotdot_relativity_humidity_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_relativity_humidity_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "RelativityHumidity", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_relativity_humidity_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_relativity_humidity_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_relativity_humidity_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "RelativityHumidity/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_relativity_humidity_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1029,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1029,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/RelativityHumidity/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_relativity_humidity_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/RelativityHumidity/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_relativity_humidity_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1029,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1029,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/RelativityHumidity/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_relativity_humidity_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/RelativityHumidity/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_relativity_humidity_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1029,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1029,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/RelativityHumidity/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_relativity_humidity_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/RelativityHumidity/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_relativity_humidity_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1029,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1029,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "RelativityHumidity/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/RelativityHumidity/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_relativity_humidity_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/RelativityHumidity/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_relativity_humidity_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_relativity_humidity_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "RelativityHumidity/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_relativity_humidity_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "RelativityHumidity/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_relativity_humidity_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_relativity_humidity_attributes_init();

  uic_mqtt_dotdot_by_group_relativity_humidity_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback_t> uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback;
static std::set<uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback_t> uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_occupancy_sensing_write_attributes_callback(
  const uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_occupancy_sensing_write_attributes_callback(
  const uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_occupancy_sensing_write_attributes_callbacks()
{
  uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback_t>& get_uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback()
{
  return uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback;
}

void uic_mqtt_dotdot_set_occupancy_sensing_force_read_attributes_callback(
  const uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_occupancy_sensing_force_read_attributes_callback(
  const uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_occupancy_sensing_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/OccupancySensing/Commands/WriteAttributes
void uic_mqtt_dotdot_on_occupancy_sensing_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_occupancy_sensing_state_t new_state = {};
  uic_mqtt_dotdot_occupancy_sensing_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_occupancy_sensing_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "OccupancySensing", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_occupancy_sensing_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_occupancy_sensing_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.occupancy = true;
      force_update.occupancy_sensor_type = true;
      force_update.occupancy_sensor_type_bitmap = true;
      force_update.pir_occupied_to_unoccupied_delay = true;
      force_update.pir_unoccupied_to_occupied_delay = true;
      force_update.pir_unoccupied_to_occupied_threshold = true;
      force_update.ultrasonic_occupied_to_unoccupied_delay = true;
      force_update.ultrasonic_unoccupied_to_occupied_delay = true;
      force_update.ultrasonic_unoccupied_to_occupied_threshold = true;
      force_update.physical_contact_occupied_to_unoccupied_delay = true;
      force_update.physical_contact_unoccupied_to_occupied_delay = true;
      force_update.physical_contact_unoccupied_to_occupied_threshold = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"Occupancy", &force_update.occupancy },
        {"OccupancySensorType", &force_update.occupancy_sensor_type },
        {"OccupancySensorTypeBitmap", &force_update.occupancy_sensor_type_bitmap },
        {"PIROccupiedToUnoccupiedDelay", &force_update.pir_occupied_to_unoccupied_delay },
        {"PIRUnoccupiedToOccupiedDelay", &force_update.pir_unoccupied_to_occupied_delay },
        {"PIRUnoccupiedToOccupiedThreshold", &force_update.pir_unoccupied_to_occupied_threshold },
        {"UltrasonicOccupiedToUnoccupiedDelay", &force_update.ultrasonic_occupied_to_unoccupied_delay },
        {"UltrasonicUnoccupiedToOccupiedDelay", &force_update.ultrasonic_unoccupied_to_occupied_delay },
        {"UltrasonicUnoccupiedToOccupiedThreshold", &force_update.ultrasonic_unoccupied_to_occupied_threshold },
        {"PhysicalContactOccupiedToUnoccupiedDelay", &force_update.physical_contact_occupied_to_unoccupied_delay },
        {"PhysicalContactUnoccupiedToOccupiedDelay", &force_update.physical_contact_unoccupied_to_occupied_delay },
        {"PhysicalContactUnoccupiedToOccupiedThreshold", &force_update.physical_contact_unoccupied_to_occupied_threshold },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "OccupancySensing/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = OccupancySensingOccupancy.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/Occupancy", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/Occupancy";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/Occupancy";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = occupancy_sensing_occupancy_sensor_type_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE. Using number instead.");
  jsn["value"] = static_cast<OccupancySensingOccupancySensorType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/OccupancySensorType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/OccupancySensorType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/OccupancySensorType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = OccupancySensingOccupancySensorTypeBitmap.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/OccupancySensorTypeBitmap", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/OccupancySensorTypeBitmap";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/OccupancySensorTypeBitmap";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1030,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1030,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PIROccupiedToUnoccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PIROccupiedToUnoccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/PIROccupiedToUnoccupiedDelay";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1030,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1030,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PIRUnoccupiedToOccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PIRUnoccupiedToOccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/PIRUnoccupiedToOccupiedDelay";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1030,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1030,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PIRUnoccupiedToOccupiedThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PIRUnoccupiedToOccupiedThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/PIRUnoccupiedToOccupiedThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1030,32,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1030,32,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/UltrasonicOccupiedToUnoccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/UltrasonicOccupiedToUnoccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/UltrasonicOccupiedToUnoccupiedDelay";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1030,33,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1030,33,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedDelay";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1030,34,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1030,34,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/UltrasonicUnoccupiedToOccupiedThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1030,48,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1030,48,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PhysicalContactOccupiedToUnoccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PhysicalContactOccupiedToUnoccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/PhysicalContactOccupiedToUnoccupiedDelay";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1030,49,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1030,49,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedDelay";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1030,50,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1030,50,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedThreshold", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedThreshold";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/PhysicalContactUnoccupiedToOccupiedThreshold";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_occupancy_sensing_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "OccupancySensing/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_occupancy_sensing_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "OccupancySensing/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_occupancy_sensing_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_occupancy_sensing_attributes_init();

  uic_mqtt_dotdot_by_group_occupancy_sensing_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_soil_moisture_write_attributes_callback_t> uic_mqtt_dotdot_soil_moisture_write_attributes_callback;
static std::set<uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback_t> uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_soil_moisture_write_attributes_callback(
  const uic_mqtt_dotdot_soil_moisture_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_soil_moisture_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_soil_moisture_write_attributes_callback(
  const uic_mqtt_dotdot_soil_moisture_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_soil_moisture_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_soil_moisture_write_attributes_callbacks()
{
  uic_mqtt_dotdot_soil_moisture_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_soil_moisture_write_attributes_callback_t>& get_uic_mqtt_dotdot_soil_moisture_write_attributes_callback()
{
  return uic_mqtt_dotdot_soil_moisture_write_attributes_callback;
}

void uic_mqtt_dotdot_set_soil_moisture_force_read_attributes_callback(
  const uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_soil_moisture_force_read_attributes_callback(
  const uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_soil_moisture_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/SoilMoisture/Commands/WriteAttributes
void uic_mqtt_dotdot_on_soil_moisture_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_soil_moisture_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_soil_moisture_state_t new_state = {};
  uic_mqtt_dotdot_soil_moisture_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_soil_moisture_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "SoilMoisture", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SoilMoisture", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SoilMoisture", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_soil_moisture_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_soil_moisture_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_soil_moisture_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "SoilMoisture/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_soil_moisture_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1032,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1032,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SoilMoisture/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SoilMoisture/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_soil_moisture_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SoilMoisture/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_soil_moisture_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1032,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1032,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SoilMoisture/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SoilMoisture/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_soil_moisture_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SoilMoisture/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_soil_moisture_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1032,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1032,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SoilMoisture/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SoilMoisture/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_soil_moisture_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SoilMoisture/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_soil_moisture_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1032,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1032,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SoilMoisture/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SoilMoisture/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_soil_moisture_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SoilMoisture/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_soil_moisture_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_soil_moisture_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "SoilMoisture/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_soil_moisture_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "SoilMoisture/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_soil_moisture_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_soil_moisture_attributes_init();

  uic_mqtt_dotdot_by_group_soil_moisture_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_ph_measurement_write_attributes_callback_t> uic_mqtt_dotdot_ph_measurement_write_attributes_callback;
static std::set<uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback_t> uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_ph_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_ph_measurement_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ph_measurement_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_ph_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_ph_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ph_measurement_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_ph_measurement_write_attributes_callbacks()
{
  uic_mqtt_dotdot_ph_measurement_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_ph_measurement_write_attributes_callback_t>& get_uic_mqtt_dotdot_ph_measurement_write_attributes_callback()
{
  return uic_mqtt_dotdot_ph_measurement_write_attributes_callback;
}

void uic_mqtt_dotdot_set_ph_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_ph_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_ph_measurement_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/PhMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_ph_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_ph_measurement_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_ph_measurement_state_t new_state = {};
  uic_mqtt_dotdot_ph_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_ph_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PhMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_ph_measurement_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_ph_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_ph_measurement_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "PhMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_ph_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1033,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1033,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PhMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ph_measurement_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PhMeasurement/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ph_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1033,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1033,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PhMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ph_measurement_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PhMeasurement/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ph_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1033,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1033,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PhMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ph_measurement_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PhMeasurement/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ph_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1033,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1033,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PhMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PhMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ph_measurement_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PhMeasurement/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_ph_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_ph_measurement_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "PhMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ph_measurement_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "PhMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ph_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_ph_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_ph_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback_t> uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback;
static std::set<uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback_t> uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_electrical_conductivity_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_electrical_conductivity_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_electrical_conductivity_measurement_write_attributes_callbacks()
{
  uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback_t>& get_uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback()
{
  return uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback;
}

void uic_mqtt_dotdot_set_electrical_conductivity_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_electrical_conductivity_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_electrical_conductivity_measurement_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalConductivityMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_electrical_conductivity_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_electrical_conductivity_measurement_state_t new_state = {};
  uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_electrical_conductivity_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalConductivityMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_electrical_conductivity_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "ElectricalConductivityMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1034,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1034,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalConductivityMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalConductivityMeasurement/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1034,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1034,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalConductivityMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalConductivityMeasurement/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1034,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1034,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalConductivityMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalConductivityMeasurement/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1034,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1034,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalConductivityMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalConductivityMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalConductivityMeasurement/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_electrical_conductivity_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "ElectricalConductivityMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_conductivity_measurement_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "ElectricalConductivityMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_conductivity_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_electrical_conductivity_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_electrical_conductivity_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback_t> uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback;
static std::set<uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback_t> uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_wind_speed_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_wind_speed_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_wind_speed_measurement_write_attributes_callbacks()
{
  uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback_t>& get_uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback()
{
  return uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback;
}

void uic_mqtt_dotdot_set_wind_speed_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_wind_speed_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_wind_speed_measurement_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/WindSpeedMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_wind_speed_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_wind_speed_measurement_state_t new_state = {};
  uic_mqtt_dotdot_wind_speed_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_wind_speed_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "WindSpeedMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_wind_speed_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_wind_speed_measurement_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "WindSpeedMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_wind_speed_measurement_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1035,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1035,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindSpeedMeasurement/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_wind_speed_measurement_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindSpeedMeasurement/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_wind_speed_measurement_min_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1035,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1035,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindSpeedMeasurement/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_wind_speed_measurement_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindSpeedMeasurement/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_wind_speed_measurement_max_measured_value_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1035,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1035,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindSpeedMeasurement/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_wind_speed_measurement_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindSpeedMeasurement/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_wind_speed_measurement_tolerance_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1035,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1035,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "WindSpeedMeasurement/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/WindSpeedMeasurement/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_wind_speed_measurement_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/WindSpeedMeasurement/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_wind_speed_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "WindSpeedMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_wind_speed_measurement_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "WindSpeedMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_wind_speed_measurement_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_wind_speed_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_wind_speed_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback_t> uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback;
static std::set<uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback_t> uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_carbon_monoxide_write_attributes_callback(
  const uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_carbon_monoxide_write_attributes_callback(
  const uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_carbon_monoxide_write_attributes_callbacks()
{
  uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback_t>& get_uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback()
{
  return uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback;
}

void uic_mqtt_dotdot_set_carbon_monoxide_force_read_attributes_callback(
  const uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_carbon_monoxide_force_read_attributes_callback(
  const uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_carbon_monoxide_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/CarbonMonoxide/Commands/WriteAttributes
void uic_mqtt_dotdot_on_carbon_monoxide_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_carbon_monoxide_state_t new_state = {};
  uic_mqtt_dotdot_carbon_monoxide_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_carbon_monoxide_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "CarbonMonoxide", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_carbon_monoxide_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_carbon_monoxide_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "CarbonMonoxide/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_carbon_monoxide_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1036,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1036,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonMonoxide/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_carbon_monoxide_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/CarbonMonoxide/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_carbon_monoxide_min_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1036,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1036,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonMonoxide/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_carbon_monoxide_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/CarbonMonoxide/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_carbon_monoxide_max_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1036,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1036,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonMonoxide/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_carbon_monoxide_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/CarbonMonoxide/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_carbon_monoxide_tolerance_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1036,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1036,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonMonoxide/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonMonoxide/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_carbon_monoxide_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/CarbonMonoxide/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_carbon_monoxide_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "CarbonMonoxide/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_carbon_monoxide_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "CarbonMonoxide/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_carbon_monoxide_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_carbon_monoxide_attributes_init();

  uic_mqtt_dotdot_by_group_carbon_monoxide_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback_t> uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback;
static std::set<uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback_t> uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_carbon_dioxide_write_attributes_callback(
  const uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_carbon_dioxide_write_attributes_callback(
  const uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_carbon_dioxide_write_attributes_callbacks()
{
  uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback_t>& get_uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback()
{
  return uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback;
}

void uic_mqtt_dotdot_set_carbon_dioxide_force_read_attributes_callback(
  const uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_carbon_dioxide_force_read_attributes_callback(
  const uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_carbon_dioxide_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/CarbonDioxide/Commands/WriteAttributes
void uic_mqtt_dotdot_on_carbon_dioxide_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_carbon_dioxide_state_t new_state = {};
  uic_mqtt_dotdot_carbon_dioxide_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_carbon_dioxide_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "CarbonDioxide", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonDioxide", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonDioxide", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_carbon_dioxide_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_carbon_dioxide_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "CarbonDioxide/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_carbon_dioxide_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1037,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1037,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonDioxide/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonDioxide/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_carbon_dioxide_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/CarbonDioxide/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_carbon_dioxide_min_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1037,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1037,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonDioxide/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonDioxide/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_carbon_dioxide_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/CarbonDioxide/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_carbon_dioxide_max_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1037,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1037,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonDioxide/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonDioxide/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_carbon_dioxide_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/CarbonDioxide/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_carbon_dioxide_tolerance_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1037,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1037,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "CarbonDioxide/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/CarbonDioxide/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_carbon_dioxide_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/CarbonDioxide/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_carbon_dioxide_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "CarbonDioxide/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_carbon_dioxide_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "CarbonDioxide/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_carbon_dioxide_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_carbon_dioxide_attributes_init();

  uic_mqtt_dotdot_by_group_carbon_dioxide_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_pm25_write_attributes_callback_t> uic_mqtt_dotdot_pm25_write_attributes_callback;
static std::set<uic_mqtt_dotdot_pm25_force_read_attributes_callback_t> uic_mqtt_dotdot_pm25_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_pm25_write_attributes_callback(
  const uic_mqtt_dotdot_pm25_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_pm25_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_pm25_write_attributes_callback(
  const uic_mqtt_dotdot_pm25_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_pm25_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_pm25_write_attributes_callbacks()
{
  uic_mqtt_dotdot_pm25_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_pm25_write_attributes_callback_t>& get_uic_mqtt_dotdot_pm25_write_attributes_callback()
{
  return uic_mqtt_dotdot_pm25_write_attributes_callback;
}

void uic_mqtt_dotdot_set_pm25_force_read_attributes_callback(
  const uic_mqtt_dotdot_pm25_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_pm25_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_pm25_force_read_attributes_callback(
  const uic_mqtt_dotdot_pm25_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_pm25_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_pm25_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_pm25_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/PM25/Commands/WriteAttributes
void uic_mqtt_dotdot_on_pm25_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_pm25_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_pm25_state_t new_state = {};
  uic_mqtt_dotdot_pm25_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_pm25_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "PM25", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PM25", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PM25", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_pm25_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_pm25_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_pm25_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_pm25_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measured_value = true;
      force_update.min_measured_value = true;
      force_update.max_measured_value = true;
      force_update.tolerance = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasuredValue", &force_update.measured_value },
        {"MinMeasuredValue", &force_update.min_measured_value },
        {"MaxMeasuredValue", &force_update.max_measured_value },
        {"Tolerance", &force_update.tolerance },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_pm25_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "PM25/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_pm25_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1066,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1066,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PM25/Attributes/MeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PM25/Attributes/MeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pm25_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PM25/Attributes/MeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pm25_min_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1066,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1066,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PM25/Attributes/MinMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PM25/Attributes/MinMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pm25_min_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PM25/Attributes/MinMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pm25_max_measured_value_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1066,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1066,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PM25/Attributes/MaxMeasuredValue", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PM25/Attributes/MaxMeasuredValue";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pm25_max_measured_value_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PM25/Attributes/MaxMeasuredValue";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_pm25_tolerance_publish(
  const char *base_topic,
  float value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1066,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1066,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "PM25/Attributes/Tolerance", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/PM25/Attributes/Tolerance";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_pm25_tolerance_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/PM25/Attributes/Tolerance";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_pm25_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_pm25_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "PM25/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_pm25_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_pm25_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "PM25/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_pm25_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_pm25_attributes_init();

  uic_mqtt_dotdot_by_group_pm25_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t> uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback;
static std::set<uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t> uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback;
static std::set<uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t> uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback;
static std::set<uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t> uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback;
static std::set<uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t> uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback;
static std::set<uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t> uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback;
static std::set<uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t> uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback;
static std::set<uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t> uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback;
static std::set<uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t> uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback;
static std::set<uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t> uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback;
static std::set<uic_mqtt_dotdot_ias_zone_write_attributes_callback_t> uic_mqtt_dotdot_ias_zone_write_attributes_callback;
static std::set<uic_mqtt_dotdot_ias_zone_force_read_attributes_callback_t> uic_mqtt_dotdot_ias_zone_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_set(const uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_unset(const uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback.erase(callback);
}
void uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_clear()
{
  uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback.clear();
}
std::set<uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t>& get_uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback()
{
  return uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback;
}

void uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback_set(const uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback_unset(const uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback.erase(callback);
}
void uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback_clear()
{
  uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback.clear();
}
void uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_set(const uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_unset(const uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback.erase(callback);
}
void uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_clear()
{
  uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback.clear();
}
std::set<uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t>& get_uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback()
{
  return uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback;
}

void uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback_set(const uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback_unset(const uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback.erase(callback);
}
void uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback_clear()
{
  uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback.clear();
}
void uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_set(const uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_unset(const uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback.erase(callback);
}
void uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_clear()
{
  uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback.clear();
}
std::set<uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t>& get_uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback()
{
  return uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback;
}

void uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback_set(const uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback_unset(const uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback.erase(callback);
}
void uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback_clear()
{
  uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback.clear();
}
void uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_set(const uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_unset(const uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback.erase(callback);
}
void uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_clear()
{
  uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback.clear();
}
std::set<uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t>& get_uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback()
{
  return uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback;
}

void uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback_set(const uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback_unset(const uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback.erase(callback);
}
void uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback_clear()
{
  uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback.clear();
}
void uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_set(const uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_unset(const uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback.erase(callback);
}
void uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_clear()
{
  uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback.clear();
}
std::set<uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t>& get_uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback()
{
  return uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback;
}

void uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback_set(const uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback_unset(const uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback.erase(callback);
}
void uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback_clear()
{
  uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback.clear();
}

void uic_mqtt_dotdot_set_ias_zone_write_attributes_callback(
  const uic_mqtt_dotdot_ias_zone_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_ias_zone_write_attributes_callback(
  const uic_mqtt_dotdot_ias_zone_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_ias_zone_write_attributes_callbacks()
{
  uic_mqtt_dotdot_ias_zone_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_ias_zone_write_attributes_callback_t>& get_uic_mqtt_dotdot_ias_zone_write_attributes_callback()
{
  return uic_mqtt_dotdot_ias_zone_write_attributes_callback;
}

void uic_mqtt_dotdot_set_ias_zone_force_read_attributes_callback(
  const uic_mqtt_dotdot_ias_zone_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_ias_zone_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_ias_zone_force_read_attributes_callback(
  const uic_mqtt_dotdot_ias_zone_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_ias_zone_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_ias_zone_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_ias_zone_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/ZoneEnrollResponse
void uic_mqtt_dotdot_on_ias_zone_zone_enroll_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  ZoneEnrollResponseEnrollResponseCode enroll_response_code = {};
  uint8_t zoneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_enroll_response(
      jsn,
      enroll_response_code,

      zoneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneEnrollResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      enroll_response_code,
  
      zoneid
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/GeneratedCommands/ZoneEnrollResponse
static void uic_mqtt_dotdot_on_generated_ias_zone_zone_enroll_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  ZoneEnrollResponseEnrollResponseCode enroll_response_code = {};
  uint8_t zoneid = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_enroll_response(
      jsn,
      enroll_response_code,

      zoneid
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneEnrollResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      enroll_response_code,
  
      zoneid
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/ZoneStatusChangeNotification
void uic_mqtt_dotdot_on_ias_zone_zone_status_change_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t zone_status = {};
  uint8_t extended_status = {};
  uint8_t zoneid = {};
  uint16_t delay = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_status_change_notification(
      jsn,
      zone_status,

      extended_status,

      zoneid,

      delay
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneStatusChangeNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneStatusChangeNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneStatusChangeNotification", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      zone_status,
  
      extended_status,
  
      zoneid,
  
      delay
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/GeneratedCommands/ZoneStatusChangeNotification
static void uic_mqtt_dotdot_on_generated_ias_zone_zone_status_change_notification(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t zone_status = {};
  uint8_t extended_status = {};
  uint8_t zoneid = {};
  uint16_t delay = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_status_change_notification(
      jsn,
      zone_status,

      extended_status,

      zoneid,

      delay
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneStatusChangeNotification");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneStatusChangeNotification", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneStatusChangeNotification", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      zone_status,
  
      extended_status,
  
      zoneid,
  
      delay
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/InitiateNormalOperationMode
void uic_mqtt_dotdot_on_ias_zone_initiate_normal_operation_mode(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "InitiateNormalOperationMode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateNormalOperationMode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateNormalOperationMode", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/GeneratedCommands/InitiateNormalOperationMode
static void uic_mqtt_dotdot_on_generated_ias_zone_initiate_normal_operation_mode(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "InitiateNormalOperationMode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateNormalOperationMode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateNormalOperationMode", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/ZoneEnrollRequest
void uic_mqtt_dotdot_on_ias_zone_zone_enroll_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  IasZoneType zone_type = {};
  uint16_t manufacturer_code = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_enroll_request(
      jsn,
      zone_type,

      manufacturer_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneEnrollRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollRequest", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      zone_type,
  
      manufacturer_code
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/GeneratedCommands/ZoneEnrollRequest
static void uic_mqtt_dotdot_on_generated_ias_zone_zone_enroll_request(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  IasZoneType zone_type = {};
  uint16_t manufacturer_code = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_zone_enroll_request(
      jsn,
      zone_type,

      manufacturer_code
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "ZoneEnrollRequest");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollRequest", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "ZoneEnrollRequest", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      zone_type,
  
      manufacturer_code
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/InitiateTestMode
void uic_mqtt_dotdot_on_ias_zone_initiate_test_mode(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t test_mode_duration = {};
  uint8_t current_zone_sensitivity_level = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_initiate_test_mode(
      jsn,
      test_mode_duration,

      current_zone_sensitivity_level
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "InitiateTestMode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateTestMode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateTestMode", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      test_mode_duration,
  
      current_zone_sensitivity_level
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/GeneratedCommands/InitiateTestMode
static void uic_mqtt_dotdot_on_generated_ias_zone_initiate_test_mode(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t test_mode_duration = {};
  uint8_t current_zone_sensitivity_level = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_ias_zone_initiate_test_mode(
      jsn,
      test_mode_duration,

      current_zone_sensitivity_level
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "InitiateTestMode");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateTestMode", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "InitiateTestMode", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      test_mode_duration,
  
      current_zone_sensitivity_level
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASZone/Commands/WriteAttributes
void uic_mqtt_dotdot_on_ias_zone_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_ias_zone_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_ias_zone_state_t new_state = {};
  uic_mqtt_dotdot_ias_zone_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_ias_zone_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASZone", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_ias_zone_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_ias_zone_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_ias_zone_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_ias_zone_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.zone_state = true;
      force_update.zone_type = true;
      force_update.zone_status = true;
      force_update.iascie_address = true;
      force_update.zoneid = true;
      force_update.number_of_zone_sensitivity_levels_supported = true;
      force_update.current_zone_sensitivity_level = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"ZoneState", &force_update.zone_state },
        {"ZoneType", &force_update.zone_type },
        {"ZoneStatus", &force_update.zone_status },
        {"IASCIEAddress", &force_update.iascie_address },
        {"ZoneID", &force_update.zoneid },
        {"NumberOfZoneSensitivityLevelsSupported", &force_update.number_of_zone_sensitivity_levels_supported },
        {"CurrentZoneSensitivityLevel", &force_update.current_zone_sensitivity_level },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_ias_zone_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "IASZone/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_ias_zone_zone_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef IAS_ZONE_ZONE_STATE_ENUM_NAME_AVAILABLE
  jsn["value"] = ias_zone_zone_state_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for IAS_ZONE_ZONE_STATE. Using number instead.");
  jsn["value"] = static_cast<IASZoneZoneState>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/ZoneState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/ZoneState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ias_zone_zone_state_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IASZone/Attributes/ZoneState";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ias_zone_zone_type_publish(
  const char *base_topic,
  IasZoneType value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef IAS_ZONE_ZONE_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = ias_zone_zone_type_get_enum_value_name((uint32_t)value);
  #elif defined(IAS_ZONE_TYPE_ENUM_NAME_AVAILABLE)
  jsn["value"] = ias_zone_type_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for IAS_ZONE_ZONE_TYPE. Using number instead.");
  jsn["value"] = static_cast<IasZoneType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/ZoneType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/ZoneType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ias_zone_zone_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IASZone/Attributes/ZoneType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ias_zone_zone_status_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = IasZoneStatus.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/ZoneStatus", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/IASZone/Attributes/ZoneStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ias_zone_zone_status_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IASZone/Attributes/ZoneStatus";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ias_zone_iascie_address_publish(
  const char *base_topic,
  EUI64 value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1280,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1280,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/IASCIEAddress", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/IASCIEAddress";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ias_zone_iascie_address_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IASZone/Attributes/IASCIEAddress";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ias_zone_zoneid_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1280,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1280,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/ZoneID", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/ZoneID";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ias_zone_zoneid_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IASZone/Attributes/ZoneID";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ias_zone_number_of_zone_sensitivity_levels_supported_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1280,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1280,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/NumberOfZoneSensitivityLevelsSupported", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/NumberOfZoneSensitivityLevelsSupported";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ias_zone_number_of_zone_sensitivity_levels_supported_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IASZone/Attributes/NumberOfZoneSensitivityLevelsSupported";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_ias_zone_current_zone_sensitivity_level_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1280,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1280,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASZone/Attributes/CurrentZoneSensitivityLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASZone/Attributes/CurrentZoneSensitivityLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_ias_zone_current_zone_sensitivity_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IASZone/Attributes/CurrentZoneSensitivityLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_ias_zone_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_ias_zone_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "IASZone/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_ias_zone_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "IASZone/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback.empty()) {
    subscription_topic = base_topic + "IASZone/Commands/ZoneEnrollResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_zone_enroll_response);
  }
  if (!uic_mqtt_dotdot_ias_zone_generated_zone_enroll_response_callback.empty()) {
    subscription_topic = base_topic + "IASZone/GeneratedCommands/ZoneEnrollResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ias_zone_zone_enroll_response);
  }
  if (!uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback.empty()) {
    subscription_topic = base_topic + "IASZone/Commands/ZoneStatusChangeNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_zone_status_change_notification);
  }
  if (!uic_mqtt_dotdot_ias_zone_generated_zone_status_change_notification_callback.empty()) {
    subscription_topic = base_topic + "IASZone/GeneratedCommands/ZoneStatusChangeNotification";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ias_zone_zone_status_change_notification);
  }
  if (!uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback.empty()) {
    subscription_topic = base_topic + "IASZone/Commands/InitiateNormalOperationMode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_initiate_normal_operation_mode);
  }
  if (!uic_mqtt_dotdot_ias_zone_generated_initiate_normal_operation_mode_callback.empty()) {
    subscription_topic = base_topic + "IASZone/GeneratedCommands/InitiateNormalOperationMode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ias_zone_initiate_normal_operation_mode);
  }
  if (!uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback.empty()) {
    subscription_topic = base_topic + "IASZone/Commands/ZoneEnrollRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_zone_enroll_request);
  }
  if (!uic_mqtt_dotdot_ias_zone_generated_zone_enroll_request_callback.empty()) {
    subscription_topic = base_topic + "IASZone/GeneratedCommands/ZoneEnrollRequest";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ias_zone_zone_enroll_request);
  }
  if (!uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback.empty()) {
    subscription_topic = base_topic + "IASZone/Commands/InitiateTestMode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_ias_zone_initiate_test_mode);
  }
  if (!uic_mqtt_dotdot_ias_zone_generated_initiate_test_mode_callback.empty()) {
    subscription_topic = base_topic + "IASZone/GeneratedCommands/InitiateTestMode";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_ias_zone_initiate_test_mode);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_ias_zone_attributes_init();

  uic_mqtt_dotdot_by_group_ias_zone_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_iaswd_start_warning_callback_t> uic_mqtt_dotdot_iaswd_start_warning_callback;
static std::set<uic_mqtt_dotdot_iaswd_start_warning_callback_t> uic_mqtt_dotdot_iaswd_generated_start_warning_callback;
static std::set<uic_mqtt_dotdot_iaswd_squawk_callback_t> uic_mqtt_dotdot_iaswd_squawk_callback;
static std::set<uic_mqtt_dotdot_iaswd_squawk_callback_t> uic_mqtt_dotdot_iaswd_generated_squawk_callback;
static std::set<uic_mqtt_dotdot_iaswd_write_attributes_callback_t> uic_mqtt_dotdot_iaswd_write_attributes_callback;
static std::set<uic_mqtt_dotdot_iaswd_force_read_attributes_callback_t> uic_mqtt_dotdot_iaswd_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_iaswd_start_warning_callback_set(const uic_mqtt_dotdot_iaswd_start_warning_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_iaswd_start_warning_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_iaswd_start_warning_callback_unset(const uic_mqtt_dotdot_iaswd_start_warning_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_start_warning_callback.erase(callback);
}
void uic_mqtt_dotdot_iaswd_start_warning_callback_clear()
{
  uic_mqtt_dotdot_iaswd_start_warning_callback.clear();
}
std::set<uic_mqtt_dotdot_iaswd_start_warning_callback_t>& get_uic_mqtt_dotdot_iaswd_start_warning_callback()
{
  return uic_mqtt_dotdot_iaswd_start_warning_callback;
}

void uic_mqtt_dotdot_iaswd_generated_start_warning_callback_set(const uic_mqtt_dotdot_iaswd_start_warning_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_iaswd_generated_start_warning_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_iaswd_generated_start_warning_callback_unset(const uic_mqtt_dotdot_iaswd_start_warning_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_generated_start_warning_callback.erase(callback);
}
void uic_mqtt_dotdot_iaswd_generated_start_warning_callback_clear()
{
  uic_mqtt_dotdot_iaswd_generated_start_warning_callback.clear();
}
void uic_mqtt_dotdot_iaswd_squawk_callback_set(const uic_mqtt_dotdot_iaswd_squawk_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_iaswd_squawk_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_iaswd_squawk_callback_unset(const uic_mqtt_dotdot_iaswd_squawk_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_squawk_callback.erase(callback);
}
void uic_mqtt_dotdot_iaswd_squawk_callback_clear()
{
  uic_mqtt_dotdot_iaswd_squawk_callback.clear();
}
std::set<uic_mqtt_dotdot_iaswd_squawk_callback_t>& get_uic_mqtt_dotdot_iaswd_squawk_callback()
{
  return uic_mqtt_dotdot_iaswd_squawk_callback;
}

void uic_mqtt_dotdot_iaswd_generated_squawk_callback_set(const uic_mqtt_dotdot_iaswd_squawk_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_iaswd_generated_squawk_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_iaswd_generated_squawk_callback_unset(const uic_mqtt_dotdot_iaswd_squawk_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_generated_squawk_callback.erase(callback);
}
void uic_mqtt_dotdot_iaswd_generated_squawk_callback_clear()
{
  uic_mqtt_dotdot_iaswd_generated_squawk_callback.clear();
}

void uic_mqtt_dotdot_set_iaswd_write_attributes_callback(
  const uic_mqtt_dotdot_iaswd_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_iaswd_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_iaswd_write_attributes_callback(
  const uic_mqtt_dotdot_iaswd_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_iaswd_write_attributes_callbacks()
{
  uic_mqtt_dotdot_iaswd_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_iaswd_write_attributes_callback_t>& get_uic_mqtt_dotdot_iaswd_write_attributes_callback()
{
  return uic_mqtt_dotdot_iaswd_write_attributes_callback;
}

void uic_mqtt_dotdot_set_iaswd_force_read_attributes_callback(
  const uic_mqtt_dotdot_iaswd_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_iaswd_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_iaswd_force_read_attributes_callback(
  const uic_mqtt_dotdot_iaswd_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_iaswd_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_iaswd_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_iaswd_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASWD/Commands/StartWarning
void uic_mqtt_dotdot_on_iaswd_start_warning(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_iaswd_start_warning_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t siren_configuration = {};
  uint16_t warning_duration = {};
  uint8_t strobe_duty_cycle = {};
  IaswdLevel strobe_level = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_iaswd_start_warning(
      jsn,
      siren_configuration,

      warning_duration,

      strobe_duty_cycle,

      strobe_level
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "StartWarning");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "StartWarning", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "StartWarning", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_iaswd_start_warning_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      siren_configuration,
  
      warning_duration,
  
      strobe_duty_cycle,
  
      strobe_level
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASWD/GeneratedCommands/StartWarning
static void uic_mqtt_dotdot_on_generated_iaswd_start_warning(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_iaswd_generated_start_warning_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t siren_configuration = {};
  uint16_t warning_duration = {};
  uint8_t strobe_duty_cycle = {};
  IaswdLevel strobe_level = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_iaswd_start_warning(
      jsn,
      siren_configuration,

      warning_duration,

      strobe_duty_cycle,

      strobe_level
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "StartWarning");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "StartWarning", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "StartWarning", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_iaswd_generated_start_warning_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      siren_configuration,
  
      warning_duration,
  
      strobe_duty_cycle,
  
      strobe_level
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASWD/Commands/Squawk
void uic_mqtt_dotdot_on_iaswd_squawk(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_iaswd_squawk_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t squawk_configuration = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_iaswd_squawk(
      jsn,
      squawk_configuration
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "Squawk");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "Squawk", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "Squawk", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_iaswd_squawk_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      squawk_configuration
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/IASWD/GeneratedCommands/Squawk
static void uic_mqtt_dotdot_on_generated_iaswd_squawk(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_iaswd_generated_squawk_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t squawk_configuration = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_iaswd_squawk(
      jsn,
      squawk_configuration
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "Squawk");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "Squawk", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "Squawk", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_iaswd_generated_squawk_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      squawk_configuration
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/IASWD/Commands/WriteAttributes
void uic_mqtt_dotdot_on_iaswd_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_iaswd_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_iaswd_state_t new_state = {};
  uic_mqtt_dotdot_iaswd_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_iaswd_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "IASWD", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_iaswd_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_iaswd_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_iaswd_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_iaswd_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.max_duration = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MaxDuration", &force_update.max_duration },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_iaswd_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "IASWD/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_iaswd_max_duration_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1282,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1282,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "IASWD/Attributes/MaxDuration", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/IASWD/Attributes/MaxDuration";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_iaswd_max_duration_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/IASWD/Attributes/MaxDuration";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_iaswd_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_iaswd_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "IASWD/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_iaswd_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_iaswd_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "IASWD/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_iaswd_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_iaswd_start_warning_callback.empty()) {
    subscription_topic = base_topic + "IASWD/Commands/StartWarning";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_iaswd_start_warning);
  }
  if (!uic_mqtt_dotdot_iaswd_generated_start_warning_callback.empty()) {
    subscription_topic = base_topic + "IASWD/GeneratedCommands/StartWarning";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_iaswd_start_warning);
  }
  if (!uic_mqtt_dotdot_iaswd_squawk_callback.empty()) {
    subscription_topic = base_topic + "IASWD/Commands/Squawk";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_iaswd_squawk);
  }
  if (!uic_mqtt_dotdot_iaswd_generated_squawk_callback.empty()) {
    subscription_topic = base_topic + "IASWD/GeneratedCommands/Squawk";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_iaswd_squawk);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_iaswd_attributes_init();

  uic_mqtt_dotdot_by_group_iaswd_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_metering_write_attributes_callback_t> uic_mqtt_dotdot_metering_write_attributes_callback;
static std::set<uic_mqtt_dotdot_metering_force_read_attributes_callback_t> uic_mqtt_dotdot_metering_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_metering_write_attributes_callback(
  const uic_mqtt_dotdot_metering_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_metering_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_metering_write_attributes_callback(
  const uic_mqtt_dotdot_metering_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_metering_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_metering_write_attributes_callbacks()
{
  uic_mqtt_dotdot_metering_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_metering_write_attributes_callback_t>& get_uic_mqtt_dotdot_metering_write_attributes_callback()
{
  return uic_mqtt_dotdot_metering_write_attributes_callback;
}

void uic_mqtt_dotdot_set_metering_force_read_attributes_callback(
  const uic_mqtt_dotdot_metering_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_metering_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_metering_force_read_attributes_callback(
  const uic_mqtt_dotdot_metering_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_metering_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_metering_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_metering_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Metering/Commands/WriteAttributes
void uic_mqtt_dotdot_on_metering_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_metering_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_metering_state_t new_state = {};
  uic_mqtt_dotdot_metering_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_metering_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Metering", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_metering_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_metering_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_metering_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_metering_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.current_summation_delivered = true;
      force_update.current_summation_received = true;
      force_update.current_max_demand_delivered = true;
      force_update.current_max_demand_received = true;
      force_update.power_factor = true;
      force_update.reading_snap_shot_time = true;
      force_update.current_max_demand_delivered_time = true;
      force_update.current_max_demand_received_time = true;
      force_update.default_update_period = true;
      force_update.supply_status = true;
      force_update.current_inlet_energy_carrier_summation = true;
      force_update.current_outlet_energy_carrier_summation = true;
      force_update.inlet_temperature = true;
      force_update.outlet_temperature = true;
      force_update.unitof_measure = true;
      force_update.multiplier = true;
      force_update.divisor = true;
      force_update.summation_formatting = true;
      force_update.demand_formatting = true;
      force_update.historical_consumption_formatting = true;
      force_update.metering_device_type = true;
      force_update.energy_carrier_unit_of_measure = true;
      force_update.energy_carrier_summation_formatting = true;
      force_update.energy_carrier_demand_formatting = true;
      force_update.temperature_unit_of_measure = true;
      force_update.temperature_formatting = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"CurrentSummationDelivered", &force_update.current_summation_delivered },
        {"CurrentSummationReceived", &force_update.current_summation_received },
        {"CurrentMaxDemandDelivered", &force_update.current_max_demand_delivered },
        {"CurrentMaxDemandReceived", &force_update.current_max_demand_received },
        {"PowerFactor", &force_update.power_factor },
        {"ReadingSnapShotTime", &force_update.reading_snap_shot_time },
        {"CurrentMaxDemandDeliveredTime", &force_update.current_max_demand_delivered_time },
        {"CurrentMaxDemandReceivedTime", &force_update.current_max_demand_received_time },
        {"DefaultUpdatePeriod", &force_update.default_update_period },
        {"SupplyStatus", &force_update.supply_status },
        {"CurrentInletEnergyCarrierSummation", &force_update.current_inlet_energy_carrier_summation },
        {"CurrentOutletEnergyCarrierSummation", &force_update.current_outlet_energy_carrier_summation },
        {"InletTemperature", &force_update.inlet_temperature },
        {"OutletTemperature", &force_update.outlet_temperature },
        {"UnitofMeasure", &force_update.unitof_measure },
        {"Multiplier", &force_update.multiplier },
        {"Divisor", &force_update.divisor },
        {"SummationFormatting", &force_update.summation_formatting },
        {"DemandFormatting", &force_update.demand_formatting },
        {"HistoricalConsumptionFormatting", &force_update.historical_consumption_formatting },
        {"MeteringDeviceType", &force_update.metering_device_type },
        {"EnergyCarrierUnitOfMeasure", &force_update.energy_carrier_unit_of_measure },
        {"EnergyCarrierSummationFormatting", &force_update.energy_carrier_summation_formatting },
        {"EnergyCarrierDemandFormatting", &force_update.energy_carrier_demand_formatting },
        {"TemperatureUnitOfMeasure", &force_update.temperature_unit_of_measure },
        {"TemperatureFormatting", &force_update.temperature_formatting },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_metering_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Metering/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_metering_current_summation_delivered_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentSummationDelivered", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentSummationDelivered";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_current_summation_delivered_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/CurrentSummationDelivered";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_current_summation_received_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentSummationReceived", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentSummationReceived";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_current_summation_received_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/CurrentSummationReceived";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_current_max_demand_delivered_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentMaxDemandDelivered", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentMaxDemandDelivered";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_current_max_demand_delivered_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/CurrentMaxDemandDelivered";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_current_max_demand_received_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentMaxDemandReceived", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentMaxDemandReceived";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_current_max_demand_received_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/CurrentMaxDemandReceived";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_power_factor_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,6,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,6,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/PowerFactor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/PowerFactor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_power_factor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/PowerFactor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_reading_snap_shot_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,7,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,7,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/ReadingSnapShotTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/ReadingSnapShotTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_reading_snap_shot_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/ReadingSnapShotTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_current_max_demand_delivered_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,8,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,8,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentMaxDemandDeliveredTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentMaxDemandDeliveredTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_current_max_demand_delivered_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/CurrentMaxDemandDeliveredTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_current_max_demand_received_time_publish(
  const char *base_topic,
  UTC value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,9,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,9,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentMaxDemandReceivedTime", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentMaxDemandReceivedTime";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_current_max_demand_received_time_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/CurrentMaxDemandReceivedTime";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_default_update_period_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,10,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,10,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/DefaultUpdatePeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/DefaultUpdatePeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_default_update_period_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/DefaultUpdatePeriod";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_supply_status_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef METERING_SUPPLY_STATUS_ENUM_NAME_AVAILABLE
  jsn["value"] = metering_supply_status_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for METERING_SUPPLY_STATUS. Using number instead.");
  jsn["value"] = static_cast<MeteringSupplyStatus>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/SupplyStatus", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/SupplyStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_supply_status_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/SupplyStatus";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_current_inlet_energy_carrier_summation_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,21,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,21,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentInletEnergyCarrierSummation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentInletEnergyCarrierSummation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_current_inlet_energy_carrier_summation_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/CurrentInletEnergyCarrierSummation";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_current_outlet_energy_carrier_summation_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,22,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,22,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/CurrentOutletEnergyCarrierSummation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/CurrentOutletEnergyCarrierSummation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_current_outlet_energy_carrier_summation_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/CurrentOutletEnergyCarrierSummation";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_inlet_temperature_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,23,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,23,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/InletTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/InletTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_inlet_temperature_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/InletTemperature";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_outlet_temperature_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,24,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,24,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/OutletTemperature", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/OutletTemperature";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_outlet_temperature_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/OutletTemperature";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_unitof_measure_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef METERING_UNITOF_MEASURE_ENUM_NAME_AVAILABLE
  jsn["value"] = metering_unitof_measure_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for METERING_UNITOF_MEASURE. Using number instead.");
  jsn["value"] = static_cast<MeteringUnitofMeasure>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/UnitofMeasure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/UnitofMeasure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_unitof_measure_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/UnitofMeasure";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_multiplier_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,769,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,769,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/Multiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/Multiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/Multiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_divisor_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(1794,770,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(1794,770,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/Divisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/Divisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_divisor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/Divisor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_summation_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringSummationFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/SummationFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/SummationFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_summation_formatting_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/SummationFormatting";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_demand_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringDemandFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/DemandFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/DemandFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_demand_formatting_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/DemandFormatting";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_historical_consumption_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringHistoricalConsumptionFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/HistoricalConsumptionFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/HistoricalConsumptionFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_historical_consumption_formatting_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/HistoricalConsumptionFormatting";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_metering_device_type_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef METERING_METERING_DEVICE_TYPE_ENUM_NAME_AVAILABLE
  jsn["value"] = metering_metering_device_type_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for METERING_METERING_DEVICE_TYPE. Using number instead.");
  jsn["value"] = static_cast<MeteringMeteringDeviceType>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/MeteringDeviceType", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/MeteringDeviceType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_metering_device_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/MeteringDeviceType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_energy_carrier_unit_of_measure_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef METERING_ENERGY_CARRIER_UNIT_OF_MEASURE_ENUM_NAME_AVAILABLE
  jsn["value"] = metering_energy_carrier_unit_of_measure_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for METERING_ENERGY_CARRIER_UNIT_OF_MEASURE. Using number instead.");
  jsn["value"] = static_cast<MeteringEnergyCarrierUnitOfMeasure>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/EnergyCarrierUnitOfMeasure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/EnergyCarrierUnitOfMeasure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_energy_carrier_unit_of_measure_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/EnergyCarrierUnitOfMeasure";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_energy_carrier_summation_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringEnergyCarrierSummationFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/EnergyCarrierSummationFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/EnergyCarrierSummationFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_energy_carrier_summation_formatting_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/EnergyCarrierSummationFormatting";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_energy_carrier_demand_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringEnergyCarrierDemandFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/EnergyCarrierDemandFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/EnergyCarrierDemandFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_energy_carrier_demand_formatting_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/EnergyCarrierDemandFormatting";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_temperature_unit_of_measure_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef METERING_TEMPERATURE_UNIT_OF_MEASURE_ENUM_NAME_AVAILABLE
  jsn["value"] = metering_temperature_unit_of_measure_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for METERING_TEMPERATURE_UNIT_OF_MEASURE. Using number instead.");
  jsn["value"] = static_cast<MeteringTemperatureUnitOfMeasure>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/TemperatureUnitOfMeasure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Metering/Attributes/TemperatureUnitOfMeasure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_temperature_unit_of_measure_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/TemperatureUnitOfMeasure";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_metering_temperature_formatting_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = MeteringTemperatureFormatting.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Metering/Attributes/TemperatureFormatting", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/Metering/Attributes/TemperatureFormatting";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_metering_temperature_formatting_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Metering/Attributes/TemperatureFormatting";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_metering_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_metering_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Metering/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_metering_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_metering_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Metering/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_metering_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_metering_attributes_init();

  uic_mqtt_dotdot_by_group_metering_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t> uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback;
static std::set<uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t> uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback;
static std::set<uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t> uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback;
static std::set<uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t> uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback;
static std::set<uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t> uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback;
static std::set<uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t> uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback;
static std::set<uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t> uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback;
static std::set<uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t> uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback;
static std::set<uic_mqtt_dotdot_electrical_measurement_write_attributes_callback_t> uic_mqtt_dotdot_electrical_measurement_write_attributes_callback;
static std::set<uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback_t> uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_unset(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback.erase(callback);
}
void uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_clear()
{
  uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback.clear();
}
std::set<uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t>& get_uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback()
{
  return uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback;
}

void uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback_unset(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback.erase(callback);
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback_clear()
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback.clear();
}
void uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_unset(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback.erase(callback);
}
void uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_clear()
{
  uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback.clear();
}
std::set<uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t>& get_uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback()
{
  return uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback;
}

void uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback_unset(const uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback.erase(callback);
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback_clear()
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback.clear();
}
void uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_unset(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback.erase(callback);
}
void uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_clear()
{
  uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback.clear();
}
std::set<uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t>& get_uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback()
{
  return uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback;
}

void uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback_unset(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback.erase(callback);
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback_clear()
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback.clear();
}
void uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_unset(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback.erase(callback);
}
void uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_clear()
{
  uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback.clear();
}
std::set<uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t>& get_uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback()
{
  return uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback;
}

void uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback_set(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback_unset(const uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback.erase(callback);
}
void uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback_clear()
{
  uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback.clear();
}

void uic_mqtt_dotdot_set_electrical_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_electrical_measurement_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_measurement_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_electrical_measurement_write_attributes_callback(
  const uic_mqtt_dotdot_electrical_measurement_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_electrical_measurement_write_attributes_callbacks()
{
  uic_mqtt_dotdot_electrical_measurement_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_electrical_measurement_write_attributes_callback_t>& get_uic_mqtt_dotdot_electrical_measurement_write_attributes_callback()
{
  return uic_mqtt_dotdot_electrical_measurement_write_attributes_callback;
}

void uic_mqtt_dotdot_set_electrical_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_electrical_measurement_force_read_attributes_callback(
  const uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_electrical_measurement_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/Commands/GetProfileInfoResponse
void uic_mqtt_dotdot_on_electrical_measurement_get_profile_info_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t profile_count = {};
  ProfileIntervalPeriod profile_interval_period = {};
  uint8_t max_number_of_intervals = {};
  std::vector<uint16_t> list_of_attributes;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_profile_info_response(
      jsn,
      profile_count,

      profile_interval_period,

      max_number_of_intervals,

      list_of_attributes
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetProfileInfoResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfoResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfoResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      profile_count,
  
      profile_interval_period,
  
      max_number_of_intervals,
  
      list_of_attributes.size(),
      list_of_attributes.data()

    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/GeneratedCommands/GetProfileInfoResponse
static void uic_mqtt_dotdot_on_generated_electrical_measurement_get_profile_info_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint8_t profile_count = {};
  ProfileIntervalPeriod profile_interval_period = {};
  uint8_t max_number_of_intervals = {};
  std::vector<uint16_t> list_of_attributes;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_profile_info_response(
      jsn,
      profile_count,

      profile_interval_period,

      max_number_of_intervals,

      list_of_attributes
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetProfileInfoResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfoResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfoResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      profile_count,
  
      profile_interval_period,
  
      max_number_of_intervals,
  
      list_of_attributes.size(),
      list_of_attributes.data()

    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/Commands/GetProfileInfo
void uic_mqtt_dotdot_on_electrical_measurement_get_profile_info(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetProfileInfo");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfo", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfo", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/GeneratedCommands/GetProfileInfo
static void uic_mqtt_dotdot_on_generated_electrical_measurement_get_profile_info(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetProfileInfo");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfo", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetProfileInfo", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/Commands/GetMeasurementProfileResponse
void uic_mqtt_dotdot_on_electrical_measurement_get_measurement_profile_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  UTC start_time = {};
  GetMeasurementProfileResponseStatus status = {};
  ProfileIntervalPeriod profile_interval_period = {};
  uint8_t number_of_intervals_delivered = {};
  uint16_t attribute_id = {};
  std::vector<uint8_t> intervals;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile_response(
      jsn,
      start_time,

      status,

      profile_interval_period,

      number_of_intervals_delivered,

      attribute_id,

      intervals
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetMeasurementProfileResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfileResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfileResponse", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      start_time,
  
      status,
  
      profile_interval_period,
  
      number_of_intervals_delivered,
  
      attribute_id,
  
      intervals.size(),
      intervals.data()

    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/GeneratedCommands/GetMeasurementProfileResponse
static void uic_mqtt_dotdot_on_generated_electrical_measurement_get_measurement_profile_response(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  UTC start_time = {};
  GetMeasurementProfileResponseStatus status = {};
  ProfileIntervalPeriod profile_interval_period = {};
  uint8_t number_of_intervals_delivered = {};
  uint16_t attribute_id = {};
  std::vector<uint8_t> intervals;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile_response(
      jsn,
      start_time,

      status,

      profile_interval_period,

      number_of_intervals_delivered,

      attribute_id,

      intervals
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetMeasurementProfileResponse");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfileResponse", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfileResponse", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      start_time,
  
      status,
  
      profile_interval_period,
  
      number_of_intervals_delivered,
  
      attribute_id,
  
      intervals.size(),
      intervals.data()

    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/Commands/GetMeasurementProfile
void uic_mqtt_dotdot_on_electrical_measurement_get_measurement_profile(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t attributeid = {};
  UTC start_time = {};
  uint8_t number_of_intervals = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile(
      jsn,
      attributeid,

      start_time,

      number_of_intervals
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetMeasurementProfile");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfile", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfile", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      attributeid,
  
      start_time,
  
      number_of_intervals
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/GeneratedCommands/GetMeasurementProfile
static void uic_mqtt_dotdot_on_generated_electrical_measurement_get_measurement_profile(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t attributeid = {};
  UTC start_time = {};
  uint8_t number_of_intervals = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_electrical_measurement_get_measurement_profile(
      jsn,
      attributeid,

      start_time,

      number_of_intervals
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "GetMeasurementProfile");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfile", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "GetMeasurementProfile", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      attributeid,
  
      start_time,
  
      number_of_intervals
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ElectricalMeasurement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_electrical_measurement_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_electrical_measurement_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_electrical_measurement_state_t new_state = {};
  uic_mqtt_dotdot_electrical_measurement_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_electrical_measurement_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ElectricalMeasurement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_electrical_measurement_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_electrical_measurement_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.measurement_type = true;
      force_update.dc_voltage = true;
      force_update.dc_voltage_min = true;
      force_update.dc_voltage_max = true;
      force_update.dc_current = true;
      force_update.dc_current_min = true;
      force_update.dc_current_max = true;
      force_update.dc_power = true;
      force_update.dc_power_min = true;
      force_update.dc_power_max = true;
      force_update.dc_voltage_multiplier = true;
      force_update.dc_voltage_divisor = true;
      force_update.dc_current_multiplier = true;
      force_update.dc_current_divisor = true;
      force_update.dc_power_multiplier = true;
      force_update.dc_power_divisor = true;
      force_update.ac_frequency = true;
      force_update.ac_frequency_min = true;
      force_update.ac_frequency_max = true;
      force_update.neutral_current = true;
      force_update.total_active_power = true;
      force_update.total_reactive_power = true;
      force_update.total_apparent_power = true;
      force_update.measured1st_harmonic_current = true;
      force_update.measured3rd_harmonic_current = true;
      force_update.measured5th_harmonic_current = true;
      force_update.measured7th_harmonic_current = true;
      force_update.measured9th_harmonic_current = true;
      force_update.measured11th_harmonic_current = true;
      force_update.measured_phase1st_harmonic_current = true;
      force_update.measured_phase3rd_harmonic_current = true;
      force_update.measured_phase5th_harmonic_current = true;
      force_update.measured_phase7th_harmonic_current = true;
      force_update.measured_phase9th_harmonic_current = true;
      force_update.measured_phase11th_harmonic_current = true;
      force_update.ac_frequency_multiplier = true;
      force_update.ac_frequency_divisor = true;
      force_update.power_multiplier = true;
      force_update.power_divisor = true;
      force_update.harmonic_current_multiplier = true;
      force_update.phase_harmonic_current_multiplier = true;
      force_update.line_current = true;
      force_update.active_current = true;
      force_update.reactive_current = true;
      force_update.rms_voltage = true;
      force_update.rms_voltage_min = true;
      force_update.rms_voltage_max = true;
      force_update.rms_current = true;
      force_update.rms_current_min = true;
      force_update.rms_current_max = true;
      force_update.active_power = true;
      force_update.active_power_min = true;
      force_update.active_power_max = true;
      force_update.reactive_power = true;
      force_update.apparent_power = true;
      force_update.power_factor = true;
      force_update.average_rms_voltage_measurement_period = true;
      force_update.average_rms_over_voltage_counter = true;
      force_update.average_rms_under_voltage_counter = true;
      force_update.rms_extreme_over_voltage_period = true;
      force_update.rms_extreme_under_voltage_period = true;
      force_update.rms_voltage_sag_period = true;
      force_update.rms_voltage_swell_period = true;
      force_update.ac_voltage_multiplier = true;
      force_update.ac_voltage_divisor = true;
      force_update.ac_current_multiplier = true;
      force_update.ac_current_divisor = true;
      force_update.ac_power_multiplier = true;
      force_update.ac_power_divisor = true;
      force_update.dc_overload_alarms_mask = true;
      force_update.dc_voltage_overload = true;
      force_update.dc_current_overload = true;
      force_update.ac_alarms_mask = true;
      force_update.ac_voltage_overload = true;
      force_update.ac_current_overload = true;
      force_update.ac_active_power_overload = true;
      force_update.ac_reactive_power_overload = true;
      force_update.average_rms_over_voltage = true;
      force_update.average_rms_under_voltage = true;
      force_update.rms_extreme_over_voltage = true;
      force_update.rms_extreme_under_voltage = true;
      force_update.rms_voltage_sag = true;
      force_update.rms_voltage_swell = true;
      force_update.line_current_phb = true;
      force_update.active_current_phb = true;
      force_update.reactive_current_phb = true;
      force_update.rms_voltage_phb = true;
      force_update.rms_voltage_min_phb = true;
      force_update.rms_voltage_max_phb = true;
      force_update.rms_current_phb = true;
      force_update.rms_current_min_phb = true;
      force_update.rms_current_max_phb = true;
      force_update.active_power_phb = true;
      force_update.active_power_min_phb = true;
      force_update.active_power_max_phb = true;
      force_update.reactive_power_phb = true;
      force_update.apparent_power_phb = true;
      force_update.power_factor_phb = true;
      force_update.average_rms_voltage_measurement_period_phb = true;
      force_update.average_rms_over_voltage_counter_phb = true;
      force_update.average_rms_under_voltage_counter_phb = true;
      force_update.rms_extreme_over_voltage_period_phb = true;
      force_update.rms_extreme_under_voltage_period_phb = true;
      force_update.rms_voltage_sag_period_phb = true;
      force_update.rms_voltage_swell_period_phb = true;
      force_update.line_current_phc = true;
      force_update.active_current_phc = true;
      force_update.reactive_current_phc = true;
      force_update.rms_voltage_phc = true;
      force_update.rms_voltage_min_phc = true;
      force_update.rms_voltage_max_phc = true;
      force_update.rms_current_phc = true;
      force_update.rms_current_min_phc = true;
      force_update.rms_current_max_phc = true;
      force_update.active_power_phc = true;
      force_update.active_power_min_phc = true;
      force_update.active_power_max_phc = true;
      force_update.reactive_power_phc = true;
      force_update.apparent_power_phc = true;
      force_update.power_factor_phc = true;
      force_update.average_rms_voltage_measurement_period_phc = true;
      force_update.average_rms_over_voltage_counter_phc = true;
      force_update.average_rms_under_voltage_counter_phc = true;
      force_update.rms_extreme_over_voltage_period_phc = true;
      force_update.rms_extreme_under_voltage_period_phc = true;
      force_update.rms_voltage_sag_period_phc = true;
      force_update.rms_voltage_swell_period_phc = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"MeasurementType", &force_update.measurement_type },
        {"DCVoltage", &force_update.dc_voltage },
        {"DCVoltageMin", &force_update.dc_voltage_min },
        {"DCVoltageMax", &force_update.dc_voltage_max },
        {"DCCurrent", &force_update.dc_current },
        {"DCCurrentMin", &force_update.dc_current_min },
        {"DCCurrentMax", &force_update.dc_current_max },
        {"DCPower", &force_update.dc_power },
        {"DCPowerMin", &force_update.dc_power_min },
        {"DCPowerMax", &force_update.dc_power_max },
        {"DCVoltageMultiplier", &force_update.dc_voltage_multiplier },
        {"DCVoltageDivisor", &force_update.dc_voltage_divisor },
        {"DCCurrentMultiplier", &force_update.dc_current_multiplier },
        {"DCCurrentDivisor", &force_update.dc_current_divisor },
        {"DCPowerMultiplier", &force_update.dc_power_multiplier },
        {"DCPowerDivisor", &force_update.dc_power_divisor },
        {"ACFrequency", &force_update.ac_frequency },
        {"ACFrequencyMin", &force_update.ac_frequency_min },
        {"ACFrequencyMax", &force_update.ac_frequency_max },
        {"NeutralCurrent", &force_update.neutral_current },
        {"TotalActivePower", &force_update.total_active_power },
        {"TotalReactivePower", &force_update.total_reactive_power },
        {"TotalApparentPower", &force_update.total_apparent_power },
        {"Measured1stHarmonicCurrent", &force_update.measured1st_harmonic_current },
        {"Measured3rdHarmonicCurrent", &force_update.measured3rd_harmonic_current },
        {"Measured5thHarmonicCurrent", &force_update.measured5th_harmonic_current },
        {"Measured7thHarmonicCurrent", &force_update.measured7th_harmonic_current },
        {"Measured9thHarmonicCurrent", &force_update.measured9th_harmonic_current },
        {"Measured11thHarmonicCurrent", &force_update.measured11th_harmonic_current },
        {"MeasuredPhase1stHarmonicCurrent", &force_update.measured_phase1st_harmonic_current },
        {"MeasuredPhase3rdHarmonicCurrent", &force_update.measured_phase3rd_harmonic_current },
        {"MeasuredPhase5thHarmonicCurrent", &force_update.measured_phase5th_harmonic_current },
        {"MeasuredPhase7thHarmonicCurrent", &force_update.measured_phase7th_harmonic_current },
        {"MeasuredPhase9thHarmonicCurrent", &force_update.measured_phase9th_harmonic_current },
        {"MeasuredPhase11thHarmonicCurrent", &force_update.measured_phase11th_harmonic_current },
        {"ACFrequencyMultiplier", &force_update.ac_frequency_multiplier },
        {"ACFrequencyDivisor", &force_update.ac_frequency_divisor },
        {"PowerMultiplier", &force_update.power_multiplier },
        {"PowerDivisor", &force_update.power_divisor },
        {"HarmonicCurrentMultiplier", &force_update.harmonic_current_multiplier },
        {"PhaseHarmonicCurrentMultiplier", &force_update.phase_harmonic_current_multiplier },
        {"LineCurrent", &force_update.line_current },
        {"ActiveCurrent", &force_update.active_current },
        {"ReactiveCurrent", &force_update.reactive_current },
        {"RMSVoltage", &force_update.rms_voltage },
        {"RMSVoltageMin", &force_update.rms_voltage_min },
        {"RMSVoltageMax", &force_update.rms_voltage_max },
        {"RMSCurrent", &force_update.rms_current },
        {"RMSCurrentMin", &force_update.rms_current_min },
        {"RMSCurrentMax", &force_update.rms_current_max },
        {"ActivePower", &force_update.active_power },
        {"ActivePowerMin", &force_update.active_power_min },
        {"ActivePowerMax", &force_update.active_power_max },
        {"ReactivePower", &force_update.reactive_power },
        {"ApparentPower", &force_update.apparent_power },
        {"PowerFactor", &force_update.power_factor },
        {"AverageRMSVoltageMeasurementPeriod", &force_update.average_rms_voltage_measurement_period },
        {"AverageRMSOverVoltageCounter", &force_update.average_rms_over_voltage_counter },
        {"AverageRMSUnderVoltageCounter", &force_update.average_rms_under_voltage_counter },
        {"RMSExtremeOverVoltagePeriod", &force_update.rms_extreme_over_voltage_period },
        {"RMSExtremeUnderVoltagePeriod", &force_update.rms_extreme_under_voltage_period },
        {"RMSVoltageSagPeriod", &force_update.rms_voltage_sag_period },
        {"RMSVoltageSwellPeriod", &force_update.rms_voltage_swell_period },
        {"ACVoltageMultiplier", &force_update.ac_voltage_multiplier },
        {"ACVoltageDivisor", &force_update.ac_voltage_divisor },
        {"ACCurrentMultiplier", &force_update.ac_current_multiplier },
        {"ACCurrentDivisor", &force_update.ac_current_divisor },
        {"ACPowerMultiplier", &force_update.ac_power_multiplier },
        {"ACPowerDivisor", &force_update.ac_power_divisor },
        {"DCOverloadAlarmsMask", &force_update.dc_overload_alarms_mask },
        {"DCVoltageOverload", &force_update.dc_voltage_overload },
        {"DCCurrentOverload", &force_update.dc_current_overload },
        {"ACAlarmsMask", &force_update.ac_alarms_mask },
        {"ACVoltageOverload", &force_update.ac_voltage_overload },
        {"ACCurrentOverload", &force_update.ac_current_overload },
        {"ACActivePowerOverload", &force_update.ac_active_power_overload },
        {"ACReactivePowerOverload", &force_update.ac_reactive_power_overload },
        {"AverageRMSOverVoltage", &force_update.average_rms_over_voltage },
        {"AverageRMSUnderVoltage", &force_update.average_rms_under_voltage },
        {"RMSExtremeOverVoltage", &force_update.rms_extreme_over_voltage },
        {"RMSExtremeUnderVoltage", &force_update.rms_extreme_under_voltage },
        {"RMSVoltageSag", &force_update.rms_voltage_sag },
        {"RMSVoltageSwell", &force_update.rms_voltage_swell },
        {"LineCurrentPhB", &force_update.line_current_phb },
        {"ActiveCurrentPhB", &force_update.active_current_phb },
        {"ReactiveCurrentPhB", &force_update.reactive_current_phb },
        {"RMSVoltagePhB", &force_update.rms_voltage_phb },
        {"RMSVoltageMinPhB", &force_update.rms_voltage_min_phb },
        {"RMSVoltageMaxPhB", &force_update.rms_voltage_max_phb },
        {"RMSCurrentPhB", &force_update.rms_current_phb },
        {"RMSCurrentMinPhB", &force_update.rms_current_min_phb },
        {"RMSCurrentMaxPhB", &force_update.rms_current_max_phb },
        {"ActivePowerPhB", &force_update.active_power_phb },
        {"ActivePowerMinPhB", &force_update.active_power_min_phb },
        {"ActivePowerMaxPhB", &force_update.active_power_max_phb },
        {"ReactivePowerPhB", &force_update.reactive_power_phb },
        {"ApparentPowerPhB", &force_update.apparent_power_phb },
        {"PowerFactorPhB", &force_update.power_factor_phb },
        {"AverageRMSVoltageMeasurementPeriodPhB", &force_update.average_rms_voltage_measurement_period_phb },
        {"AverageRMSOverVoltageCounterPhB", &force_update.average_rms_over_voltage_counter_phb },
        {"AverageRMSUnderVoltageCounterPhB", &force_update.average_rms_under_voltage_counter_phb },
        {"RMSExtremeOverVoltagePeriodPhB", &force_update.rms_extreme_over_voltage_period_phb },
        {"RMSExtremeUnderVoltagePeriodPhB", &force_update.rms_extreme_under_voltage_period_phb },
        {"RMSVoltageSagPeriodPhB", &force_update.rms_voltage_sag_period_phb },
        {"RMSVoltageSwellPeriodPhB", &force_update.rms_voltage_swell_period_phb },
        {"LineCurrentPhC", &force_update.line_current_phc },
        {"ActiveCurrentPhC", &force_update.active_current_phc },
        {"ReactiveCurrentPhC", &force_update.reactive_current_phc },
        {"RMSVoltagePhC", &force_update.rms_voltage_phc },
        {"RMSVoltageMinPhC", &force_update.rms_voltage_min_phc },
        {"RMSVoltageMaxPhC", &force_update.rms_voltage_max_phc },
        {"RMSCurrentPhC", &force_update.rms_current_phc },
        {"RMSCurrentMinPhC", &force_update.rms_current_min_phc },
        {"RMSCurrentMaxPhC", &force_update.rms_current_max_phc },
        {"ActivePowerPhC", &force_update.active_power_phc },
        {"ActivePowerMinPhC", &force_update.active_power_min_phc },
        {"ActivePowerMaxPhC", &force_update.active_power_max_phc },
        {"ReactivePowerPhC", &force_update.reactive_power_phc },
        {"ApparentPowerPhC", &force_update.apparent_power_phc },
        {"PowerFactorPhC", &force_update.power_factor_phc },
        {"AverageRMSVoltageMeasurementPeriodPhC", &force_update.average_rms_voltage_measurement_period_phc },
        {"AverageRMSOverVoltageCounterPhC", &force_update.average_rms_over_voltage_counter_phc },
        {"AverageRMSUnderVoltageCounterPhC", &force_update.average_rms_under_voltage_counter_phc },
        {"RMSExtremeOverVoltagePeriodPhC", &force_update.rms_extreme_over_voltage_period_phc },
        {"RMSExtremeUnderVoltagePeriodPhC", &force_update.rms_extreme_under_voltage_period_phc },
        {"RMSVoltageSagPeriodPhC", &force_update.rms_voltage_sag_period_phc },
        {"RMSVoltageSwellPeriodPhC", &force_update.rms_voltage_swell_period_phc },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "ElectricalMeasurement/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measurement_type_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ElectricalMeasurementMeasurementType.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasurementType", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasurementType";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measurement_type_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/MeasurementType";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,256,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,256,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,257,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,257,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltageMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltageMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCVoltageMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,258,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,258,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltageMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltageMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_max_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCVoltageMax";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,259,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,259,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,260,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,260,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrentMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrentMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCCurrentMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,261,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,261,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrentMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrentMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_max_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCCurrentMax";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,262,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,262,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCPower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCPower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCPower";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,263,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,263,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCPowerMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCPowerMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCPowerMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,264,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,264,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCPowerMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCPowerMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_max_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCPowerMax";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,512,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,512,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltageMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltageMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCVoltageMultiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,513,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,513,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltageDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltageDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_divisor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCVoltageDivisor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,514,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,514,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrentMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrentMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCCurrentMultiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,515,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,515,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrentDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrentDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_divisor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCCurrentDivisor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,516,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,516,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCPowerMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCPowerMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCPowerMultiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,517,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,517,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCPowerDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCPowerDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_power_divisor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCPowerDivisor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,768,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,768,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACFrequency", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACFrequency";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACFrequency";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_min_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,769,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,769,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACFrequencyMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACFrequencyMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACFrequencyMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,770,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,770,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACFrequencyMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACFrequencyMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_max_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACFrequencyMax";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_neutral_current_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,771,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,771,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/NeutralCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/NeutralCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_neutral_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/NeutralCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_total_active_power_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,772,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,772,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/TotalActivePower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/TotalActivePower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_total_active_power_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/TotalActivePower";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_total_reactive_power_publish(
  const char *base_topic,
  int32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,773,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,773,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/TotalReactivePower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/TotalReactivePower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_total_reactive_power_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/TotalReactivePower";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_total_apparent_power_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,774,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,774,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/TotalApparentPower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/TotalApparentPower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_total_apparent_power_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/TotalApparentPower";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured1st_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,775,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,775,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured1stHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured1stHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured1st_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/Measured1stHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured3rd_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,776,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,776,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured3rdHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured3rdHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured3rd_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/Measured3rdHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured5th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,777,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,777,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured5thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured5thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured5th_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/Measured5thHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured7th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,778,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,778,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured7thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured7thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured7th_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/Measured7thHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured9th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,779,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,779,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured9thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured9thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured9th_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/Measured9thHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured11th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,780,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,780,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/Measured11thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/Measured11thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured11th_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/Measured11thHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase1st_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,781,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,781,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase1stHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase1stHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase1st_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/MeasuredPhase1stHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase3rd_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,782,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,782,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase3rdHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase3rdHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase3rd_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/MeasuredPhase3rdHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase5th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,783,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,783,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase5thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase5thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase5th_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/MeasuredPhase5thHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase7th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,784,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,784,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase7thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase7thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase7th_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/MeasuredPhase7thHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase9th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,785,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,785,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase9thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase9thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase9th_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/MeasuredPhase9thHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase11th_harmonic_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,786,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,786,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/MeasuredPhase11thHarmonicCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/MeasuredPhase11thHarmonicCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_measured_phase11th_harmonic_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/MeasuredPhase11thHarmonicCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1024,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1024,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACFrequencyMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACFrequencyMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACFrequencyMultiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1025,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1025,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACFrequencyDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACFrequencyDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_frequency_divisor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACFrequencyDivisor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_power_multiplier_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1026,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1026,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PowerMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PowerMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_power_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/PowerMultiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_power_divisor_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1027,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1027,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PowerDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PowerDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_power_divisor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/PowerDivisor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_harmonic_current_multiplier_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1028,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1028,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/HarmonicCurrentMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/HarmonicCurrentMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_harmonic_current_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/HarmonicCurrentMultiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_phase_harmonic_current_multiplier_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1029,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1029,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PhaseHarmonicCurrentMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PhaseHarmonicCurrentMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_phase_harmonic_current_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/PhaseHarmonicCurrentMultiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1281,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1281,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/LineCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/LineCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/LineCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1282,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1282,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActiveCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActiveCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActiveCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1283,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1283,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactiveCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactiveCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ReactiveCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1285,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1285,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1286,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1286,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1287,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1287,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageMax";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1288,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1288,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSCurrent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1289,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1289,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSCurrentMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1290,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1290,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSCurrentMax";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1291,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1291,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActivePower";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1292,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1292,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMin", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMin";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActivePowerMin";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1293,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1293,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMax", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMax";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActivePowerMax";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1294,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1294,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactivePower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactivePower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ReactivePower";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1295,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1295,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ApparentPower", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ApparentPower";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ApparentPower";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1296,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1296,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PowerFactor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PowerFactor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/PowerFactor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1297,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1297,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriod";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1298,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1298,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounter", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounter";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounter";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1299,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1299,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounter", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounter";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounter";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1300,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1300,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriod";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1301,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1301,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriod";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1302,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1302,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSagPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSagPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageSagPeriod";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1303,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1303,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSwellPeriod", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSwellPeriod";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageSwellPeriod";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1536,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1536,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACVoltageMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACVoltageMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACVoltageMultiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1537,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1537,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACVoltageDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACVoltageDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_divisor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACVoltageDivisor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1538,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1538,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACCurrentMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACCurrentMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACCurrentMultiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1539,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1539,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACCurrentDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACCurrentDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_divisor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACCurrentDivisor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_power_multiplier_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1540,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1540,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACPowerMultiplier", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACPowerMultiplier";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_power_multiplier_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACPowerMultiplier";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_power_divisor_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1541,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1541,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACPowerDivisor", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACPowerDivisor";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_power_divisor_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACPowerDivisor";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_overload_alarms_mask_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ElectricalMeasurementDCOverloadAlarmsMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCOverloadAlarmsMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCOverloadAlarmsMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_overload_alarms_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCOverloadAlarmsMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1793,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1793,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCVoltageOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCVoltageOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_voltage_overload_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCVoltageOverload";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,1794,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,1794,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/DCCurrentOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/DCCurrentOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_dc_current_overload_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/DCCurrentOverload";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_alarms_mask_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json bitmap_values = ElectricalMeasurementACAlarmsMask.get_bitmap_values_as_json_tree((uint32_t)value);
  jsn["value"] = bitmap_values;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACAlarmsMask", e.what());
    return SL_STATUS_OK;
  }

  boost::replace_all(payload_str, "\"true\"", "true");
  boost::replace_all(payload_str, "\"false\"", "false");

  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACAlarmsMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_alarms_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACAlarmsMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2049,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2049,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACVoltageOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACVoltageOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_voltage_overload_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACVoltageOverload";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2050,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2050,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACCurrentOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACCurrentOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_current_overload_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACCurrentOverload";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_active_power_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2051,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2051,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACActivePowerOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACActivePowerOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_active_power_overload_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACActivePowerOverload";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_reactive_power_overload_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2052,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2052,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ACReactivePowerOverload", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ACReactivePowerOverload";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_ac_reactive_power_overload_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ACReactivePowerOverload";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2053,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2053,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSOverVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2054,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2054,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSUnderVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2055,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2055,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeOverVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2056,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2056,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2057,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2057,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSag", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSag";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageSag";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2058,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2058,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSwell", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSwell";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageSwell";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2305,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2305,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/LineCurrentPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/LineCurrentPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/LineCurrentPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2306,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2306,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActiveCurrentPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActiveCurrentPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActiveCurrentPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2307,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2307,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactiveCurrentPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactiveCurrentPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ReactiveCurrentPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2309,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2309,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltagePhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltagePhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltagePhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2310,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2310,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMinPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMinPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageMinPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2311,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2311,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMaxPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMaxPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageMaxPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2312,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2312,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSCurrentPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2313,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2313,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMinPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMinPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSCurrentMinPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2314,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2314,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMaxPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMaxPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSCurrentMaxPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2315,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2315,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActivePowerPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2316,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2316,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMinPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMinPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActivePowerMinPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2317,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2317,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMaxPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMaxPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActivePowerMaxPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_phb_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2318,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2318,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactivePowerPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactivePowerPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ReactivePowerPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2319,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2319,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ApparentPowerPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ApparentPowerPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ApparentPowerPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_phb_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2320,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2320,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PowerFactorPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PowerFactorPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/PowerFactorPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2321,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2321,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2322,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2322,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2323,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2323,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2324,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2324,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2325,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2325,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2326,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2326,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phb_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2327,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2327,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2561,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2561,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/LineCurrentPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/LineCurrentPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_line_current_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/LineCurrentPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2562,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2562,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActiveCurrentPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActiveCurrentPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_current_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActiveCurrentPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2563,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2563,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactiveCurrentPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactiveCurrentPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_current_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ReactiveCurrentPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2565,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2565,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltagePhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltagePhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltagePhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2566,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2566,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMinPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMinPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageMinPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2567,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2567,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageMaxPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageMaxPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageMaxPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2568,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2568,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSCurrentPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2569,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2569,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMinPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMinPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_min_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSCurrentMinPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2570,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2570,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSCurrentMaxPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSCurrentMaxPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_current_max_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSCurrentMaxPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2571,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2571,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActivePowerPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2572,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2572,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMinPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMinPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_min_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActivePowerMinPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2573,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2573,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ActivePowerMaxPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ActivePowerMaxPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_active_power_max_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ActivePowerMaxPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_phc_publish(
  const char *base_topic,
  int16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2574,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2574,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ReactivePowerPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ReactivePowerPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_reactive_power_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ReactivePowerPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2575,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2575,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/ApparentPowerPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ApparentPowerPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_apparent_power_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ApparentPowerPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_phc_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2576,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2576,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/PowerFactorPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/PowerFactorPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_power_factor_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/PowerFactorPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2577,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2577,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSVoltageMeasurementPeriodPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2578,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2578,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSOverVoltageCounterPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2579,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2579,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/AverageRMSUnderVoltageCounterPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2580,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2580,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSExtremeOverVoltagePeriodPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2581,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2581,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSExtremeUnderVoltagePeriodPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2582,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2582,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageSagPeriodPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phc_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2820,2583,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2820,2583,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhC", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhC";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phc_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/RMSVoltageSwellPeriodPhC";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_electrical_measurement_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_electrical_measurement_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback.empty()) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/GetProfileInfoResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_get_profile_info_response);
  }
  if (!uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_response_callback.empty()) {
    subscription_topic = base_topic + "ElectricalMeasurement/GeneratedCommands/GetProfileInfoResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_electrical_measurement_get_profile_info_response);
  }
  if (!uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback.empty()) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/GetProfileInfo";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_get_profile_info);
  }
  if (!uic_mqtt_dotdot_electrical_measurement_generated_get_profile_info_callback.empty()) {
    subscription_topic = base_topic + "ElectricalMeasurement/GeneratedCommands/GetProfileInfo";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_electrical_measurement_get_profile_info);
  }
  if (!uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback.empty()) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/GetMeasurementProfileResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_get_measurement_profile_response);
  }
  if (!uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_response_callback.empty()) {
    subscription_topic = base_topic + "ElectricalMeasurement/GeneratedCommands/GetMeasurementProfileResponse";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_electrical_measurement_get_measurement_profile_response);
  }
  if (!uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback.empty()) {
    subscription_topic = base_topic + "ElectricalMeasurement/Commands/GetMeasurementProfile";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_electrical_measurement_get_measurement_profile);
  }
  if (!uic_mqtt_dotdot_electrical_measurement_generated_get_measurement_profile_callback.empty()) {
    subscription_topic = base_topic + "ElectricalMeasurement/GeneratedCommands/GetMeasurementProfile";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_electrical_measurement_get_measurement_profile);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_electrical_measurement_attributes_init();

  uic_mqtt_dotdot_by_group_electrical_measurement_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_diagnostics_write_attributes_callback_t> uic_mqtt_dotdot_diagnostics_write_attributes_callback;
static std::set<uic_mqtt_dotdot_diagnostics_force_read_attributes_callback_t> uic_mqtt_dotdot_diagnostics_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_diagnostics_write_attributes_callback(
  const uic_mqtt_dotdot_diagnostics_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_diagnostics_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_diagnostics_write_attributes_callback(
  const uic_mqtt_dotdot_diagnostics_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_diagnostics_write_attributes_callbacks()
{
  uic_mqtt_dotdot_diagnostics_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_diagnostics_write_attributes_callback_t>& get_uic_mqtt_dotdot_diagnostics_write_attributes_callback()
{
  return uic_mqtt_dotdot_diagnostics_write_attributes_callback;
}

void uic_mqtt_dotdot_set_diagnostics_force_read_attributes_callback(
  const uic_mqtt_dotdot_diagnostics_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_diagnostics_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_diagnostics_force_read_attributes_callback(
  const uic_mqtt_dotdot_diagnostics_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_diagnostics_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_diagnostics_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_diagnostics_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Diagnostics/Commands/WriteAttributes
void uic_mqtt_dotdot_on_diagnostics_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_diagnostics_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_diagnostics_state_t new_state = {};
  uic_mqtt_dotdot_diagnostics_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_diagnostics_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Diagnostics", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_diagnostics_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_diagnostics_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_diagnostics_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_diagnostics_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.number_of_resets = true;
      force_update.persistent_memory_writes = true;
      force_update.mac_rx_bcast = true;
      force_update.mac_tx_bcast = true;
      force_update.mac_rx_ucast = true;
      force_update.mac_tx_ucast = true;
      force_update.mac_tx_ucast_retry = true;
      force_update.mac_tx_ucast_fail = true;
      force_update.aps_rx_bcast = true;
      force_update.aps_tx_bcast = true;
      force_update.aps_rx_ucast = true;
      force_update.aps_tx_ucast_success = true;
      force_update.aps_tx_ucast_retry = true;
      force_update.aps_tx_ucast_fail = true;
      force_update.route_disc_initiated = true;
      force_update.neighbor_added = true;
      force_update.neighbor_removed = true;
      force_update.neighbor_stale = true;
      force_update.join_indication = true;
      force_update.child_moved = true;
      force_update.nwkfc_failure = true;
      force_update.apsfc_failure = true;
      force_update.aps_unauthorized_key = true;
      force_update.nwk_decrypt_failures = true;
      force_update.aps_decrypt_failures = true;
      force_update.packet_buffer_allocate_failures = true;
      force_update.relayed_ucast = true;
      force_update.phy_to_mac_queue_limit_reached = true;
      force_update.packet_validate_drop_count = true;
      force_update.average_mac_retry_per_aps_message_sent = true;
      force_update.last_messagelqi = true;
      force_update.last_messagerssi = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"NumberOfResets", &force_update.number_of_resets },
        {"PersistentMemoryWrites", &force_update.persistent_memory_writes },
        {"MacRxBcast", &force_update.mac_rx_bcast },
        {"MacTxBcast", &force_update.mac_tx_bcast },
        {"MacRxUcast", &force_update.mac_rx_ucast },
        {"MacTxUcast", &force_update.mac_tx_ucast },
        {"MacTxUcastRetry", &force_update.mac_tx_ucast_retry },
        {"MacTxUcastFail", &force_update.mac_tx_ucast_fail },
        {"APSRxBcast", &force_update.aps_rx_bcast },
        {"APSTxBcast", &force_update.aps_tx_bcast },
        {"APSRxUcast", &force_update.aps_rx_ucast },
        {"APSTxUcastSuccess", &force_update.aps_tx_ucast_success },
        {"APSTxUcastRetry", &force_update.aps_tx_ucast_retry },
        {"APSTxUcastFail", &force_update.aps_tx_ucast_fail },
        {"RouteDiscInitiated", &force_update.route_disc_initiated },
        {"NeighborAdded", &force_update.neighbor_added },
        {"NeighborRemoved", &force_update.neighbor_removed },
        {"NeighborStale", &force_update.neighbor_stale },
        {"JoinIndication", &force_update.join_indication },
        {"ChildMoved", &force_update.child_moved },
        {"NWKFCFailure", &force_update.nwkfc_failure },
        {"APSFCFailure", &force_update.apsfc_failure },
        {"APSUnauthorizedKey", &force_update.aps_unauthorized_key },
        {"NWKDecryptFailures", &force_update.nwk_decrypt_failures },
        {"APSDecryptFailures", &force_update.aps_decrypt_failures },
        {"PacketBufferAllocateFailures", &force_update.packet_buffer_allocate_failures },
        {"RelayedUcast", &force_update.relayed_ucast },
        {"PHYToMACQueueLimitReached", &force_update.phy_to_mac_queue_limit_reached },
        {"PacketValidateDropCount", &force_update.packet_validate_drop_count },
        {"AverageMACRetryPerAPSMessageSent", &force_update.average_mac_retry_per_aps_message_sent },
        {"LastMessageLQI", &force_update.last_messagelqi },
        {"LastMessageRSSI", &force_update.last_messagerssi },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_diagnostics_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Diagnostics/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_diagnostics_number_of_resets_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NumberOfResets", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NumberOfResets";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_number_of_resets_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/NumberOfResets";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_persistent_memory_writes_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/PersistentMemoryWrites", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/PersistentMemoryWrites";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_persistent_memory_writes_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/PersistentMemoryWrites";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_mac_rx_bcast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,256,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,256,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacRxBcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacRxBcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_mac_rx_bcast_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/MacRxBcast";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_bcast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,257,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,257,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacTxBcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacTxBcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_bcast_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/MacTxBcast";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_mac_rx_ucast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,258,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,258,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacRxUcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacRxUcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_mac_rx_ucast_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/MacRxUcast";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,259,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,259,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacTxUcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacTxUcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/MacTxUcast";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_retry_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,260,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,260,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacTxUcastRetry", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacTxUcastRetry";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_retry_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/MacTxUcastRetry";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_fail_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,261,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,261,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/MacTxUcastFail", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/MacTxUcastFail";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_mac_tx_ucast_fail_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/MacTxUcastFail";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_aps_rx_bcast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,262,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,262,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSRxBcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSRxBcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_aps_rx_bcast_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/APSRxBcast";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_bcast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,263,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,263,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSTxBcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSTxBcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_bcast_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/APSTxBcast";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_aps_rx_ucast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,264,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,264,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSRxUcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSRxUcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_aps_rx_ucast_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/APSRxUcast";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_success_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,265,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,265,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSTxUcastSuccess", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSTxUcastSuccess";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_success_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/APSTxUcastSuccess";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_retry_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,266,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,266,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSTxUcastRetry", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSTxUcastRetry";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_retry_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/APSTxUcastRetry";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_fail_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,267,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,267,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSTxUcastFail", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSTxUcastFail";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_aps_tx_ucast_fail_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/APSTxUcastFail";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_route_disc_initiated_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,268,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,268,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/RouteDiscInitiated", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/RouteDiscInitiated";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_route_disc_initiated_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/RouteDiscInitiated";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_added_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,269,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,269,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NeighborAdded", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NeighborAdded";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_added_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/NeighborAdded";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_removed_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,270,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,270,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NeighborRemoved", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NeighborRemoved";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_removed_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/NeighborRemoved";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_stale_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,271,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,271,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NeighborStale", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NeighborStale";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_neighbor_stale_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/NeighborStale";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_join_indication_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,272,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,272,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/JoinIndication", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/JoinIndication";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_join_indication_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/JoinIndication";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_child_moved_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,273,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,273,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/ChildMoved", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/ChildMoved";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_child_moved_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/ChildMoved";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_nwkfc_failure_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,274,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,274,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NWKFCFailure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NWKFCFailure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_nwkfc_failure_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/NWKFCFailure";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_apsfc_failure_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,275,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,275,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSFCFailure", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSFCFailure";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_apsfc_failure_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/APSFCFailure";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_aps_unauthorized_key_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,276,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,276,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSUnauthorizedKey", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSUnauthorizedKey";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_aps_unauthorized_key_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/APSUnauthorizedKey";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_nwk_decrypt_failures_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,277,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,277,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/NWKDecryptFailures", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/NWKDecryptFailures";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_nwk_decrypt_failures_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/NWKDecryptFailures";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_aps_decrypt_failures_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,278,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,278,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/APSDecryptFailures", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/APSDecryptFailures";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_aps_decrypt_failures_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/APSDecryptFailures";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_packet_buffer_allocate_failures_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,279,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,279,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/PacketBufferAllocateFailures", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/PacketBufferAllocateFailures";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_packet_buffer_allocate_failures_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/PacketBufferAllocateFailures";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_relayed_ucast_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,280,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,280,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/RelayedUcast", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/RelayedUcast";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_relayed_ucast_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/RelayedUcast";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_phy_to_mac_queue_limit_reached_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,281,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,281,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/PHYToMACQueueLimitReached", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/PHYToMACQueueLimitReached";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_phy_to_mac_queue_limit_reached_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/PHYToMACQueueLimitReached";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_packet_validate_drop_count_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,282,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,282,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/PacketValidateDropCount", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/PacketValidateDropCount";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_packet_validate_drop_count_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/PacketValidateDropCount";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_average_mac_retry_per_aps_message_sent_publish(
  const char *base_topic,
  uint16_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,283,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,283,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/AverageMACRetryPerAPSMessageSent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/AverageMACRetryPerAPSMessageSent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_average_mac_retry_per_aps_message_sent_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/AverageMACRetryPerAPSMessageSent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_last_messagelqi_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,284,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,284,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/LastMessageLQI", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/LastMessageLQI";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_last_messagelqi_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/LastMessageLQI";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_diagnostics_last_messagerssi_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(2821,285,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(2821,285,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Diagnostics/Attributes/LastMessageRSSI", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Diagnostics/Attributes/LastMessageRSSI";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_diagnostics_last_messagerssi_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/LastMessageRSSI";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_diagnostics_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_diagnostics_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Diagnostics/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_diagnostics_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_diagnostics_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Diagnostics/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_diagnostics_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_diagnostics_attributes_init();

  uic_mqtt_dotdot_by_group_diagnostics_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t> uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback;
static std::set<uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t> uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback;
static std::set<uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback_t> uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback;
static std::set<uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback_t> uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_set(const uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_unset(const uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback.erase(callback);
}
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_clear()
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback.clear();
}
std::set<uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t>& get_uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback()
{
  return uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback;
}

void uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback_set(const uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback_unset(const uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback.erase(callback);
}
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback_clear()
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback.clear();
}

void uic_mqtt_dotdot_set_protocol_controller_rf_telemetry_write_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_protocol_controller_rf_telemetry_write_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_protocol_controller_rf_telemetry_write_attributes_callbacks()
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback_t>& get_uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback()
{
  return uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback;
}

void uic_mqtt_dotdot_set_protocol_controller_rf_telemetry_force_read_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_protocol_controller_rf_telemetry_force_read_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_protocol_controller_rf_telemetry_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-RFTelemetry/Commands/TxReport
void uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_tx_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string sourceunid;
  std::string destinationunid;
  bool transmission_successful = {};
  uint16_t transmission_time_ms = {};
  int8_t tx_powerd_bm = {};
  uint8_t tx_channel = {};
  uint8_t routing_attempts = {};
  bool route_changed = {};
  TxReportTransmissionSpeed transmission_speed = {};
  int8_t measured_noise_floord_bm = {};
  std::vector<std::string> last_route_repeaters;
  std::vector<int8_t> incoming_rssi_repeaters;
  int8_t ackrssi = {};
  uint8_t ack_channel = {};
  std::string last_route_failed_link_functionalunid;
  std::string last_route_failed_link_non_functionalunid;
  int8_t destination_ack_tx_powerd_bm = {};
  int8_t destination_ack_measuredrssi = {};
  int8_t destination_ack_measured_noise_floor = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_protocol_controller_rf_telemetry_tx_report(
      jsn,
      sourceunid,

      destinationunid,

      transmission_successful,

      transmission_time_ms,

      tx_powerd_bm,

      tx_channel,

      routing_attempts,

      route_changed,

      transmission_speed,

      measured_noise_floord_bm,

      last_route_repeaters,

      incoming_rssi_repeaters,

      ackrssi,

      ack_channel,

      last_route_failed_link_functionalunid,

      last_route_failed_link_non_functionalunid,

      destination_ack_tx_powerd_bm,

      destination_ack_measuredrssi,

      destination_ack_measured_noise_floor
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-RFTelemetry", "TxReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "TxReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "TxReport", "");
    return;
  }


  // Convert the to std::vector<std::string> to std::vector<const char*>
  std::vector<const char*> last_route_repeaters_c_strings;
  for (size_t i = 0;i<last_route_repeaters.size();++i){
    last_route_repeaters_c_strings.push_back(last_route_repeaters[i].c_str());
  }


  for (const auto& callback: uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      sourceunid.c_str(),
  
      destinationunid.c_str(),
  
      transmission_successful,
  
      transmission_time_ms,
  
      tx_powerd_bm,
  
      tx_channel,
  
      routing_attempts,
  
      route_changed,
  
      transmission_speed,
  
      measured_noise_floord_bm,
  
      last_route_repeaters_c_strings.size(),
      static_cast<const char**>(last_route_repeaters_c_strings.data()),

      incoming_rssi_repeaters.size(),
      incoming_rssi_repeaters.data(),

      ackrssi,
  
      ack_channel,
  
      last_route_failed_link_functionalunid.c_str(),
  
      last_route_failed_link_non_functionalunid.c_str(),
  
      destination_ack_tx_powerd_bm,
  
      destination_ack_measuredrssi,
  
      destination_ack_measured_noise_floor
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-RFTelemetry/GeneratedCommands/TxReport
static void uic_mqtt_dotdot_on_generated_protocol_controller_rf_telemetry_tx_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string sourceunid;
  std::string destinationunid;
  bool transmission_successful = {};
  uint16_t transmission_time_ms = {};
  int8_t tx_powerd_bm = {};
  uint8_t tx_channel = {};
  uint8_t routing_attempts = {};
  bool route_changed = {};
  TxReportTransmissionSpeed transmission_speed = {};
  int8_t measured_noise_floord_bm = {};
  std::vector<std::string> last_route_repeaters;
  std::vector<int8_t> incoming_rssi_repeaters;
  int8_t ackrssi = {};
  uint8_t ack_channel = {};
  std::string last_route_failed_link_functionalunid;
  std::string last_route_failed_link_non_functionalunid;
  int8_t destination_ack_tx_powerd_bm = {};
  int8_t destination_ack_measuredrssi = {};
  int8_t destination_ack_measured_noise_floor = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_protocol_controller_rf_telemetry_tx_report(
      jsn,
      sourceunid,

      destinationunid,

      transmission_successful,

      transmission_time_ms,

      tx_powerd_bm,

      tx_channel,

      routing_attempts,

      route_changed,

      transmission_speed,

      measured_noise_floord_bm,

      last_route_repeaters,

      incoming_rssi_repeaters,

      ackrssi,

      ack_channel,

      last_route_failed_link_functionalunid,

      last_route_failed_link_non_functionalunid,

      destination_ack_tx_powerd_bm,

      destination_ack_measuredrssi,

      destination_ack_measured_noise_floor
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-RFTelemetry", "TxReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "TxReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "TxReport", "");
    return;
  }


  // Convert the to std::vector<std::string> to std::vector<const char*>
  std::vector<const char*> last_route_repeaters_c_strings;
  for (size_t i = 0;i<last_route_repeaters.size();++i){
    last_route_repeaters_c_strings.push_back(last_route_repeaters[i].c_str());
  }



  for (const auto& callback: uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      sourceunid.c_str(),
  
      destinationunid.c_str(),
  
      transmission_successful,
  
      transmission_time_ms,
  
      tx_powerd_bm,
  
      tx_channel,
  
      routing_attempts,
  
      route_changed,
  
      transmission_speed,
  
      measured_noise_floord_bm,
  
      last_route_repeaters_c_strings.size(),
      static_cast<const char**>(last_route_repeaters_c_strings.data()),

      incoming_rssi_repeaters.size(),
      incoming_rssi_repeaters.data(),

      ackrssi,
  
      ack_channel,
  
      last_route_failed_link_functionalunid.c_str(),
  
      last_route_failed_link_non_functionalunid.c_str(),
  
      destination_ack_tx_powerd_bm,
  
      destination_ack_measuredrssi,
  
      destination_ack_measured_noise_floor
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-RFTelemetry/Commands/WriteAttributes
void uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_protocol_controller_rf_telemetry_state_t new_state = {};
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_protocol_controller_rf_telemetry_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-RFTelemetry", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-RFTelemetry", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.tx_report_enabled = true;
      force_update.pti_enabled = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"TxReportEnabled", &force_update.tx_report_enabled },
        {"PTIEnabled", &force_update.pti_enabled },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "ProtocolController-RFTelemetry/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64769,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64769,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController/RFTelemetry/Attributes/TxReportEnabled", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ProtocolController/RFTelemetry/Attributes/TxReportEnabled";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_enabled_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ProtocolController/RFTelemetry/Attributes/TxReportEnabled";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_pti_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64769,1,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64769,1,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController/RFTelemetry/Attributes/PTIEnabled", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ProtocolController/RFTelemetry/Attributes/PTIEnabled";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_pti_enabled_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ProtocolController/RFTelemetry/Attributes/PTIEnabled";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_protocol_controller_rf_telemetry_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "ProtocolController/RFTelemetry/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "ProtocolController/RFTelemetry/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback.empty()) {
    subscription_topic = base_topic + "ProtocolController/RFTelemetry/Commands/TxReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_rf_telemetry_tx_report);
  }
  if (!uic_mqtt_dotdot_protocol_controller_rf_telemetry_generated_tx_report_callback.empty()) {
    subscription_topic = base_topic + "ProtocolController/RFTelemetry/GeneratedCommands/TxReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_protocol_controller_rf_telemetry_tx_report);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_attributes_init();


  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_state_remove_callback_t> uic_mqtt_dotdot_state_remove_callback;
static std::set<uic_mqtt_dotdot_state_remove_callback_t> uic_mqtt_dotdot_state_generated_remove_callback;
static std::set<uic_mqtt_dotdot_state_remove_offline_callback_t> uic_mqtt_dotdot_state_remove_offline_callback;
static std::set<uic_mqtt_dotdot_state_remove_offline_callback_t> uic_mqtt_dotdot_state_generated_remove_offline_callback;
static std::set<uic_mqtt_dotdot_state_discover_neighbors_callback_t> uic_mqtt_dotdot_state_discover_neighbors_callback;
static std::set<uic_mqtt_dotdot_state_discover_neighbors_callback_t> uic_mqtt_dotdot_state_generated_discover_neighbors_callback;
static std::set<uic_mqtt_dotdot_state_interview_callback_t> uic_mqtt_dotdot_state_interview_callback;
static std::set<uic_mqtt_dotdot_state_interview_callback_t> uic_mqtt_dotdot_state_generated_interview_callback;
static std::set<uic_mqtt_dotdot_state_discover_security_callback_t> uic_mqtt_dotdot_state_discover_security_callback;
static std::set<uic_mqtt_dotdot_state_discover_security_callback_t> uic_mqtt_dotdot_state_generated_discover_security_callback;
static std::set<uic_mqtt_dotdot_state_write_attributes_callback_t> uic_mqtt_dotdot_state_write_attributes_callback;
static std::set<uic_mqtt_dotdot_state_force_read_attributes_callback_t> uic_mqtt_dotdot_state_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_state_remove_callback_set(const uic_mqtt_dotdot_state_remove_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_remove_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_state_remove_callback_unset(const uic_mqtt_dotdot_state_remove_callback_t callback)
{
  uic_mqtt_dotdot_state_remove_callback.erase(callback);
}
void uic_mqtt_dotdot_state_remove_callback_clear()
{
  uic_mqtt_dotdot_state_remove_callback.clear();
}
std::set<uic_mqtt_dotdot_state_remove_callback_t>& get_uic_mqtt_dotdot_state_remove_callback()
{
  return uic_mqtt_dotdot_state_remove_callback;
}

void uic_mqtt_dotdot_state_generated_remove_callback_set(const uic_mqtt_dotdot_state_remove_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_generated_remove_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_state_generated_remove_callback_unset(const uic_mqtt_dotdot_state_remove_callback_t callback)
{
  uic_mqtt_dotdot_state_generated_remove_callback.erase(callback);
}
void uic_mqtt_dotdot_state_generated_remove_callback_clear()
{
  uic_mqtt_dotdot_state_generated_remove_callback.clear();
}
void uic_mqtt_dotdot_state_remove_offline_callback_set(const uic_mqtt_dotdot_state_remove_offline_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_remove_offline_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_state_remove_offline_callback_unset(const uic_mqtt_dotdot_state_remove_offline_callback_t callback)
{
  uic_mqtt_dotdot_state_remove_offline_callback.erase(callback);
}
void uic_mqtt_dotdot_state_remove_offline_callback_clear()
{
  uic_mqtt_dotdot_state_remove_offline_callback.clear();
}
std::set<uic_mqtt_dotdot_state_remove_offline_callback_t>& get_uic_mqtt_dotdot_state_remove_offline_callback()
{
  return uic_mqtt_dotdot_state_remove_offline_callback;
}

void uic_mqtt_dotdot_state_generated_remove_offline_callback_set(const uic_mqtt_dotdot_state_remove_offline_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_generated_remove_offline_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_state_generated_remove_offline_callback_unset(const uic_mqtt_dotdot_state_remove_offline_callback_t callback)
{
  uic_mqtt_dotdot_state_generated_remove_offline_callback.erase(callback);
}
void uic_mqtt_dotdot_state_generated_remove_offline_callback_clear()
{
  uic_mqtt_dotdot_state_generated_remove_offline_callback.clear();
}
void uic_mqtt_dotdot_state_discover_neighbors_callback_set(const uic_mqtt_dotdot_state_discover_neighbors_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_discover_neighbors_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_state_discover_neighbors_callback_unset(const uic_mqtt_dotdot_state_discover_neighbors_callback_t callback)
{
  uic_mqtt_dotdot_state_discover_neighbors_callback.erase(callback);
}
void uic_mqtt_dotdot_state_discover_neighbors_callback_clear()
{
  uic_mqtt_dotdot_state_discover_neighbors_callback.clear();
}
std::set<uic_mqtt_dotdot_state_discover_neighbors_callback_t>& get_uic_mqtt_dotdot_state_discover_neighbors_callback()
{
  return uic_mqtt_dotdot_state_discover_neighbors_callback;
}

void uic_mqtt_dotdot_state_generated_discover_neighbors_callback_set(const uic_mqtt_dotdot_state_discover_neighbors_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_generated_discover_neighbors_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_state_generated_discover_neighbors_callback_unset(const uic_mqtt_dotdot_state_discover_neighbors_callback_t callback)
{
  uic_mqtt_dotdot_state_generated_discover_neighbors_callback.erase(callback);
}
void uic_mqtt_dotdot_state_generated_discover_neighbors_callback_clear()
{
  uic_mqtt_dotdot_state_generated_discover_neighbors_callback.clear();
}
void uic_mqtt_dotdot_state_interview_callback_set(const uic_mqtt_dotdot_state_interview_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_interview_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_state_interview_callback_unset(const uic_mqtt_dotdot_state_interview_callback_t callback)
{
  uic_mqtt_dotdot_state_interview_callback.erase(callback);
}
void uic_mqtt_dotdot_state_interview_callback_clear()
{
  uic_mqtt_dotdot_state_interview_callback.clear();
}
std::set<uic_mqtt_dotdot_state_interview_callback_t>& get_uic_mqtt_dotdot_state_interview_callback()
{
  return uic_mqtt_dotdot_state_interview_callback;
}

void uic_mqtt_dotdot_state_generated_interview_callback_set(const uic_mqtt_dotdot_state_interview_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_generated_interview_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_state_generated_interview_callback_unset(const uic_mqtt_dotdot_state_interview_callback_t callback)
{
  uic_mqtt_dotdot_state_generated_interview_callback.erase(callback);
}
void uic_mqtt_dotdot_state_generated_interview_callback_clear()
{
  uic_mqtt_dotdot_state_generated_interview_callback.clear();
}
void uic_mqtt_dotdot_state_discover_security_callback_set(const uic_mqtt_dotdot_state_discover_security_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_discover_security_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_state_discover_security_callback_unset(const uic_mqtt_dotdot_state_discover_security_callback_t callback)
{
  uic_mqtt_dotdot_state_discover_security_callback.erase(callback);
}
void uic_mqtt_dotdot_state_discover_security_callback_clear()
{
  uic_mqtt_dotdot_state_discover_security_callback.clear();
}
std::set<uic_mqtt_dotdot_state_discover_security_callback_t>& get_uic_mqtt_dotdot_state_discover_security_callback()
{
  return uic_mqtt_dotdot_state_discover_security_callback;
}

void uic_mqtt_dotdot_state_generated_discover_security_callback_set(const uic_mqtt_dotdot_state_discover_security_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_generated_discover_security_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_state_generated_discover_security_callback_unset(const uic_mqtt_dotdot_state_discover_security_callback_t callback)
{
  uic_mqtt_dotdot_state_generated_discover_security_callback.erase(callback);
}
void uic_mqtt_dotdot_state_generated_discover_security_callback_clear()
{
  uic_mqtt_dotdot_state_generated_discover_security_callback.clear();
}

void uic_mqtt_dotdot_set_state_write_attributes_callback(
  const uic_mqtt_dotdot_state_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_state_write_attributes_callback(
  const uic_mqtt_dotdot_state_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_state_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_state_write_attributes_callbacks()
{
  uic_mqtt_dotdot_state_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_state_write_attributes_callback_t>& get_uic_mqtt_dotdot_state_write_attributes_callback()
{
  return uic_mqtt_dotdot_state_write_attributes_callback;
}

void uic_mqtt_dotdot_set_state_force_read_attributes_callback(
  const uic_mqtt_dotdot_state_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_state_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_state_force_read_attributes_callback(
  const uic_mqtt_dotdot_state_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_state_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_state_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_state_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/Remove
void uic_mqtt_dotdot_on_state_remove(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_remove_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "Remove");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Remove", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Remove", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_state_remove_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/State/GeneratedCommands/Remove
static void uic_mqtt_dotdot_on_generated_state_remove(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_generated_remove_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "Remove");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Remove", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Remove", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_state_generated_remove_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/RemoveOffline
void uic_mqtt_dotdot_on_state_remove_offline(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_remove_offline_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "RemoveOffline");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "RemoveOffline", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "RemoveOffline", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_state_remove_offline_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/State/GeneratedCommands/RemoveOffline
static void uic_mqtt_dotdot_on_generated_state_remove_offline(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_generated_remove_offline_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "RemoveOffline");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "RemoveOffline", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "RemoveOffline", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_state_generated_remove_offline_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/DiscoverNeighbors
void uic_mqtt_dotdot_on_state_discover_neighbors(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_discover_neighbors_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "DiscoverNeighbors");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverNeighbors", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverNeighbors", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_state_discover_neighbors_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/State/GeneratedCommands/DiscoverNeighbors
static void uic_mqtt_dotdot_on_generated_state_discover_neighbors(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_generated_discover_neighbors_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "DiscoverNeighbors");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverNeighbors", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverNeighbors", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_state_generated_discover_neighbors_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/Interview
void uic_mqtt_dotdot_on_state_interview(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_interview_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "Interview");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Interview", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Interview", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_state_interview_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/State/GeneratedCommands/Interview
static void uic_mqtt_dotdot_on_generated_state_interview(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_generated_interview_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "Interview");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Interview", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "Interview", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_state_generated_interview_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/DiscoverSecurity
void uic_mqtt_dotdot_on_state_discover_security(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_discover_security_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "DiscoverSecurity");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverSecurity", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverSecurity", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_state_discover_security_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/State/GeneratedCommands/DiscoverSecurity
static void uic_mqtt_dotdot_on_generated_state_discover_security(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_state_generated_discover_security_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "DiscoverSecurity");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverSecurity", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "DiscoverSecurity", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_state_generated_discover_security_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/State/Commands/WriteAttributes
void uic_mqtt_dotdot_on_state_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_state_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_state_state_t new_state = {};
  uic_mqtt_dotdot_state_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_state_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "State", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_state_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_state_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_state_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_state_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.endpoint_id_list = true;
      force_update.network_status = true;
      force_update.security = true;
      force_update.maximum_command_delay = true;
      force_update.network_list = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"EndpointIdList", &force_update.endpoint_id_list },
        {"NetworkStatus", &force_update.network_status },
        {"Security", &force_update.security },
        {"MaximumCommandDelay", &force_update.maximum_command_delay },
        {"NetworkList", &force_update.network_list },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_state_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "State/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_state_endpoint_id_list_publish(
  const char *base_topic,
  size_t value_count,
  const uint8_t* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State/Attributes/EndpointIdList", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/State/Attributes/EndpointIdList";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_state_endpoint_id_list_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/State/Attributes/EndpointIdList";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_state_network_status_publish(
  const char *base_topic,
  NodeStateNetworkStatus value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef STATE_NETWORK_STATUS_ENUM_NAME_AVAILABLE
  jsn["value"] = state_network_status_get_enum_value_name((uint32_t)value);
  #elif defined(NODE_STATE_NETWORK_STATUS_ENUM_NAME_AVAILABLE)
  jsn["value"] = node_state_network_status_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for STATE_NETWORK_STATUS. Using number instead.");
  jsn["value"] = static_cast<NodeStateNetworkStatus>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State/Attributes/NetworkStatus", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/State/Attributes/NetworkStatus";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_state_network_status_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/State/Attributes/NetworkStatus";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_state_security_publish(
  const char *base_topic,
  NodeStateSecurity value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef STATE_SECURITY_ENUM_NAME_AVAILABLE
  jsn["value"] = state_security_get_enum_value_name((uint32_t)value);
  #elif defined(NODE_STATE_SECURITY_ENUM_NAME_AVAILABLE)
  jsn["value"] = node_state_security_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for STATE_SECURITY. Using number instead.");
  jsn["value"] = static_cast<NodeStateSecurity>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State/Attributes/Security", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/State/Attributes/Security";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_state_security_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/State/Attributes/Security";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_state_maximum_command_delay_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64770,3,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64770,3,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State/Attributes/MaximumCommandDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/State/Attributes/MaximumCommandDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_state_maximum_command_delay_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/State/Attributes/MaximumCommandDelay";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_state_network_list_publish(
  const char *base_topic,
  size_t value_count,
  const char** value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // String type
    jsn["value"].push_back(std::string(value[i]));
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "State/Attributes/NetworkList", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/State/Attributes/NetworkList";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_state_network_list_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/State/Attributes/NetworkList";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_state_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_state_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "State/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_state_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "State/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_state_remove_callback.empty()) {
    subscription_topic = base_topic + "State/Commands/Remove";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_remove);
  }
  if (!uic_mqtt_dotdot_state_generated_remove_callback.empty()) {
    subscription_topic = base_topic + "State/GeneratedCommands/Remove";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_state_remove);
  }
  if (!uic_mqtt_dotdot_state_remove_offline_callback.empty()) {
    subscription_topic = base_topic + "State/Commands/RemoveOffline";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_remove_offline);
  }
  if (!uic_mqtt_dotdot_state_generated_remove_offline_callback.empty()) {
    subscription_topic = base_topic + "State/GeneratedCommands/RemoveOffline";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_state_remove_offline);
  }
  if (!uic_mqtt_dotdot_state_discover_neighbors_callback.empty()) {
    subscription_topic = base_topic + "State/Commands/DiscoverNeighbors";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_discover_neighbors);
  }
  if (!uic_mqtt_dotdot_state_generated_discover_neighbors_callback.empty()) {
    subscription_topic = base_topic + "State/GeneratedCommands/DiscoverNeighbors";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_state_discover_neighbors);
  }
  if (!uic_mqtt_dotdot_state_interview_callback.empty()) {
    subscription_topic = base_topic + "State/Commands/Interview";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_interview);
  }
  if (!uic_mqtt_dotdot_state_generated_interview_callback.empty()) {
    subscription_topic = base_topic + "State/GeneratedCommands/Interview";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_state_interview);
  }
  if (!uic_mqtt_dotdot_state_discover_security_callback.empty()) {
    subscription_topic = base_topic + "State/Commands/DiscoverSecurity";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_state_discover_security);
  }
  if (!uic_mqtt_dotdot_state_generated_discover_security_callback.empty()) {
    subscription_topic = base_topic + "State/GeneratedCommands/DiscoverSecurity";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_state_discover_security);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_state_attributes_init();


  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_binding_bind_callback_t> uic_mqtt_dotdot_binding_bind_callback;
static std::set<uic_mqtt_dotdot_binding_bind_callback_t> uic_mqtt_dotdot_binding_generated_bind_callback;
static std::set<uic_mqtt_dotdot_binding_unbind_callback_t> uic_mqtt_dotdot_binding_unbind_callback;
static std::set<uic_mqtt_dotdot_binding_unbind_callback_t> uic_mqtt_dotdot_binding_generated_unbind_callback;
static std::set<uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t> uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback;
static std::set<uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t> uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback;
static std::set<uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t> uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback;
static std::set<uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t> uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback;
static std::set<uic_mqtt_dotdot_binding_write_attributes_callback_t> uic_mqtt_dotdot_binding_write_attributes_callback;
static std::set<uic_mqtt_dotdot_binding_force_read_attributes_callback_t> uic_mqtt_dotdot_binding_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_binding_bind_callback_set(const uic_mqtt_dotdot_binding_bind_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_binding_bind_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_binding_bind_callback_unset(const uic_mqtt_dotdot_binding_bind_callback_t callback)
{
  uic_mqtt_dotdot_binding_bind_callback.erase(callback);
}
void uic_mqtt_dotdot_binding_bind_callback_clear()
{
  uic_mqtt_dotdot_binding_bind_callback.clear();
}
std::set<uic_mqtt_dotdot_binding_bind_callback_t>& get_uic_mqtt_dotdot_binding_bind_callback()
{
  return uic_mqtt_dotdot_binding_bind_callback;
}

void uic_mqtt_dotdot_binding_generated_bind_callback_set(const uic_mqtt_dotdot_binding_bind_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_binding_generated_bind_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_binding_generated_bind_callback_unset(const uic_mqtt_dotdot_binding_bind_callback_t callback)
{
  uic_mqtt_dotdot_binding_generated_bind_callback.erase(callback);
}
void uic_mqtt_dotdot_binding_generated_bind_callback_clear()
{
  uic_mqtt_dotdot_binding_generated_bind_callback.clear();
}
void uic_mqtt_dotdot_binding_unbind_callback_set(const uic_mqtt_dotdot_binding_unbind_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_binding_unbind_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_binding_unbind_callback_unset(const uic_mqtt_dotdot_binding_unbind_callback_t callback)
{
  uic_mqtt_dotdot_binding_unbind_callback.erase(callback);
}
void uic_mqtt_dotdot_binding_unbind_callback_clear()
{
  uic_mqtt_dotdot_binding_unbind_callback.clear();
}
std::set<uic_mqtt_dotdot_binding_unbind_callback_t>& get_uic_mqtt_dotdot_binding_unbind_callback()
{
  return uic_mqtt_dotdot_binding_unbind_callback;
}

void uic_mqtt_dotdot_binding_generated_unbind_callback_set(const uic_mqtt_dotdot_binding_unbind_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_binding_generated_unbind_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_binding_generated_unbind_callback_unset(const uic_mqtt_dotdot_binding_unbind_callback_t callback)
{
  uic_mqtt_dotdot_binding_generated_unbind_callback.erase(callback);
}
void uic_mqtt_dotdot_binding_generated_unbind_callback_clear()
{
  uic_mqtt_dotdot_binding_generated_unbind_callback.clear();
}
void uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_set(const uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_unset(const uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t callback)
{
  uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback.erase(callback);
}
void uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_clear()
{
  uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback.clear();
}
std::set<uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t>& get_uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback()
{
  return uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback;
}

void uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback_set(const uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback_unset(const uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback_t callback)
{
  uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback.erase(callback);
}
void uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback_clear()
{
  uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback.clear();
}
void uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_set(const uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_unset(const uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t callback)
{
  uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback.erase(callback);
}
void uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_clear()
{
  uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback.clear();
}
std::set<uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t>& get_uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback()
{
  return uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback;
}

void uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback_set(const uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback_unset(const uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback_t callback)
{
  uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback.erase(callback);
}
void uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback_clear()
{
  uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback.clear();
}

void uic_mqtt_dotdot_set_binding_write_attributes_callback(
  const uic_mqtt_dotdot_binding_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_binding_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_binding_write_attributes_callback(
  const uic_mqtt_dotdot_binding_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_binding_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_binding_write_attributes_callbacks()
{
  uic_mqtt_dotdot_binding_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_binding_write_attributes_callback_t>& get_uic_mqtt_dotdot_binding_write_attributes_callback()
{
  return uic_mqtt_dotdot_binding_write_attributes_callback;
}

void uic_mqtt_dotdot_set_binding_force_read_attributes_callback(
  const uic_mqtt_dotdot_binding_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_binding_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_binding_force_read_attributes_callback(
  const uic_mqtt_dotdot_binding_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_binding_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_binding_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_binding_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Binding/Commands/Bind
void uic_mqtt_dotdot_on_binding_bind(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_bind_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string cluster_name;
  std::string destination_unid;
  uint8_t destination_ep = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_bind(
      jsn,
      cluster_name,

      destination_unid,

      destination_ep
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "Bind");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Bind", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Bind", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_binding_bind_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      cluster_name.c_str(),
  
      destination_unid.c_str(),
  
      destination_ep
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Binding/GeneratedCommands/Bind
static void uic_mqtt_dotdot_on_generated_binding_bind(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_generated_bind_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string cluster_name;
  std::string destination_unid;
  uint8_t destination_ep = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_bind(
      jsn,
      cluster_name,

      destination_unid,

      destination_ep
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "Bind");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Bind", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Bind", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_binding_generated_bind_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      cluster_name.c_str(),
  
      destination_unid.c_str(),
  
      destination_ep
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Binding/Commands/Unbind
void uic_mqtt_dotdot_on_binding_unbind(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_unbind_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string cluster_name;
  std::string destination_unid;
  uint8_t destination_ep = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_unbind(
      jsn,
      cluster_name,

      destination_unid,

      destination_ep
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "Unbind");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Unbind", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Unbind", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_binding_unbind_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      cluster_name.c_str(),
  
      destination_unid.c_str(),
  
      destination_ep
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Binding/GeneratedCommands/Unbind
static void uic_mqtt_dotdot_on_generated_binding_unbind(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_generated_unbind_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string cluster_name;
  std::string destination_unid;
  uint8_t destination_ep = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_unbind(
      jsn,
      cluster_name,

      destination_unid,

      destination_ep
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "Unbind");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Unbind", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "Unbind", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_binding_generated_unbind_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      cluster_name.c_str(),
  
      destination_unid.c_str(),
  
      destination_ep
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Binding/Commands/BindToProtocolController
void uic_mqtt_dotdot_on_binding_bind_to_protocol_controller(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string cluster_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_bind_to_protocol_controller(
      jsn,
      cluster_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "BindToProtocolController");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "BindToProtocolController", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "BindToProtocolController", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      cluster_name.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Binding/GeneratedCommands/BindToProtocolController
static void uic_mqtt_dotdot_on_generated_binding_bind_to_protocol_controller(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string cluster_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_bind_to_protocol_controller(
      jsn,
      cluster_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "BindToProtocolController");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "BindToProtocolController", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "BindToProtocolController", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      cluster_name.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Binding/Commands/UnbindFromProtocolController
void uic_mqtt_dotdot_on_binding_unbind_from_protocol_controller(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string cluster_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_unbind_from_protocol_controller(
      jsn,
      cluster_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "UnbindFromProtocolController");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "UnbindFromProtocolController", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "UnbindFromProtocolController", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      cluster_name.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/Binding/GeneratedCommands/UnbindFromProtocolController
static void uic_mqtt_dotdot_on_generated_binding_unbind_from_protocol_controller(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string cluster_name;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_binding_unbind_from_protocol_controller(
      jsn,
      cluster_name
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "UnbindFromProtocolController");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "UnbindFromProtocolController", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "UnbindFromProtocolController", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      cluster_name.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/Binding/Commands/WriteAttributes
void uic_mqtt_dotdot_on_binding_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_binding_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_binding_state_t new_state = {};
  uic_mqtt_dotdot_binding_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_binding_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Binding", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_binding_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_binding_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_binding_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_binding_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.binding_table_full = true;
      force_update.bindable_cluster_list = true;
      force_update.binding_table = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"BindingTableFull", &force_update.binding_table_full },
        {"BindableClusterList", &force_update.bindable_cluster_list },
        {"BindingTable", &force_update.binding_table },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_binding_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Binding/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_binding_binding_table_full_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64771,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64771,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding/Attributes/BindingTableFull", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Binding/Attributes/BindingTableFull";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_binding_binding_table_full_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Binding/Attributes/BindingTableFull";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_binding_bindable_cluster_list_publish(
  const char *base_topic,
  size_t value_count,
  const char** value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // String type
    jsn["value"].push_back(std::string(value[i]));
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding/Attributes/BindableClusterList", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Binding/Attributes/BindableClusterList";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_binding_bindable_cluster_list_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Binding/Attributes/BindableClusterList";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_binding_binding_table_publish(
  const char *base_topic,
  size_t value_count,
  const BindingObject* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["ClusterName"] = value[i].ClusterName;
    json_object["DestinationUnid"] = value[i].DestinationUnid;
    json_object["DestinationEp"] = value[i].DestinationEp;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Binding/Attributes/BindingTable", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Binding/Attributes/BindingTable";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_binding_binding_table_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Binding/Attributes/BindingTable";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_binding_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_binding_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Binding/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_binding_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Binding/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_binding_bind_callback.empty()) {
    subscription_topic = base_topic + "Binding/Commands/Bind";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_bind);
  }
  if (!uic_mqtt_dotdot_binding_generated_bind_callback.empty()) {
    subscription_topic = base_topic + "Binding/GeneratedCommands/Bind";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_binding_bind);
  }
  if (!uic_mqtt_dotdot_binding_unbind_callback.empty()) {
    subscription_topic = base_topic + "Binding/Commands/Unbind";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_unbind);
  }
  if (!uic_mqtt_dotdot_binding_generated_unbind_callback.empty()) {
    subscription_topic = base_topic + "Binding/GeneratedCommands/Unbind";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_binding_unbind);
  }
  if (!uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback.empty()) {
    subscription_topic = base_topic + "Binding/Commands/BindToProtocolController";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_bind_to_protocol_controller);
  }
  if (!uic_mqtt_dotdot_binding_generated_bind_to_protocol_controller_callback.empty()) {
    subscription_topic = base_topic + "Binding/GeneratedCommands/BindToProtocolController";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_binding_bind_to_protocol_controller);
  }
  if (!uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback.empty()) {
    subscription_topic = base_topic + "Binding/Commands/UnbindFromProtocolController";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_binding_unbind_from_protocol_controller);
  }
  if (!uic_mqtt_dotdot_binding_generated_unbind_from_protocol_controller_callback.empty()) {
    subscription_topic = base_topic + "Binding/GeneratedCommands/UnbindFromProtocolController";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_binding_unbind_from_protocol_controller);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_binding_attributes_init();

  uic_mqtt_dotdot_by_group_binding_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_system_metrics_write_attributes_callback_t> uic_mqtt_dotdot_system_metrics_write_attributes_callback;
static std::set<uic_mqtt_dotdot_system_metrics_force_read_attributes_callback_t> uic_mqtt_dotdot_system_metrics_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_system_metrics_write_attributes_callback(
  const uic_mqtt_dotdot_system_metrics_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_system_metrics_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_system_metrics_write_attributes_callback(
  const uic_mqtt_dotdot_system_metrics_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_system_metrics_write_attributes_callbacks()
{
  uic_mqtt_dotdot_system_metrics_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_system_metrics_write_attributes_callback_t>& get_uic_mqtt_dotdot_system_metrics_write_attributes_callback()
{
  return uic_mqtt_dotdot_system_metrics_write_attributes_callback;
}

void uic_mqtt_dotdot_set_system_metrics_force_read_attributes_callback(
  const uic_mqtt_dotdot_system_metrics_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_system_metrics_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_system_metrics_force_read_attributes_callback(
  const uic_mqtt_dotdot_system_metrics_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_system_metrics_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_system_metrics_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_system_metrics_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/SystemMetrics/Commands/WriteAttributes
void uic_mqtt_dotdot_on_system_metrics_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_system_metrics_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_system_metrics_state_t new_state = {};
  uic_mqtt_dotdot_system_metrics_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_system_metrics_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "SystemMetrics", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_system_metrics_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_system_metrics_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_system_metrics_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_system_metrics_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.reporting_interval_seconds = true;
      force_update.cpu_usage_percent = true;
      force_update.cpu_frequencym_hz = true;
      force_update.cpu_average_usage_percent = true;
      force_update.cpu_min_usage_percent = true;
      force_update.cpu_max_usage_percent = true;
      force_update.ram_totalmb = true;
      force_update.ram_freemb = true;
      force_update.ram_availablemb = true;
      force_update.swap_memory_totalmb = true;
      force_update.swap_memory_usedmb = true;
      force_update.virtual_memory_totalmb = true;
      force_update.virtual_memory_usedmb = true;
      force_update.disks_usage = true;
      force_update.disks_counters = true;
      force_update.network_interfaces_data = true;
      force_update.wireless_network_interfaces_data = true;
      force_update.hostname = true;
      force_update.fqdn = true;
      force_update.uptime_minutes = true;
      force_update.current_temperature_celcius = true;
      force_update.average_temperature_celcius = true;
      force_update.min_temperature_celcius = true;
      force_update.max_temperature_celcius = true;
      force_update.power_plugged = true;
      force_update.battery_percentage = true;
      force_update.system_interrupts = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"ReportingIntervalSeconds", &force_update.reporting_interval_seconds },
        {"CPUUsagePercent", &force_update.cpu_usage_percent },
        {"CPUFrequencyMHz", &force_update.cpu_frequencym_hz },
        {"CPUAverageUsagePercent", &force_update.cpu_average_usage_percent },
        {"CPUMinUsagePercent", &force_update.cpu_min_usage_percent },
        {"CPUMaxUsagePercent", &force_update.cpu_max_usage_percent },
        {"RAMTotalMB", &force_update.ram_totalmb },
        {"RAMFreeMB", &force_update.ram_freemb },
        {"RAMAvailableMB", &force_update.ram_availablemb },
        {"SWAPMemoryTotalMB", &force_update.swap_memory_totalmb },
        {"SWAPMemoryUsedMB", &force_update.swap_memory_usedmb },
        {"VirtualMemoryTotalMB", &force_update.virtual_memory_totalmb },
        {"VirtualMemoryUsedMB", &force_update.virtual_memory_usedmb },
        {"DisksUsage", &force_update.disks_usage },
        {"DisksCounters", &force_update.disks_counters },
        {"NetworkInterfacesData", &force_update.network_interfaces_data },
        {"WirelessNetworkInterfacesData", &force_update.wireless_network_interfaces_data },
        {"Hostname", &force_update.hostname },
        {"FQDN", &force_update.fqdn },
        {"UptimeMinutes", &force_update.uptime_minutes },
        {"CurrentTemperatureCelcius", &force_update.current_temperature_celcius },
        {"AverageTemperatureCelcius", &force_update.average_temperature_celcius },
        {"MinTemperatureCelcius", &force_update.min_temperature_celcius },
        {"MaxTemperatureCelcius", &force_update.max_temperature_celcius },
        {"PowerPlugged", &force_update.power_plugged },
        {"BatteryPercentage", &force_update.battery_percentage },
        {"SystemInterrupts", &force_update.system_interrupts },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_system_metrics_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "SystemMetrics/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_system_metrics_reporting_interval_seconds_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,0,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,0,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/ReportingIntervalSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/ReportingIntervalSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_reporting_interval_seconds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/ReportingIntervalSeconds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_cpu_usage_percent_publish(
  const char *base_topic,
  size_t value_count,
  const double* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CPUUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CPUUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_cpu_usage_percent_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/CPUUsagePercent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_cpu_frequencym_hz_publish(
  const char *base_topic,
  size_t value_count,
  const double* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CPUFrequencyMHz", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CPUFrequencyMHz";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_cpu_frequencym_hz_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/CPUFrequencyMHz";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_cpu_average_usage_percent_publish(
  const char *base_topic,
  size_t value_count,
  const double* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CPUAverageUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CPUAverageUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_cpu_average_usage_percent_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/CPUAverageUsagePercent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_cpu_min_usage_percent_publish(
  const char *base_topic,
  size_t value_count,
  const double* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CPUMinUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CPUMinUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_cpu_min_usage_percent_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/CPUMinUsagePercent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_cpu_max_usage_percent_publish(
  const char *base_topic,
  size_t value_count,
  const double* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CPUMaxUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CPUMaxUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_cpu_max_usage_percent_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/CPUMaxUsagePercent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_ram_totalmb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,32,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,32,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/RAMTotalMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/RAMTotalMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_ram_totalmb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/RAMTotalMB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_ram_freemb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,33,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,33,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/RAMFreeMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/RAMFreeMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_ram_freemb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/RAMFreeMB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_ram_availablemb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,34,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,34,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/RAMAvailableMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/RAMAvailableMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_ram_availablemb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/RAMAvailableMB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_swap_memory_totalmb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,35,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,35,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/SWAPMemoryTotalMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/SWAPMemoryTotalMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_swap_memory_totalmb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/SWAPMemoryTotalMB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_swap_memory_usedmb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,36,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,36,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/SWAPMemoryUsedMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/SWAPMemoryUsedMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_swap_memory_usedmb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/SWAPMemoryUsedMB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_virtual_memory_totalmb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,37,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,37,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/VirtualMemoryTotalMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/VirtualMemoryTotalMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_virtual_memory_totalmb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/VirtualMemoryTotalMB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_virtual_memory_usedmb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,38,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,38,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/VirtualMemoryUsedMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/VirtualMemoryUsedMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_virtual_memory_usedmb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/VirtualMemoryUsedMB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_disks_usage_publish(
  const char *base_topic,
  size_t value_count,
  const DiskUsageData* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["UUID"] = value[i].UUID;
    json_object["UsagePercent"] = value[i].UsagePercent;
    json_object["FreeSpaceMB"] = value[i].FreeSpaceMB;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/DisksUsage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/DisksUsage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_disks_usage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/DisksUsage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_disks_counters_publish(
  const char *base_topic,
  size_t value_count,
  const DiskIOCounters* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["UUID"] = value[i].UUID;
    json_object["ReadCount"] = value[i].ReadCount;
    json_object["WriteCount"] = value[i].WriteCount;
    json_object["ReadBytes"] = value[i].ReadBytes;
    json_object["WriteBytes"] = value[i].WriteBytes;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/DisksCounters", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/DisksCounters";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_disks_counters_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/DisksCounters";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_network_interfaces_data_publish(
  const char *base_topic,
  size_t value_count,
  const NetworkInterfaceData* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["InterfaceName"] = value[i].InterfaceName;
    json_object["BytesSent"] = value[i].BytesSent;
    json_object["BytesReceived"] = value[i].BytesReceived;
    json_object["PacketsSent"] = value[i].PacketsSent;
    json_object["PacketsReceived"] = value[i].PacketsReceived;
    json_object["ErrorsIn"] = value[i].ErrorsIn;
    json_object["ErrorsOut"] = value[i].ErrorsOut;
    json_object["DropIn"] = value[i].DropIn;
    json_object["DropOut"] = value[i].DropOut;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/NetworkInterfacesData", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/NetworkInterfacesData";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_network_interfaces_data_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/NetworkInterfacesData";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_wireless_network_interfaces_data_publish(
  const char *base_topic,
  size_t value_count,
  const WirelessNetworkInterfaceData* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["InterfaceName"] = value[i].InterfaceName;
    json_object["SignalStrengthdBm"] = value[i].SignalStrengthdBm;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/WirelessNetworkInterfacesData", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/WirelessNetworkInterfacesData";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_wireless_network_interfaces_data_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/WirelessNetworkInterfacesData";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_hostname_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/Hostname", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/Hostname";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_hostname_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/Hostname";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_fqdn_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/FQDN", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/FQDN";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_fqdn_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/FQDN";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_uptime_minutes_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,64,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,64,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/UptimeMinutes", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/UptimeMinutes";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_uptime_minutes_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/UptimeMinutes";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_current_temperature_celcius_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,80,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,80,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/CurrentTemperatureCelcius", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/CurrentTemperatureCelcius";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_current_temperature_celcius_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/CurrentTemperatureCelcius";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_average_temperature_celcius_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,81,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,81,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/AverageTemperatureCelcius", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/AverageTemperatureCelcius";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_average_temperature_celcius_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/AverageTemperatureCelcius";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_min_temperature_celcius_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,82,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,82,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/MinTemperatureCelcius", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/MinTemperatureCelcius";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_min_temperature_celcius_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/MinTemperatureCelcius";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_max_temperature_celcius_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,83,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,83,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/MaxTemperatureCelcius", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/MaxTemperatureCelcius";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_max_temperature_celcius_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/MaxTemperatureCelcius";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_power_plugged_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,96,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,96,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/PowerPlugged", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/PowerPlugged";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_power_plugged_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/PowerPlugged";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_battery_percentage_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,97,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,97,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/BatteryPercentage", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/BatteryPercentage";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_battery_percentage_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/BatteryPercentage";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_system_metrics_system_interrupts_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64772,112,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64772,112,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "SystemMetrics/Attributes/SystemInterrupts", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/SystemMetrics/Attributes/SystemInterrupts";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_system_metrics_system_interrupts_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/SystemInterrupts";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_system_metrics_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_system_metrics_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "SystemMetrics/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_system_metrics_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_system_metrics_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "SystemMetrics/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_system_metrics_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_system_metrics_attributes_init();


  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_application_monitoring_log_entry_callback_t> uic_mqtt_dotdot_application_monitoring_log_entry_callback;
static std::set<uic_mqtt_dotdot_application_monitoring_log_entry_callback_t> uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback;
static std::set<uic_mqtt_dotdot_application_monitoring_write_attributes_callback_t> uic_mqtt_dotdot_application_monitoring_write_attributes_callback;
static std::set<uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback_t> uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_application_monitoring_log_entry_callback_set(const uic_mqtt_dotdot_application_monitoring_log_entry_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_application_monitoring_log_entry_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_application_monitoring_log_entry_callback_unset(const uic_mqtt_dotdot_application_monitoring_log_entry_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_log_entry_callback.erase(callback);
}
void uic_mqtt_dotdot_application_monitoring_log_entry_callback_clear()
{
  uic_mqtt_dotdot_application_monitoring_log_entry_callback.clear();
}
std::set<uic_mqtt_dotdot_application_monitoring_log_entry_callback_t>& get_uic_mqtt_dotdot_application_monitoring_log_entry_callback()
{
  return uic_mqtt_dotdot_application_monitoring_log_entry_callback;
}

void uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback_set(const uic_mqtt_dotdot_application_monitoring_log_entry_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback_unset(const uic_mqtt_dotdot_application_monitoring_log_entry_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback.erase(callback);
}
void uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback_clear()
{
  uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback.clear();
}

void uic_mqtt_dotdot_set_application_monitoring_write_attributes_callback(
  const uic_mqtt_dotdot_application_monitoring_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_application_monitoring_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_application_monitoring_write_attributes_callback(
  const uic_mqtt_dotdot_application_monitoring_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_application_monitoring_write_attributes_callbacks()
{
  uic_mqtt_dotdot_application_monitoring_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_application_monitoring_write_attributes_callback_t>& get_uic_mqtt_dotdot_application_monitoring_write_attributes_callback()
{
  return uic_mqtt_dotdot_application_monitoring_write_attributes_callback;
}

void uic_mqtt_dotdot_set_application_monitoring_force_read_attributes_callback(
  const uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_application_monitoring_force_read_attributes_callback(
  const uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_application_monitoring_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/ApplicationMonitoring/Commands/LogEntry
void uic_mqtt_dotdot_on_application_monitoring_log_entry(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_application_monitoring_log_entry_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string timestamp;
  LoggingLevelEnum log_level = {};
  std::string log_tag;
  std::string log_message;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_application_monitoring_log_entry(
      jsn,
      timestamp,

      log_level,

      log_tag,

      log_message
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ApplicationMonitoring", "LogEntry");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "LogEntry", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "LogEntry", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_application_monitoring_log_entry_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      timestamp.c_str(),
  
      log_level,
  
      log_tag.c_str(),
  
      log_message.c_str()
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ApplicationMonitoring/GeneratedCommands/LogEntry
static void uic_mqtt_dotdot_on_generated_application_monitoring_log_entry(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string timestamp;
  LoggingLevelEnum log_level = {};
  std::string log_tag;
  std::string log_message;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_application_monitoring_log_entry(
      jsn,
      timestamp,

      log_level,

      log_tag,

      log_message
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ApplicationMonitoring", "LogEntry");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "LogEntry", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "LogEntry", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      timestamp.c_str(),
  
      log_level,
  
      log_tag.c_str(),
  
      log_message.c_str()
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ApplicationMonitoring/Commands/WriteAttributes
void uic_mqtt_dotdot_on_application_monitoring_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_application_monitoring_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_application_monitoring_state_t new_state = {};
  uic_mqtt_dotdot_application_monitoring_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_application_monitoring_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ApplicationMonitoring", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_application_monitoring_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_application_monitoring_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_application_monitoring_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.application_name = true;
      force_update.application_version = true;
      force_update.application_connected = true;
      force_update.application_mqtt_topics = true;
      force_update.uptime_minutes = true;
      force_update.process_id = true;
      force_update.hostname = true;
      force_update.fqdn = true;
      force_update.mqtt_logging_enabled = true;
      force_update.mqtt_logging_level = true;
      force_update.mqtt_statistics_reporting_interval_seconds = true;
      force_update.mqtt_messages_sent = true;
      force_update.mqtt_messages_received = true;
      force_update.mqtt_subscription_count = true;
      force_update.mqtt_average_delivery_time_seconds = true;
      force_update.mqtt_min_delivery_time_seconds = true;
      force_update.mqtt_max_delivery_time_seconds = true;
      force_update.application_statistics_reporting_interval_seconds = true;
      force_update.application_cpu_usage_percent = true;
      force_update.application_cpu_average_usage_percent = true;
      force_update.application_cpu_min_usage_percent = true;
      force_update.application_cpu_max_usage_percent = true;
      force_update.application_ram_usagemb = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"ApplicationName", &force_update.application_name },
        {"ApplicationVersion", &force_update.application_version },
        {"ApplicationConnected", &force_update.application_connected },
        {"ApplicationMQTTTopics", &force_update.application_mqtt_topics },
        {"UptimeMinutes", &force_update.uptime_minutes },
        {"ProcessId", &force_update.process_id },
        {"Hostname", &force_update.hostname },
        {"FQDN", &force_update.fqdn },
        {"MQTTLoggingEnabled", &force_update.mqtt_logging_enabled },
        {"MQTTLoggingLevel", &force_update.mqtt_logging_level },
        {"MQTTStatisticsReportingIntervalSeconds", &force_update.mqtt_statistics_reporting_interval_seconds },
        {"MQTTMessagesSent", &force_update.mqtt_messages_sent },
        {"MQTTMessagesReceived", &force_update.mqtt_messages_received },
        {"MQTTSubscriptionCount", &force_update.mqtt_subscription_count },
        {"MQTTAverageDeliveryTimeSeconds", &force_update.mqtt_average_delivery_time_seconds },
        {"MQTTMinDeliveryTimeSeconds", &force_update.mqtt_min_delivery_time_seconds },
        {"MQTTMaxDeliveryTimeSeconds", &force_update.mqtt_max_delivery_time_seconds },
        {"ApplicationStatisticsReportingIntervalSeconds", &force_update.application_statistics_reporting_interval_seconds },
        {"ApplicationCPUUsagePercent", &force_update.application_cpu_usage_percent },
        {"ApplicationCPUAverageUsagePercent", &force_update.application_cpu_average_usage_percent },
        {"ApplicationCPUMinUsagePercent", &force_update.application_cpu_min_usage_percent },
        {"ApplicationCPUMaxUsagePercent", &force_update.application_cpu_max_usage_percent },
        {"ApplicationRAMUsageMB", &force_update.application_ram_usagemb },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "ApplicationMonitoring/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_name_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationName", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationName";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_name_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ApplicationName";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_application_version_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationVersion", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationVersion";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_version_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ApplicationVersion";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_application_connected_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationConnected", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationConnected";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_connected_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ApplicationConnected";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_application_mqtt_topics_publish(
  const char *base_topic,
  size_t value_count,
  const char** value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // String type
    jsn["value"].push_back(std::string(value[i]));
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationMQTTTopics", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationMQTTTopics";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_mqtt_topics_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ApplicationMQTTTopics";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_uptime_minutes_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,16,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,16,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/UptimeMinutes", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/UptimeMinutes";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_uptime_minutes_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/UptimeMinutes";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_process_id_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ProcessId", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ProcessId";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_process_id_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ProcessId";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_hostname_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/Hostname", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/Hostname";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_hostname_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/Hostname";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_fqdn_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/FQDN", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/FQDN";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_fqdn_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/FQDN";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_logging_enabled_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,33,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,33,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTLoggingEnabled", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTLoggingEnabled";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_logging_enabled_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/MQTTLoggingEnabled";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_logging_level_publish(
  const char *base_topic,
  LoggingLevelEnum value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef APPLICATION_MONITORING_MQTT_LOGGING_LEVEL_ENUM_NAME_AVAILABLE
  jsn["value"] = application_monitoring_mqtt_logging_level_get_enum_value_name((uint32_t)value);
  #elif defined(LOGGING_LEVEL_ENUM_ENUM_NAME_AVAILABLE)
  jsn["value"] = logging_level_enum_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for APPLICATION_MONITORING_MQTT_LOGGING_LEVEL. Using number instead.");
  jsn["value"] = static_cast<LoggingLevelEnum>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTLoggingLevel", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTLoggingLevel";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_logging_level_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/MQTTLoggingLevel";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_statistics_reporting_interval_seconds_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,48,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,48,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTStatisticsReportingIntervalSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTStatisticsReportingIntervalSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_statistics_reporting_interval_seconds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/MQTTStatisticsReportingIntervalSeconds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_messages_sent_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,49,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,49,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTMessagesSent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTMessagesSent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_messages_sent_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/MQTTMessagesSent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_messages_received_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,50,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,50,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTMessagesReceived", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTMessagesReceived";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_messages_received_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/MQTTMessagesReceived";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_subscription_count_publish(
  const char *base_topic,
  uint64_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,51,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,51,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTSubscriptionCount", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTSubscriptionCount";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_subscription_count_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/MQTTSubscriptionCount";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_average_delivery_time_seconds_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,52,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,52,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTAverageDeliveryTimeSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTAverageDeliveryTimeSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_average_delivery_time_seconds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/MQTTAverageDeliveryTimeSeconds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_min_delivery_time_seconds_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,53,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,53,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTMinDeliveryTimeSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTMinDeliveryTimeSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_min_delivery_time_seconds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/MQTTMinDeliveryTimeSeconds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_max_delivery_time_seconds_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,54,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,54,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/MQTTMaxDeliveryTimeSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/MQTTMaxDeliveryTimeSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_mqtt_max_delivery_time_seconds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/MQTTMaxDeliveryTimeSeconds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_application_statistics_reporting_interval_seconds_publish(
  const char *base_topic,
  uint32_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,64,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,64,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationStatisticsReportingIntervalSeconds", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationStatisticsReportingIntervalSeconds";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_statistics_reporting_interval_seconds_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ApplicationStatisticsReportingIntervalSeconds";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_application_cpu_usage_percent_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,65,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,65,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationCPUUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationCPUUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_cpu_usage_percent_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ApplicationCPUUsagePercent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_application_cpu_average_usage_percent_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,66,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,66,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationCPUAverageUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationCPUAverageUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_cpu_average_usage_percent_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ApplicationCPUAverageUsagePercent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_application_cpu_min_usage_percent_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,67,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,67,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationCPUMinUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationCPUMinUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_cpu_min_usage_percent_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ApplicationCPUMinUsagePercent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_application_cpu_max_usage_percent_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,68,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,68,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationCPUMaxUsagePercent", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationCPUMaxUsagePercent";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_cpu_max_usage_percent_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ApplicationCPUMaxUsagePercent";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_application_monitoring_application_ram_usagemb_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64773,69,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64773,69,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ApplicationMonitoring/Attributes/ApplicationRAMUsageMB", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ApplicationRAMUsageMB";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_application_monitoring_application_ram_usagemb_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ApplicationRAMUsageMB";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_application_monitoring_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_application_monitoring_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "ApplicationMonitoring/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_application_monitoring_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "ApplicationMonitoring/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_application_monitoring_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_application_monitoring_log_entry_callback.empty()) {
    subscription_topic = base_topic + "ApplicationMonitoring/Commands/LogEntry";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_application_monitoring_log_entry);
  }
  if (!uic_mqtt_dotdot_application_monitoring_generated_log_entry_callback.empty()) {
    subscription_topic = base_topic + "ApplicationMonitoring/GeneratedCommands/LogEntry";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_application_monitoring_log_entry);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_application_monitoring_attributes_init();


  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_name_and_location_write_attributes_callback_t> uic_mqtt_dotdot_name_and_location_write_attributes_callback;
static std::set<uic_mqtt_dotdot_name_and_location_force_read_attributes_callback_t> uic_mqtt_dotdot_name_and_location_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_name_and_location_write_attributes_callback(
  const uic_mqtt_dotdot_name_and_location_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_name_and_location_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_name_and_location_write_attributes_callback(
  const uic_mqtt_dotdot_name_and_location_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_name_and_location_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_name_and_location_write_attributes_callbacks()
{
  uic_mqtt_dotdot_name_and_location_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_name_and_location_write_attributes_callback_t>& get_uic_mqtt_dotdot_name_and_location_write_attributes_callback()
{
  return uic_mqtt_dotdot_name_and_location_write_attributes_callback;
}

void uic_mqtt_dotdot_set_name_and_location_force_read_attributes_callback(
  const uic_mqtt_dotdot_name_and_location_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_name_and_location_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_name_and_location_force_read_attributes_callback(
  const uic_mqtt_dotdot_name_and_location_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_name_and_location_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_name_and_location_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_name_and_location_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/NameAndLocation/Commands/WriteAttributes
void uic_mqtt_dotdot_on_name_and_location_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_name_and_location_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_name_and_location_state_t new_state = {};
  uic_mqtt_dotdot_name_and_location_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_name_and_location_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "NameAndLocation", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "NameAndLocation", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "NameAndLocation", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_name_and_location_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_name_and_location_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_name_and_location_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_name_and_location_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.name = true;
      force_update.location = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"Name", &force_update.name },
        {"Location", &force_update.location },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_name_and_location_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "NameAndLocation/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_name_and_location_name_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "NameAndLocation/Attributes/Name", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/NameAndLocation/Attributes/Name";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_name_and_location_name_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/NameAndLocation/Attributes/Name";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_name_and_location_location_publish(
  const char *base_topic,
  const char* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  jsn["value"] = std::string(value);


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "NameAndLocation/Attributes/Location", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/NameAndLocation/Attributes/Location";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_name_and_location_location_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/NameAndLocation/Attributes/Location";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_name_and_location_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_name_and_location_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "NameAndLocation/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_name_and_location_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_name_and_location_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "NameAndLocation/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_name_and_location_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_name_and_location_attributes_init();

  uic_mqtt_dotdot_by_group_name_and_location_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t> uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback;
static std::set<uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t> uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback;
static std::set<uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t> uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback;
static std::set<uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t> uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback;
static std::set<uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t> uic_mqtt_dotdot_configuration_parameters_set_parameter_callback;
static std::set<uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t> uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback;
static std::set<uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback_t> uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback;
static std::set<uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback_t> uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_range_callback;
static std::set<uic_mqtt_dotdot_configuration_parameters_write_attributes_callback_t> uic_mqtt_dotdot_configuration_parameters_write_attributes_callback;
static std::set<uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback_t> uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_set(const uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_unset(const uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback.erase(callback);
}
void uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_clear()
{
  uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback.clear();
}
std::set<uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t>& get_uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback()
{
  return uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback;
}

void uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback_set(const uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback_unset(const uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback.erase(callback);
}
void uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback_clear()
{
  uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback.clear();
}
void uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_set(const uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_unset(const uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback.erase(callback);
}
void uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_clear()
{
  uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback.clear();
}
std::set<uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t>& get_uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback()
{
  return uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback;
}

void uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback_set(const uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback_unset(const uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback.erase(callback);
}
void uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback_clear()
{
  uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback.clear();
}
void uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_set(const uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_configuration_parameters_set_parameter_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_unset(const uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_set_parameter_callback.erase(callback);
}
void uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_clear()
{
  uic_mqtt_dotdot_configuration_parameters_set_parameter_callback.clear();
}
std::set<uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t>& get_uic_mqtt_dotdot_configuration_parameters_set_parameter_callback()
{
  return uic_mqtt_dotdot_configuration_parameters_set_parameter_callback;
}

void uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback_set(const uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback_unset(const uic_mqtt_dotdot_configuration_parameters_set_parameter_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback.erase(callback);
}
void uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback_clear()
{
  uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback.clear();
}
void uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback_set(const uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback_unset(const uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback.erase(callback);
}
void uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback_clear()
{
  uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback.clear();
}
std::set<uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback_t>& get_uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback()
{
  return uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback;
}

void uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_range_callback_set(const uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_range_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_range_callback_unset(const uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_range_callback.erase(callback);
}
void uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_range_callback_clear()
{
  uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_range_callback.clear();
}

void uic_mqtt_dotdot_set_configuration_parameters_write_attributes_callback(
  const uic_mqtt_dotdot_configuration_parameters_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_configuration_parameters_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_configuration_parameters_write_attributes_callback(
  const uic_mqtt_dotdot_configuration_parameters_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_configuration_parameters_write_attributes_callbacks()
{
  uic_mqtt_dotdot_configuration_parameters_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_configuration_parameters_write_attributes_callback_t>& get_uic_mqtt_dotdot_configuration_parameters_write_attributes_callback()
{
  return uic_mqtt_dotdot_configuration_parameters_write_attributes_callback;
}

void uic_mqtt_dotdot_set_configuration_parameters_force_read_attributes_callback(
  const uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_configuration_parameters_force_read_attributes_callback(
  const uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_configuration_parameters_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/Commands/DiscoverParameter
void uic_mqtt_dotdot_on_configuration_parameters_discover_parameter(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t parameter_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_configuration_parameters_discover_parameter(
      jsn,
      parameter_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DiscoverParameter");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameter", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameter", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      parameter_id
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/GeneratedCommands/DiscoverParameter
static void uic_mqtt_dotdot_on_generated_configuration_parameters_discover_parameter(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t parameter_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_configuration_parameters_discover_parameter(
      jsn,
      parameter_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DiscoverParameter");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameter", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameter", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      parameter_id
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/Commands/DefaultResetAllParameters
void uic_mqtt_dotdot_on_configuration_parameters_default_reset_all_parameters(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DefaultResetAllParameters");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DefaultResetAllParameters", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DefaultResetAllParameters", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/GeneratedCommands/DefaultResetAllParameters
static void uic_mqtt_dotdot_on_generated_configuration_parameters_default_reset_all_parameters(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DefaultResetAllParameters");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DefaultResetAllParameters", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DefaultResetAllParameters", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/Commands/SetParameter
void uic_mqtt_dotdot_on_configuration_parameters_set_parameter(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_set_parameter_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t parameter_id = {};
  int64_t value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_configuration_parameters_set_parameter(
      jsn,
      parameter_id,

      value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "SetParameter");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "SetParameter", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "SetParameter", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_set_parameter_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      parameter_id,
  
      value
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/GeneratedCommands/SetParameter
static void uic_mqtt_dotdot_on_generated_configuration_parameters_set_parameter(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t parameter_id = {};
  int64_t value = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_configuration_parameters_set_parameter(
      jsn,
      parameter_id,

      value
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "SetParameter");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "SetParameter", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "SetParameter", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      parameter_id,
  
      value
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/Commands/DiscoverParameterRange
void uic_mqtt_dotdot_on_configuration_parameters_discover_parameter_range(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t first_parameter_id = {};
  uint16_t last_parameter_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_configuration_parameters_discover_parameter_range(
      jsn,
      first_parameter_id,

      last_parameter_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DiscoverParameterRange");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameterRange", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameterRange", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      first_parameter_id,
  
      last_parameter_id
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/GeneratedCommands/DiscoverParameterRange
static void uic_mqtt_dotdot_on_generated_configuration_parameters_discover_parameter_range(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_range_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uint16_t first_parameter_id = {};
  uint16_t last_parameter_id = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_configuration_parameters_discover_parameter_range(
      jsn,
      first_parameter_id,

      last_parameter_id
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "DiscoverParameterRange");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameterRange", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "DiscoverParameterRange", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_range_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      first_parameter_id,
  
      last_parameter_id
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ConfigurationParameters/Commands/WriteAttributes
void uic_mqtt_dotdot_on_configuration_parameters_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_configuration_parameters_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_configuration_parameters_state_t new_state = {};
  uic_mqtt_dotdot_configuration_parameters_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_configuration_parameters_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ConfigurationParameters", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_configuration_parameters_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_configuration_parameters_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.configuration_parameters = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"ConfigurationParameters", &force_update.configuration_parameters },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "ConfigurationParameters/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_configuration_parameters_configuration_parameters_publish(
  const char *base_topic,
  size_t value_count,
  const ConfigurationParameter* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["ParameterId"] = value[i].ParameterId;
    json_object["Value"] = value[i].Value;
    json_object["Name"] = value[i].Name;
    json_object["Info"] = value[i].Info;
    json_object["MinimumValue"] = value[i].MinimumValue;
    json_object["MaximumValue"] = value[i].MaximumValue;
    json_object["DefaultValue"] = value[i].DefaultValue;
    json_object["DisplayFormat"] = value[i].DisplayFormat;
    json_object["ReadOnly"] = value[i].ReadOnly;
    json_object["Advanced"] = value[i].Advanced;
    json_object["AlteringCapabilities"] = value[i].AlteringCapabilities;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ConfigurationParameters/Attributes/ConfigurationParameters", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ConfigurationParameters/Attributes/ConfigurationParameters";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_configuration_parameters_configuration_parameters_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ConfigurationParameters/Attributes/ConfigurationParameters";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_configuration_parameters_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_configuration_parameters_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback.empty()) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/DiscoverParameter";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_discover_parameter);
  }
  if (!uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_callback.empty()) {
    subscription_topic = base_topic + "ConfigurationParameters/GeneratedCommands/DiscoverParameter";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_configuration_parameters_discover_parameter);
  }
  if (!uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback.empty()) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/DefaultResetAllParameters";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_default_reset_all_parameters);
  }
  if (!uic_mqtt_dotdot_configuration_parameters_generated_default_reset_all_parameters_callback.empty()) {
    subscription_topic = base_topic + "ConfigurationParameters/GeneratedCommands/DefaultResetAllParameters";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_configuration_parameters_default_reset_all_parameters);
  }
  if (!uic_mqtt_dotdot_configuration_parameters_set_parameter_callback.empty()) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/SetParameter";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_set_parameter);
  }
  if (!uic_mqtt_dotdot_configuration_parameters_generated_set_parameter_callback.empty()) {
    subscription_topic = base_topic + "ConfigurationParameters/GeneratedCommands/SetParameter";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_configuration_parameters_set_parameter);
  }
  if (!uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback.empty()) {
    subscription_topic = base_topic + "ConfigurationParameters/Commands/DiscoverParameterRange";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_configuration_parameters_discover_parameter_range);
  }
  if (!uic_mqtt_dotdot_configuration_parameters_generated_discover_parameter_range_callback.empty()) {
    subscription_topic = base_topic + "ConfigurationParameters/GeneratedCommands/DiscoverParameterRange";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_configuration_parameters_discover_parameter_range);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_configuration_parameters_attributes_init();

  uic_mqtt_dotdot_by_group_configuration_parameters_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_aox_locator_iq_report_callback_t> uic_mqtt_dotdot_aox_locator_iq_report_callback;
static std::set<uic_mqtt_dotdot_aox_locator_iq_report_callback_t> uic_mqtt_dotdot_aox_locator_generated_iq_report_callback;
static std::set<uic_mqtt_dotdot_aox_locator_angle_report_callback_t> uic_mqtt_dotdot_aox_locator_angle_report_callback;
static std::set<uic_mqtt_dotdot_aox_locator_angle_report_callback_t> uic_mqtt_dotdot_aox_locator_generated_angle_report_callback;
static std::set<uic_mqtt_dotdot_aox_locator_angle_correction_callback_t> uic_mqtt_dotdot_aox_locator_angle_correction_callback;
static std::set<uic_mqtt_dotdot_aox_locator_angle_correction_callback_t> uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback;
static std::set<uic_mqtt_dotdot_aox_locator_write_attributes_callback_t> uic_mqtt_dotdot_aox_locator_write_attributes_callback;
static std::set<uic_mqtt_dotdot_aox_locator_force_read_attributes_callback_t> uic_mqtt_dotdot_aox_locator_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_aox_locator_iq_report_callback_set(const uic_mqtt_dotdot_aox_locator_iq_report_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_aox_locator_iq_report_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_aox_locator_iq_report_callback_unset(const uic_mqtt_dotdot_aox_locator_iq_report_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_iq_report_callback.erase(callback);
}
void uic_mqtt_dotdot_aox_locator_iq_report_callback_clear()
{
  uic_mqtt_dotdot_aox_locator_iq_report_callback.clear();
}
std::set<uic_mqtt_dotdot_aox_locator_iq_report_callback_t>& get_uic_mqtt_dotdot_aox_locator_iq_report_callback()
{
  return uic_mqtt_dotdot_aox_locator_iq_report_callback;
}

void uic_mqtt_dotdot_aox_locator_generated_iq_report_callback_set(const uic_mqtt_dotdot_aox_locator_iq_report_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_aox_locator_generated_iq_report_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_aox_locator_generated_iq_report_callback_unset(const uic_mqtt_dotdot_aox_locator_iq_report_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_generated_iq_report_callback.erase(callback);
}
void uic_mqtt_dotdot_aox_locator_generated_iq_report_callback_clear()
{
  uic_mqtt_dotdot_aox_locator_generated_iq_report_callback.clear();
}
void uic_mqtt_dotdot_aox_locator_angle_report_callback_set(const uic_mqtt_dotdot_aox_locator_angle_report_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_aox_locator_angle_report_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_aox_locator_angle_report_callback_unset(const uic_mqtt_dotdot_aox_locator_angle_report_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_angle_report_callback.erase(callback);
}
void uic_mqtt_dotdot_aox_locator_angle_report_callback_clear()
{
  uic_mqtt_dotdot_aox_locator_angle_report_callback.clear();
}
std::set<uic_mqtt_dotdot_aox_locator_angle_report_callback_t>& get_uic_mqtt_dotdot_aox_locator_angle_report_callback()
{
  return uic_mqtt_dotdot_aox_locator_angle_report_callback;
}

void uic_mqtt_dotdot_aox_locator_generated_angle_report_callback_set(const uic_mqtt_dotdot_aox_locator_angle_report_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_aox_locator_generated_angle_report_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_aox_locator_generated_angle_report_callback_unset(const uic_mqtt_dotdot_aox_locator_angle_report_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_generated_angle_report_callback.erase(callback);
}
void uic_mqtt_dotdot_aox_locator_generated_angle_report_callback_clear()
{
  uic_mqtt_dotdot_aox_locator_generated_angle_report_callback.clear();
}
void uic_mqtt_dotdot_aox_locator_angle_correction_callback_set(const uic_mqtt_dotdot_aox_locator_angle_correction_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_aox_locator_angle_correction_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_aox_locator_angle_correction_callback_unset(const uic_mqtt_dotdot_aox_locator_angle_correction_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_angle_correction_callback.erase(callback);
}
void uic_mqtt_dotdot_aox_locator_angle_correction_callback_clear()
{
  uic_mqtt_dotdot_aox_locator_angle_correction_callback.clear();
}
std::set<uic_mqtt_dotdot_aox_locator_angle_correction_callback_t>& get_uic_mqtt_dotdot_aox_locator_angle_correction_callback()
{
  return uic_mqtt_dotdot_aox_locator_angle_correction_callback;
}

void uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback_set(const uic_mqtt_dotdot_aox_locator_angle_correction_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback_unset(const uic_mqtt_dotdot_aox_locator_angle_correction_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback.erase(callback);
}
void uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback_clear()
{
  uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback.clear();
}

void uic_mqtt_dotdot_set_aox_locator_write_attributes_callback(
  const uic_mqtt_dotdot_aox_locator_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_aox_locator_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_aox_locator_write_attributes_callback(
  const uic_mqtt_dotdot_aox_locator_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_aox_locator_write_attributes_callbacks()
{
  uic_mqtt_dotdot_aox_locator_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_aox_locator_write_attributes_callback_t>& get_uic_mqtt_dotdot_aox_locator_write_attributes_callback()
{
  return uic_mqtt_dotdot_aox_locator_write_attributes_callback;
}

void uic_mqtt_dotdot_set_aox_locator_force_read_attributes_callback(
  const uic_mqtt_dotdot_aox_locator_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_aox_locator_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_aox_locator_force_read_attributes_callback(
  const uic_mqtt_dotdot_aox_locator_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_aox_locator_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_aox_locator_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_aox_locator_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/Commands/IQReport
void uic_mqtt_dotdot_on_aox_locator_iq_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_iq_report_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string tag_unid;
  uint8_t channel = {};
  int8_t rssi = {};
  std::vector<int8_t> samples;
  int32_t sequence = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_iq_report(
      jsn,
      tag_unid,

      channel,

      rssi,

      samples,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "IQReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "IQReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "IQReport", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_aox_locator_iq_report_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      tag_unid.c_str(),
  
      channel,
  
      rssi,
  
      samples.size(),
      samples.data(),

      sequence
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/GeneratedCommands/IQReport
static void uic_mqtt_dotdot_on_generated_aox_locator_iq_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_generated_iq_report_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string tag_unid;
  uint8_t channel = {};
  int8_t rssi = {};
  std::vector<int8_t> samples;
  int32_t sequence = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_iq_report(
      jsn,
      tag_unid,

      channel,

      rssi,

      samples,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "IQReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "IQReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "IQReport", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_aox_locator_generated_iq_report_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      tag_unid.c_str(),
  
      channel,
  
      rssi,
  
      samples.size(),
      samples.data(),

      sequence
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/Commands/AngleReport
void uic_mqtt_dotdot_on_aox_locator_angle_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_angle_report_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string tag_unid;
  SphericalCoordinates direction = {};
  SphericalCoordinates deviation = {};
  int32_t sequence = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_angle_report(
      jsn,
      tag_unid,

      direction,

      deviation,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "AngleReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleReport", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_aox_locator_angle_report_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      tag_unid.c_str(),
  
      direction,
  
      deviation,
  
      sequence
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/GeneratedCommands/AngleReport
static void uic_mqtt_dotdot_on_generated_aox_locator_angle_report(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_generated_angle_report_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string tag_unid;
  SphericalCoordinates direction = {};
  SphericalCoordinates deviation = {};
  int32_t sequence = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_angle_report(
      jsn,
      tag_unid,

      direction,

      deviation,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "AngleReport");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleReport", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleReport", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_aox_locator_generated_angle_report_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      tag_unid.c_str(),
  
      direction,
  
      deviation,
  
      sequence
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/Commands/AngleCorrection
void uic_mqtt_dotdot_on_aox_locator_angle_correction(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_angle_correction_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string tag_unid;
  SphericalCoordinates direction = {};
  SphericalCoordinates deviation = {};
  int32_t sequence = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_angle_correction(
      jsn,
      tag_unid,

      direction,

      deviation,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "AngleCorrection");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleCorrection", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleCorrection", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_aox_locator_angle_correction_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      tag_unid.c_str(),
  
      direction,
  
      deviation,
  
      sequence
  
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/GeneratedCommands/AngleCorrection
static void uic_mqtt_dotdot_on_generated_aox_locator_angle_correction(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  std::string tag_unid;
  SphericalCoordinates direction = {};
  SphericalCoordinates deviation = {};
  int32_t sequence = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
    uic_mqtt_dotdot_parse_aox_locator_angle_correction(
      jsn,
      tag_unid,

      direction,

      deviation,

      sequence
      );

  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "AngleCorrection");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleCorrection", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "AngleCorrection", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      tag_unid.c_str(),
  
      direction,
  
      deviation,
  
      sequence
  
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/AoXLocator/Commands/WriteAttributes
void uic_mqtt_dotdot_on_aox_locator_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_aox_locator_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_aox_locator_state_t new_state = {};
  uic_mqtt_dotdot_aox_locator_updated_state_t new_updated_state = {};

  std::vector<MinMaxPair> azimuth_mask;

  std::vector<MinMaxPair> elevation_mask;

  std::vector<const char*> allow_list;

  std::vector<int8_t> antenna_array;


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_aox_locator_write_attributes(
      jsn,
      new_state,
      new_updated_state,
      azimuth_mask,
      elevation_mask,
      allow_list,
      antenna_array
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXLocator", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_aox_locator_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_aox_locator_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_aox_locator_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_aox_locator_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.reporting_mode = true;
      force_update.position_and_orientation_valid = true;
      force_update.position_and_orientation = true;
      force_update.azimuth_mask = true;
      force_update.elevation_mask = true;
      force_update.allow_list = true;
      force_update.aox_mode = true;
      force_update.antenna_mode = true;
      force_update.antenna_array = true;
      force_update.period_samples = true;
      force_update.angle_filtering = true;
      force_update.angle_filtering_weight = true;
      force_update.angle_correction_timeout = true;
      force_update.angle_correction_delay = true;
      force_update.cte_mode = true;
      force_update.cte_sampling_interval = true;
      force_update.cte_length = true;
      force_update.slot_duration = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"ReportingMode", &force_update.reporting_mode },
        {"PositionAndOrientationValid", &force_update.position_and_orientation_valid },
        {"PositionAndOrientation", &force_update.position_and_orientation },
        {"AzimuthMask", &force_update.azimuth_mask },
        {"ElevationMask", &force_update.elevation_mask },
        {"AllowList", &force_update.allow_list },
        {"AoXMode", &force_update.aox_mode },
        {"AntennaMode", &force_update.antenna_mode },
        {"AntennaArray", &force_update.antenna_array },
        {"PeriodSamples", &force_update.period_samples },
        {"AngleFiltering", &force_update.angle_filtering },
        {"AngleFilteringWeight", &force_update.angle_filtering_weight },
        {"AngleCorrectionTimeout", &force_update.angle_correction_timeout },
        {"AngleCorrectionDelay", &force_update.angle_correction_delay },
        {"CTEMode", &force_update.cte_mode },
        {"CTESamplingInterval", &force_update.cte_sampling_interval },
        {"CTELength", &force_update.cte_length },
        {"SlotDuration", &force_update.slot_duration },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_aox_locator_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "AoXLocator/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_aox_locator_reporting_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef AOX_LOCATOR_REPORTING_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = aox_locator_reporting_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for AOX_LOCATOR_REPORTING_MODE. Using number instead.");
  jsn["value"] = static_cast<AoXLocatorReportingMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/ReportingMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/ReportingMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_reporting_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/ReportingMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_position_and_orientation_valid_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64784,2,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64784,2,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/PositionAndOrientationValid", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/PositionAndOrientationValid";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_position_and_orientation_valid_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/PositionAndOrientationValid";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_position_and_orientation_publish(
  const char *base_topic,
  CoordinateAndOrientation value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json json_object = nlohmann::json::object();
   json_object["CoordinateX"] = value.CoordinateX;
   json_object["CoordinateY"] = value.CoordinateY;
   json_object["CoordinateZ"] = value.CoordinateZ;
   json_object["OrientationX"] = value.OrientationX;
   json_object["OrientationY"] = value.OrientationY;
   json_object["OrientationZ"] = value.OrientationZ;
  jsn["value"]= json_object;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/PositionAndOrientation", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/PositionAndOrientation";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_position_and_orientation_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/PositionAndOrientation";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_azimuth_mask_publish(
  const char *base_topic,
  size_t value_count,
  const MinMaxPair* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["Min"] = value[i].Min;
    json_object["Max"] = value[i].Max;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AzimuthMask", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AzimuthMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_azimuth_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/AzimuthMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_elevation_mask_publish(
  const char *base_topic,
  size_t value_count,
  const MinMaxPair* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["Min"] = value[i].Min;
    json_object["Max"] = value[i].Max;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/ElevationMask", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/ElevationMask";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_elevation_mask_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/ElevationMask";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_allow_list_publish(
  const char *base_topic,
  size_t value_count,
  const char** value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // String type
    jsn["value"].push_back(std::string(value[i]));
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AllowList", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AllowList";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_allow_list_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/AllowList";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_aox_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef AOX_LOCATOR_AOX_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = aox_locator_aox_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for AOX_LOCATOR_AOX_MODE. Using number instead.");
  jsn["value"] = static_cast<AoXLocatorAoXMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AoXMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AoXMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_aox_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/AoXMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_antenna_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef AOX_LOCATOR_ANTENNA_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = aox_locator_antenna_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for AOX_LOCATOR_ANTENNA_MODE. Using number instead.");
  jsn["value"] = static_cast<AoXLocatorAntennaMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AntennaMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AntennaMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_antenna_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/AntennaMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_antenna_array_publish(
  const char *base_topic,
  size_t value_count,
  const int8_t* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    jsn["value"].push_back(value[i]);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AntennaArray", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AntennaArray";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_antenna_array_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/AntennaArray";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_period_samples_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64784,11,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64784,11,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/PeriodSamples", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/PeriodSamples";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_period_samples_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/PeriodSamples";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_angle_filtering_publish(
  const char *base_topic,
  bool value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64784,12,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64784,12,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AngleFiltering", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AngleFiltering";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_angle_filtering_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/AngleFiltering";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_angle_filtering_weight_publish(
  const char *base_topic,
  double value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64784,13,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64784,13,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AngleFilteringWeight", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AngleFilteringWeight";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_angle_filtering_weight_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/AngleFilteringWeight";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_angle_correction_timeout_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64784,14,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64784,14,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AngleCorrectionTimeout", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AngleCorrectionTimeout";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_angle_correction_timeout_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/AngleCorrectionTimeout";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_angle_correction_delay_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64784,15,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64784,15,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/AngleCorrectionDelay", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/AngleCorrectionDelay";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_angle_correction_delay_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/AngleCorrectionDelay";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_cte_mode_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef AOX_LOCATOR_CTE_MODE_ENUM_NAME_AVAILABLE
  jsn["value"] = aox_locator_cte_mode_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for AOX_LOCATOR_CTE_MODE. Using number instead.");
  jsn["value"] = static_cast<AoXLocatorCTEMode>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/CTEMode", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/CTEMode";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_cte_mode_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/CTEMode";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_cte_sampling_interval_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64784,17,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64784,17,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/CTESamplingInterval", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/CTESamplingInterval";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_cte_sampling_interval_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/CTESamplingInterval";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_cte_length_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64784,18,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64784,18,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/CTELength", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/CTELength";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_cte_length_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/CTELength";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off

sl_status_t uic_mqtt_dotdot_aox_locator_slot_duration_publish(
  const char *base_topic,
  int8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  if (true == uic_dotdot_has_attribute_value_a_name(64784,19,value)) {
    jsn["value"] = uic_dotdot_get_attribute_value_name(64784,19,value);
  }else{
    jsn["value"] = value;
  }


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXLocator/Attributes/SlotDuration", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXLocator/Attributes/SlotDuration";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_locator_slot_duration_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/SlotDuration";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_aox_locator_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_aox_locator_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "AoXLocator/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_locator_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_aox_locator_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "AoXLocator/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_locator_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_aox_locator_iq_report_callback.empty()) {
    subscription_topic = base_topic + "AoXLocator/Commands/IQReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_locator_iq_report);
  }
  if (!uic_mqtt_dotdot_aox_locator_generated_iq_report_callback.empty()) {
    subscription_topic = base_topic + "AoXLocator/GeneratedCommands/IQReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_aox_locator_iq_report);
  }
  if (!uic_mqtt_dotdot_aox_locator_angle_report_callback.empty()) {
    subscription_topic = base_topic + "AoXLocator/Commands/AngleReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_locator_angle_report);
  }
  if (!uic_mqtt_dotdot_aox_locator_generated_angle_report_callback.empty()) {
    subscription_topic = base_topic + "AoXLocator/GeneratedCommands/AngleReport";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_aox_locator_angle_report);
  }
  if (!uic_mqtt_dotdot_aox_locator_angle_correction_callback.empty()) {
    subscription_topic = base_topic + "AoXLocator/Commands/AngleCorrection";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_locator_angle_correction);
  }
  if (!uic_mqtt_dotdot_aox_locator_generated_angle_correction_callback.empty()) {
    subscription_topic = base_topic + "AoXLocator/GeneratedCommands/AngleCorrection";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_aox_locator_angle_correction);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_aox_locator_attributes_init();

  uic_mqtt_dotdot_by_group_aox_locator_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback_t> uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback;
static std::set<uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback_t> uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_aox_position_estimation_write_attributes_callback(
  const uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_aox_position_estimation_write_attributes_callback(
  const uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_aox_position_estimation_write_attributes_callbacks()
{
  uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback_t>& get_uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback()
{
  return uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback;
}

void uic_mqtt_dotdot_set_aox_position_estimation_force_read_attributes_callback(
  const uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_aox_position_estimation_force_read_attributes_callback(
  const uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_aox_position_estimation_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/AoXPositionEstimation/Commands/WriteAttributes
void uic_mqtt_dotdot_on_aox_position_estimation_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_aox_position_estimation_state_t new_state = {};
  uic_mqtt_dotdot_aox_position_estimation_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_aox_position_estimation_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "AoXPositionEstimation", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXPositionEstimation", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXPositionEstimation", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_aox_position_estimation_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_aox_position_estimation_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.position = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"Position", &force_update.position },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "AoXPositionEstimation/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_aox_position_estimation_position_publish(
  const char *base_topic,
  EstimatedPosition value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json json_object = nlohmann::json::object();
   json_object["ApplicationId"] = value.ApplicationId;
   json_object["X"] = value.X;
   json_object["Y"] = value.Y;
   json_object["Z"] = value.Z;
   json_object["DeviationX"] = value.DeviationX;
   json_object["DeviationY"] = value.DeviationY;
   json_object["DeviationZ"] = value.DeviationZ;
   json_object["Sequence"] = value.Sequence;
  jsn["value"]= json_object;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "AoXPositionEstimation/Attributes/Position", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/AoXPositionEstimation/Attributes/Position";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_aox_position_estimation_position_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/AoXPositionEstimation/Attributes/Position";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_aox_position_estimation_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "AoXPositionEstimation/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_position_estimation_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "AoXPositionEstimation/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_aox_position_estimation_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_aox_position_estimation_attributes_init();

  uic_mqtt_dotdot_by_group_aox_position_estimation_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t> uic_mqtt_dotdot_protocol_controller_network_management_write_callback;
static std::set<uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t> uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback;
static std::set<uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback_t> uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback;
static std::set<uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback_t> uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback;

// Callbacks setters
void uic_mqtt_dotdot_protocol_controller_network_management_write_callback_set(const uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_protocol_controller_network_management_write_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_protocol_controller_network_management_write_callback_unset(const uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_network_management_write_callback.erase(callback);
}
void uic_mqtt_dotdot_protocol_controller_network_management_write_callback_clear()
{
  uic_mqtt_dotdot_protocol_controller_network_management_write_callback.clear();
}
std::set<uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t>& get_uic_mqtt_dotdot_protocol_controller_network_management_write_callback()
{
  return uic_mqtt_dotdot_protocol_controller_network_management_write_callback;
}

void uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback_set(const uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback_unset(const uic_mqtt_dotdot_protocol_controller_network_management_write_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback.erase(callback);
}
void uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback_clear()
{
  uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback.clear();
}

void uic_mqtt_dotdot_set_protocol_controller_network_management_write_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_protocol_controller_network_management_write_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_protocol_controller_network_management_write_attributes_callbacks()
{
  uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback_t>& get_uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback()
{
  return uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback;
}

void uic_mqtt_dotdot_set_protocol_controller_network_management_force_read_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_protocol_controller_network_management_force_read_attributes_callback(
  const uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_protocol_controller_network_management_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-NetworkManagement/Commands/Write
void uic_mqtt_dotdot_on_protocol_controller_network_management_write(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_protocol_controller_network_management_write_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-NetworkManagement", "Write");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "Write", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "Write", "");
    return;
  }



  for (const auto& callback: uic_mqtt_dotdot_protocol_controller_network_management_write_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }

}

// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-NetworkManagement/GeneratedCommands/Write
static void uic_mqtt_dotdot_on_generated_protocol_controller_network_management_write(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (message_length == 0 || (uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback.empty())) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }



  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

  
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-NetworkManagement", "Write");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "Write", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "Write", "");
    return;
  }




  for (const auto& callback: uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL
    );
  }
}


// Callback function for incoming publications on ucl/by-unid/+/+/ProtocolController-NetworkManagement/Commands/WriteAttributes
void uic_mqtt_dotdot_on_protocol_controller_network_management_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic_no_endpoint(topic,unid)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_protocol_controller_network_management_state_t new_state = {};
  uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_protocol_controller_network_management_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "ProtocolController-NetworkManagement", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController-NetworkManagement", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_protocol_controller_network_management_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.network_management_state = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"NetworkManagementState", &force_update.network_management_state },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "ProtocolController-NetworkManagement/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_protocol_controller_network_management_network_management_state_publish(
  const char *base_topic,
  NetworkManagementState value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  nlohmann::json json_object = nlohmann::json::object();
   json_object["State"] = value.State;
   json_object["SupportedStateList"] = value.SupportedStateList;
   json_object["StateParameters"] = value.StateParameters;
   json_object["RequestedStateParameters"] = value.RequestedStateParameters;
  jsn["value"]= json_object;


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "ProtocolController/NetworkManagement/Attributes/NetworkManagementState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/ProtocolController/NetworkManagement/Attributes/NetworkManagementState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_protocol_controller_network_management_network_management_state_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/ProtocolController/NetworkManagement/Attributes/NetworkManagementState";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_protocol_controller_network_management_init()
{
  std::string base_topic = "ucl/by-unid/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "ProtocolController/NetworkManagement/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_network_management_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "ProtocolController/NetworkManagement/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_network_management_force_read_attributes);
  }
  if (!uic_mqtt_dotdot_protocol_controller_network_management_write_callback.empty()) {
    subscription_topic = base_topic + "ProtocolController/NetworkManagement/Commands/Write";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_protocol_controller_network_management_write);
  }
  if (!uic_mqtt_dotdot_protocol_controller_network_management_generated_write_callback.empty()) {
    subscription_topic = base_topic + "ProtocolController/NetworkManagement/GeneratedCommands/Write";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_protocol_controller_network_management_write);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_protocol_controller_network_management_attributes_init();


  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_descriptor_write_attributes_callback_t> uic_mqtt_dotdot_descriptor_write_attributes_callback;
static std::set<uic_mqtt_dotdot_descriptor_force_read_attributes_callback_t> uic_mqtt_dotdot_descriptor_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_descriptor_write_attributes_callback(
  const uic_mqtt_dotdot_descriptor_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_descriptor_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_descriptor_write_attributes_callback(
  const uic_mqtt_dotdot_descriptor_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_descriptor_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_descriptor_write_attributes_callbacks()
{
  uic_mqtt_dotdot_descriptor_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_descriptor_write_attributes_callback_t>& get_uic_mqtt_dotdot_descriptor_write_attributes_callback()
{
  return uic_mqtt_dotdot_descriptor_write_attributes_callback;
}

void uic_mqtt_dotdot_set_descriptor_force_read_attributes_callback(
  const uic_mqtt_dotdot_descriptor_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_descriptor_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_descriptor_force_read_attributes_callback(
  const uic_mqtt_dotdot_descriptor_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_descriptor_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_descriptor_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_descriptor_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/Descriptor/Commands/WriteAttributes
void uic_mqtt_dotdot_on_descriptor_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_descriptor_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_descriptor_state_t new_state = {};
  uic_mqtt_dotdot_descriptor_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_descriptor_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "Descriptor", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Descriptor", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Descriptor", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_descriptor_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_descriptor_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_descriptor_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_descriptor_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.device_type_list = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"DeviceTypeList", &force_update.device_type_list },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_descriptor_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "Descriptor/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_descriptor_device_type_list_publish(
  const char *base_topic,
  size_t value_count,
  const DeviceTypeStruct* value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a variable size array of the same known type.
  // Create an array under the value {"value":[]}
  jsn["value"] = nlohmann::json::array();

  for (size_t i = 0; i<value_count;i++){
    // Struct type
    nlohmann::json json_object = nlohmann::json::object();
    json_object["DeviceType"] = value[i].DeviceType;
    json_object["Revision"] = value[i].Revision;
    jsn["value"].push_back(json_object);
  }



  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "Descriptor/Attributes/DeviceTypeList", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/Descriptor/Attributes/DeviceTypeList";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_descriptor_device_type_list_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/Descriptor/Attributes/DeviceTypeList";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_descriptor_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_descriptor_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "Descriptor/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_descriptor_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_descriptor_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "Descriptor/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_descriptor_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_descriptor_attributes_init();

  uic_mqtt_dotdot_by_group_descriptor_init();

  return SL_STATUS_OK;
}

// Callbacks pointers
static std::set<uic_mqtt_dotdot_unify_thermostat_write_attributes_callback_t> uic_mqtt_dotdot_unify_thermostat_write_attributes_callback;
static std::set<uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback_t> uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback;

// Callbacks setters

void uic_mqtt_dotdot_set_unify_thermostat_write_attributes_callback(
  const uic_mqtt_dotdot_unify_thermostat_write_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_unify_thermostat_write_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_unify_thermostat_write_attributes_callback(
  const uic_mqtt_dotdot_unify_thermostat_write_attributes_callback_t callback)
{
  uic_mqtt_dotdot_unify_thermostat_write_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_unify_thermostat_write_attributes_callbacks()
{
  uic_mqtt_dotdot_unify_thermostat_write_attributes_callback.clear();
}
std::set<uic_mqtt_dotdot_unify_thermostat_write_attributes_callback_t>& get_uic_mqtt_dotdot_unify_thermostat_write_attributes_callback()
{
  return uic_mqtt_dotdot_unify_thermostat_write_attributes_callback;
}

void uic_mqtt_dotdot_set_unify_thermostat_force_read_attributes_callback(
  const uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback_t callback)
{
  if (callback != nullptr) {
    uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback.insert(callback);
  }
}
void uic_mqtt_dotdot_unset_unify_thermostat_force_read_attributes_callback(
  const uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback_t callback)
{
  uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback.erase(callback);
}
void uic_mqtt_dotdot_clear_unify_thermostat_force_read_attributes_callbacks()
{
  uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback.clear();
}


// Callback function for incoming publications on ucl/by-unid/+/+/UnifyThermostat/Commands/WriteAttributes
void uic_mqtt_dotdot_on_unify_thermostat_WriteAttributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  if (uic_mqtt_dotdot_unify_thermostat_write_attributes_callback.empty()) {
    return;
  }

  if (message_length == 0) {
    return;
  }

  std::string unid;
  uint8_t endpoint = 0; // Default value for endpoint-less topics.
  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  uic_mqtt_dotdot_unify_thermostat_state_t new_state = {};
  uic_mqtt_dotdot_unify_thermostat_updated_state_t new_updated_state = {};


  nlohmann::json jsn;
  try {
    jsn = nlohmann::json::parse(std::string(message));

    uic_mqtt_dotdot_parse_unify_thermostat_write_attributes(
      jsn,
      new_state,
      new_updated_state
    );
  } catch (const nlohmann::json::parse_error& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyThermostat", "WriteAttributes");
    return;
  } catch (const nlohmann::json::exception& e) {
    // Catch JSON object field parsing errors
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyThermostat", "WriteAttributes", e.what());
    return;
  } catch (const std::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyThermostat", "WriteAttributes", "");
    return;
  }

  for (const auto& callback: uic_mqtt_dotdot_unify_thermostat_write_attributes_callback){
    callback(
      static_cast<dotdot_unid_t>(unid.c_str()),
      endpoint,
      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
      new_state,
      new_updated_state
    );
  }

}

static void uic_mqtt_dotdot_on_unify_thermostat_force_read_attributes(
  const char *topic,
  const char *message,
  const size_t message_length)
{
  uint8_t endpoint = 0;
  std::string unid;

  if ((message_length == 0) || (uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback.empty())) {
    return;
  }

  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
    sl_log_debug(LOG_TAG,
                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
                topic);
    return;
  }

  try {
    uic_mqtt_dotdot_unify_thermostat_updated_state_t force_update = {0};
    bool trigger_handler = false;

    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();

    // Assume all attributes to be read on empty array received
    if (attributes.size() == 0) {
      force_update.operating_state = true;
      trigger_handler = true;
    } else {
      std::unordered_map<std::string, bool *> supported_attrs = {
        {"OperatingState", &force_update.operating_state },
      };

      for (auto& attribute : attributes) {
        auto found_attr = supported_attrs.find(attribute);
        if (found_attr != supported_attrs.end()) {
          *(found_attr->second) = true;
          trigger_handler = true;
        }
      }
    }

    if (trigger_handler == true) {
      for (const auto& callback: uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback) {
        callback(
          static_cast<dotdot_unid_t>(unid.c_str()),
          endpoint,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
          force_update
        );
      }
    }
  } catch (...) {
    sl_log_debug(LOG_TAG, "UnifyThermostat/Commands/ForceReadAttributes: Unable to parse JSON payload");
    return;
  }
}

sl_status_t uic_mqtt_dotdot_unify_thermostat_operating_state_publish(
  const char *base_topic,
  uint8_t value,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type
)
{
  nlohmann::json jsn;

  // This is a single value

  #ifdef UNIFY_THERMOSTAT_OPERATING_STATE_ENUM_NAME_AVAILABLE
  jsn["value"] = unify_thermostat_operating_state_get_enum_value_name((uint32_t)value);
  #elif defined(ENUM8_ENUM_NAME_AVAILABLE)
  jsn["value"] = enum8_get_enum_value_name((uint32_t)value);
  #else
  sl_log_warning(LOG_TAG,"Warning: Enum name not available for UNIFY_THERMOSTAT_OPERATING_STATE. Using number instead.");
  jsn["value"] = static_cast<UnifyThermostatOperatingState>(value);
  #endif


  std::string payload_str;
  try {
    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
  } catch (const nlohmann::json::exception& e) {
    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyThermostat/Attributes/OperatingState", e.what());
    return SL_STATUS_OK;
  }


  std::string topic = std::string(base_topic) + "/UnifyThermostat/Attributes/OperatingState";
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
  {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
  {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(),
              payload_str.c_str(),
              payload_str.length(),
              true);
  }
  return SL_STATUS_OK;
}

sl_status_t uic_mqtt_dotdot_unify_thermostat_operating_state_unretain(
  const char *base_topic,
  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
{
  // clang-format on
  std::string topic
    = std::string(base_topic)
      + "/UnifyThermostat/Attributes/OperatingState";

  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_desired = topic + "/Desired";
    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
  }
  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
    std::string topic_reported = topic + "/Reported";
    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
  }
  return SL_STATUS_OK;
}
// clang-format off


sl_status_t uic_mqtt_dotdot_unify_thermostat_init()
{
  std::string base_topic = "ucl/by-unid/+/+/";

  std::string subscription_topic;
  if(!uic_mqtt_dotdot_unify_thermostat_write_attributes_callback.empty()) {
    subscription_topic = base_topic + "UnifyThermostat/Commands/WriteAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_thermostat_WriteAttributes);
  }

  if(!uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback.empty()) {
    subscription_topic = base_topic + "UnifyThermostat/Commands/ForceReadAttributes";
    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_thermostat_force_read_attributes);
  }

  // Init the attributes for that cluster
  uic_mqtt_dotdot_unify_thermostat_attributes_init();

  uic_mqtt_dotdot_by_group_unify_thermostat_init();

  return SL_STATUS_OK;
}


sl_status_t uic_mqtt_dotdot_init() {

  sl_status_t status_flag = SL_STATUS_OK;

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_basic_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_power_configuration_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_device_temperature_configuration_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_identify_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_groups_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_scenes_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_on_off_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_level_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_alarms_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_time_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_poll_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_shade_configuration_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_door_lock_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_window_covering_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_barrier_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_pump_configuration_and_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_thermostat_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_fan_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_dehumidification_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_thermostat_user_interface_configuration_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_color_control_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_ballast_configuration_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_illuminance_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_illuminance_level_sensing_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_temperature_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_pressure_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_flow_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_relativity_humidity_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_occupancy_sensing_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_soil_moisture_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_ph_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_electrical_conductivity_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_wind_speed_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_carbon_monoxide_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_carbon_dioxide_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_pm25_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_ias_zone_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_iaswd_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_metering_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_electrical_measurement_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_diagnostics_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_protocol_controller_rf_telemetry_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_state_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_binding_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_system_metrics_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_application_monitoring_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_name_and_location_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_configuration_parameters_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_aox_locator_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_aox_position_estimation_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_protocol_controller_network_management_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_descriptor_init();
  }

  if (status_flag == SL_STATUS_OK) {
    status_flag = uic_mqtt_dotdot_unify_thermostat_init();
  }


  return status_flag;
}

// Publish all supported dotdot cluster commands per each endpoints.
void uic_mqtt_dotdot_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  uic_mqtt_dotdot_basic_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_power_configuration_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_device_temperature_configuration_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_identify_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_groups_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_scenes_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_on_off_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_level_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_alarms_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_time_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_poll_control_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_shade_configuration_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_door_lock_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_window_covering_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_barrier_control_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_pump_configuration_and_control_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_thermostat_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_fan_control_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_dehumidification_control_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_color_control_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_ballast_configuration_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_illuminance_measurement_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_illuminance_level_sensing_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_temperature_measurement_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_pressure_measurement_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_flow_measurement_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_relativity_humidity_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_occupancy_sensing_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_soil_moisture_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_ph_measurement_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_electrical_conductivity_measurement_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_wind_speed_measurement_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_carbon_monoxide_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_carbon_dioxide_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_pm25_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_ias_zone_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_iaswd_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_metering_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_electrical_measurement_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_diagnostics_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_supported_commands(unid, 0);
  uic_mqtt_dotdot_state_publish_supported_commands(unid, 0);
  uic_mqtt_dotdot_binding_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_system_metrics_publish_supported_commands(unid, 0);
  uic_mqtt_dotdot_application_monitoring_publish_supported_commands(unid, 0);
  uic_mqtt_dotdot_name_and_location_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_configuration_parameters_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_aox_locator_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_aox_position_estimation_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_protocol_controller_network_management_publish_supported_commands(unid, 0);
  uic_mqtt_dotdot_descriptor_publish_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(unid, endpoint_id);
}

void uic_mqtt_dotdot_publish_empty_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  uic_mqtt_dotdot_basic_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_power_configuration_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_device_temperature_configuration_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_identify_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_groups_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_scenes_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_on_off_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_level_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_alarms_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_time_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_poll_control_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_shade_configuration_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_door_lock_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_window_covering_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_barrier_control_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_pump_configuration_and_control_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_thermostat_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_fan_control_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_dehumidification_control_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_color_control_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_ballast_configuration_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_illuminance_measurement_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_illuminance_level_sensing_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_temperature_measurement_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_pressure_measurement_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_flow_measurement_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_relativity_humidity_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_occupancy_sensing_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_soil_moisture_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_ph_measurement_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_electrical_conductivity_measurement_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_wind_speed_measurement_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_carbon_monoxide_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_carbon_dioxide_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_pm25_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_ias_zone_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_iaswd_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_metering_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_electrical_measurement_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_diagnostics_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_empty_supported_commands(unid);
  uic_mqtt_dotdot_state_publish_empty_supported_commands(unid);
  uic_mqtt_dotdot_binding_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_system_metrics_publish_empty_supported_commands(unid);
  uic_mqtt_dotdot_application_monitoring_publish_empty_supported_commands(unid);
  uic_mqtt_dotdot_name_and_location_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_configuration_parameters_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_aox_locator_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_aox_position_estimation_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_protocol_controller_network_management_publish_empty_supported_commands(unid);
  uic_mqtt_dotdot_descriptor_publish_empty_supported_commands(unid, endpoint_id);
  uic_mqtt_dotdot_unify_thermostat_publish_empty_supported_commands(unid, endpoint_id);
}

// Publishing Cluster Revision for Basic Cluster
void uic_mqtt_dotdot_basic_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Basic/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Basic Cluster
void uic_mqtt_dotdot_basic_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Basic/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_basic_reset_to_factory_defaults_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_basic_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_basic_write_attributes_callback) {
    uic_mqtt_dotdot_basic_state_t basic_new_state = {};
    uic_mqtt_dotdot_basic_updated_state_t basic_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          basic_new_state,
          basic_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_basic_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_basic_force_read_attributes_callback) {
    uic_mqtt_dotdot_basic_updated_state_t basic_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          basic_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Basic Cluster
void uic_mqtt_dotdot_basic_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_basic_reset_to_factory_defaults_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ResetToFactoryDefaults")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_basic_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_basic_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Basic/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Basic/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Basic Cluster
void uic_mqtt_dotdot_basic_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Basic/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for PowerConfiguration Cluster
void uic_mqtt_dotdot_power_configuration_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/PowerConfiguration/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for PowerConfiguration Cluster
void uic_mqtt_dotdot_power_configuration_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/PowerConfiguration/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_power_configuration_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_power_configuration_write_attributes_callback) {
    uic_mqtt_dotdot_power_configuration_state_t power_configuration_new_state = {};
    uic_mqtt_dotdot_power_configuration_updated_state_t power_configuration_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          power_configuration_new_state,
          power_configuration_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_power_configuration_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_power_configuration_force_read_attributes_callback) {
    uic_mqtt_dotdot_power_configuration_updated_state_t power_configuration_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          power_configuration_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for PowerConfiguration Cluster
void uic_mqtt_dotdot_power_configuration_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_power_configuration_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_power_configuration_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PowerConfiguration/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/PowerConfiguration/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for PowerConfiguration Cluster
void uic_mqtt_dotdot_power_configuration_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PowerConfiguration/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for DeviceTemperatureConfiguration Cluster
void uic_mqtt_dotdot_device_temperature_configuration_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/DeviceTemperatureConfiguration/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for DeviceTemperatureConfiguration Cluster
void uic_mqtt_dotdot_device_temperature_configuration_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/DeviceTemperatureConfiguration/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_device_temperature_configuration_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_device_temperature_configuration_write_attributes_callback) {
    uic_mqtt_dotdot_device_temperature_configuration_state_t device_temperature_configuration_new_state = {};
    uic_mqtt_dotdot_device_temperature_configuration_updated_state_t device_temperature_configuration_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          device_temperature_configuration_new_state,
          device_temperature_configuration_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_callback) {
    uic_mqtt_dotdot_device_temperature_configuration_updated_state_t device_temperature_configuration_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          device_temperature_configuration_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for DeviceTemperatureConfiguration Cluster
void uic_mqtt_dotdot_device_temperature_configuration_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_device_temperature_configuration_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_device_temperature_configuration_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/DeviceTemperatureConfiguration/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/DeviceTemperatureConfiguration/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for DeviceTemperatureConfiguration Cluster
void uic_mqtt_dotdot_device_temperature_configuration_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/DeviceTemperatureConfiguration/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Identify Cluster
void uic_mqtt_dotdot_identify_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Identify/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Identify Cluster
void uic_mqtt_dotdot_identify_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Identify/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_identify_identify_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t identify_time_value;
    memset(&identify_time_value, 0x00, sizeof(identify_time_value));
    for (const auto& callback: uic_mqtt_dotdot_identify_identify_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        identify_time_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_identify_identify_query_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t timeout_value;
    memset(&timeout_value, 0x00, sizeof(timeout_value));
    for (const auto& callback: uic_mqtt_dotdot_identify_identify_query_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        timeout_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_identify_identify_query_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_identify_identify_query_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_identify_trigger_effect_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    TriggerEffectEffectIdentifier effect_identifier_value;
    memset(&effect_identifier_value, 0x00, sizeof(effect_identifier_value));
    TriggerEffectEffectVariant effect_variant_value;
    memset(&effect_variant_value, 0x00, sizeof(effect_variant_value));
    for (const auto& callback: uic_mqtt_dotdot_identify_trigger_effect_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        effect_identifier_value,
    
        effect_variant_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_identify_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_identify_write_attributes_callback) {
    uic_mqtt_dotdot_identify_state_t identify_new_state = {};
    uic_mqtt_dotdot_identify_updated_state_t identify_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          identify_new_state,
          identify_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_identify_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_identify_force_read_attributes_callback) {
    uic_mqtt_dotdot_identify_updated_state_t identify_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          identify_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Identify Cluster
void uic_mqtt_dotdot_identify_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_identify_identify_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Identify")";
  }
  if (uic_mqtt_dotdot_identify_identify_query_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("IdentifyQueryResponse")";
  }
  if (uic_mqtt_dotdot_identify_identify_query_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("IdentifyQuery")";
  }
  if (uic_mqtt_dotdot_identify_trigger_effect_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("TriggerEffect")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_identify_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_identify_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Identify/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Identify/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Identify Cluster
void uic_mqtt_dotdot_identify_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Identify/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Groups Cluster
void uic_mqtt_dotdot_groups_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Groups/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Groups Cluster
void uic_mqtt_dotdot_groups_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Groups/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_groups_add_group_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t group_id_value;
    memset(&group_id_value, 0x00, sizeof(group_id_value));
    const char* group_name_value;
    memset(&group_name_value, 0x00, sizeof(group_name_value));
    for (const auto& callback: uic_mqtt_dotdot_groups_add_group_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        group_id_value,
    
        group_name_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_groups_add_group_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    uint16_t group_id_value;
    memset(&group_id_value, 0x00, sizeof(group_id_value));
    for (const auto& callback: uic_mqtt_dotdot_groups_add_group_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        group_id_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_groups_view_group_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t group_id_value;
    memset(&group_id_value, 0x00, sizeof(group_id_value));
    for (const auto& callback: uic_mqtt_dotdot_groups_view_group_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        group_id_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_groups_view_group_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    uint16_t group_id_value;
    memset(&group_id_value, 0x00, sizeof(group_id_value));
    const char* group_name_value;
    memset(&group_name_value, 0x00, sizeof(group_name_value));
    for (const auto& callback: uic_mqtt_dotdot_groups_view_group_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        group_id_value,
    
        group_name_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_groups_get_group_membership_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_groups_get_group_membership_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        0, nullptr

        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_groups_get_group_membership_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t capacity_value;
    memset(&capacity_value, 0x00, sizeof(capacity_value));
    for (const auto& callback: uic_mqtt_dotdot_groups_get_group_membership_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        capacity_value,
    
        0, nullptr

        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_groups_remove_group_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t group_id_value;
    memset(&group_id_value, 0x00, sizeof(group_id_value));
    for (const auto& callback: uic_mqtt_dotdot_groups_remove_group_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        group_id_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_groups_remove_group_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    uint16_t group_id_value;
    memset(&group_id_value, 0x00, sizeof(group_id_value));
    for (const auto& callback: uic_mqtt_dotdot_groups_remove_group_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        group_id_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_groups_remove_all_groups_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_groups_remove_all_groups_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_groups_add_group_if_identifying_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t group_id_value;
    memset(&group_id_value, 0x00, sizeof(group_id_value));
    const char* group_name_value;
    memset(&group_name_value, 0x00, sizeof(group_name_value));
    for (const auto& callback: uic_mqtt_dotdot_groups_add_group_if_identifying_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        group_id_value,
    
        group_name_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_groups_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_groups_write_attributes_callback) {
    uic_mqtt_dotdot_groups_state_t groups_new_state = {};
    uic_mqtt_dotdot_groups_updated_state_t groups_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          groups_new_state,
          groups_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_groups_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_groups_force_read_attributes_callback) {
    uic_mqtt_dotdot_groups_updated_state_t groups_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          groups_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Groups Cluster
void uic_mqtt_dotdot_groups_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_groups_add_group_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("AddGroup")";
  }
  if (uic_mqtt_dotdot_groups_add_group_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("AddGroupResponse")";
  }
  if (uic_mqtt_dotdot_groups_view_group_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ViewGroup")";
  }
  if (uic_mqtt_dotdot_groups_view_group_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ViewGroupResponse")";
  }
  if (uic_mqtt_dotdot_groups_get_group_membership_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetGroupMembership")";
  }
  if (uic_mqtt_dotdot_groups_get_group_membership_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetGroupMembershipResponse")";
  }
  if (uic_mqtt_dotdot_groups_remove_group_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("RemoveGroup")";
  }
  if (uic_mqtt_dotdot_groups_remove_group_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("RemoveGroupResponse")";
  }
  if (uic_mqtt_dotdot_groups_remove_all_groups_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("RemoveAllGroups")";
  }
  if (uic_mqtt_dotdot_groups_add_group_if_identifying_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("AddGroupIfIdentifying")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_groups_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_groups_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Groups/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Groups/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Groups Cluster
void uic_mqtt_dotdot_groups_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Groups/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Scenes Cluster
void uic_mqtt_dotdot_scenes_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Scenes/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Scenes Cluster
void uic_mqtt_dotdot_scenes_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Scenes/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_scenes_add_scene_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    SSceneName scene_name_value;
    memset(&scene_name_value, 0x00, sizeof(scene_name_value));
    uint8_t transition_time100ms_value;
    memset(&transition_time100ms_value, 0x00, sizeof(transition_time100ms_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_add_scene_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        groupid_value,
    
        sceneid_value,
    
        transition_time_value,
    
        scene_name_value,
    
        0, nullptr,

        transition_time100ms_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_add_scene_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_add_scene_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        groupid_value,
    
        sceneid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_view_scene_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_view_scene_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        groupid_value,
    
        sceneid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_view_scene_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    SSceneName scene_name_value;
    memset(&scene_name_value, 0x00, sizeof(scene_name_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_view_scene_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        groupid_value,
    
        sceneid_value,
    
        transition_time_value,
    
        scene_name_value,
    
        0, nullptr

        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_remove_scene_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_remove_scene_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        groupid_value,
    
        sceneid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_remove_scene_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_remove_scene_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        groupid_value,
    
        sceneid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_remove_all_scenes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_remove_all_scenes_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        groupid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_remove_all_scenes_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_remove_all_scenes_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        groupid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_store_scene_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_store_scene_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        groupid_value,
    
        sceneid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_store_scene_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_store_scene_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        groupid_value,
    
        sceneid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_recall_scene_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_recall_scene_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        groupid_value,
    
        sceneid_value,
    
        transition_time_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_get_scene_membership_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_get_scene_membership_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        groupid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_get_scene_membership_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    uint8_t capacity_value;
    memset(&capacity_value, 0x00, sizeof(capacity_value));
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_get_scene_membership_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        capacity_value,
    
        groupid_value,
    
        0, nullptr

        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_enhanced_add_scene_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    SSceneName scene_name_value;
    memset(&scene_name_value, 0x00, sizeof(scene_name_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_enhanced_add_scene_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        groupid_value,
    
        sceneid_value,
    
        transition_time_value,
    
        scene_name_value,
    
        0, nullptr

        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_enhanced_add_scene_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_enhanced_add_scene_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        groupid_value,
    
        sceneid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_enhanced_view_scene_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_enhanced_view_scene_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        groupid_value,
    
        sceneid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_enhanced_view_scene_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    SGroupId groupid_value;
    memset(&groupid_value, 0x00, sizeof(groupid_value));
    uint8_t sceneid_value;
    memset(&sceneid_value, 0x00, sizeof(sceneid_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    SSceneName scene_name_value;
    memset(&scene_name_value, 0x00, sizeof(scene_name_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_enhanced_view_scene_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        groupid_value,
    
        sceneid_value,
    
        transition_time_value,
    
        scene_name_value,
    
        0, nullptr

        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_copy_scene_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t mode_value;
    memset(&mode_value, 0x00, sizeof(mode_value));
    SGroupId group_identifier_from_value;
    memset(&group_identifier_from_value, 0x00, sizeof(group_identifier_from_value));
    uint8_t scene_identifier_from_value;
    memset(&scene_identifier_from_value, 0x00, sizeof(scene_identifier_from_value));
    SGroupId group_identifier_to_value;
    memset(&group_identifier_to_value, 0x00, sizeof(group_identifier_to_value));
    uint8_t scene_identifier_to_value;
    memset(&scene_identifier_to_value, 0x00, sizeof(scene_identifier_to_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_copy_scene_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        mode_value,
    
        group_identifier_from_value,
    
        scene_identifier_from_value,
    
        group_identifier_to_value,
    
        scene_identifier_to_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_scenes_copy_scene_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    SGroupId group_identifier_from_value;
    memset(&group_identifier_from_value, 0x00, sizeof(group_identifier_from_value));
    uint8_t scene_identifier_from_value;
    memset(&scene_identifier_from_value, 0x00, sizeof(scene_identifier_from_value));
    for (const auto& callback: uic_mqtt_dotdot_scenes_copy_scene_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        group_identifier_from_value,
    
        scene_identifier_from_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_scenes_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_scenes_write_attributes_callback) {
    uic_mqtt_dotdot_scenes_state_t scenes_new_state = {};
    uic_mqtt_dotdot_scenes_updated_state_t scenes_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          scenes_new_state,
          scenes_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_scenes_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_scenes_force_read_attributes_callback) {
    uic_mqtt_dotdot_scenes_updated_state_t scenes_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          scenes_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Scenes Cluster
void uic_mqtt_dotdot_scenes_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_scenes_add_scene_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("AddScene")";
  }
  if (uic_mqtt_dotdot_scenes_add_scene_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("AddSceneResponse")";
  }
  if (uic_mqtt_dotdot_scenes_view_scene_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ViewScene")";
  }
  if (uic_mqtt_dotdot_scenes_view_scene_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ViewSceneResponse")";
  }
  if (uic_mqtt_dotdot_scenes_remove_scene_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("RemoveScene")";
  }
  if (uic_mqtt_dotdot_scenes_remove_scene_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("RemoveSceneResponse")";
  }
  if (uic_mqtt_dotdot_scenes_remove_all_scenes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("RemoveAllScenes")";
  }
  if (uic_mqtt_dotdot_scenes_remove_all_scenes_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("RemoveAllScenesResponse")";
  }
  if (uic_mqtt_dotdot_scenes_store_scene_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("StoreScene")";
  }
  if (uic_mqtt_dotdot_scenes_store_scene_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("StoreSceneResponse")";
  }
  if (uic_mqtt_dotdot_scenes_recall_scene_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("RecallScene")";
  }
  if (uic_mqtt_dotdot_scenes_get_scene_membership_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetSceneMembership")";
  }
  if (uic_mqtt_dotdot_scenes_get_scene_membership_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetSceneMembershipResponse")";
  }
  if (uic_mqtt_dotdot_scenes_enhanced_add_scene_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("EnhancedAddScene")";
  }
  if (uic_mqtt_dotdot_scenes_enhanced_add_scene_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("EnhancedAddSceneResponse")";
  }
  if (uic_mqtt_dotdot_scenes_enhanced_view_scene_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("EnhancedViewScene")";
  }
  if (uic_mqtt_dotdot_scenes_enhanced_view_scene_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("EnhancedViewSceneResponse")";
  }
  if (uic_mqtt_dotdot_scenes_copy_scene_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("CopyScene")";
  }
  if (uic_mqtt_dotdot_scenes_copy_scene_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("CopySceneResponse")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_scenes_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_scenes_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Scenes/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Scenes/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Scenes Cluster
void uic_mqtt_dotdot_scenes_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Scenes/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for OnOff Cluster
void uic_mqtt_dotdot_on_off_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/OnOff/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for OnOff Cluster
void uic_mqtt_dotdot_on_off_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/OnOff/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_on_off_off_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_on_off_off_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_on_off_on_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_on_off_on_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_on_off_toggle_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_on_off_toggle_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_on_off_off_with_effect_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    OffWithEffectEffectIdentifier effect_identifier_value;
    memset(&effect_identifier_value, 0x00, sizeof(effect_identifier_value));
    uint8_t effect_variant_value;
    memset(&effect_variant_value, 0x00, sizeof(effect_variant_value));
    for (const auto& callback: uic_mqtt_dotdot_on_off_off_with_effect_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        effect_identifier_value,
    
        effect_variant_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_on_off_on_with_recall_global_scene_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_on_off_on_with_timed_off_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t on_off_control_value;
    memset(&on_off_control_value, 0x00, sizeof(on_off_control_value));
    uint16_t on_time_value;
    memset(&on_time_value, 0x00, sizeof(on_time_value));
    uint16_t off_wait_time_value;
    memset(&off_wait_time_value, 0x00, sizeof(off_wait_time_value));
    for (const auto& callback: uic_mqtt_dotdot_on_off_on_with_timed_off_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        on_off_control_value,
    
        on_time_value,
    
        off_wait_time_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_on_off_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_on_off_write_attributes_callback) {
    uic_mqtt_dotdot_on_off_state_t on_off_new_state = {};
    uic_mqtt_dotdot_on_off_updated_state_t on_off_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          on_off_new_state,
          on_off_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_on_off_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_on_off_force_read_attributes_callback) {
    uic_mqtt_dotdot_on_off_updated_state_t on_off_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          on_off_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for OnOff Cluster
void uic_mqtt_dotdot_on_off_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_on_off_off_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Off")";
  }
  if (uic_mqtt_dotdot_on_off_on_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("On")";
  }
  if (uic_mqtt_dotdot_on_off_toggle_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Toggle")";
  }
  if (uic_mqtt_dotdot_on_off_off_with_effect_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("OffWithEffect")";
  }
  if (uic_mqtt_dotdot_on_off_on_with_recall_global_scene_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("OnWithRecallGlobalScene")";
  }
  if (uic_mqtt_dotdot_on_off_on_with_timed_off_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("OnWithTimedOff")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_on_off_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_on_off_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/OnOff/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/OnOff/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for OnOff Cluster
void uic_mqtt_dotdot_on_off_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/OnOff/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Level Cluster
void uic_mqtt_dotdot_level_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Level/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Level Cluster
void uic_mqtt_dotdot_level_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Level/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_level_move_to_level_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t level_value;
    memset(&level_value, 0x00, sizeof(level_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_level_move_to_level_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        level_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_level_move_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    MoveStepMode move_mode_value;
    memset(&move_mode_value, 0x00, sizeof(move_mode_value));
    uint8_t rate_value;
    memset(&rate_value, 0x00, sizeof(rate_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_level_move_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        move_mode_value,
    
        rate_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_level_step_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    MoveStepMode step_mode_value;
    memset(&step_mode_value, 0x00, sizeof(step_mode_value));
    uint8_t step_size_value;
    memset(&step_size_value, 0x00, sizeof(step_size_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_level_step_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        step_mode_value,
    
        step_size_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_level_stop_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_level_stop_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_level_move_to_level_with_on_off_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t level_value;
    memset(&level_value, 0x00, sizeof(level_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_level_move_to_level_with_on_off_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        level_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_level_move_with_on_off_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    MoveStepMode move_mode_value;
    memset(&move_mode_value, 0x00, sizeof(move_mode_value));
    uint8_t rate_value;
    memset(&rate_value, 0x00, sizeof(rate_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_level_move_with_on_off_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        move_mode_value,
    
        rate_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_level_step_with_on_off_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    MoveStepMode step_mode_value;
    memset(&step_mode_value, 0x00, sizeof(step_mode_value));
    uint8_t step_size_value;
    memset(&step_size_value, 0x00, sizeof(step_size_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_level_step_with_on_off_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        step_mode_value,
    
        step_size_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_level_stop_with_on_off_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_level_stop_with_on_off_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_level_move_to_closest_frequency_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t frequency_value;
    memset(&frequency_value, 0x00, sizeof(frequency_value));
    for (const auto& callback: uic_mqtt_dotdot_level_move_to_closest_frequency_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        frequency_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_level_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_level_write_attributes_callback) {
    uic_mqtt_dotdot_level_state_t level_new_state = {};
    uic_mqtt_dotdot_level_updated_state_t level_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          level_new_state,
          level_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_level_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_level_force_read_attributes_callback) {
    uic_mqtt_dotdot_level_updated_state_t level_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          level_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Level Cluster
void uic_mqtt_dotdot_level_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_level_move_to_level_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveToLevel")";
  }
  if (uic_mqtt_dotdot_level_move_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Move")";
  }
  if (uic_mqtt_dotdot_level_step_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Step")";
  }
  if (uic_mqtt_dotdot_level_stop_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Stop")";
  }
  if (uic_mqtt_dotdot_level_move_to_level_with_on_off_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveToLevelWithOnOff")";
  }
  if (uic_mqtt_dotdot_level_move_with_on_off_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveWithOnOff")";
  }
  if (uic_mqtt_dotdot_level_step_with_on_off_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("StepWithOnOff")";
  }
  if (uic_mqtt_dotdot_level_stop_with_on_off_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("StopWithOnOff")";
  }
  if (uic_mqtt_dotdot_level_move_to_closest_frequency_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveToClosestFrequency")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_level_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_level_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Level/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Level/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Level Cluster
void uic_mqtt_dotdot_level_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Level/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Alarms Cluster
void uic_mqtt_dotdot_alarms_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Alarms/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Alarms Cluster
void uic_mqtt_dotdot_alarms_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Alarms/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_alarms_reset_alarm_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t alarm_code_value;
    memset(&alarm_code_value, 0x00, sizeof(alarm_code_value));
    clusterId cluster_identifier_value;
    memset(&cluster_identifier_value, 0x00, sizeof(cluster_identifier_value));
    for (const auto& callback: uic_mqtt_dotdot_alarms_reset_alarm_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        alarm_code_value,
    
        cluster_identifier_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_alarms_alarm_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t alarm_code_value;
    memset(&alarm_code_value, 0x00, sizeof(alarm_code_value));
    clusterId cluster_identifier_value;
    memset(&cluster_identifier_value, 0x00, sizeof(cluster_identifier_value));
    for (const auto& callback: uic_mqtt_dotdot_alarms_alarm_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        alarm_code_value,
    
        cluster_identifier_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_alarms_reset_all_alarms_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_alarms_reset_all_alarms_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_alarms_get_alarm_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    uint8_t alarm_code_value;
    memset(&alarm_code_value, 0x00, sizeof(alarm_code_value));
    clusterId cluster_identifier_value;
    memset(&cluster_identifier_value, 0x00, sizeof(cluster_identifier_value));
    uint32_t time_stamp_value;
    memset(&time_stamp_value, 0x00, sizeof(time_stamp_value));
    for (const auto& callback: uic_mqtt_dotdot_alarms_get_alarm_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value,
    
        alarm_code_value,
    
        cluster_identifier_value,
    
        time_stamp_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_alarms_get_alarm_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_alarms_get_alarm_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_alarms_reset_alarm_log_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_alarms_reset_alarm_log_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_alarms_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_alarms_write_attributes_callback) {
    uic_mqtt_dotdot_alarms_state_t alarms_new_state = {};
    uic_mqtt_dotdot_alarms_updated_state_t alarms_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          alarms_new_state,
          alarms_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_alarms_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_alarms_force_read_attributes_callback) {
    uic_mqtt_dotdot_alarms_updated_state_t alarms_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          alarms_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Alarms Cluster
void uic_mqtt_dotdot_alarms_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_alarms_reset_alarm_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ResetAlarm")";
  }
  if (uic_mqtt_dotdot_alarms_alarm_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Alarm")";
  }
  if (uic_mqtt_dotdot_alarms_reset_all_alarms_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ResetAllAlarms")";
  }
  if (uic_mqtt_dotdot_alarms_get_alarm_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetAlarmResponse")";
  }
  if (uic_mqtt_dotdot_alarms_get_alarm_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetAlarm")";
  }
  if (uic_mqtt_dotdot_alarms_reset_alarm_log_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ResetAlarmLog")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_alarms_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_alarms_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Alarms/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Alarms/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Alarms Cluster
void uic_mqtt_dotdot_alarms_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Alarms/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Time Cluster
void uic_mqtt_dotdot_time_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Time/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Time Cluster
void uic_mqtt_dotdot_time_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Time/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_time_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_time_write_attributes_callback) {
    uic_mqtt_dotdot_time_state_t time_new_state = {};
    uic_mqtt_dotdot_time_updated_state_t time_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          time_new_state,
          time_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_time_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_time_force_read_attributes_callback) {
    uic_mqtt_dotdot_time_updated_state_t time_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          time_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Time Cluster
void uic_mqtt_dotdot_time_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_time_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_time_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Time/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Time/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Time Cluster
void uic_mqtt_dotdot_time_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Time/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for PollControl Cluster
void uic_mqtt_dotdot_poll_control_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/PollControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for PollControl Cluster
void uic_mqtt_dotdot_poll_control_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/PollControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_poll_control_check_in_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_poll_control_check_in_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_poll_control_check_in_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    bool start_fast_polling_value;
    memset(&start_fast_polling_value, 0x00, sizeof(start_fast_polling_value));
    uint16_t fast_poll_timeout_value;
    memset(&fast_poll_timeout_value, 0x00, sizeof(fast_poll_timeout_value));
    for (const auto& callback: uic_mqtt_dotdot_poll_control_check_in_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        start_fast_polling_value,
    
        fast_poll_timeout_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_poll_control_fast_poll_stop_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_poll_control_fast_poll_stop_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_poll_control_set_long_poll_interval_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint32_t new_long_poll_interval_value;
    memset(&new_long_poll_interval_value, 0x00, sizeof(new_long_poll_interval_value));
    for (const auto& callback: uic_mqtt_dotdot_poll_control_set_long_poll_interval_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        new_long_poll_interval_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_poll_control_set_short_poll_interval_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t new_short_poll_interval_value;
    memset(&new_short_poll_interval_value, 0x00, sizeof(new_short_poll_interval_value));
    for (const auto& callback: uic_mqtt_dotdot_poll_control_set_short_poll_interval_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        new_short_poll_interval_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_poll_control_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_poll_control_write_attributes_callback) {
    uic_mqtt_dotdot_poll_control_state_t poll_control_new_state = {};
    uic_mqtt_dotdot_poll_control_updated_state_t poll_control_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          poll_control_new_state,
          poll_control_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_poll_control_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_poll_control_force_read_attributes_callback) {
    uic_mqtt_dotdot_poll_control_updated_state_t poll_control_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          poll_control_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for PollControl Cluster
void uic_mqtt_dotdot_poll_control_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_poll_control_check_in_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("CheckIn")";
  }
  if (uic_mqtt_dotdot_poll_control_check_in_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("CheckInResponse")";
  }
  if (uic_mqtt_dotdot_poll_control_fast_poll_stop_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("FastPollStop")";
  }
  if (uic_mqtt_dotdot_poll_control_set_long_poll_interval_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetLongPollInterval")";
  }
  if (uic_mqtt_dotdot_poll_control_set_short_poll_interval_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetShortPollInterval")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_poll_control_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_poll_control_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PollControl/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/PollControl/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for PollControl Cluster
void uic_mqtt_dotdot_poll_control_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PollControl/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for ShadeConfiguration Cluster
void uic_mqtt_dotdot_shade_configuration_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/ShadeConfiguration/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for ShadeConfiguration Cluster
void uic_mqtt_dotdot_shade_configuration_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/ShadeConfiguration/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_shade_configuration_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_shade_configuration_write_attributes_callback) {
    uic_mqtt_dotdot_shade_configuration_state_t shade_configuration_new_state = {};
    uic_mqtt_dotdot_shade_configuration_updated_state_t shade_configuration_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          shade_configuration_new_state,
          shade_configuration_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_shade_configuration_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_shade_configuration_force_read_attributes_callback) {
    uic_mqtt_dotdot_shade_configuration_updated_state_t shade_configuration_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          shade_configuration_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for ShadeConfiguration Cluster
void uic_mqtt_dotdot_shade_configuration_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_shade_configuration_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_shade_configuration_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ShadeConfiguration/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/ShadeConfiguration/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for ShadeConfiguration Cluster
void uic_mqtt_dotdot_shade_configuration_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ShadeConfiguration/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for DoorLock Cluster
void uic_mqtt_dotdot_door_lock_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/DoorLock/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for DoorLock Cluster
void uic_mqtt_dotdot_door_lock_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/DoorLock/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_door_lock_lock_door_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* pin_or_rfid_code_value;
    memset(&pin_or_rfid_code_value, 0x00, sizeof(pin_or_rfid_code_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_lock_door_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        pin_or_rfid_code_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_lock_door_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_lock_door_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_unlock_door_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* pin_or_rfid_code_value;
    memset(&pin_or_rfid_code_value, 0x00, sizeof(pin_or_rfid_code_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_unlock_door_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        pin_or_rfid_code_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_unlock_door_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_unlock_door_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_toggle_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* pin_or_rfid_code_value;
    memset(&pin_or_rfid_code_value, 0x00, sizeof(pin_or_rfid_code_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_toggle_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        pin_or_rfid_code_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_toggle_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_toggle_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_unlock_with_timeout_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t timeout_in_seconds_value;
    memset(&timeout_in_seconds_value, 0x00, sizeof(timeout_in_seconds_value));
    const char* pin_or_rfid_code_value;
    memset(&pin_or_rfid_code_value, 0x00, sizeof(pin_or_rfid_code_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        timeout_in_seconds_value,
    
        pin_or_rfid_code_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_log_record_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t log_index_value;
    memset(&log_index_value, 0x00, sizeof(log_index_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_log_record_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        log_index_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_log_record_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t log_entryid_value;
    memset(&log_entryid_value, 0x00, sizeof(log_entryid_value));
    uint32_t timestamp_value;
    memset(&timestamp_value, 0x00, sizeof(timestamp_value));
    GetLogRecordResponseEventType event_type_value;
    memset(&event_type_value, 0x00, sizeof(event_type_value));
    DrlkOperEventSource source_operation_event_value;
    memset(&source_operation_event_value, 0x00, sizeof(source_operation_event_value));
    uint8_t event_id_or_alarm_code_value;
    memset(&event_id_or_alarm_code_value, 0x00, sizeof(event_id_or_alarm_code_value));
    uint16_t userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    const char* pin_value;
    memset(&pin_value, 0x00, sizeof(pin_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_log_record_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        log_entryid_value,
    
        timestamp_value,
    
        event_type_value,
    
        source_operation_event_value,
    
        event_id_or_alarm_code_value,
    
        userid_value,
    
        pin_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_pin_code_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPINUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    DrlkSettableUserStatus user_status_value;
    memset(&user_status_value, 0x00, sizeof(user_status_value));
    DrlkUserType user_type_value;
    memset(&user_type_value, 0x00, sizeof(user_type_value));
    const char* pin_value;
    memset(&pin_value, 0x00, sizeof(pin_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_pin_code_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value,
    
        user_status_value,
    
        user_type_value,
    
        pin_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_pin_code_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkSetCodeStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_pin_code_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_pin_code_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPINUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_pin_code_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_pin_code_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    DrlkUserStatus user_status_value;
    memset(&user_status_value, 0x00, sizeof(user_status_value));
    DrlkUserType user_type_value;
    memset(&user_type_value, 0x00, sizeof(user_type_value));
    const char* code_value;
    memset(&code_value, 0x00, sizeof(code_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_pin_code_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value,
    
        user_status_value,
    
        user_type_value,
    
        code_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_pin_code_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPINUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_pin_code_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_pin_code_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_pin_code_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_all_pin_codes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_user_status_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkTotalUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    DrlkSettableUserStatus user_status_value;
    memset(&user_status_value, 0x00, sizeof(user_status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_user_status_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value,
    
        user_status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_user_status_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_user_status_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_user_status_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkTotalUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_status_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_user_status_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    DrlkUserStatus user_status_value;
    memset(&user_status_value, 0x00, sizeof(user_status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_status_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value,
    
        user_status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_weekday_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkWeekDayScheduleID scheduleid_value;
    memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
    DrlkTotalUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    uint8_t days_mask_value;
    memset(&days_mask_value, 0x00, sizeof(days_mask_value));
    uint8_t start_hour_value;
    memset(&start_hour_value, 0x00, sizeof(start_hour_value));
    uint8_t start_minute_value;
    memset(&start_minute_value, 0x00, sizeof(start_minute_value));
    uint8_t end_hour_value;
    memset(&end_hour_value, 0x00, sizeof(end_hour_value));
    uint8_t end_minute_value;
    memset(&end_minute_value, 0x00, sizeof(end_minute_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        scheduleid_value,
    
        userid_value,
    
        days_mask_value,
    
        start_hour_value,
    
        start_minute_value,
    
        end_hour_value,
    
        end_minute_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_weekday_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkWeekDayScheduleID scheduleid_value;
    memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
    DrlkTotalUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        scheduleid_value,
    
        userid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t scheduleid_value;
    memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
    uint16_t userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    uint8_t days_mask_value;
    memset(&days_mask_value, 0x00, sizeof(days_mask_value));
    uint8_t start_hour_value;
    memset(&start_hour_value, 0x00, sizeof(start_hour_value));
    uint8_t start_minute_value;
    memset(&start_minute_value, 0x00, sizeof(start_minute_value));
    uint8_t end_hour_value;
    memset(&end_hour_value, 0x00, sizeof(end_hour_value));
    uint8_t end_minute_value;
    memset(&end_minute_value, 0x00, sizeof(end_minute_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        scheduleid_value,
    
        userid_value,
    
        status_value,
    
        days_mask_value,
    
        start_hour_value,
    
        start_minute_value,
    
        end_hour_value,
    
        end_minute_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_weekday_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkWeekDayScheduleID scheduleid_value;
    memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
    DrlkTotalUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        scheduleid_value,
    
        userid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_year_day_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkYearDayScheduleID scheduleid_value;
    memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
    DrlkTotalUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    uint32_t local_start_time_value;
    memset(&local_start_time_value, 0x00, sizeof(local_start_time_value));
    uint32_t local_end_time_value;
    memset(&local_end_time_value, 0x00, sizeof(local_end_time_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        scheduleid_value,
    
        userid_value,
    
        local_start_time_value,
    
        local_end_time_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_year_day_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkYearDayScheduleID scheduleid_value;
    memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
    DrlkTotalUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        scheduleid_value,
    
        userid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t scheduleid_value;
    memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
    uint16_t userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    uint32_t local_start_time_value;
    memset(&local_start_time_value, 0x00, sizeof(local_start_time_value));
    uint32_t local_end_time_value;
    memset(&local_end_time_value, 0x00, sizeof(local_end_time_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        scheduleid_value,
    
        userid_value,
    
        status_value,
    
        local_start_time_value,
    
        local_end_time_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_year_day_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkYearDayScheduleID scheduleid_value;
    memset(&scheduleid_value, 0x00, sizeof(scheduleid_value));
    DrlkTotalUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        scheduleid_value,
    
        userid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_holiday_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkHolidayScheduleID holiday_scheduleid_value;
    memset(&holiday_scheduleid_value, 0x00, sizeof(holiday_scheduleid_value));
    uint32_t local_start_time_value;
    memset(&local_start_time_value, 0x00, sizeof(local_start_time_value));
    uint32_t local_end_time_value;
    memset(&local_end_time_value, 0x00, sizeof(local_end_time_value));
    DrlkOperMode operating_mode_during_holiday_value;
    memset(&operating_mode_during_holiday_value, 0x00, sizeof(operating_mode_during_holiday_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        holiday_scheduleid_value,
    
        local_start_time_value,
    
        local_end_time_value,
    
        operating_mode_during_holiday_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_holiday_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkHolidayScheduleID holiday_scheduleid_value;
    memset(&holiday_scheduleid_value, 0x00, sizeof(holiday_scheduleid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        holiday_scheduleid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t holiday_scheduleid_value;
    memset(&holiday_scheduleid_value, 0x00, sizeof(holiday_scheduleid_value));
    zclStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    uint32_t local_start_time_value;
    memset(&local_start_time_value, 0x00, sizeof(local_start_time_value));
    uint32_t local_end_time_value;
    memset(&local_end_time_value, 0x00, sizeof(local_end_time_value));
    DrlkOperMode operating_mode_during_holiday_value;
    memset(&operating_mode_during_holiday_value, 0x00, sizeof(operating_mode_during_holiday_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        holiday_scheduleid_value,
    
        status_value,
    
        local_start_time_value,
    
        local_end_time_value,
    
        operating_mode_during_holiday_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_holiday_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkHolidayScheduleID holiday_scheduleid_value;
    memset(&holiday_scheduleid_value, 0x00, sizeof(holiday_scheduleid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        holiday_scheduleid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_user_type_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkTotalUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    DrlkUserType user_type_value;
    memset(&user_type_value, 0x00, sizeof(user_type_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_user_type_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value,
    
        user_type_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_user_type_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_user_type_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_user_type_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkTotalUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_type_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_user_type_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    DrlkUserType user_type_value;
    memset(&user_type_value, 0x00, sizeof(user_type_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_type_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value,
    
        user_type_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_rfid_code_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkRFIDUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    DrlkSettableUserStatus user_status_value;
    memset(&user_status_value, 0x00, sizeof(user_status_value));
    DrlkUserType user_type_value;
    memset(&user_type_value, 0x00, sizeof(user_type_value));
    const char* rfid_code_value;
    memset(&rfid_code_value, 0x00, sizeof(rfid_code_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_rfid_code_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value,
    
        user_status_value,
    
        user_type_value,
    
        rfid_code_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_rfid_code_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkSetCodeStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_rfid_code_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_rfid_code_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkRFIDUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_rfid_code_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_rfid_code_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    DrlkUserStatus user_status_value;
    memset(&user_status_value, 0x00, sizeof(user_status_value));
    DrlkUserType user_type_value;
    memset(&user_type_value, 0x00, sizeof(user_type_value));
    const char* rfid_code_value;
    memset(&rfid_code_value, 0x00, sizeof(rfid_code_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_rfid_code_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value,
    
        user_status_value,
    
        user_type_value,
    
        rfid_code_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_rfid_code_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkRFIDUserID userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_rfid_code_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        userid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_rfid_code_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_rfid_code_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkPassFailStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        status_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_user_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DataOperationTypeEnum operation_type_value;
    memset(&operation_type_value, 0x00, sizeof(operation_type_value));
    uint16_t user_index_value;
    memset(&user_index_value, 0x00, sizeof(user_index_value));
    const char* user_name_value;
    memset(&user_name_value, 0x00, sizeof(user_name_value));
    uint32_t user_uniqueid_value;
    memset(&user_uniqueid_value, 0x00, sizeof(user_uniqueid_value));
    DrlkUserStatus user_status_value;
    memset(&user_status_value, 0x00, sizeof(user_status_value));
    DrlkUserType user_type_value;
    memset(&user_type_value, 0x00, sizeof(user_type_value));
    CredentialRuleEnum credential_rule_value;
    memset(&credential_rule_value, 0x00, sizeof(credential_rule_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_user_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        operation_type_value,
    
        user_index_value,
    
        user_name_value,
    
        user_uniqueid_value,
    
        user_status_value,
    
        user_type_value,
    
        credential_rule_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_user_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t user_index_value;
    memset(&user_index_value, 0x00, sizeof(user_index_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        user_index_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_user_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_user_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_user_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t user_index_value;
    memset(&user_index_value, 0x00, sizeof(user_index_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_user_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        user_index_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_operating_event_notification_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DrlkOperEventSource operation_event_source_value;
    memset(&operation_event_source_value, 0x00, sizeof(operation_event_source_value));
    OperatingEventNotificationOperationEventCode operation_event_code_value;
    memset(&operation_event_code_value, 0x00, sizeof(operation_event_code_value));
    uint16_t userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    const char* pin_value;
    memset(&pin_value, 0x00, sizeof(pin_value));
    uint32_t local_time_value;
    memset(&local_time_value, 0x00, sizeof(local_time_value));
    const char* data_value;
    memset(&data_value, 0x00, sizeof(data_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_operating_event_notification_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        operation_event_source_value,
    
        operation_event_code_value,
    
        userid_value,
    
        pin_value,
    
        local_time_value,
    
        data_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_programming_event_notification_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    ProgrammingEventNotificationProgramEventSource program_event_source_value;
    memset(&program_event_source_value, 0x00, sizeof(program_event_source_value));
    ProgrammingEventNotificationProgramEventCode program_event_code_value;
    memset(&program_event_code_value, 0x00, sizeof(program_event_code_value));
    uint16_t userid_value;
    memset(&userid_value, 0x00, sizeof(userid_value));
    const char* pin_value;
    memset(&pin_value, 0x00, sizeof(pin_value));
    DrlkUserType user_type_value;
    memset(&user_type_value, 0x00, sizeof(user_type_value));
    DrlkUserStatus user_status_value;
    memset(&user_status_value, 0x00, sizeof(user_status_value));
    uint32_t local_time_value;
    memset(&local_time_value, 0x00, sizeof(local_time_value));
    const char* data_value;
    memset(&data_value, 0x00, sizeof(data_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_programming_event_notification_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        program_event_source_value,
    
        program_event_code_value,
    
        userid_value,
    
        pin_value,
    
        user_type_value,
    
        user_status_value,
    
        local_time_value,
    
        data_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_credential_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    DataOperationTypeEnum operation_type_value;
    memset(&operation_type_value, 0x00, sizeof(operation_type_value));
    CredentialStruct credential_value;
    memset(&credential_value, 0x00, sizeof(credential_value));
    const char* credential_data_value;
    memset(&credential_data_value, 0x00, sizeof(credential_data_value));
    uint16_t user_index_value;
    memset(&user_index_value, 0x00, sizeof(user_index_value));
    DrlkUserStatus user_status_value;
    memset(&user_status_value, 0x00, sizeof(user_status_value));
    DrlkUserType user_type_value;
    memset(&user_type_value, 0x00, sizeof(user_type_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_credential_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        operation_type_value,
    
        credential_value,
    
        credential_data_value,
    
        user_index_value,
    
        user_status_value,
    
        user_type_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_set_credential_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_door_lock_set_credential_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_credential_status_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    CredentialStruct credential_value;
    memset(&credential_value, 0x00, sizeof(credential_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_credential_status_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        credential_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_get_credential_status_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_door_lock_get_credential_status_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_clear_credential_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    CredentialStruct credential_value;
    memset(&credential_value, 0x00, sizeof(credential_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_clear_credential_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        credential_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_door_lock_unbolt_door_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* pin_code_value;
    memset(&pin_code_value, 0x00, sizeof(pin_code_value));
    for (const auto& callback: uic_mqtt_dotdot_door_lock_unbolt_door_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        pin_code_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_door_lock_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_door_lock_write_attributes_callback) {
    uic_mqtt_dotdot_door_lock_state_t door_lock_new_state = {};
    uic_mqtt_dotdot_door_lock_updated_state_t door_lock_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          door_lock_new_state,
          door_lock_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_door_lock_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_door_lock_force_read_attributes_callback) {
    uic_mqtt_dotdot_door_lock_updated_state_t door_lock_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          door_lock_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for DoorLock Cluster
void uic_mqtt_dotdot_door_lock_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_door_lock_lock_door_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("LockDoor")";
  }
  if (uic_mqtt_dotdot_door_lock_lock_door_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("LockDoorResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_unlock_door_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("UnlockDoor")";
  }
  if (uic_mqtt_dotdot_door_lock_unlock_door_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("UnlockDoorResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_toggle_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Toggle")";
  }
  if (uic_mqtt_dotdot_door_lock_toggle_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ToggleResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_unlock_with_timeout_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("UnlockWithTimeout")";
  }
  if (uic_mqtt_dotdot_door_lock_unlock_with_timeout_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("UnlockWithTimeoutResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_get_log_record_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetLogRecord")";
  }
  if (uic_mqtt_dotdot_door_lock_get_log_record_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetLogRecordResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_set_pin_code_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetPINCode")";
  }
  if (uic_mqtt_dotdot_door_lock_set_pin_code_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetPINCodeResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_get_pin_code_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetPINCode")";
  }
  if (uic_mqtt_dotdot_door_lock_get_pin_code_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetPINCodeResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_pin_code_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearPINCode")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_pin_code_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearPINCodeResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_all_pin_codes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearAllPINCodes")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_all_pin_codes_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearAllPINCodesResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_set_user_status_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetUserStatus")";
  }
  if (uic_mqtt_dotdot_door_lock_set_user_status_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetUserStatusResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_get_user_status_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetUserStatus")";
  }
  if (uic_mqtt_dotdot_door_lock_get_user_status_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetUserStatusResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_set_weekday_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetWeekdaySchedule")";
  }
  if (uic_mqtt_dotdot_door_lock_set_weekday_schedule_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetWeekdayScheduleResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_get_weekday_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetWeekdaySchedule")";
  }
  if (uic_mqtt_dotdot_door_lock_get_weekday_schedule_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetWeekdayScheduleResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_weekday_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearWeekdaySchedule")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_weekday_schedule_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearWeekdayScheduleResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_set_year_day_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetYearDaySchedule")";
  }
  if (uic_mqtt_dotdot_door_lock_set_year_day_schedule_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetYearDayScheduleResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_get_year_day_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetYearDaySchedule")";
  }
  if (uic_mqtt_dotdot_door_lock_get_year_day_schedule_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetYearDayScheduleResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_year_day_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearYearDaySchedule")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_year_day_schedule_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearYearDayScheduleResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_set_holiday_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetHolidaySchedule")";
  }
  if (uic_mqtt_dotdot_door_lock_set_holiday_schedule_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetHolidayScheduleResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_get_holiday_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetHolidaySchedule")";
  }
  if (uic_mqtt_dotdot_door_lock_get_holiday_schedule_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetHolidayScheduleResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_holiday_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearHolidaySchedule")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_holiday_schedule_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearHolidayScheduleResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_set_user_type_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetUserType")";
  }
  if (uic_mqtt_dotdot_door_lock_set_user_type_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetUserTypeResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_get_user_type_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetUserType")";
  }
  if (uic_mqtt_dotdot_door_lock_get_user_type_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetUserTypeResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_set_rfid_code_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetRFIDCode")";
  }
  if (uic_mqtt_dotdot_door_lock_set_rfid_code_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetRFIDCodeResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_get_rfid_code_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetRFIDCode")";
  }
  if (uic_mqtt_dotdot_door_lock_get_rfid_code_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetRFIDCodeResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_rfid_code_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearRFIDCode")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_rfid_code_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearRFIDCodeResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearAllRFIDCodes")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearAllRFIDCodesResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_set_user_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetUser")";
  }
  if (uic_mqtt_dotdot_door_lock_get_user_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetUser")";
  }
  if (uic_mqtt_dotdot_door_lock_get_user_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetUserResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_user_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearUser")";
  }
  if (uic_mqtt_dotdot_door_lock_operating_event_notification_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("OperatingEventNotification")";
  }
  if (uic_mqtt_dotdot_door_lock_programming_event_notification_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ProgrammingEventNotification")";
  }
  if (uic_mqtt_dotdot_door_lock_set_credential_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetCredential")";
  }
  if (uic_mqtt_dotdot_door_lock_set_credential_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetCredentialResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_get_credential_status_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetCredentialStatus")";
  }
  if (uic_mqtt_dotdot_door_lock_get_credential_status_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetCredentialStatusResponse")";
  }
  if (uic_mqtt_dotdot_door_lock_clear_credential_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearCredential")";
  }
  if (uic_mqtt_dotdot_door_lock_unbolt_door_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("UnboltDoor")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_door_lock_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_door_lock_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/DoorLock/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/DoorLock/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for DoorLock Cluster
void uic_mqtt_dotdot_door_lock_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/DoorLock/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for WindowCovering Cluster
void uic_mqtt_dotdot_window_covering_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/WindowCovering/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for WindowCovering Cluster
void uic_mqtt_dotdot_window_covering_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/WindowCovering/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_window_covering_up_or_open_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_window_covering_up_or_open_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_window_covering_down_or_close_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_window_covering_down_or_close_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_window_covering_stop_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_window_covering_stop_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_window_covering_go_to_lift_value_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t lift_value_value;
    memset(&lift_value_value, 0x00, sizeof(lift_value_value));
    for (const auto& callback: uic_mqtt_dotdot_window_covering_go_to_lift_value_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        lift_value_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_window_covering_go_to_lift_percentage_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t percentage_lift_value_value;
    memset(&percentage_lift_value_value, 0x00, sizeof(percentage_lift_value_value));
    for (const auto& callback: uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        percentage_lift_value_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_window_covering_go_to_tilt_value_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t tilt_value_value;
    memset(&tilt_value_value, 0x00, sizeof(tilt_value_value));
    for (const auto& callback: uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        tilt_value_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t percentage_tilt_value_value;
    memset(&percentage_tilt_value_value, 0x00, sizeof(percentage_tilt_value_value));
    for (const auto& callback: uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        percentage_tilt_value_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_window_covering_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_window_covering_write_attributes_callback) {
    uic_mqtt_dotdot_window_covering_state_t window_covering_new_state = {};
    uic_mqtt_dotdot_window_covering_updated_state_t window_covering_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          window_covering_new_state,
          window_covering_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_window_covering_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_window_covering_force_read_attributes_callback) {
    uic_mqtt_dotdot_window_covering_updated_state_t window_covering_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          window_covering_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for WindowCovering Cluster
void uic_mqtt_dotdot_window_covering_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_window_covering_up_or_open_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("UpOrOpen")";
  }
  if (uic_mqtt_dotdot_window_covering_down_or_close_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("DownOrClose")";
  }
  if (uic_mqtt_dotdot_window_covering_stop_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Stop")";
  }
  if (uic_mqtt_dotdot_window_covering_go_to_lift_value_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GoToLiftValue")";
  }
  if (uic_mqtt_dotdot_window_covering_go_to_lift_percentage_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GoToLiftPercentage")";
  }
  if (uic_mqtt_dotdot_window_covering_go_to_tilt_value_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GoToTiltValue")";
  }
  if (uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GoToTiltPercentage")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_window_covering_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_window_covering_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/WindowCovering/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/WindowCovering/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for WindowCovering Cluster
void uic_mqtt_dotdot_window_covering_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/WindowCovering/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for BarrierControl Cluster
void uic_mqtt_dotdot_barrier_control_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/BarrierControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for BarrierControl Cluster
void uic_mqtt_dotdot_barrier_control_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/BarrierControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_barrier_control_go_to_percent_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t percent_open_value;
    memset(&percent_open_value, 0x00, sizeof(percent_open_value));
    for (const auto& callback: uic_mqtt_dotdot_barrier_control_go_to_percent_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        percent_open_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_barrier_control_stop_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_barrier_control_stop_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_barrier_control_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_barrier_control_write_attributes_callback) {
    uic_mqtt_dotdot_barrier_control_state_t barrier_control_new_state = {};
    uic_mqtt_dotdot_barrier_control_updated_state_t barrier_control_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          barrier_control_new_state,
          barrier_control_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_barrier_control_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_barrier_control_force_read_attributes_callback) {
    uic_mqtt_dotdot_barrier_control_updated_state_t barrier_control_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          barrier_control_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for BarrierControl Cluster
void uic_mqtt_dotdot_barrier_control_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_barrier_control_go_to_percent_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GoToPercent")";
  }
  if (uic_mqtt_dotdot_barrier_control_stop_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Stop")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_barrier_control_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_barrier_control_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/BarrierControl/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/BarrierControl/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for BarrierControl Cluster
void uic_mqtt_dotdot_barrier_control_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/BarrierControl/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for PumpConfigurationAndControl Cluster
void uic_mqtt_dotdot_pump_configuration_and_control_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/PumpConfigurationAndControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for PumpConfigurationAndControl Cluster
void uic_mqtt_dotdot_pump_configuration_and_control_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/PumpConfigurationAndControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_callback) {
    uic_mqtt_dotdot_pump_configuration_and_control_state_t pump_configuration_and_control_new_state = {};
    uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t pump_configuration_and_control_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          pump_configuration_and_control_new_state,
          pump_configuration_and_control_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_callback) {
    uic_mqtt_dotdot_pump_configuration_and_control_updated_state_t pump_configuration_and_control_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          pump_configuration_and_control_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for PumpConfigurationAndControl Cluster
void uic_mqtt_dotdot_pump_configuration_and_control_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_pump_configuration_and_control_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_pump_configuration_and_control_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PumpConfigurationAndControl/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/PumpConfigurationAndControl/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for PumpConfigurationAndControl Cluster
void uic_mqtt_dotdot_pump_configuration_and_control_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PumpConfigurationAndControl/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Thermostat Cluster
void uic_mqtt_dotdot_thermostat_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Thermostat/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Thermostat Cluster
void uic_mqtt_dotdot_thermostat_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Thermostat/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    SetpointRaiseOrLowerMode mode_value;
    memset(&mode_value, 0x00, sizeof(mode_value));
    int8_t amount_value;
    memset(&amount_value, 0x00, sizeof(amount_value));
    for (const auto& callback: uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        mode_value,
    
        amount_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t number_of_transitions_value;
    memset(&number_of_transitions_value, 0x00, sizeof(number_of_transitions_value));
    uint8_t day_of_week_value;
    memset(&day_of_week_value, 0x00, sizeof(day_of_week_value));
    uint8_t mode_value;
    memset(&mode_value, 0x00, sizeof(mode_value));
    for (const auto& callback: uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        number_of_transitions_value,
    
        day_of_week_value,
    
        mode_value,
    
        0, nullptr

        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_thermostat_set_weekly_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t number_of_transitions_value;
    memset(&number_of_transitions_value, 0x00, sizeof(number_of_transitions_value));
    uint8_t day_of_week_value;
    memset(&day_of_week_value, 0x00, sizeof(day_of_week_value));
    uint8_t mode_value;
    memset(&mode_value, 0x00, sizeof(mode_value));
    for (const auto& callback: uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        number_of_transitions_value,
    
        day_of_week_value,
    
        mode_value,
    
        0, nullptr

        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_thermostat_get_relay_status_log_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t time_of_day_value;
    memset(&time_of_day_value, 0x00, sizeof(time_of_day_value));
    uint8_t relay_status_value;
    memset(&relay_status_value, 0x00, sizeof(relay_status_value));
    int16_t local_temperature_value;
    memset(&local_temperature_value, 0x00, sizeof(local_temperature_value));
    uint8_t humidity_percentage_value;
    memset(&humidity_percentage_value, 0x00, sizeof(humidity_percentage_value));
    int16_t set_point_value;
    memset(&set_point_value, 0x00, sizeof(set_point_value));
    uint16_t unread_entries_value;
    memset(&unread_entries_value, 0x00, sizeof(unread_entries_value));
    for (const auto& callback: uic_mqtt_dotdot_thermostat_get_relay_status_log_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        time_of_day_value,
    
        relay_status_value,
    
        local_temperature_value,
    
        humidity_percentage_value,
    
        set_point_value,
    
        unread_entries_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_thermostat_get_weekly_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t days_to_return_value;
    memset(&days_to_return_value, 0x00, sizeof(days_to_return_value));
    uint8_t mode_to_return_value;
    memset(&mode_to_return_value, 0x00, sizeof(mode_to_return_value));
    for (const auto& callback: uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        days_to_return_value,
    
        mode_to_return_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_thermostat_clear_weekly_schedule_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_thermostat_get_relay_status_log_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_thermostat_get_relay_status_log_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_thermostat_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_thermostat_write_attributes_callback) {
    uic_mqtt_dotdot_thermostat_state_t thermostat_new_state = {};
    uic_mqtt_dotdot_thermostat_updated_state_t thermostat_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          thermostat_new_state,
          thermostat_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_thermostat_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_thermostat_force_read_attributes_callback) {
    uic_mqtt_dotdot_thermostat_updated_state_t thermostat_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          thermostat_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Thermostat Cluster
void uic_mqtt_dotdot_thermostat_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetpointRaiseOrLower")";
  }
  if (uic_mqtt_dotdot_thermostat_get_weekly_schedule_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetWeeklyScheduleResponse")";
  }
  if (uic_mqtt_dotdot_thermostat_set_weekly_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetWeeklySchedule")";
  }
  if (uic_mqtt_dotdot_thermostat_get_relay_status_log_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetRelayStatusLogResponse")";
  }
  if (uic_mqtt_dotdot_thermostat_get_weekly_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetWeeklySchedule")";
  }
  if (uic_mqtt_dotdot_thermostat_clear_weekly_schedule_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ClearWeeklySchedule")";
  }
  if (uic_mqtt_dotdot_thermostat_get_relay_status_log_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetRelayStatusLog")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_thermostat_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_thermostat_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Thermostat/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Thermostat/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Thermostat Cluster
void uic_mqtt_dotdot_thermostat_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Thermostat/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for FanControl Cluster
void uic_mqtt_dotdot_fan_control_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/FanControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for FanControl Cluster
void uic_mqtt_dotdot_fan_control_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/FanControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_fan_control_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_fan_control_write_attributes_callback) {
    uic_mqtt_dotdot_fan_control_state_t fan_control_new_state = {};
    uic_mqtt_dotdot_fan_control_updated_state_t fan_control_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          fan_control_new_state,
          fan_control_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_fan_control_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_fan_control_force_read_attributes_callback) {
    uic_mqtt_dotdot_fan_control_updated_state_t fan_control_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          fan_control_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for FanControl Cluster
void uic_mqtt_dotdot_fan_control_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_fan_control_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_fan_control_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/FanControl/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/FanControl/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for FanControl Cluster
void uic_mqtt_dotdot_fan_control_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/FanControl/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for DehumidificationControl Cluster
void uic_mqtt_dotdot_dehumidification_control_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/DehumidificationControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for DehumidificationControl Cluster
void uic_mqtt_dotdot_dehumidification_control_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/DehumidificationControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_dehumidification_control_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_dehumidification_control_write_attributes_callback) {
    uic_mqtt_dotdot_dehumidification_control_state_t dehumidification_control_new_state = {};
    uic_mqtt_dotdot_dehumidification_control_updated_state_t dehumidification_control_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          dehumidification_control_new_state,
          dehumidification_control_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_dehumidification_control_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_dehumidification_control_force_read_attributes_callback) {
    uic_mqtt_dotdot_dehumidification_control_updated_state_t dehumidification_control_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          dehumidification_control_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for DehumidificationControl Cluster
void uic_mqtt_dotdot_dehumidification_control_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_dehumidification_control_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_dehumidification_control_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/DehumidificationControl/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/DehumidificationControl/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for DehumidificationControl Cluster
void uic_mqtt_dotdot_dehumidification_control_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/DehumidificationControl/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for ThermostatUserInterfaceConfiguration Cluster
void uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/ThermostatUserInterfaceConfiguration/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for ThermostatUserInterfaceConfiguration Cluster
void uic_mqtt_dotdot_thermostat_user_interface_configuration_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/ThermostatUserInterfaceConfiguration/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_callback) {
    uic_mqtt_dotdot_thermostat_user_interface_configuration_state_t thermostat_user_interface_configuration_new_state = {};
    uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t thermostat_user_interface_configuration_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          thermostat_user_interface_configuration_new_state,
          thermostat_user_interface_configuration_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_callback) {
    uic_mqtt_dotdot_thermostat_user_interface_configuration_updated_state_t thermostat_user_interface_configuration_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          thermostat_user_interface_configuration_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for ThermostatUserInterfaceConfiguration Cluster
void uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_thermostat_user_interface_configuration_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_thermostat_user_interface_configuration_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ThermostatUserInterfaceConfiguration/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/ThermostatUserInterfaceConfiguration/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for ThermostatUserInterfaceConfiguration Cluster
void uic_mqtt_dotdot_thermostat_user_interface_configuration_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ThermostatUserInterfaceConfiguration/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for ColorControl Cluster
void uic_mqtt_dotdot_color_control_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/ColorControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for ColorControl Cluster
void uic_mqtt_dotdot_color_control_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/ColorControl/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_color_control_move_to_hue_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t hue_value;
    memset(&hue_value, 0x00, sizeof(hue_value));
    CCDirection direction_value;
    memset(&direction_value, 0x00, sizeof(direction_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_move_to_hue_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        hue_value,
    
        direction_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_move_hue_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    CCMoveMode move_mode_value;
    memset(&move_mode_value, 0x00, sizeof(move_mode_value));
    uint8_t rate_value;
    memset(&rate_value, 0x00, sizeof(rate_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_move_hue_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        move_mode_value,
    
        rate_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_step_hue_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    CCStepMode step_mode_value;
    memset(&step_mode_value, 0x00, sizeof(step_mode_value));
    uint8_t step_size_value;
    memset(&step_size_value, 0x00, sizeof(step_size_value));
    uint8_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_step_hue_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        step_mode_value,
    
        step_size_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_move_to_saturation_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t saturation_value;
    memset(&saturation_value, 0x00, sizeof(saturation_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_move_to_saturation_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        saturation_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_move_saturation_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    CCMoveMode move_mode_value;
    memset(&move_mode_value, 0x00, sizeof(move_mode_value));
    uint8_t rate_value;
    memset(&rate_value, 0x00, sizeof(rate_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_move_saturation_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        move_mode_value,
    
        rate_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_step_saturation_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    CCStepMode step_mode_value;
    memset(&step_mode_value, 0x00, sizeof(step_mode_value));
    uint8_t step_size_value;
    memset(&step_size_value, 0x00, sizeof(step_size_value));
    uint8_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_step_saturation_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        step_mode_value,
    
        step_size_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t hue_value;
    memset(&hue_value, 0x00, sizeof(hue_value));
    uint8_t saturation_value;
    memset(&saturation_value, 0x00, sizeof(saturation_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        hue_value,
    
        saturation_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_move_to_color_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t colorx_value;
    memset(&colorx_value, 0x00, sizeof(colorx_value));
    uint16_t colory_value;
    memset(&colory_value, 0x00, sizeof(colory_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_move_to_color_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        colorx_value,
    
        colory_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_move_color_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    int16_t ratex_value;
    memset(&ratex_value, 0x00, sizeof(ratex_value));
    int16_t ratey_value;
    memset(&ratey_value, 0x00, sizeof(ratey_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_move_color_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        ratex_value,
    
        ratey_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_step_color_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    int16_t stepx_value;
    memset(&stepx_value, 0x00, sizeof(stepx_value));
    int16_t stepy_value;
    memset(&stepy_value, 0x00, sizeof(stepy_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_step_color_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        stepx_value,
    
        stepy_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_move_to_color_temperature_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t color_temperature_mireds_value;
    memset(&color_temperature_mireds_value, 0x00, sizeof(color_temperature_mireds_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_move_to_color_temperature_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        color_temperature_mireds_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_enhanced_move_to_hue_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t enhanced_hue_value;
    memset(&enhanced_hue_value, 0x00, sizeof(enhanced_hue_value));
    CCDirection direction_value;
    memset(&direction_value, 0x00, sizeof(direction_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        enhanced_hue_value,
    
        direction_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_enhanced_move_hue_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    CCMoveMode move_mode_value;
    memset(&move_mode_value, 0x00, sizeof(move_mode_value));
    uint16_t rate_value;
    memset(&rate_value, 0x00, sizeof(rate_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_enhanced_move_hue_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        move_mode_value,
    
        rate_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_enhanced_step_hue_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    CCStepMode step_mode_value;
    memset(&step_mode_value, 0x00, sizeof(step_mode_value));
    uint16_t step_size_value;
    memset(&step_size_value, 0x00, sizeof(step_size_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_enhanced_step_hue_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        step_mode_value,
    
        step_size_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t enhanced_hue_value;
    memset(&enhanced_hue_value, 0x00, sizeof(enhanced_hue_value));
    uint8_t saturation_value;
    memset(&saturation_value, 0x00, sizeof(saturation_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        enhanced_hue_value,
    
        saturation_value,
    
        transition_time_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_color_loop_set_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t update_flags_value;
    memset(&update_flags_value, 0x00, sizeof(update_flags_value));
    ColorLoopSetAction action_value;
    memset(&action_value, 0x00, sizeof(action_value));
    CCColorLoopDirection direction_value;
    memset(&direction_value, 0x00, sizeof(direction_value));
    uint16_t time_value;
    memset(&time_value, 0x00, sizeof(time_value));
    uint16_t start_hue_value;
    memset(&start_hue_value, 0x00, sizeof(start_hue_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_color_loop_set_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        update_flags_value,
    
        action_value,
    
        direction_value,
    
        time_value,
    
        start_hue_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_stop_move_step_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_stop_move_step_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_move_color_temperature_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    CCMoveMode move_mode_value;
    memset(&move_mode_value, 0x00, sizeof(move_mode_value));
    uint16_t rate_value;
    memset(&rate_value, 0x00, sizeof(rate_value));
    CCMinMiredsField color_temperature_minimum_mireds_value;
    memset(&color_temperature_minimum_mireds_value, 0x00, sizeof(color_temperature_minimum_mireds_value));
    CCMaxMiredsField color_temperature_maximum_mireds_value;
    memset(&color_temperature_maximum_mireds_value, 0x00, sizeof(color_temperature_maximum_mireds_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_move_color_temperature_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        move_mode_value,
    
        rate_value,
    
        color_temperature_minimum_mireds_value,
    
        color_temperature_maximum_mireds_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_color_control_step_color_temperature_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    CCStepMode step_mode_value;
    memset(&step_mode_value, 0x00, sizeof(step_mode_value));
    uint16_t step_size_value;
    memset(&step_size_value, 0x00, sizeof(step_size_value));
    uint16_t transition_time_value;
    memset(&transition_time_value, 0x00, sizeof(transition_time_value));
    CCMinMiredsField color_temperature_minimum_mireds_value;
    memset(&color_temperature_minimum_mireds_value, 0x00, sizeof(color_temperature_minimum_mireds_value));
    CCMaxMiredsField color_temperature_maximum_mireds_value;
    memset(&color_temperature_maximum_mireds_value, 0x00, sizeof(color_temperature_maximum_mireds_value));
    uint8_t options_mask_value;
    memset(&options_mask_value, 0x00, sizeof(options_mask_value));
    uint8_t options_override_value;
    memset(&options_override_value, 0x00, sizeof(options_override_value));
    for (const auto& callback: uic_mqtt_dotdot_color_control_step_color_temperature_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        step_mode_value,
    
        step_size_value,
    
        transition_time_value,
    
        color_temperature_minimum_mireds_value,
    
        color_temperature_maximum_mireds_value,
    
        options_mask_value,
    
        options_override_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_color_control_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_color_control_write_attributes_callback) {
    uic_mqtt_dotdot_color_control_state_t color_control_new_state = {};
    uic_mqtt_dotdot_color_control_updated_state_t color_control_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          color_control_new_state,
          color_control_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_color_control_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_color_control_force_read_attributes_callback) {
    uic_mqtt_dotdot_color_control_updated_state_t color_control_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          color_control_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for ColorControl Cluster
void uic_mqtt_dotdot_color_control_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_color_control_move_to_hue_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveToHue")";
  }
  if (uic_mqtt_dotdot_color_control_move_hue_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveHue")";
  }
  if (uic_mqtt_dotdot_color_control_step_hue_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("StepHue")";
  }
  if (uic_mqtt_dotdot_color_control_move_to_saturation_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveToSaturation")";
  }
  if (uic_mqtt_dotdot_color_control_move_saturation_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveSaturation")";
  }
  if (uic_mqtt_dotdot_color_control_step_saturation_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("StepSaturation")";
  }
  if (uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveToHueAndSaturation")";
  }
  if (uic_mqtt_dotdot_color_control_move_to_color_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveToColor")";
  }
  if (uic_mqtt_dotdot_color_control_move_color_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveColor")";
  }
  if (uic_mqtt_dotdot_color_control_step_color_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("StepColor")";
  }
  if (uic_mqtt_dotdot_color_control_move_to_color_temperature_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveToColorTemperature")";
  }
  if (uic_mqtt_dotdot_color_control_enhanced_move_to_hue_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("EnhancedMoveToHue")";
  }
  if (uic_mqtt_dotdot_color_control_enhanced_move_hue_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("EnhancedMoveHue")";
  }
  if (uic_mqtt_dotdot_color_control_enhanced_step_hue_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("EnhancedStepHue")";
  }
  if (uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("EnhancedMoveToHueAndSaturation")";
  }
  if (uic_mqtt_dotdot_color_control_color_loop_set_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ColorLoopSet")";
  }
  if (uic_mqtt_dotdot_color_control_stop_move_step_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("StopMoveStep")";
  }
  if (uic_mqtt_dotdot_color_control_move_color_temperature_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("MoveColorTemperature")";
  }
  if (uic_mqtt_dotdot_color_control_step_color_temperature_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("StepColorTemperature")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_color_control_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_color_control_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ColorControl/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/ColorControl/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for ColorControl Cluster
void uic_mqtt_dotdot_color_control_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ColorControl/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for BallastConfiguration Cluster
void uic_mqtt_dotdot_ballast_configuration_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/BallastConfiguration/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for BallastConfiguration Cluster
void uic_mqtt_dotdot_ballast_configuration_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/BallastConfiguration/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_ballast_configuration_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_ballast_configuration_write_attributes_callback) {
    uic_mqtt_dotdot_ballast_configuration_state_t ballast_configuration_new_state = {};
    uic_mqtt_dotdot_ballast_configuration_updated_state_t ballast_configuration_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          ballast_configuration_new_state,
          ballast_configuration_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_ballast_configuration_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_ballast_configuration_force_read_attributes_callback) {
    uic_mqtt_dotdot_ballast_configuration_updated_state_t ballast_configuration_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          ballast_configuration_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for BallastConfiguration Cluster
void uic_mqtt_dotdot_ballast_configuration_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_ballast_configuration_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_ballast_configuration_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/BallastConfiguration/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/BallastConfiguration/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for BallastConfiguration Cluster
void uic_mqtt_dotdot_ballast_configuration_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/BallastConfiguration/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for IlluminanceMeasurement Cluster
void uic_mqtt_dotdot_illuminance_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/IlluminanceMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for IlluminanceMeasurement Cluster
void uic_mqtt_dotdot_illuminance_measurement_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/IlluminanceMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_illuminance_measurement_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_illuminance_measurement_write_attributes_callback) {
    uic_mqtt_dotdot_illuminance_measurement_state_t illuminance_measurement_new_state = {};
    uic_mqtt_dotdot_illuminance_measurement_updated_state_t illuminance_measurement_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          illuminance_measurement_new_state,
          illuminance_measurement_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_callback) {
    uic_mqtt_dotdot_illuminance_measurement_updated_state_t illuminance_measurement_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          illuminance_measurement_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for IlluminanceMeasurement Cluster
void uic_mqtt_dotdot_illuminance_measurement_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_illuminance_measurement_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_illuminance_measurement_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/IlluminanceMeasurement/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/IlluminanceMeasurement/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for IlluminanceMeasurement Cluster
void uic_mqtt_dotdot_illuminance_measurement_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/IlluminanceMeasurement/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for IlluminanceLevelSensing Cluster
void uic_mqtt_dotdot_illuminance_level_sensing_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/IlluminanceLevelSensing/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for IlluminanceLevelSensing Cluster
void uic_mqtt_dotdot_illuminance_level_sensing_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/IlluminanceLevelSensing/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_callback) {
    uic_mqtt_dotdot_illuminance_level_sensing_state_t illuminance_level_sensing_new_state = {};
    uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t illuminance_level_sensing_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          illuminance_level_sensing_new_state,
          illuminance_level_sensing_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_callback) {
    uic_mqtt_dotdot_illuminance_level_sensing_updated_state_t illuminance_level_sensing_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          illuminance_level_sensing_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for IlluminanceLevelSensing Cluster
void uic_mqtt_dotdot_illuminance_level_sensing_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_illuminance_level_sensing_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_illuminance_level_sensing_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/IlluminanceLevelSensing/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/IlluminanceLevelSensing/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for IlluminanceLevelSensing Cluster
void uic_mqtt_dotdot_illuminance_level_sensing_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/IlluminanceLevelSensing/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for TemperatureMeasurement Cluster
void uic_mqtt_dotdot_temperature_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/TemperatureMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for TemperatureMeasurement Cluster
void uic_mqtt_dotdot_temperature_measurement_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/TemperatureMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_temperature_measurement_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_temperature_measurement_write_attributes_callback) {
    uic_mqtt_dotdot_temperature_measurement_state_t temperature_measurement_new_state = {};
    uic_mqtt_dotdot_temperature_measurement_updated_state_t temperature_measurement_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          temperature_measurement_new_state,
          temperature_measurement_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_temperature_measurement_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_temperature_measurement_force_read_attributes_callback) {
    uic_mqtt_dotdot_temperature_measurement_updated_state_t temperature_measurement_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          temperature_measurement_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for TemperatureMeasurement Cluster
void uic_mqtt_dotdot_temperature_measurement_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_temperature_measurement_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_temperature_measurement_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/TemperatureMeasurement/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/TemperatureMeasurement/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for TemperatureMeasurement Cluster
void uic_mqtt_dotdot_temperature_measurement_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/TemperatureMeasurement/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for PressureMeasurement Cluster
void uic_mqtt_dotdot_pressure_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/PressureMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for PressureMeasurement Cluster
void uic_mqtt_dotdot_pressure_measurement_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/PressureMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_pressure_measurement_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_pressure_measurement_write_attributes_callback) {
    uic_mqtt_dotdot_pressure_measurement_state_t pressure_measurement_new_state = {};
    uic_mqtt_dotdot_pressure_measurement_updated_state_t pressure_measurement_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          pressure_measurement_new_state,
          pressure_measurement_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_pressure_measurement_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_pressure_measurement_force_read_attributes_callback) {
    uic_mqtt_dotdot_pressure_measurement_updated_state_t pressure_measurement_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          pressure_measurement_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for PressureMeasurement Cluster
void uic_mqtt_dotdot_pressure_measurement_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_pressure_measurement_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_pressure_measurement_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PressureMeasurement/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/PressureMeasurement/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for PressureMeasurement Cluster
void uic_mqtt_dotdot_pressure_measurement_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PressureMeasurement/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for FlowMeasurement Cluster
void uic_mqtt_dotdot_flow_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/FlowMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for FlowMeasurement Cluster
void uic_mqtt_dotdot_flow_measurement_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/FlowMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_flow_measurement_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_flow_measurement_write_attributes_callback) {
    uic_mqtt_dotdot_flow_measurement_state_t flow_measurement_new_state = {};
    uic_mqtt_dotdot_flow_measurement_updated_state_t flow_measurement_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          flow_measurement_new_state,
          flow_measurement_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_flow_measurement_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_flow_measurement_force_read_attributes_callback) {
    uic_mqtt_dotdot_flow_measurement_updated_state_t flow_measurement_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          flow_measurement_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for FlowMeasurement Cluster
void uic_mqtt_dotdot_flow_measurement_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_flow_measurement_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_flow_measurement_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/FlowMeasurement/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/FlowMeasurement/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for FlowMeasurement Cluster
void uic_mqtt_dotdot_flow_measurement_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/FlowMeasurement/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for RelativityHumidity Cluster
void uic_mqtt_dotdot_relativity_humidity_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/RelativityHumidity/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for RelativityHumidity Cluster
void uic_mqtt_dotdot_relativity_humidity_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/RelativityHumidity/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_relativity_humidity_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_relativity_humidity_write_attributes_callback) {
    uic_mqtt_dotdot_relativity_humidity_state_t relativity_humidity_new_state = {};
    uic_mqtt_dotdot_relativity_humidity_updated_state_t relativity_humidity_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          relativity_humidity_new_state,
          relativity_humidity_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_relativity_humidity_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_relativity_humidity_force_read_attributes_callback) {
    uic_mqtt_dotdot_relativity_humidity_updated_state_t relativity_humidity_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          relativity_humidity_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for RelativityHumidity Cluster
void uic_mqtt_dotdot_relativity_humidity_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_relativity_humidity_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_relativity_humidity_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/RelativityHumidity/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/RelativityHumidity/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for RelativityHumidity Cluster
void uic_mqtt_dotdot_relativity_humidity_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/RelativityHumidity/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for OccupancySensing Cluster
void uic_mqtt_dotdot_occupancy_sensing_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/OccupancySensing/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for OccupancySensing Cluster
void uic_mqtt_dotdot_occupancy_sensing_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/OccupancySensing/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_occupancy_sensing_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_occupancy_sensing_write_attributes_callback) {
    uic_mqtt_dotdot_occupancy_sensing_state_t occupancy_sensing_new_state = {};
    uic_mqtt_dotdot_occupancy_sensing_updated_state_t occupancy_sensing_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          occupancy_sensing_new_state,
          occupancy_sensing_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_callback) {
    uic_mqtt_dotdot_occupancy_sensing_updated_state_t occupancy_sensing_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          occupancy_sensing_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for OccupancySensing Cluster
void uic_mqtt_dotdot_occupancy_sensing_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_occupancy_sensing_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_occupancy_sensing_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/OccupancySensing/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/OccupancySensing/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for OccupancySensing Cluster
void uic_mqtt_dotdot_occupancy_sensing_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/OccupancySensing/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for SoilMoisture Cluster
void uic_mqtt_dotdot_soil_moisture_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/SoilMoisture/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for SoilMoisture Cluster
void uic_mqtt_dotdot_soil_moisture_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/SoilMoisture/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_soil_moisture_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_soil_moisture_write_attributes_callback) {
    uic_mqtt_dotdot_soil_moisture_state_t soil_moisture_new_state = {};
    uic_mqtt_dotdot_soil_moisture_updated_state_t soil_moisture_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          soil_moisture_new_state,
          soil_moisture_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_soil_moisture_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_soil_moisture_force_read_attributes_callback) {
    uic_mqtt_dotdot_soil_moisture_updated_state_t soil_moisture_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          soil_moisture_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for SoilMoisture Cluster
void uic_mqtt_dotdot_soil_moisture_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_soil_moisture_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_soil_moisture_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/SoilMoisture/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/SoilMoisture/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for SoilMoisture Cluster
void uic_mqtt_dotdot_soil_moisture_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/SoilMoisture/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for PhMeasurement Cluster
void uic_mqtt_dotdot_ph_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/PhMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for PhMeasurement Cluster
void uic_mqtt_dotdot_ph_measurement_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/PhMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_ph_measurement_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_ph_measurement_write_attributes_callback) {
    uic_mqtt_dotdot_ph_measurement_state_t ph_measurement_new_state = {};
    uic_mqtt_dotdot_ph_measurement_updated_state_t ph_measurement_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          ph_measurement_new_state,
          ph_measurement_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_ph_measurement_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_ph_measurement_force_read_attributes_callback) {
    uic_mqtt_dotdot_ph_measurement_updated_state_t ph_measurement_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          ph_measurement_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for PhMeasurement Cluster
void uic_mqtt_dotdot_ph_measurement_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_ph_measurement_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_ph_measurement_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PhMeasurement/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/PhMeasurement/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for PhMeasurement Cluster
void uic_mqtt_dotdot_ph_measurement_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PhMeasurement/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for ElectricalConductivityMeasurement Cluster
void uic_mqtt_dotdot_electrical_conductivity_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/ElectricalConductivityMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for ElectricalConductivityMeasurement Cluster
void uic_mqtt_dotdot_electrical_conductivity_measurement_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/ElectricalConductivityMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_callback) {
    uic_mqtt_dotdot_electrical_conductivity_measurement_state_t electrical_conductivity_measurement_new_state = {};
    uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t electrical_conductivity_measurement_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          electrical_conductivity_measurement_new_state,
          electrical_conductivity_measurement_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_callback) {
    uic_mqtt_dotdot_electrical_conductivity_measurement_updated_state_t electrical_conductivity_measurement_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          electrical_conductivity_measurement_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for ElectricalConductivityMeasurement Cluster
void uic_mqtt_dotdot_electrical_conductivity_measurement_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_electrical_conductivity_measurement_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_electrical_conductivity_measurement_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ElectricalConductivityMeasurement/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/ElectricalConductivityMeasurement/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for ElectricalConductivityMeasurement Cluster
void uic_mqtt_dotdot_electrical_conductivity_measurement_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ElectricalConductivityMeasurement/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for WindSpeedMeasurement Cluster
void uic_mqtt_dotdot_wind_speed_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/WindSpeedMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for WindSpeedMeasurement Cluster
void uic_mqtt_dotdot_wind_speed_measurement_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/WindSpeedMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_wind_speed_measurement_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_wind_speed_measurement_write_attributes_callback) {
    uic_mqtt_dotdot_wind_speed_measurement_state_t wind_speed_measurement_new_state = {};
    uic_mqtt_dotdot_wind_speed_measurement_updated_state_t wind_speed_measurement_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          wind_speed_measurement_new_state,
          wind_speed_measurement_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_callback) {
    uic_mqtt_dotdot_wind_speed_measurement_updated_state_t wind_speed_measurement_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          wind_speed_measurement_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for WindSpeedMeasurement Cluster
void uic_mqtt_dotdot_wind_speed_measurement_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_wind_speed_measurement_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_wind_speed_measurement_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/WindSpeedMeasurement/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/WindSpeedMeasurement/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for WindSpeedMeasurement Cluster
void uic_mqtt_dotdot_wind_speed_measurement_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/WindSpeedMeasurement/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for CarbonMonoxide Cluster
void uic_mqtt_dotdot_carbon_monoxide_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/CarbonMonoxide/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for CarbonMonoxide Cluster
void uic_mqtt_dotdot_carbon_monoxide_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/CarbonMonoxide/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_carbon_monoxide_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_carbon_monoxide_write_attributes_callback) {
    uic_mqtt_dotdot_carbon_monoxide_state_t carbon_monoxide_new_state = {};
    uic_mqtt_dotdot_carbon_monoxide_updated_state_t carbon_monoxide_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          carbon_monoxide_new_state,
          carbon_monoxide_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_callback) {
    uic_mqtt_dotdot_carbon_monoxide_updated_state_t carbon_monoxide_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          carbon_monoxide_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for CarbonMonoxide Cluster
void uic_mqtt_dotdot_carbon_monoxide_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_carbon_monoxide_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_carbon_monoxide_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/CarbonMonoxide/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/CarbonMonoxide/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for CarbonMonoxide Cluster
void uic_mqtt_dotdot_carbon_monoxide_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/CarbonMonoxide/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for CarbonDioxide Cluster
void uic_mqtt_dotdot_carbon_dioxide_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/CarbonDioxide/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for CarbonDioxide Cluster
void uic_mqtt_dotdot_carbon_dioxide_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/CarbonDioxide/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_carbon_dioxide_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_carbon_dioxide_write_attributes_callback) {
    uic_mqtt_dotdot_carbon_dioxide_state_t carbon_dioxide_new_state = {};
    uic_mqtt_dotdot_carbon_dioxide_updated_state_t carbon_dioxide_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          carbon_dioxide_new_state,
          carbon_dioxide_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_callback) {
    uic_mqtt_dotdot_carbon_dioxide_updated_state_t carbon_dioxide_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          carbon_dioxide_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for CarbonDioxide Cluster
void uic_mqtt_dotdot_carbon_dioxide_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_carbon_dioxide_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_carbon_dioxide_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/CarbonDioxide/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/CarbonDioxide/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for CarbonDioxide Cluster
void uic_mqtt_dotdot_carbon_dioxide_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/CarbonDioxide/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for PM25 Cluster
void uic_mqtt_dotdot_pm25_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/PM25/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for PM25 Cluster
void uic_mqtt_dotdot_pm25_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/PM25/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_pm25_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_pm25_write_attributes_callback) {
    uic_mqtt_dotdot_pm25_state_t pm25_new_state = {};
    uic_mqtt_dotdot_pm25_updated_state_t pm25_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          pm25_new_state,
          pm25_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_pm25_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_pm25_force_read_attributes_callback) {
    uic_mqtt_dotdot_pm25_updated_state_t pm25_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          pm25_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for PM25 Cluster
void uic_mqtt_dotdot_pm25_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_pm25_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_pm25_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PM25/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/PM25/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for PM25 Cluster
void uic_mqtt_dotdot_pm25_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/PM25/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for IASZone Cluster
void uic_mqtt_dotdot_ias_zone_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/IASZone/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for IASZone Cluster
void uic_mqtt_dotdot_ias_zone_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/IASZone/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_ias_zone_zone_enroll_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    ZoneEnrollResponseEnrollResponseCode enroll_response_code_value;
    memset(&enroll_response_code_value, 0x00, sizeof(enroll_response_code_value));
    uint8_t zoneid_value;
    memset(&zoneid_value, 0x00, sizeof(zoneid_value));
    for (const auto& callback: uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        enroll_response_code_value,
    
        zoneid_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_ias_zone_zone_status_change_notification_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t zone_status_value;
    memset(&zone_status_value, 0x00, sizeof(zone_status_value));
    uint8_t extended_status_value;
    memset(&extended_status_value, 0x00, sizeof(extended_status_value));
    uint8_t zoneid_value;
    memset(&zoneid_value, 0x00, sizeof(zoneid_value));
    uint16_t delay_value;
    memset(&delay_value, 0x00, sizeof(delay_value));
    for (const auto& callback: uic_mqtt_dotdot_ias_zone_zone_status_change_notification_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        zone_status_value,
    
        extended_status_value,
    
        zoneid_value,
    
        delay_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_ias_zone_zone_enroll_request_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    IasZoneType zone_type_value;
    memset(&zone_type_value, 0x00, sizeof(zone_type_value));
    uint16_t manufacturer_code_value;
    memset(&manufacturer_code_value, 0x00, sizeof(manufacturer_code_value));
    for (const auto& callback: uic_mqtt_dotdot_ias_zone_zone_enroll_request_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        zone_type_value,
    
        manufacturer_code_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_ias_zone_initiate_test_mode_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t test_mode_duration_value;
    memset(&test_mode_duration_value, 0x00, sizeof(test_mode_duration_value));
    uint8_t current_zone_sensitivity_level_value;
    memset(&current_zone_sensitivity_level_value, 0x00, sizeof(current_zone_sensitivity_level_value));
    for (const auto& callback: uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        test_mode_duration_value,
    
        current_zone_sensitivity_level_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_ias_zone_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_ias_zone_write_attributes_callback) {
    uic_mqtt_dotdot_ias_zone_state_t ias_zone_new_state = {};
    uic_mqtt_dotdot_ias_zone_updated_state_t ias_zone_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          ias_zone_new_state,
          ias_zone_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_ias_zone_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_ias_zone_force_read_attributes_callback) {
    uic_mqtt_dotdot_ias_zone_updated_state_t ias_zone_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          ias_zone_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for IASZone Cluster
void uic_mqtt_dotdot_ias_zone_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_ias_zone_zone_enroll_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ZoneEnrollResponse")";
  }
  if (uic_mqtt_dotdot_ias_zone_zone_status_change_notification_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ZoneStatusChangeNotification")";
  }
  if (uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("InitiateNormalOperationMode")";
  }
  if (uic_mqtt_dotdot_ias_zone_zone_enroll_request_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ZoneEnrollRequest")";
  }
  if (uic_mqtt_dotdot_ias_zone_initiate_test_mode_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("InitiateTestMode")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_ias_zone_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_ias_zone_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/IASZone/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/IASZone/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for IASZone Cluster
void uic_mqtt_dotdot_ias_zone_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/IASZone/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for IASWD Cluster
void uic_mqtt_dotdot_iaswd_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/IASWD/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for IASWD Cluster
void uic_mqtt_dotdot_iaswd_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/IASWD/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_iaswd_start_warning_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t siren_configuration_value;
    memset(&siren_configuration_value, 0x00, sizeof(siren_configuration_value));
    uint16_t warning_duration_value;
    memset(&warning_duration_value, 0x00, sizeof(warning_duration_value));
    uint8_t strobe_duty_cycle_value;
    memset(&strobe_duty_cycle_value, 0x00, sizeof(strobe_duty_cycle_value));
    IaswdLevel strobe_level_value;
    memset(&strobe_level_value, 0x00, sizeof(strobe_level_value));
    for (const auto& callback: uic_mqtt_dotdot_iaswd_start_warning_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        siren_configuration_value,
    
        warning_duration_value,
    
        strobe_duty_cycle_value,
    
        strobe_level_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_iaswd_squawk_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t squawk_configuration_value;
    memset(&squawk_configuration_value, 0x00, sizeof(squawk_configuration_value));
    for (const auto& callback: uic_mqtt_dotdot_iaswd_squawk_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        squawk_configuration_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_iaswd_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_iaswd_write_attributes_callback) {
    uic_mqtt_dotdot_iaswd_state_t iaswd_new_state = {};
    uic_mqtt_dotdot_iaswd_updated_state_t iaswd_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          iaswd_new_state,
          iaswd_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_iaswd_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_iaswd_force_read_attributes_callback) {
    uic_mqtt_dotdot_iaswd_updated_state_t iaswd_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          iaswd_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for IASWD Cluster
void uic_mqtt_dotdot_iaswd_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_iaswd_start_warning_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("StartWarning")";
  }
  if (uic_mqtt_dotdot_iaswd_squawk_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Squawk")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_iaswd_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_iaswd_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/IASWD/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/IASWD/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for IASWD Cluster
void uic_mqtt_dotdot_iaswd_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/IASWD/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Metering Cluster
void uic_mqtt_dotdot_metering_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Metering/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Metering Cluster
void uic_mqtt_dotdot_metering_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Metering/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_metering_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_metering_write_attributes_callback) {
    uic_mqtt_dotdot_metering_state_t metering_new_state = {};
    uic_mqtt_dotdot_metering_updated_state_t metering_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          metering_new_state,
          metering_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_metering_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_metering_force_read_attributes_callback) {
    uic_mqtt_dotdot_metering_updated_state_t metering_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          metering_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Metering Cluster
void uic_mqtt_dotdot_metering_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_metering_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_metering_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Metering/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Metering/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Metering Cluster
void uic_mqtt_dotdot_metering_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Metering/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for ElectricalMeasurement Cluster
void uic_mqtt_dotdot_electrical_measurement_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/ElectricalMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for ElectricalMeasurement Cluster
void uic_mqtt_dotdot_electrical_measurement_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/ElectricalMeasurement/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint8_t profile_count_value;
    memset(&profile_count_value, 0x00, sizeof(profile_count_value));
    ProfileIntervalPeriod profile_interval_period_value;
    memset(&profile_interval_period_value, 0x00, sizeof(profile_interval_period_value));
    uint8_t max_number_of_intervals_value;
    memset(&max_number_of_intervals_value, 0x00, sizeof(max_number_of_intervals_value));
    for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        profile_count_value,
    
        profile_interval_period_value,
    
        max_number_of_intervals_value,
    
        0, nullptr

        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_electrical_measurement_get_profile_info_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_get_profile_info_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    UTC start_time_value;
    memset(&start_time_value, 0x00, sizeof(start_time_value));
    GetMeasurementProfileResponseStatus status_value;
    memset(&status_value, 0x00, sizeof(status_value));
    ProfileIntervalPeriod profile_interval_period_value;
    memset(&profile_interval_period_value, 0x00, sizeof(profile_interval_period_value));
    uint8_t number_of_intervals_delivered_value;
    memset(&number_of_intervals_delivered_value, 0x00, sizeof(number_of_intervals_delivered_value));
    uint16_t attribute_id_value;
    memset(&attribute_id_value, 0x00, sizeof(attribute_id_value));
    for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        start_time_value,
    
        status_value,
    
        profile_interval_period_value,
    
        number_of_intervals_delivered_value,
    
        attribute_id_value,
    
        0, nullptr

        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t attributeid_value;
    memset(&attributeid_value, 0x00, sizeof(attributeid_value));
    UTC start_time_value;
    memset(&start_time_value, 0x00, sizeof(start_time_value));
    uint8_t number_of_intervals_value;
    memset(&number_of_intervals_value, 0x00, sizeof(number_of_intervals_value));
    for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        attributeid_value,
    
        start_time_value,
    
        number_of_intervals_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_electrical_measurement_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_write_attributes_callback) {
    uic_mqtt_dotdot_electrical_measurement_state_t electrical_measurement_new_state = {};
    uic_mqtt_dotdot_electrical_measurement_updated_state_t electrical_measurement_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          electrical_measurement_new_state,
          electrical_measurement_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_electrical_measurement_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_electrical_measurement_force_read_attributes_callback) {
    uic_mqtt_dotdot_electrical_measurement_updated_state_t electrical_measurement_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          electrical_measurement_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for ElectricalMeasurement Cluster
void uic_mqtt_dotdot_electrical_measurement_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetProfileInfoResponse")";
  }
  if (uic_mqtt_dotdot_electrical_measurement_get_profile_info_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetProfileInfo")";
  }
  if (uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetMeasurementProfileResponse")";
  }
  if (uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("GetMeasurementProfile")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_electrical_measurement_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_electrical_measurement_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ElectricalMeasurement/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/ElectricalMeasurement/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for ElectricalMeasurement Cluster
void uic_mqtt_dotdot_electrical_measurement_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ElectricalMeasurement/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Diagnostics Cluster
void uic_mqtt_dotdot_diagnostics_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Diagnostics/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Diagnostics Cluster
void uic_mqtt_dotdot_diagnostics_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Diagnostics/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_diagnostics_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_diagnostics_write_attributes_callback) {
    uic_mqtt_dotdot_diagnostics_state_t diagnostics_new_state = {};
    uic_mqtt_dotdot_diagnostics_updated_state_t diagnostics_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          diagnostics_new_state,
          diagnostics_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_diagnostics_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_diagnostics_force_read_attributes_callback) {
    uic_mqtt_dotdot_diagnostics_updated_state_t diagnostics_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          diagnostics_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Diagnostics Cluster
void uic_mqtt_dotdot_diagnostics_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_diagnostics_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_diagnostics_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Diagnostics/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Diagnostics/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Diagnostics Cluster
void uic_mqtt_dotdot_diagnostics_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Diagnostics/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for ProtocolController-RFTelemetry Cluster
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/ProtocolController/RFTelemetry/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for ProtocolController-RFTelemetry Cluster
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/ProtocolController/RFTelemetry/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* sourceunid_value;
    memset(&sourceunid_value, 0x00, sizeof(sourceunid_value));
    const char* destinationunid_value;
    memset(&destinationunid_value, 0x00, sizeof(destinationunid_value));
    bool transmission_successful_value;
    memset(&transmission_successful_value, 0x00, sizeof(transmission_successful_value));
    uint16_t transmission_time_ms_value;
    memset(&transmission_time_ms_value, 0x00, sizeof(transmission_time_ms_value));
    int8_t tx_powerd_bm_value;
    memset(&tx_powerd_bm_value, 0x00, sizeof(tx_powerd_bm_value));
    uint8_t tx_channel_value;
    memset(&tx_channel_value, 0x00, sizeof(tx_channel_value));
    uint8_t routing_attempts_value;
    memset(&routing_attempts_value, 0x00, sizeof(routing_attempts_value));
    bool route_changed_value;
    memset(&route_changed_value, 0x00, sizeof(route_changed_value));
    TxReportTransmissionSpeed transmission_speed_value;
    memset(&transmission_speed_value, 0x00, sizeof(transmission_speed_value));
    int8_t measured_noise_floord_bm_value;
    memset(&measured_noise_floord_bm_value, 0x00, sizeof(measured_noise_floord_bm_value));
    int8_t ackrssi_value;
    memset(&ackrssi_value, 0x00, sizeof(ackrssi_value));
    uint8_t ack_channel_value;
    memset(&ack_channel_value, 0x00, sizeof(ack_channel_value));
    const char* last_route_failed_link_functionalunid_value;
    memset(&last_route_failed_link_functionalunid_value, 0x00, sizeof(last_route_failed_link_functionalunid_value));
    const char* last_route_failed_link_non_functionalunid_value;
    memset(&last_route_failed_link_non_functionalunid_value, 0x00, sizeof(last_route_failed_link_non_functionalunid_value));
    int8_t destination_ack_tx_powerd_bm_value;
    memset(&destination_ack_tx_powerd_bm_value, 0x00, sizeof(destination_ack_tx_powerd_bm_value));
    int8_t destination_ack_measuredrssi_value;
    memset(&destination_ack_measuredrssi_value, 0x00, sizeof(destination_ack_measuredrssi_value));
    int8_t destination_ack_measured_noise_floor_value;
    memset(&destination_ack_measured_noise_floor_value, 0x00, sizeof(destination_ack_measured_noise_floor_value));
    for (const auto& callback: uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        sourceunid_value,
    
        destinationunid_value,
    
        transmission_successful_value,
    
        transmission_time_ms_value,
    
        tx_powerd_bm_value,
    
        tx_channel_value,
    
        routing_attempts_value,
    
        route_changed_value,
    
        transmission_speed_value,
    
        measured_noise_floord_bm_value,
    
        0, nullptr,

        0, nullptr,

        ackrssi_value,
    
        ack_channel_value,
    
        last_route_failed_link_functionalunid_value,
    
        last_route_failed_link_non_functionalunid_value,
    
        destination_ack_tx_powerd_bm_value,
    
        destination_ack_measuredrssi_value,
    
        destination_ack_measured_noise_floor_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_callback) {
    uic_mqtt_dotdot_protocol_controller_rf_telemetry_state_t protocol_controller_rf_telemetry_new_state = {};
    uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t protocol_controller_rf_telemetry_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          protocol_controller_rf_telemetry_new_state,
          protocol_controller_rf_telemetry_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_callback) {
    uic_mqtt_dotdot_protocol_controller_rf_telemetry_updated_state_t protocol_controller_rf_telemetry_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          protocol_controller_rf_telemetry_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for ProtocolController-RFTelemetry Cluster
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_protocol_controller_rf_telemetry_tx_report_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("TxReport")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_protocol_controller_rf_telemetry_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_protocol_controller_rf_telemetry_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  
  topic +=  "/ProtocolController/RFTelemetry/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    
    attributes_topic += "/ProtocolController/RFTelemetry/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for ProtocolController-RFTelemetry Cluster
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_empty_supported_commands(
  const dotdot_unid_t unid
  )
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ProtocolController/RFTelemetry/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for State Cluster
void uic_mqtt_dotdot_state_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/State/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for State Cluster
void uic_mqtt_dotdot_state_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/State/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_state_remove_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_state_remove_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_state_remove_offline_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_state_remove_offline_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_state_discover_neighbors_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_state_discover_neighbors_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_state_interview_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_state_interview_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_state_discover_security_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_state_discover_security_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_state_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_state_write_attributes_callback) {
    uic_mqtt_dotdot_state_state_t state_new_state = {};
    uic_mqtt_dotdot_state_updated_state_t state_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          state_new_state,
          state_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_state_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_state_force_read_attributes_callback) {
    uic_mqtt_dotdot_state_updated_state_t state_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          state_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for State Cluster
void uic_mqtt_dotdot_state_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_state_remove_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Remove")";
  }
  if (uic_mqtt_dotdot_state_remove_offline_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("RemoveOffline")";
  }
  if (uic_mqtt_dotdot_state_discover_neighbors_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("DiscoverNeighbors")";
  }
  if (uic_mqtt_dotdot_state_interview_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Interview")";
  }
  if (uic_mqtt_dotdot_state_discover_security_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("DiscoverSecurity")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_state_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_state_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  
  topic +=  "/State/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    
    attributes_topic += "/State/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for State Cluster
void uic_mqtt_dotdot_state_publish_empty_supported_commands(
  const dotdot_unid_t unid
  )
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/State/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Binding Cluster
void uic_mqtt_dotdot_binding_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Binding/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Binding Cluster
void uic_mqtt_dotdot_binding_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Binding/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_binding_bind_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* cluster_name_value;
    memset(&cluster_name_value, 0x00, sizeof(cluster_name_value));
    const char* destination_unid_value;
    memset(&destination_unid_value, 0x00, sizeof(destination_unid_value));
    uint8_t destination_ep_value;
    memset(&destination_ep_value, 0x00, sizeof(destination_ep_value));
    for (const auto& callback: uic_mqtt_dotdot_binding_bind_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        cluster_name_value,
    
        destination_unid_value,
    
        destination_ep_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_binding_unbind_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* cluster_name_value;
    memset(&cluster_name_value, 0x00, sizeof(cluster_name_value));
    const char* destination_unid_value;
    memset(&destination_unid_value, 0x00, sizeof(destination_unid_value));
    uint8_t destination_ep_value;
    memset(&destination_ep_value, 0x00, sizeof(destination_ep_value));
    for (const auto& callback: uic_mqtt_dotdot_binding_unbind_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        cluster_name_value,
    
        destination_unid_value,
    
        destination_ep_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_binding_bind_to_protocol_controller_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* cluster_name_value;
    memset(&cluster_name_value, 0x00, sizeof(cluster_name_value));
    for (const auto& callback: uic_mqtt_dotdot_binding_bind_to_protocol_controller_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        cluster_name_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_binding_unbind_from_protocol_controller_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* cluster_name_value;
    memset(&cluster_name_value, 0x00, sizeof(cluster_name_value));
    for (const auto& callback: uic_mqtt_dotdot_binding_unbind_from_protocol_controller_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        cluster_name_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_binding_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_binding_write_attributes_callback) {
    uic_mqtt_dotdot_binding_state_t binding_new_state = {};
    uic_mqtt_dotdot_binding_updated_state_t binding_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          binding_new_state,
          binding_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_binding_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_binding_force_read_attributes_callback) {
    uic_mqtt_dotdot_binding_updated_state_t binding_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          binding_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Binding Cluster
void uic_mqtt_dotdot_binding_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_binding_bind_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Bind")";
  }
  if (uic_mqtt_dotdot_binding_unbind_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Unbind")";
  }
  if (uic_mqtt_dotdot_binding_bind_to_protocol_controller_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("BindToProtocolController")";
  }
  if (uic_mqtt_dotdot_binding_unbind_from_protocol_controller_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("UnbindFromProtocolController")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_binding_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_binding_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Binding/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Binding/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Binding Cluster
void uic_mqtt_dotdot_binding_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Binding/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for SystemMetrics Cluster
void uic_mqtt_dotdot_system_metrics_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/SystemMetrics/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for SystemMetrics Cluster
void uic_mqtt_dotdot_system_metrics_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/SystemMetrics/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_system_metrics_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_system_metrics_write_attributes_callback) {
    uic_mqtt_dotdot_system_metrics_state_t system_metrics_new_state = {};
    uic_mqtt_dotdot_system_metrics_updated_state_t system_metrics_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          system_metrics_new_state,
          system_metrics_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_system_metrics_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_system_metrics_force_read_attributes_callback) {
    uic_mqtt_dotdot_system_metrics_updated_state_t system_metrics_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          system_metrics_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for SystemMetrics Cluster
void uic_mqtt_dotdot_system_metrics_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_system_metrics_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_system_metrics_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  
  topic +=  "/SystemMetrics/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    
    attributes_topic += "/SystemMetrics/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for SystemMetrics Cluster
void uic_mqtt_dotdot_system_metrics_publish_empty_supported_commands(
  const dotdot_unid_t unid
  )
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/SystemMetrics/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for ApplicationMonitoring Cluster
void uic_mqtt_dotdot_application_monitoring_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/ApplicationMonitoring/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for ApplicationMonitoring Cluster
void uic_mqtt_dotdot_application_monitoring_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/ApplicationMonitoring/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_application_monitoring_log_entry_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* timestamp_value;
    memset(&timestamp_value, 0x00, sizeof(timestamp_value));
    LoggingLevelEnum log_level_value;
    memset(&log_level_value, 0x00, sizeof(log_level_value));
    const char* log_tag_value;
    memset(&log_tag_value, 0x00, sizeof(log_tag_value));
    const char* log_message_value;
    memset(&log_message_value, 0x00, sizeof(log_message_value));
    for (const auto& callback: uic_mqtt_dotdot_application_monitoring_log_entry_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        timestamp_value,
    
        log_level_value,
    
        log_tag_value,
    
        log_message_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_application_monitoring_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_application_monitoring_write_attributes_callback) {
    uic_mqtt_dotdot_application_monitoring_state_t application_monitoring_new_state = {};
    uic_mqtt_dotdot_application_monitoring_updated_state_t application_monitoring_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          application_monitoring_new_state,
          application_monitoring_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_application_monitoring_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_application_monitoring_force_read_attributes_callback) {
    uic_mqtt_dotdot_application_monitoring_updated_state_t application_monitoring_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          application_monitoring_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for ApplicationMonitoring Cluster
void uic_mqtt_dotdot_application_monitoring_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_application_monitoring_log_entry_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("LogEntry")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_application_monitoring_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_application_monitoring_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  
  topic +=  "/ApplicationMonitoring/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    
    attributes_topic += "/ApplicationMonitoring/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for ApplicationMonitoring Cluster
void uic_mqtt_dotdot_application_monitoring_publish_empty_supported_commands(
  const dotdot_unid_t unid
  )
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ApplicationMonitoring/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for NameAndLocation Cluster
void uic_mqtt_dotdot_name_and_location_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/NameAndLocation/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for NameAndLocation Cluster
void uic_mqtt_dotdot_name_and_location_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/NameAndLocation/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_name_and_location_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_name_and_location_write_attributes_callback) {
    uic_mqtt_dotdot_name_and_location_state_t name_and_location_new_state = {};
    uic_mqtt_dotdot_name_and_location_updated_state_t name_and_location_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          name_and_location_new_state,
          name_and_location_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_name_and_location_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_name_and_location_force_read_attributes_callback) {
    uic_mqtt_dotdot_name_and_location_updated_state_t name_and_location_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          name_and_location_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for NameAndLocation Cluster
void uic_mqtt_dotdot_name_and_location_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_name_and_location_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_name_and_location_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/NameAndLocation/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/NameAndLocation/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for NameAndLocation Cluster
void uic_mqtt_dotdot_name_and_location_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/NameAndLocation/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for ConfigurationParameters Cluster
void uic_mqtt_dotdot_configuration_parameters_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/ConfigurationParameters/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for ConfigurationParameters Cluster
void uic_mqtt_dotdot_configuration_parameters_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/ConfigurationParameters/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_configuration_parameters_discover_parameter_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t parameter_id_value;
    memset(&parameter_id_value, 0x00, sizeof(parameter_id_value));
    for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_discover_parameter_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        parameter_id_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_configuration_parameters_set_parameter_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t parameter_id_value;
    memset(&parameter_id_value, 0x00, sizeof(parameter_id_value));
    int64_t value_value;
    memset(&value_value, 0x00, sizeof(value_value));
    for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_set_parameter_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        parameter_id_value,
    
        value_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    uint16_t first_parameter_id_value;
    memset(&first_parameter_id_value, 0x00, sizeof(first_parameter_id_value));
    uint16_t last_parameter_id_value;
    memset(&last_parameter_id_value, 0x00, sizeof(last_parameter_id_value));
    for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        first_parameter_id_value,
    
        last_parameter_id_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_configuration_parameters_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_write_attributes_callback) {
    uic_mqtt_dotdot_configuration_parameters_state_t configuration_parameters_new_state = {};
    uic_mqtt_dotdot_configuration_parameters_updated_state_t configuration_parameters_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          configuration_parameters_new_state,
          configuration_parameters_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_configuration_parameters_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_configuration_parameters_force_read_attributes_callback) {
    uic_mqtt_dotdot_configuration_parameters_updated_state_t configuration_parameters_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          configuration_parameters_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for ConfigurationParameters Cluster
void uic_mqtt_dotdot_configuration_parameters_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_configuration_parameters_discover_parameter_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("DiscoverParameter")";
  }
  if (uic_mqtt_dotdot_configuration_parameters_default_reset_all_parameters_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("DefaultResetAllParameters")";
  }
  if (uic_mqtt_dotdot_configuration_parameters_set_parameter_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("SetParameter")";
  }
  if (uic_mqtt_dotdot_configuration_parameters_discover_parameter_range_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("DiscoverParameterRange")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_configuration_parameters_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_configuration_parameters_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ConfigurationParameters/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/ConfigurationParameters/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for ConfigurationParameters Cluster
void uic_mqtt_dotdot_configuration_parameters_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/ConfigurationParameters/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for AoXLocator Cluster
void uic_mqtt_dotdot_aox_locator_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/AoXLocator/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for AoXLocator Cluster
void uic_mqtt_dotdot_aox_locator_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/AoXLocator/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_aox_locator_iq_report_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* tag_unid_value;
    memset(&tag_unid_value, 0x00, sizeof(tag_unid_value));
    uint8_t channel_value;
    memset(&channel_value, 0x00, sizeof(channel_value));
    int8_t rssi_value;
    memset(&rssi_value, 0x00, sizeof(rssi_value));
    int32_t sequence_value;
    memset(&sequence_value, 0x00, sizeof(sequence_value));
    for (const auto& callback: uic_mqtt_dotdot_aox_locator_iq_report_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        tag_unid_value,
    
        channel_value,
    
        rssi_value,
    
        0, nullptr,

        sequence_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_aox_locator_angle_report_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* tag_unid_value;
    memset(&tag_unid_value, 0x00, sizeof(tag_unid_value));
    SphericalCoordinates direction_value;
    memset(&direction_value, 0x00, sizeof(direction_value));
    SphericalCoordinates deviation_value;
    memset(&deviation_value, 0x00, sizeof(deviation_value));
    int32_t sequence_value;
    memset(&sequence_value, 0x00, sizeof(sequence_value));
    for (const auto& callback: uic_mqtt_dotdot_aox_locator_angle_report_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        tag_unid_value,
    
        direction_value,
    
        deviation_value,
    
        sequence_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}
static inline bool uic_mqtt_dotdot_aox_locator_angle_correction_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    const char* tag_unid_value;
    memset(&tag_unid_value, 0x00, sizeof(tag_unid_value));
    SphericalCoordinates direction_value;
    memset(&direction_value, 0x00, sizeof(direction_value));
    SphericalCoordinates deviation_value;
    memset(&deviation_value, 0x00, sizeof(deviation_value));
    int32_t sequence_value;
    memset(&sequence_value, 0x00, sizeof(sequence_value));
    for (const auto& callback: uic_mqtt_dotdot_aox_locator_angle_correction_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    ,
        tag_unid_value,
    
        direction_value,
    
        deviation_value,
    
        sequence_value
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_aox_locator_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_aox_locator_write_attributes_callback) {
    uic_mqtt_dotdot_aox_locator_state_t aox_locator_new_state = {};
    uic_mqtt_dotdot_aox_locator_updated_state_t aox_locator_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          aox_locator_new_state,
          aox_locator_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_aox_locator_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_aox_locator_force_read_attributes_callback) {
    uic_mqtt_dotdot_aox_locator_updated_state_t aox_locator_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          aox_locator_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for AoXLocator Cluster
void uic_mqtt_dotdot_aox_locator_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_aox_locator_iq_report_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("IQReport")";
  }
  if (uic_mqtt_dotdot_aox_locator_angle_report_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("AngleReport")";
  }
  if (uic_mqtt_dotdot_aox_locator_angle_correction_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("AngleCorrection")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_aox_locator_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_aox_locator_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/AoXLocator/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/AoXLocator/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for AoXLocator Cluster
void uic_mqtt_dotdot_aox_locator_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/AoXLocator/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for AoXPositionEstimation Cluster
void uic_mqtt_dotdot_aox_position_estimation_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/AoXPositionEstimation/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for AoXPositionEstimation Cluster
void uic_mqtt_dotdot_aox_position_estimation_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/AoXPositionEstimation/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_aox_position_estimation_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_aox_position_estimation_write_attributes_callback) {
    uic_mqtt_dotdot_aox_position_estimation_state_t aox_position_estimation_new_state = {};
    uic_mqtt_dotdot_aox_position_estimation_updated_state_t aox_position_estimation_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          aox_position_estimation_new_state,
          aox_position_estimation_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_callback) {
    uic_mqtt_dotdot_aox_position_estimation_updated_state_t aox_position_estimation_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          aox_position_estimation_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for AoXPositionEstimation Cluster
void uic_mqtt_dotdot_aox_position_estimation_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_aox_position_estimation_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_aox_position_estimation_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/AoXPositionEstimation/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/AoXPositionEstimation/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for AoXPositionEstimation Cluster
void uic_mqtt_dotdot_aox_position_estimation_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/AoXPositionEstimation/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for ProtocolController-NetworkManagement Cluster
void uic_mqtt_dotdot_protocol_controller_network_management_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/ProtocolController/NetworkManagement/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for ProtocolController-NetworkManagement Cluster
void uic_mqtt_dotdot_protocol_controller_network_management_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/ProtocolController/NetworkManagement/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}

static inline bool uic_mqtt_dotdot_protocol_controller_network_management_write_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
    for (const auto& callback: uic_mqtt_dotdot_protocol_controller_network_management_write_callback) {
      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
    
        ) == SL_STATUS_OK) {
      return true;
    }
  }

  return false;
}

static inline bool uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_callback) {
    uic_mqtt_dotdot_protocol_controller_network_management_state_t protocol_controller_network_management_new_state = {};
    uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t protocol_controller_network_management_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          protocol_controller_network_management_new_state,
          protocol_controller_network_management_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_callback) {
    uic_mqtt_dotdot_protocol_controller_network_management_updated_state_t protocol_controller_network_management_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          protocol_controller_network_management_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for ProtocolController-NetworkManagement Cluster
void uic_mqtt_dotdot_protocol_controller_network_management_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command
  if (uic_mqtt_dotdot_protocol_controller_network_management_write_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("Write")";
  }

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_protocol_controller_network_management_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_protocol_controller_network_management_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  
  topic +=  "/ProtocolController/NetworkManagement/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    
    attributes_topic += "/ProtocolController/NetworkManagement/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for ProtocolController-NetworkManagement Cluster
void uic_mqtt_dotdot_protocol_controller_network_management_publish_empty_supported_commands(
  const dotdot_unid_t unid
  )
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ProtocolController/NetworkManagement/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for Descriptor Cluster
void uic_mqtt_dotdot_descriptor_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/Descriptor/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for Descriptor Cluster
void uic_mqtt_dotdot_descriptor_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/Descriptor/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_descriptor_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_descriptor_write_attributes_callback) {
    uic_mqtt_dotdot_descriptor_state_t descriptor_new_state = {};
    uic_mqtt_dotdot_descriptor_updated_state_t descriptor_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          descriptor_new_state,
          descriptor_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_descriptor_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_descriptor_force_read_attributes_callback) {
    uic_mqtt_dotdot_descriptor_updated_state_t descriptor_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          descriptor_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for Descriptor Cluster
void uic_mqtt_dotdot_descriptor_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_descriptor_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_descriptor_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Descriptor/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/Descriptor/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for Descriptor Cluster
void uic_mqtt_dotdot_descriptor_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/Descriptor/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}

// Publishing Cluster Revision for UnifyThermostat Cluster
void uic_mqtt_dotdot_unify_thermostat_publish_cluster_revision(const char* base_topic, uint16_t value)
{
  std::string cluster_topic = std::string(base_topic) + "/UnifyThermostat/Attributes/ClusterRevision";
  // Publish Desired
  std::string pub_topic_des = cluster_topic + "/Desired";
  std::string payload = std::string(R"({"value": )")
    + std::to_string(value) + std::string("}");
  uic_mqtt_publish(pub_topic_des.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
  // Publish Reported
  std::string pub_topic_rep = cluster_topic + "/Reported";
  uic_mqtt_publish(pub_topic_rep.c_str(),
                    payload.c_str(),
                    payload.size(),
                    true);
}

// Unretain Cluster Revision for UnifyThermostat Cluster
void uic_mqtt_dotdot_unify_thermostat_unretain_cluster_revision(const char* base_topic)
{
  // clang-format on
  std::string cluster_topic
    = std::string(base_topic)
      + "/UnifyThermostat/Attributes/ClusterRevision";
  // Publish Desired
  std::string desired_topic = cluster_topic + "/Desired";
  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
  // Publish Reported
  std::string reported_topic = cluster_topic + "/Reported";
  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
  // clang-format off
}


static inline bool uic_mqtt_dotdot_unify_thermostat_write_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_unify_thermostat_write_attributes_callback) {
    uic_mqtt_dotdot_unify_thermostat_state_t unify_thermostat_new_state = {};
    uic_mqtt_dotdot_unify_thermostat_updated_state_t unify_thermostat_new_updated_state = {};

    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          unify_thermostat_new_state,
          unify_thermostat_new_updated_state
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

static inline bool uic_mqtt_dotdot_unify_thermostat_force_read_attributes_is_supported(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  for (const auto& callback: uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback) {
    uic_mqtt_dotdot_unify_thermostat_updated_state_t unify_thermostat_force_update = {0};
    if (callback(
          unid,
          endpoint_id,
          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
          unify_thermostat_force_update
      ) == SL_STATUS_OK) {
      return true;
    }
  }
  return false;
}

// Publishing Supported Commands for UnifyThermostat Cluster
void uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(
  const dotdot_unid_t unid,
  dotdot_endpoint_id_t endpoint_id)
{
  std::stringstream ss;
  bool first_command = true;
  ss.str("");

  // check if there is callback for each command

  // Check for a WriteAttributes Callback
  if(uic_mqtt_dotdot_unify_thermostat_write_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("WriteAttributes")";
  }

  // Check for a ForceReadAttributes Callback
  if (uic_mqtt_dotdot_unify_thermostat_force_read_attributes_is_supported(unid, endpoint_id)) {
    if (first_command == false) {
      ss << ", ";
    }
    first_command = false;
    ss << R"("ForceReadAttributes")";
  }

  // Publish supported commands
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/UnifyThermostat/SupportedCommands";
  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
  if (first_command == false) {
    uic_mqtt_publish(topic.c_str(),
                      payload_str.c_str(),
                      payload_str.length(),
                      true);
  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
    // There are no supported commands, but make sure we publish some
    // SupportedCommands = [] if any attribute has been published for a cluster.
    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
    attributes_topic += "/UnifyThermostat/Attributes";

    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
      uic_mqtt_publish(topic.c_str(),
                      EMPTY_VALUE_ARRAY,
                      strlen(EMPTY_VALUE_ARRAY),
                      true);
    }
  }
}

// Publishing empty/no Supported Commands for UnifyThermostat Cluster
void uic_mqtt_dotdot_unify_thermostat_publish_empty_supported_commands(
  const dotdot_unid_t unid
  , dotdot_endpoint_id_t endpoint_id)
{
  std::string topic = "ucl/by-unid/" + std::string(unid);
  topic +=  "/ep"+ std::to_string(endpoint_id);
  topic +=  "/UnifyThermostat/SupportedCommands";

  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
    uic_mqtt_publish(topic.c_str(),
                     EMPTY_VALUE_ARRAY,
                     strlen(EMPTY_VALUE_ARRAY),
                     true);
  }
}


////////////////////////////////////////////////////////////////////////////////
// Generated Commands publications functions
////////////////////////////////////////////////////////////////////////////////
/**
 * @brief Publishes an incoming/generated ResetToFactoryDefaults command for
 * the Basic cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Basic/GeneratedCommands/ResetToFactoryDefaults
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_basic_publish_generated_reset_to_factory_defaults_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Basic/GeneratedCommands/ResetToFactoryDefaults";

  std::string payload =
    get_json_payload_for_basic_reset_to_factory_defaults_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Identify command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/Identify
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_identify_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_identify_command_identify_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/Identify";

  std::string payload =
    get_json_payload_for_identify_identify_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated IdentifyQueryResponse command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/IdentifyQueryResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_identify_query_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_identify_command_identify_query_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/IdentifyQueryResponse";

  std::string payload =
    get_json_payload_for_identify_identify_query_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated IdentifyQuery command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/IdentifyQuery
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_identify_query_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/IdentifyQuery";

  std::string payload =
    get_json_payload_for_identify_identify_query_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated TriggerEffect command for
 * the Identify cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Identify/GeneratedCommands/TriggerEffect
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_identify_publish_generated_trigger_effect_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_identify_command_trigger_effect_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Identify/GeneratedCommands/TriggerEffect";

  std::string payload =
    get_json_payload_for_identify_trigger_effect_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddGroup command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/AddGroup
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_add_group_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/AddGroup";

  std::string payload =
    get_json_payload_for_groups_add_group_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddGroupResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/AddGroupResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_add_group_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/AddGroupResponse";

  std::string payload =
    get_json_payload_for_groups_add_group_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewGroup command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/ViewGroup
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_view_group_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_view_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/ViewGroup";

  std::string payload =
    get_json_payload_for_groups_view_group_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewGroupResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/ViewGroupResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_view_group_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_view_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/ViewGroupResponse";

  std::string payload =
    get_json_payload_for_groups_view_group_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetGroupMembership command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/GetGroupMembership
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_get_group_membership_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_get_group_membership_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/GetGroupMembership";

  std::string payload =
    get_json_payload_for_groups_get_group_membership_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetGroupMembershipResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/GetGroupMembershipResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_get_group_membership_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_get_group_membership_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/GetGroupMembershipResponse";

  std::string payload =
    get_json_payload_for_groups_get_group_membership_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveGroup command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/RemoveGroup
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_remove_group_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_remove_group_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/RemoveGroup";

  std::string payload =
    get_json_payload_for_groups_remove_group_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveGroupResponse command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/RemoveGroupResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_remove_group_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_remove_group_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/RemoveGroupResponse";

  std::string payload =
    get_json_payload_for_groups_remove_group_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveAllGroups command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/RemoveAllGroups
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_remove_all_groups_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/RemoveAllGroups";

  std::string payload =
    get_json_payload_for_groups_remove_all_groups_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddGroupIfIdentifying command for
 * the Groups cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Groups/GeneratedCommands/AddGroupIfIdentifying
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_groups_publish_generated_add_group_if_identifying_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_groups_command_add_group_if_identifying_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Groups/GeneratedCommands/AddGroupIfIdentifying";

  std::string payload =
    get_json_payload_for_groups_add_group_if_identifying_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/AddScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_add_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_add_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/AddScene";

  std::string payload =
    get_json_payload_for_scenes_add_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AddSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/AddSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_add_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_add_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/AddSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_add_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/ViewScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_view_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_view_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/ViewScene";

  std::string payload =
    get_json_payload_for_scenes_view_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ViewSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/ViewSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_view_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_view_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/ViewSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_view_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveScene";

  std::string payload =
    get_json_payload_for_scenes_remove_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_remove_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveAllScenes command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveAllScenes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_all_scenes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveAllScenes";

  std::string payload =
    get_json_payload_for_scenes_remove_all_scenes_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveAllScenesResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RemoveAllScenesResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_remove_all_scenes_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_remove_all_scenes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RemoveAllScenesResponse";

  std::string payload =
    get_json_payload_for_scenes_remove_all_scenes_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StoreScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/StoreScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_store_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_store_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/StoreScene";

  std::string payload =
    get_json_payload_for_scenes_store_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StoreSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/StoreSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_store_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_store_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/StoreSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_store_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RecallScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/RecallScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_recall_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_recall_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/RecallScene";

  std::string payload =
    get_json_payload_for_scenes_recall_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetSceneMembership command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/GetSceneMembership
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_get_scene_membership_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/GetSceneMembership";

  std::string payload =
    get_json_payload_for_scenes_get_scene_membership_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetSceneMembershipResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/GetSceneMembershipResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_get_scene_membership_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_get_scene_membership_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/GetSceneMembershipResponse";

  std::string payload =
    get_json_payload_for_scenes_get_scene_membership_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedAddScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedAddScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_add_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedAddScene";

  std::string payload =
    get_json_payload_for_scenes_enhanced_add_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedAddSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedAddSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_add_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_add_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedAddSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_enhanced_add_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedViewScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedViewScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_view_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedViewScene";

  std::string payload =
    get_json_payload_for_scenes_enhanced_view_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedViewSceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/EnhancedViewSceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_enhanced_view_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_enhanced_view_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/EnhancedViewSceneResponse";

  std::string payload =
    get_json_payload_for_scenes_enhanced_view_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CopyScene command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/CopyScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_copy_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_copy_scene_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/CopyScene";

  std::string payload =
    get_json_payload_for_scenes_copy_scene_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CopySceneResponse command for
 * the Scenes cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Scenes/GeneratedCommands/CopySceneResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_scenes_publish_generated_copy_scene_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_scenes_command_copy_scene_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Scenes/GeneratedCommands/CopySceneResponse";

  std::string payload =
    get_json_payload_for_scenes_copy_scene_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Off command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/Off
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/Off";

  std::string payload =
    get_json_payload_for_on_off_off_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated On command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/On
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_on_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/On";

  std::string payload =
    get_json_payload_for_on_off_on_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Toggle command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/Toggle
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_toggle_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/Toggle";

  std::string payload =
    get_json_payload_for_on_off_toggle_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OffWithEffect command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/OffWithEffect
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_off_with_effect_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_on_off_command_off_with_effect_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/OffWithEffect";

  std::string payload =
    get_json_payload_for_on_off_off_with_effect_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OnWithRecallGlobalScene command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/OnWithRecallGlobalScene
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_on_with_recall_global_scene_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/OnWithRecallGlobalScene";

  std::string payload =
    get_json_payload_for_on_off_on_with_recall_global_scene_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OnWithTimedOff command for
 * the OnOff cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/OnOff/GeneratedCommands/OnWithTimedOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_on_off_publish_generated_on_with_timed_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_on_off_command_on_with_timed_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "OnOff/GeneratedCommands/OnWithTimedOff";

  std::string payload =
    get_json_payload_for_on_off_on_with_timed_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToLevel command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveToLevel
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_to_level_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_to_level_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveToLevel";

  std::string payload =
    get_json_payload_for_level_move_to_level_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Move command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/Move
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/Move";

  std::string payload =
    get_json_payload_for_level_move_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Step command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/Step
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_step_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_step_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/Step";

  std::string payload =
    get_json_payload_for_level_step_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Stop command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/Stop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_stop_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/Stop";

  std::string payload =
    get_json_payload_for_level_stop_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToLevelWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveToLevelWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_to_level_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_to_level_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveToLevelWithOnOff";

  std::string payload =
    get_json_payload_for_level_move_to_level_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveWithOnOff";

  std::string payload =
    get_json_payload_for_level_move_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/StepWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_step_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_step_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/StepWithOnOff";

  std::string payload =
    get_json_payload_for_level_step_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StopWithOnOff command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/StopWithOnOff
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_stop_with_on_off_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_stop_with_on_off_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/StopWithOnOff";

  std::string payload =
    get_json_payload_for_level_stop_with_on_off_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToClosestFrequency command for
 * the Level cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Level/GeneratedCommands/MoveToClosestFrequency
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_level_publish_generated_move_to_closest_frequency_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_level_command_move_to_closest_frequency_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Level/GeneratedCommands/MoveToClosestFrequency";

  std::string payload =
    get_json_payload_for_level_move_to_closest_frequency_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ResetAlarm command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/ResetAlarm
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_reset_alarm_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_alarms_command_reset_alarm_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/ResetAlarm";

  std::string payload =
    get_json_payload_for_alarms_reset_alarm_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Alarm command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/Alarm
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_alarm_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_alarms_command_alarm_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/Alarm";

  std::string payload =
    get_json_payload_for_alarms_alarm_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ResetAllAlarms command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/ResetAllAlarms
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_reset_all_alarms_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/ResetAllAlarms";

  std::string payload =
    get_json_payload_for_alarms_reset_all_alarms_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetAlarmResponse command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/GetAlarmResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_get_alarm_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_alarms_command_get_alarm_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/GetAlarmResponse";

  std::string payload =
    get_json_payload_for_alarms_get_alarm_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetAlarm command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/GetAlarm
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_get_alarm_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/GetAlarm";

  std::string payload =
    get_json_payload_for_alarms_get_alarm_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ResetAlarmLog command for
 * the Alarms cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Alarms/GeneratedCommands/ResetAlarmLog
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_alarms_publish_generated_reset_alarm_log_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Alarms/GeneratedCommands/ResetAlarmLog";

  std::string payload =
    get_json_payload_for_alarms_reset_alarm_log_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CheckIn command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/CheckIn
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_check_in_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/CheckIn";

  std::string payload =
    get_json_payload_for_poll_control_check_in_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated CheckInResponse command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/CheckInResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_check_in_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_poll_control_command_check_in_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/CheckInResponse";

  std::string payload =
    get_json_payload_for_poll_control_check_in_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated FastPollStop command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/FastPollStop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_fast_poll_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/FastPollStop";

  std::string payload =
    get_json_payload_for_poll_control_fast_poll_stop_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetLongPollInterval command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/SetLongPollInterval
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_set_long_poll_interval_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_poll_control_command_set_long_poll_interval_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/SetLongPollInterval";

  std::string payload =
    get_json_payload_for_poll_control_set_long_poll_interval_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetShortPollInterval command for
 * the PollControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/PollControl/GeneratedCommands/SetShortPollInterval
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_poll_control_publish_generated_set_short_poll_interval_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_poll_control_command_set_short_poll_interval_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "PollControl/GeneratedCommands/SetShortPollInterval";

  std::string payload =
    get_json_payload_for_poll_control_set_short_poll_interval_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated LockDoor command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/LockDoor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_lock_door_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_lock_door_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/LockDoor";

  std::string payload =
    get_json_payload_for_door_lock_lock_door_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated LockDoorResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/LockDoorResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_lock_door_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_lock_door_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/LockDoorResponse";

  std::string payload =
    get_json_payload_for_door_lock_lock_door_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockDoor command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockDoor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_door_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockDoor";

  std::string payload =
    get_json_payload_for_door_lock_unlock_door_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockDoorResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockDoorResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_door_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockDoorResponse";

  std::string payload =
    get_json_payload_for_door_lock_unlock_door_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Toggle command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/Toggle
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_toggle_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_toggle_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/Toggle";

  std::string payload =
    get_json_payload_for_door_lock_toggle_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ToggleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ToggleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_toggle_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_toggle_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ToggleResponse";

  std::string payload =
    get_json_payload_for_door_lock_toggle_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockWithTimeout command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockWithTimeout
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_with_timeout_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockWithTimeout";

  std::string payload =
    get_json_payload_for_door_lock_unlock_with_timeout_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnlockWithTimeoutResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnlockWithTimeoutResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unlock_with_timeout_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnlockWithTimeoutResponse";

  std::string payload =
    get_json_payload_for_door_lock_unlock_with_timeout_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetLogRecord command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetLogRecord
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_log_record_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetLogRecord";

  std::string payload =
    get_json_payload_for_door_lock_get_log_record_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetLogRecordResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetLogRecordResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_log_record_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetLogRecordResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_log_record_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetPINCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetPINCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_pin_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_pin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetPINCode";

  std::string payload =
    get_json_payload_for_door_lock_set_pin_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetPINCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetPINCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_pin_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_pin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_pin_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetPINCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetPINCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_pin_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_pin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetPINCode";

  std::string payload =
    get_json_payload_for_door_lock_get_pin_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetPINCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetPINCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_pin_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_pin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_pin_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearPINCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearPINCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_pin_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_pin_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearPINCode";

  std::string payload =
    get_json_payload_for_door_lock_clear_pin_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearPINCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearPINCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_pin_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_pin_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearPINCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_pin_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllPINCodes command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllPINCodes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_all_pin_codes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllPINCodes";

  std::string payload =
    get_json_payload_for_door_lock_clear_all_pin_codes_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllPINCodesResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllPINCodesResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_all_pin_codes_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_all_pin_codes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllPINCodesResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_all_pin_codes_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserStatus command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserStatus
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_status_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserStatus";

  std::string payload =
    get_json_payload_for_door_lock_set_user_status_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserStatusResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserStatusResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_status_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserStatusResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_user_status_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserStatus command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserStatus
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_status_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserStatus";

  std::string payload =
    get_json_payload_for_door_lock_get_user_status_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserStatusResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserStatusResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_status_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserStatusResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_user_status_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetWeekdaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetWeekdaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_weekday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_weekday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetWeekdayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetWeekdayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_weekday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_weekday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeekdaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetWeekdaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_weekday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_weekday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeekdayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetWeekdayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_weekday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_weekday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearWeekdaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearWeekdaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_weekday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearWeekdaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_weekday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearWeekdayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearWeekdayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_weekday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearWeekdayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_weekday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetYearDaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetYearDaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_year_day_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_year_day_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetYearDayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetYearDayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_year_day_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_year_day_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetYearDaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetYearDaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_year_day_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_year_day_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetYearDayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetYearDayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_year_day_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_year_day_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearYearDaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearYearDaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_year_day_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearYearDaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_year_day_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearYearDayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearYearDayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_year_day_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearYearDayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_year_day_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetHolidaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetHolidaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_holiday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_set_holiday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetHolidayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetHolidayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_holiday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_holiday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetHolidaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetHolidaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_holiday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_get_holiday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetHolidayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetHolidayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_holiday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_holiday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearHolidaySchedule command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearHolidaySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_holiday_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearHolidaySchedule";

  std::string payload =
    get_json_payload_for_door_lock_clear_holiday_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearHolidayScheduleResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearHolidayScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_holiday_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearHolidayScheduleResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_holiday_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserType command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserType
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_type_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserType";

  std::string payload =
    get_json_payload_for_door_lock_set_user_type_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUserTypeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUserTypeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_type_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUserTypeResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_user_type_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserType command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserType
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_type_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserType";

  std::string payload =
    get_json_payload_for_door_lock_get_user_type_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserTypeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserTypeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_type_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserTypeResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_user_type_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetRFIDCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetRFIDCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_rfid_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_rfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_set_rfid_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetRFIDCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetRFIDCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_rfid_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_rfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_rfid_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRFIDCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetRFIDCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_rfid_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_rfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_get_rfid_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRFIDCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetRFIDCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_rfid_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_rfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_rfid_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearRFIDCode command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearRFIDCode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_rfid_code_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_rfid_code_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearRFIDCode";

  std::string payload =
    get_json_payload_for_door_lock_clear_rfid_code_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearRFIDCodeResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearRFIDCodeResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_rfid_code_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_rfid_code_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearRFIDCodeResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_rfid_code_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllRFIDCodes command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllRFIDCodes
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_all_rfid_codes_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllRFIDCodes";

  std::string payload =
    get_json_payload_for_door_lock_clear_all_rfid_codes_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearAllRFIDCodesResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearAllRFIDCodesResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_all_rfid_codes_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_all_rfid_codes_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearAllRFIDCodesResponse";

  std::string payload =
    get_json_payload_for_door_lock_clear_all_rfid_codes_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetUser command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetUser
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_user_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_user_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetUser";

  std::string payload =
    get_json_payload_for_door_lock_set_user_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUser command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUser
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_user_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUser";

  std::string payload =
    get_json_payload_for_door_lock_get_user_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetUserResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetUserResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_user_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetUserResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_user_response_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearUser command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearUser
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_user_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_user_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearUser";

  std::string payload =
    get_json_payload_for_door_lock_clear_user_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated OperatingEventNotification command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/OperatingEventNotification
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_operating_event_notification_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_operating_event_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/OperatingEventNotification";

  std::string payload =
    get_json_payload_for_door_lock_operating_event_notification_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ProgrammingEventNotification command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ProgrammingEventNotification
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_programming_event_notification_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_programming_event_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ProgrammingEventNotification";

  std::string payload =
    get_json_payload_for_door_lock_programming_event_notification_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetCredential command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetCredential
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_credential_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_set_credential_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetCredential";

  std::string payload =
    get_json_payload_for_door_lock_set_credential_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetCredentialResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/SetCredentialResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_set_credential_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/SetCredentialResponse";

  std::string payload =
    get_json_payload_for_door_lock_set_credential_response_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetCredentialStatus command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetCredentialStatus
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_credential_status_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_get_credential_status_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetCredentialStatus";

  std::string payload =
    get_json_payload_for_door_lock_get_credential_status_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetCredentialStatusResponse command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/GetCredentialStatusResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_get_credential_status_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/GetCredentialStatusResponse";

  std::string payload =
    get_json_payload_for_door_lock_get_credential_status_response_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearCredential command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/ClearCredential
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_clear_credential_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_clear_credential_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/ClearCredential";

  std::string payload =
    get_json_payload_for_door_lock_clear_credential_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnboltDoor command for
 * the DoorLock cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/DoorLock/GeneratedCommands/UnboltDoor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_door_lock_publish_generated_unbolt_door_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_door_lock_command_unbolt_door_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "DoorLock/GeneratedCommands/UnboltDoor";

  std::string payload =
    get_json_payload_for_door_lock_unbolt_door_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UpOrOpen command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/UpOrOpen
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_up_or_open_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/UpOrOpen";

  std::string payload =
    get_json_payload_for_window_covering_up_or_open_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DownOrClose command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/DownOrClose
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_down_or_close_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/DownOrClose";

  std::string payload =
    get_json_payload_for_window_covering_down_or_close_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Stop command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/Stop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/Stop";

  std::string payload =
    get_json_payload_for_window_covering_stop_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToLiftValue command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToLiftValue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_lift_value_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_value_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToLiftValue";

  std::string payload =
    get_json_payload_for_window_covering_go_to_lift_value_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToLiftPercentage command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToLiftPercentage
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_lift_percentage_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_lift_percentage_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToLiftPercentage";

  std::string payload =
    get_json_payload_for_window_covering_go_to_lift_percentage_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToTiltValue command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToTiltValue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_tilt_value_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_value_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToTiltValue";

  std::string payload =
    get_json_payload_for_window_covering_go_to_tilt_value_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToTiltPercentage command for
 * the WindowCovering cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/WindowCovering/GeneratedCommands/GoToTiltPercentage
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_window_covering_publish_generated_go_to_tilt_percentage_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_window_covering_command_go_to_tilt_percentage_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "WindowCovering/GeneratedCommands/GoToTiltPercentage";

  std::string payload =
    get_json_payload_for_window_covering_go_to_tilt_percentage_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GoToPercent command for
 * the BarrierControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BarrierControl/GeneratedCommands/GoToPercent
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_barrier_control_publish_generated_go_to_percent_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_barrier_control_command_go_to_percent_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "BarrierControl/GeneratedCommands/GoToPercent";

  std::string payload =
    get_json_payload_for_barrier_control_go_to_percent_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Stop command for
 * the BarrierControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/BarrierControl/GeneratedCommands/Stop
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_barrier_control_publish_generated_stop_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "BarrierControl/GeneratedCommands/Stop";

  std::string payload =
    get_json_payload_for_barrier_control_stop_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetpointRaiseOrLower command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/SetpointRaiseOrLower
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_setpoint_raise_or_lower_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_setpoint_raise_or_lower_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/SetpointRaiseOrLower";

  std::string payload =
    get_json_payload_for_thermostat_setpoint_raise_or_lower_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeeklyScheduleResponse command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetWeeklyScheduleResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_weekly_schedule_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetWeeklyScheduleResponse";

  std::string payload =
    get_json_payload_for_thermostat_get_weekly_schedule_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetWeeklySchedule command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/SetWeeklySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_set_weekly_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_set_weekly_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/SetWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_set_weekly_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRelayStatusLogResponse command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetRelayStatusLogResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_relay_status_log_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_relay_status_log_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetRelayStatusLogResponse";

  std::string payload =
    get_json_payload_for_thermostat_get_relay_status_log_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetWeeklySchedule command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetWeeklySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_weekly_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_get_weekly_schedule_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ClearWeeklySchedule command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/ClearWeeklySchedule
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_clear_weekly_schedule_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/ClearWeeklySchedule";

  std::string payload =
    get_json_payload_for_thermostat_clear_weekly_schedule_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetRelayStatusLog command for
 * the Thermostat cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Thermostat/GeneratedCommands/GetRelayStatusLog
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_thermostat_publish_generated_get_relay_status_log_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Thermostat/GeneratedCommands/GetRelayStatusLog";

  std::string payload =
    get_json_payload_for_thermostat_get_relay_status_log_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToHue";

  std::string payload =
    get_json_payload_for_color_control_move_to_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveHue";

  std::string payload =
    get_json_payload_for_color_control_move_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepHue";

  std::string payload =
    get_json_payload_for_color_control_step_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_to_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepSaturation";

  std::string payload =
    get_json_payload_for_color_control_step_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToHueAndSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToHueAndSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_hue_and_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_and_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToHueAndSaturation";

  std::string payload =
    get_json_payload_for_color_control_move_to_hue_and_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToColor command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToColor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_color_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToColor";

  std::string payload =
    get_json_payload_for_color_control_move_to_color_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveColor command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveColor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_color_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveColor";

  std::string payload =
    get_json_payload_for_color_control_move_color_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepColor command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepColor
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_color_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_color_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepColor";

  std::string payload =
    get_json_payload_for_color_control_step_color_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveToColorTemperature command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveToColorTemperature
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_to_color_temperature_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_to_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveToColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_move_to_color_temperature_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedMoveToHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedMoveToHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_move_to_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedMoveToHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_to_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedMoveHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedMoveHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_move_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedMoveHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedStepHue command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedStepHue
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_step_hue_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_step_hue_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedStepHue";

  std::string payload =
    get_json_payload_for_color_control_enhanced_step_hue_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated EnhancedMoveToHueAndSaturation command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/EnhancedMoveToHueAndSaturation
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_enhanced_move_to_hue_and_saturation_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_and_saturation_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/EnhancedMoveToHueAndSaturation";

  std::string payload =
    get_json_payload_for_color_control_enhanced_move_to_hue_and_saturation_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ColorLoopSet command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/ColorLoopSet
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_color_loop_set_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_color_loop_set_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/ColorLoopSet";

  std::string payload =
    get_json_payload_for_color_control_color_loop_set_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StopMoveStep command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StopMoveStep
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_stop_move_step_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_stop_move_step_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StopMoveStep";

  std::string payload =
    get_json_payload_for_color_control_stop_move_step_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated MoveColorTemperature command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/MoveColorTemperature
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_move_color_temperature_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_move_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/MoveColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_move_color_temperature_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StepColorTemperature command for
 * the ColorControl cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ColorControl/GeneratedCommands/StepColorTemperature
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_color_control_publish_generated_step_color_temperature_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_color_control_command_step_color_temperature_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ColorControl/GeneratedCommands/StepColorTemperature";

  std::string payload =
    get_json_payload_for_color_control_step_color_temperature_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ZoneEnrollResponse command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/ZoneEnrollResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_zone_enroll_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/ZoneEnrollResponse";

  std::string payload =
    get_json_payload_for_ias_zone_zone_enroll_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ZoneStatusChangeNotification command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/ZoneStatusChangeNotification
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_zone_status_change_notification_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_status_change_notification_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/ZoneStatusChangeNotification";

  std::string payload =
    get_json_payload_for_ias_zone_zone_status_change_notification_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated InitiateNormalOperationMode command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/InitiateNormalOperationMode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_initiate_normal_operation_mode_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/InitiateNormalOperationMode";

  std::string payload =
    get_json_payload_for_ias_zone_initiate_normal_operation_mode_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated ZoneEnrollRequest command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/ZoneEnrollRequest
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_zone_enroll_request_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_request_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/ZoneEnrollRequest";

  std::string payload =
    get_json_payload_for_ias_zone_zone_enroll_request_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated InitiateTestMode command for
 * the IASZone cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASZone/GeneratedCommands/InitiateTestMode
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_ias_zone_publish_generated_initiate_test_mode_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_ias_zone_command_initiate_test_mode_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASZone/GeneratedCommands/InitiateTestMode";

  std::string payload =
    get_json_payload_for_ias_zone_initiate_test_mode_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated StartWarning command for
 * the IASWD cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASWD/GeneratedCommands/StartWarning
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_iaswd_publish_generated_start_warning_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_iaswd_command_start_warning_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASWD/GeneratedCommands/StartWarning";

  std::string payload =
    get_json_payload_for_iaswd_start_warning_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Squawk command for
 * the IASWD cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/IASWD/GeneratedCommands/Squawk
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_iaswd_publish_generated_squawk_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_iaswd_command_squawk_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "IASWD/GeneratedCommands/Squawk";

  std::string payload =
    get_json_payload_for_iaswd_squawk_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetProfileInfoResponse command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetProfileInfoResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_profile_info_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_profile_info_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetProfileInfoResponse";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_profile_info_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetProfileInfo command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetProfileInfo
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_profile_info_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetProfileInfo";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_profile_info_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetMeasurementProfileResponse command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetMeasurementProfileResponse
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_measurement_profile_response_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_response_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetMeasurementProfileResponse";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_measurement_profile_response_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated GetMeasurementProfile command for
 * the ElectricalMeasurement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ElectricalMeasurement/GeneratedCommands/GetMeasurementProfile
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_electrical_measurement_publish_generated_get_measurement_profile_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_electrical_measurement_command_get_measurement_profile_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ElectricalMeasurement/GeneratedCommands/GetMeasurementProfile";

  std::string payload =
    get_json_payload_for_electrical_measurement_get_measurement_profile_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated TxReport command for
 * the ProtocolController-RFTelemetry cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/RFTelemetry/GeneratedCommands/TxReport
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_protocol_controller_rf_telemetry_publish_generated_tx_report_command(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_protocol_controller_rf_telemetry_command_tx_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ProtocolController/RFTelemetry/GeneratedCommands/TxReport";

  std::string payload =
    get_json_payload_for_protocol_controller_rf_telemetry_tx_report_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Remove command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/Remove
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_remove_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/Remove";

  std::string payload =
    get_json_payload_for_state_remove_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated RemoveOffline command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/RemoveOffline
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_remove_offline_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/RemoveOffline";

  std::string payload =
    get_json_payload_for_state_remove_offline_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DiscoverNeighbors command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/DiscoverNeighbors
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_discover_neighbors_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/DiscoverNeighbors";

  std::string payload =
    get_json_payload_for_state_discover_neighbors_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Interview command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/Interview
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_interview_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/Interview";

  std::string payload =
    get_json_payload_for_state_interview_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DiscoverSecurity command for
 * the State cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/State/GeneratedCommands/DiscoverSecurity
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_state_publish_generated_discover_security_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "State/GeneratedCommands/DiscoverSecurity";

  std::string payload =
    get_json_payload_for_state_discover_security_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Bind command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/Bind
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_bind_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_bind_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/Bind";

  std::string payload =
    get_json_payload_for_binding_bind_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Unbind command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/Unbind
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_unbind_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_unbind_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/Unbind";

  std::string payload =
    get_json_payload_for_binding_unbind_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated BindToProtocolController command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/BindToProtocolController
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_bind_to_protocol_controller_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_bind_to_protocol_controller_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/BindToProtocolController";

  std::string payload =
    get_json_payload_for_binding_bind_to_protocol_controller_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated UnbindFromProtocolController command for
 * the Binding cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/Binding/GeneratedCommands/UnbindFromProtocolController
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_binding_publish_generated_unbind_from_protocol_controller_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_binding_command_unbind_from_protocol_controller_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "Binding/GeneratedCommands/UnbindFromProtocolController";

  std::string payload =
    get_json_payload_for_binding_unbind_from_protocol_controller_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated LogEntry command for
 * the ApplicationMonitoring cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ApplicationMonitoring/GeneratedCommands/LogEntry
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_application_monitoring_publish_generated_log_entry_command(
  const dotdot_unid_t unid,
  const uic_mqtt_dotdot_application_monitoring_command_log_entry_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ApplicationMonitoring/GeneratedCommands/LogEntry";

  std::string payload =
    get_json_payload_for_application_monitoring_log_entry_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DiscoverParameter command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/DiscoverParameter
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_discover_parameter_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/DiscoverParameter";

  std::string payload =
    get_json_payload_for_configuration_parameters_discover_parameter_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DefaultResetAllParameters command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/DefaultResetAllParameters
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_default_reset_all_parameters_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/DefaultResetAllParameters";

  std::string payload =
    get_json_payload_for_configuration_parameters_default_reset_all_parameters_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated SetParameter command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/SetParameter
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_set_parameter_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_set_parameter_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/SetParameter";

  std::string payload =
    get_json_payload_for_configuration_parameters_set_parameter_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated DiscoverParameterRange command for
 * the ConfigurationParameters cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/ConfigurationParameters/GeneratedCommands/DiscoverParameterRange
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_configuration_parameters_publish_generated_discover_parameter_range_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_configuration_parameters_command_discover_parameter_range_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "ConfigurationParameters/GeneratedCommands/DiscoverParameterRange";

  std::string payload =
    get_json_payload_for_configuration_parameters_discover_parameter_range_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated IQReport command for
 * the AoXLocator cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/GeneratedCommands/IQReport
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_generated_iq_report_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_locator_command_iq_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXLocator/GeneratedCommands/IQReport";

  std::string payload =
    get_json_payload_for_aox_locator_iq_report_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AngleReport command for
 * the AoXLocator cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/GeneratedCommands/AngleReport
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_generated_angle_report_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_locator_command_angle_report_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXLocator/GeneratedCommands/AngleReport";

  std::string payload =
    get_json_payload_for_aox_locator_angle_report_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated AngleCorrection command for
 * the AoXLocator cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/epID/AoXLocator/GeneratedCommands/AngleCorrection
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * @param endpoint  The Endpoint ID of the node that sent us the command.
 * 
 * 
 * @param fields                Struct pointer with the fields value of the command
 * 
 */
void uic_mqtt_dotdot_aox_locator_publish_generated_angle_correction_command(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  const uic_mqtt_dotdot_aox_locator_command_angle_correction_fields_t *fields
  
) {
  // Create the topic
  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
                      std::to_string(endpoint) + "/";
  topic += "AoXLocator/GeneratedCommands/AngleCorrection";

  std::string payload =
    get_json_payload_for_aox_locator_angle_correction_command(
    fields);

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
/**
 * @brief Publishes an incoming/generated Write command for
 * the ProtocolController-NetworkManagement cluster.
 *
 * Publication will be made at the following topic
 * ucl/by-unid/UNID/ProtocolController/NetworkManagement/GeneratedCommands/Write
 *
 * @param unid      The UNID of the node that sent us the command.
 * 
 * 
 */
void uic_mqtt_dotdot_protocol_controller_network_management_publish_generated_write_command(
  const dotdot_unid_t unid
) {
  // Create the topic
  std::string topic = "ucl/by-unid/" + std::string(unid) + "/";
  topic += "ProtocolController/NetworkManagement/GeneratedCommands/Write";

  std::string payload =
    get_json_payload_for_protocol_controller_network_management_write_command(
    );

  // Publish our command
  uic_mqtt_publish(topic.c_str(),
                    payload.c_str(),
                    payload.size(),
                    false);
}
