/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

/**
 * @defgroup dotdot_attributes DotDot attributes mapper
 * @ingroup dotdot_mapper
 * @brief Maps DotDot attributes to Attribute Store
 *
 * This module contains functions to map from DotDot attributes to the
 * Attribute Store \ref attribute_store
 *
 * @{
 */
// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.
#ifndef DOTDOT_ATTRIBUTES_H
#define DOTDOT_ATTRIBUTES_H

#include <stdint.h>
#include <stdbool.h>

#include "sl_status.h"
#include "zap-types.h"
#include "zwave_controller_types.h"
#include "attribute_store.h"
#include "zwave_unid.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Basic
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Basic
#define DOTDOT_ATTRIBUTE_ID_BASIC_ZCL_VERSION ((attribute_store_type_t) 0xba5c0000)
///< This represents the ZCLVersion attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_APPLICATION_VERSION ((attribute_store_type_t) 0xba5c0001)
///< This represents the ApplicationVersion attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_STACK_VERSION ((attribute_store_type_t) 0xba5c0002)
///< This represents the StackVersion attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_HW_VERSION ((attribute_store_type_t) 0xba5c0003)
///< This represents the HWVersion attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_NAME ((attribute_store_type_t) 0xba5c0004)
///< This represents the ManufacturerName attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_MODEL_IDENTIFIER ((attribute_store_type_t) 0xba5c0005)
///< This represents the ModelIdentifier attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_DATE_CODE ((attribute_store_type_t) 0xba5c0006)
///< This represents the DateCode attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_POWER_SOURCE ((attribute_store_type_t) 0xba5c0007)
///< This represents the PowerSource attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_CLASS ((attribute_store_type_t) 0xba5c0008)
///< This represents the GenericDevice-Class attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_GENERIC_DEVICE_TYPE ((attribute_store_type_t) 0xba5c0009)
///< This represents the GenericDevice-Type attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_CODE ((attribute_store_type_t) 0xba5c000a)
///< This represents the ProductCode attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCTURL ((attribute_store_type_t) 0xba5c000b)
///< This represents the ProductURL attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_MANUFACTURER_VERSION_DETAILS ((attribute_store_type_t) 0xba5c000c)
///< This represents the ManufacturerVersionDetails attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_SERIAL_NUMBER ((attribute_store_type_t) 0xba5c000d)
///< This represents the SerialNumber attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_PRODUCT_LABEL ((attribute_store_type_t) 0xba5c000e)
///< This represents the ProductLabel attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_LOCATION_DESCRIPTION ((attribute_store_type_t) 0xba5c0010)
///< This represents the LocationDescription attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_PHYSICAL_ENVIRONMENT ((attribute_store_type_t) 0xba5c0011)
///< This represents the PhysicalEnvironment attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_DEVICE_ENABLED ((attribute_store_type_t) 0xba5c0012)
///< This represents the DeviceEnabled attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_ALARM_MASK ((attribute_store_type_t) 0xba5c0013)
///< This represents the AlarmMask attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_DISABLE_LOCAL_CONFIG ((attribute_store_type_t) 0xba5c0014)
///< This represents the DisableLocalConfig attribute in the DotDot Basic cluster

#define DOTDOT_ATTRIBUTE_ID_BASIC_SW_BUILDID ((attribute_store_type_t) 0xba5c4000)
///< This represents the SWBuildID attribute in the DotDot Basic cluster

// Basic ZCLVersion
/**
 * @brief Verifies if the DotDot Basic ZCLVersion is supported
 *
 * @returns true if ZCLVersion is supported
 * @returns false if ZCLVersion is not supported
 */
bool dotdot_is_supported_basic_zcl_version (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ZCLVersion attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ZCLVersion attribute
 */
uint8_t dotdot_get_basic_zcl_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ZCLVersion attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_zcl_version new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_zcl_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_zcl_version);

// Basic ApplicationVersion
/**
 * @brief Verifies if the DotDot Basic ApplicationVersion is supported
 *
 * @returns true if ApplicationVersion is supported
 * @returns false if ApplicationVersion is not supported
 */
bool dotdot_is_supported_basic_application_version (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationVersion attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationVersion attribute
 */
uint8_t dotdot_get_basic_application_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationVersion attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_application_version new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_application_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_application_version);

// Basic StackVersion
/**
 * @brief Verifies if the DotDot Basic StackVersion is supported
 *
 * @returns true if StackVersion is supported
 * @returns false if StackVersion is not supported
 */
bool dotdot_is_supported_basic_stack_version (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot StackVersion attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns StackVersion attribute
 */
uint8_t dotdot_get_basic_stack_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot StackVersion attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_stack_version new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_stack_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_stack_version);

// Basic HWVersion
/**
 * @brief Verifies if the DotDot Basic HWVersion is supported
 *
 * @returns true if HWVersion is supported
 * @returns false if HWVersion is not supported
 */
bool dotdot_is_supported_basic_hw_version (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot HWVersion attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns HWVersion attribute
 */
uint8_t dotdot_get_basic_hw_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot HWVersion attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_hw_version new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_hw_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_hw_version);

// Basic ManufacturerName
/**
 * @brief Verifies if the DotDot Basic ManufacturerName is supported
 *
 * @returns true if ManufacturerName is supported
 * @returns false if ManufacturerName is not supported
 */
bool dotdot_is_supported_basic_manufacturer_name (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ManufacturerName attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ManufacturerName attribute
 */
const char* dotdot_get_basic_manufacturer_name(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ManufacturerName attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_manufacturer_name new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_manufacturer_name(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_manufacturer_name);

// Basic ModelIdentifier
/**
 * @brief Verifies if the DotDot Basic ModelIdentifier is supported
 *
 * @returns true if ModelIdentifier is supported
 * @returns false if ModelIdentifier is not supported
 */
bool dotdot_is_supported_basic_model_identifier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ModelIdentifier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ModelIdentifier attribute
 */
const char* dotdot_get_basic_model_identifier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ModelIdentifier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_model_identifier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_model_identifier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_model_identifier);

// Basic DateCode
/**
 * @brief Verifies if the DotDot Basic DateCode is supported
 *
 * @returns true if DateCode is supported
 * @returns false if DateCode is not supported
 */
bool dotdot_is_supported_basic_date_code (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DateCode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DateCode attribute
 */
const char* dotdot_get_basic_date_code(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DateCode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_date_code new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_date_code(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_date_code);

// Basic PowerSource
/**
 * @brief Verifies if the DotDot Basic PowerSource is supported
 *
 * @returns true if PowerSource is supported
 * @returns false if PowerSource is not supported
 */
bool dotdot_is_supported_basic_power_source (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PowerSource attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PowerSource attribute
 */
uint8_t dotdot_get_basic_power_source(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PowerSource attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power_source new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_power_source(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_power_source);

// Basic GenericDevice-Class
/**
 * @brief Verifies if the DotDot Basic GenericDevice-Class is supported
 *
 * @returns true if GenericDevice-Class is supported
 * @returns false if GenericDevice-Class is not supported
 */
bool dotdot_is_supported_basic_generic_device_class (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot GenericDevice-Class attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns GenericDevice-Class attribute
 */
uint8_t dotdot_get_basic_generic_device_class(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot GenericDevice-Class attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_generic_device_class new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_generic_device_class(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_generic_device_class);

// Basic GenericDevice-Type
/**
 * @brief Verifies if the DotDot Basic GenericDevice-Type is supported
 *
 * @returns true if GenericDevice-Type is supported
 * @returns false if GenericDevice-Type is not supported
 */
bool dotdot_is_supported_basic_generic_device_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot GenericDevice-Type attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns GenericDevice-Type attribute
 */
uint8_t dotdot_get_basic_generic_device_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot GenericDevice-Type attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_generic_device_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_generic_device_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_generic_device_type);

// Basic ProductCode
/**
 * @brief Verifies if the DotDot Basic ProductCode is supported
 *
 * @returns true if ProductCode is supported
 * @returns false if ProductCode is not supported
 */
bool dotdot_is_supported_basic_product_code (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ProductCode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ProductCode attribute
 */
const char* dotdot_get_basic_product_code(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ProductCode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_product_code new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_product_code(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_product_code);

// Basic ProductURL
/**
 * @brief Verifies if the DotDot Basic ProductURL is supported
 *
 * @returns true if ProductURL is supported
 * @returns false if ProductURL is not supported
 */
bool dotdot_is_supported_basic_producturl (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ProductURL attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ProductURL attribute
 */
const char* dotdot_get_basic_producturl(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ProductURL attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_producturl new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_producturl(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_producturl);

// Basic ManufacturerVersionDetails
/**
 * @brief Verifies if the DotDot Basic ManufacturerVersionDetails is supported
 *
 * @returns true if ManufacturerVersionDetails is supported
 * @returns false if ManufacturerVersionDetails is not supported
 */
bool dotdot_is_supported_basic_manufacturer_version_details (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ManufacturerVersionDetails attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ManufacturerVersionDetails attribute
 */
const char* dotdot_get_basic_manufacturer_version_details(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ManufacturerVersionDetails attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_manufacturer_version_details new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_manufacturer_version_details(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_manufacturer_version_details);

// Basic SerialNumber
/**
 * @brief Verifies if the DotDot Basic SerialNumber is supported
 *
 * @returns true if SerialNumber is supported
 * @returns false if SerialNumber is not supported
 */
bool dotdot_is_supported_basic_serial_number (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SerialNumber attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SerialNumber attribute
 */
const char* dotdot_get_basic_serial_number(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SerialNumber attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_serial_number new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_serial_number(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_serial_number);

// Basic ProductLabel
/**
 * @brief Verifies if the DotDot Basic ProductLabel is supported
 *
 * @returns true if ProductLabel is supported
 * @returns false if ProductLabel is not supported
 */
bool dotdot_is_supported_basic_product_label (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ProductLabel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ProductLabel attribute
 */
const char* dotdot_get_basic_product_label(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ProductLabel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_product_label new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_product_label(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_product_label);

// Basic LocationDescription
/**
 * @brief Verifies if the DotDot Basic LocationDescription is supported
 *
 * @returns true if LocationDescription is supported
 * @returns false if LocationDescription is not supported
 */
bool dotdot_is_supported_basic_location_description (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LocationDescription attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LocationDescription attribute
 */
const char* dotdot_get_basic_location_description(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LocationDescription attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_location_description new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_location_description(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_location_description);

// Basic PhysicalEnvironment
/**
 * @brief Verifies if the DotDot Basic PhysicalEnvironment is supported
 *
 * @returns true if PhysicalEnvironment is supported
 * @returns false if PhysicalEnvironment is not supported
 */
bool dotdot_is_supported_basic_physical_environment (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PhysicalEnvironment attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PhysicalEnvironment attribute
 */
uint8_t dotdot_get_basic_physical_environment(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PhysicalEnvironment attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_physical_environment new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_physical_environment(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_physical_environment);

// Basic DeviceEnabled
/**
 * @brief Verifies if the DotDot Basic DeviceEnabled is supported
 *
 * @returns true if DeviceEnabled is supported
 * @returns false if DeviceEnabled is not supported
 */
bool dotdot_is_supported_basic_device_enabled (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DeviceEnabled attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DeviceEnabled attribute
 */
bool dotdot_get_basic_device_enabled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DeviceEnabled attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_device_enabled new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_device_enabled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_device_enabled);

// Basic AlarmMask
/**
 * @brief Verifies if the DotDot Basic AlarmMask is supported
 *
 * @returns true if AlarmMask is supported
 * @returns false if AlarmMask is not supported
 */
bool dotdot_is_supported_basic_alarm_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AlarmMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AlarmMask attribute
 */
uint8_t dotdot_get_basic_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AlarmMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_alarm_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_alarm_mask);

// Basic DisableLocalConfig
/**
 * @brief Verifies if the DotDot Basic DisableLocalConfig is supported
 *
 * @returns true if DisableLocalConfig is supported
 * @returns false if DisableLocalConfig is not supported
 */
bool dotdot_is_supported_basic_disable_local_config (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DisableLocalConfig attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DisableLocalConfig attribute
 */
uint8_t dotdot_get_basic_disable_local_config(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DisableLocalConfig attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_disable_local_config new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_disable_local_config(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_disable_local_config);

// Basic SWBuildID
/**
 * @brief Verifies if the DotDot Basic SWBuildID is supported
 *
 * @returns true if SWBuildID is supported
 * @returns false if SWBuildID is not supported
 */
bool dotdot_is_supported_basic_sw_buildid (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SWBuildID attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SWBuildID attribute
 */
const char* dotdot_get_basic_sw_buildid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SWBuildID attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_sw_buildid new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_basic_sw_buildid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_sw_buildid);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster PowerConfiguration
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for PowerConfiguration
#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE ((attribute_store_type_t) 0x00010000)
///< This represents the MainsVoltage attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_FREQUENCY ((attribute_store_type_t) 0x00010001)
///< This represents the MainsFrequency attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_ALARM_MASK ((attribute_store_type_t) 0x00010010)
///< This represents the MainsAlarmMask attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MIN_THRESHOLD ((attribute_store_type_t) 0x00010011)
///< This represents the MainsVoltageMinThreshold attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_MAX_THRESHOLD ((attribute_store_type_t) 0x00010012)
///< This represents the MainsVoltageMaxThreshold attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_MAINS_VOLTAGE_DWELL_TRIP_POINT ((attribute_store_type_t) 0x00010013)
///< This represents the MainsVoltageDwellTripPoint attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE ((attribute_store_type_t) 0x00010020)
///< This represents the BatteryVoltage attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_REMAINING ((attribute_store_type_t) 0x00010021)
///< This represents the BatteryPercentageRemaining attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_MANUFACTURER ((attribute_store_type_t) 0x00010030)
///< This represents the BatteryManufacturer attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_SIZE ((attribute_store_type_t) 0x00010031)
///< This represents the BatterySize attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERYA_HR_RATING ((attribute_store_type_t) 0x00010032)
///< This represents the BatteryAHrRating attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_QUANTITY ((attribute_store_type_t) 0x00010033)
///< This represents the BatteryQuantity attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_RATED_VOLTAGE ((attribute_store_type_t) 0x00010034)
///< This represents the BatteryRatedVoltage attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_MASK ((attribute_store_type_t) 0x00010035)
///< This represents the BatteryAlarmMask attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_MIN_THRESHOLD ((attribute_store_type_t) 0x00010036)
///< This represents the BatteryVoltageMinThreshold attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD1 ((attribute_store_type_t) 0x00010037)
///< This represents the BatteryVoltageThreshold1 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD2 ((attribute_store_type_t) 0x00010038)
///< This represents the BatteryVoltageThreshold2 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_VOLTAGE_THRESHOLD3 ((attribute_store_type_t) 0x00010039)
///< This represents the BatteryVoltageThreshold3 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_MIN_THRESHOLD ((attribute_store_type_t) 0x0001003a)
///< This represents the BatteryPercentageMinThreshold attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD1 ((attribute_store_type_t) 0x0001003b)
///< This represents the BatteryPercentageThreshold1 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD2 ((attribute_store_type_t) 0x0001003c)
///< This represents the BatteryPercentageThreshold2 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_PERCENTAGE_THRESHOLD3 ((attribute_store_type_t) 0x0001003d)
///< This represents the BatteryPercentageThreshold3 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY_ALARM_STATE ((attribute_store_type_t) 0x0001003e)
///< This represents the BatteryAlarmState attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE ((attribute_store_type_t) 0x00010040)
///< This represents the Battery2Voltage attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_REMAINING ((attribute_store_type_t) 0x00010041)
///< This represents the Battery2PercentageRemaining attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_MANUFACTURER ((attribute_store_type_t) 0x00010050)
///< This represents the Battery2Manufacturer attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_SIZE ((attribute_store_type_t) 0x00010051)
///< This represents the Battery2Size attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2A_HR_RATING ((attribute_store_type_t) 0x00010052)
///< This represents the Battery2AHrRating attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_QUANTITY ((attribute_store_type_t) 0x00010053)
///< This represents the Battery2Quantity attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_RATED_VOLTAGE ((attribute_store_type_t) 0x00010054)
///< This represents the Battery2RatedVoltage attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_MASK ((attribute_store_type_t) 0x00010055)
///< This represents the Battery2AlarmMask attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_MIN_THRESHOLD ((attribute_store_type_t) 0x00010056)
///< This represents the Battery2VoltageMinThreshold attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD1 ((attribute_store_type_t) 0x00010057)
///< This represents the Battery2VoltageThreshold1 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD2 ((attribute_store_type_t) 0x00010058)
///< This represents the Battery2VoltageThreshold2 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_VOLTAGE_THRESHOLD3 ((attribute_store_type_t) 0x00010059)
///< This represents the Battery2VoltageThreshold3 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_MIN_THRESHOLD ((attribute_store_type_t) 0x0001005a)
///< This represents the Battery2PercentageMinThreshold attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD1 ((attribute_store_type_t) 0x0001005b)
///< This represents the Battery2PercentageThreshold1 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD2 ((attribute_store_type_t) 0x0001005c)
///< This represents the Battery2PercentageThreshold2 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_PERCENTAGE_THRESHOLD3 ((attribute_store_type_t) 0x0001005d)
///< This represents the Battery2PercentageThreshold3 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY2_ALARM_STATE ((attribute_store_type_t) 0x0001005e)
///< This represents the Battery2AlarmState attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE ((attribute_store_type_t) 0x00010060)
///< This represents the Battery3Voltage attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_REMAINING ((attribute_store_type_t) 0x00010061)
///< This represents the Battery3PercentageRemaining attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_MANUFACTURER ((attribute_store_type_t) 0x00010070)
///< This represents the Battery3Manufacturer attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_SIZE ((attribute_store_type_t) 0x00010071)
///< This represents the Battery3Size attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3A_HR_RATING ((attribute_store_type_t) 0x00010072)
///< This represents the Battery3AHrRating attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_QUANTITY ((attribute_store_type_t) 0x00010073)
///< This represents the Battery3Quantity attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_RATED_VOLTAGE ((attribute_store_type_t) 0x00010074)
///< This represents the Battery3RatedVoltage attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_MASK ((attribute_store_type_t) 0x00010075)
///< This represents the Battery3AlarmMask attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_MIN_THRESHOLD ((attribute_store_type_t) 0x00010076)
///< This represents the Battery3VoltageMinThreshold attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD1 ((attribute_store_type_t) 0x00010077)
///< This represents the Battery3VoltageThreshold1 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD2 ((attribute_store_type_t) 0x00010078)
///< This represents the Battery3VoltageThreshold2 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_VOLTAGE_THRESHOLD3 ((attribute_store_type_t) 0x00010079)
///< This represents the Battery3VoltageThreshold3 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_MIN_THRESHOLD ((attribute_store_type_t) 0x0001007a)
///< This represents the Battery3PercentageMinThreshold attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD1 ((attribute_store_type_t) 0x0001007b)
///< This represents the Battery3PercentageThreshold1 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD2 ((attribute_store_type_t) 0x0001007c)
///< This represents the Battery3PercentageThreshold2 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_PERCENTAGE_THRESHOLD3 ((attribute_store_type_t) 0x0001007d)
///< This represents the Battery3PercentageThreshold3 attribute in the DotDot PowerConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_POWER_CONFIGURATION_BATTERY3_ALARM_STATE ((attribute_store_type_t) 0x0001007e)
///< This represents the Battery3AlarmState attribute in the DotDot PowerConfiguration cluster

// PowerConfiguration MainsVoltage
/**
 * @brief Verifies if the DotDot PowerConfiguration MainsVoltage is supported
 *
 * @returns true if MainsVoltage is supported
 * @returns false if MainsVoltage is not supported
 */
bool dotdot_is_supported_power_configuration_mains_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MainsVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MainsVoltage attribute
 */
uint16_t dotdot_get_power_configuration_mains_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MainsVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mains_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_mains_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_mains_voltage);

// PowerConfiguration MainsFrequency
/**
 * @brief Verifies if the DotDot PowerConfiguration MainsFrequency is supported
 *
 * @returns true if MainsFrequency is supported
 * @returns false if MainsFrequency is not supported
 */
bool dotdot_is_supported_power_configuration_mains_frequency (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MainsFrequency attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MainsFrequency attribute
 */
uint8_t dotdot_get_power_configuration_mains_frequency(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MainsFrequency attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mains_frequency new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_mains_frequency(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_mains_frequency);

// PowerConfiguration MainsAlarmMask
/**
 * @brief Verifies if the DotDot PowerConfiguration MainsAlarmMask is supported
 *
 * @returns true if MainsAlarmMask is supported
 * @returns false if MainsAlarmMask is not supported
 */
bool dotdot_is_supported_power_configuration_mains_alarm_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MainsAlarmMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MainsAlarmMask attribute
 */
uint8_t dotdot_get_power_configuration_mains_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MainsAlarmMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mains_alarm_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_mains_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_mains_alarm_mask);

// PowerConfiguration MainsVoltageMinThreshold
/**
 * @brief Verifies if the DotDot PowerConfiguration MainsVoltageMinThreshold is supported
 *
 * @returns true if MainsVoltageMinThreshold is supported
 * @returns false if MainsVoltageMinThreshold is not supported
 */
bool dotdot_is_supported_power_configuration_mains_voltage_min_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MainsVoltageMinThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MainsVoltageMinThreshold attribute
 */
uint16_t dotdot_get_power_configuration_mains_voltage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MainsVoltageMinThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mains_voltage_min_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_mains_voltage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_mains_voltage_min_threshold);

// PowerConfiguration MainsVoltageMaxThreshold
/**
 * @brief Verifies if the DotDot PowerConfiguration MainsVoltageMaxThreshold is supported
 *
 * @returns true if MainsVoltageMaxThreshold is supported
 * @returns false if MainsVoltageMaxThreshold is not supported
 */
bool dotdot_is_supported_power_configuration_mains_voltage_max_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MainsVoltageMaxThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MainsVoltageMaxThreshold attribute
 */
uint16_t dotdot_get_power_configuration_mains_voltage_max_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MainsVoltageMaxThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mains_voltage_max_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_mains_voltage_max_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_mains_voltage_max_threshold);

// PowerConfiguration MainsVoltageDwellTripPoint
/**
 * @brief Verifies if the DotDot PowerConfiguration MainsVoltageDwellTripPoint is supported
 *
 * @returns true if MainsVoltageDwellTripPoint is supported
 * @returns false if MainsVoltageDwellTripPoint is not supported
 */
bool dotdot_is_supported_power_configuration_mains_voltage_dwell_trip_point (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MainsVoltageDwellTripPoint attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MainsVoltageDwellTripPoint attribute
 */
uint16_t dotdot_get_power_configuration_mains_voltage_dwell_trip_point(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MainsVoltageDwellTripPoint attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mains_voltage_dwell_trip_point new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_mains_voltage_dwell_trip_point(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_mains_voltage_dwell_trip_point);

// PowerConfiguration BatteryVoltage
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryVoltage is supported
 *
 * @returns true if BatteryVoltage is supported
 * @returns false if BatteryVoltage is not supported
 */
bool dotdot_is_supported_power_configuration_battery_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryVoltage attribute
 */
uint8_t dotdot_get_power_configuration_battery_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_voltage);

// PowerConfiguration BatteryPercentageRemaining
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryPercentageRemaining is supported
 *
 * @returns true if BatteryPercentageRemaining is supported
 * @returns false if BatteryPercentageRemaining is not supported
 */
bool dotdot_is_supported_power_configuration_battery_percentage_remaining (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryPercentageRemaining attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryPercentageRemaining attribute
 */
uint8_t dotdot_get_power_configuration_battery_percentage_remaining(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryPercentageRemaining attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_percentage_remaining new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_percentage_remaining(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_percentage_remaining);

// PowerConfiguration BatteryManufacturer
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryManufacturer is supported
 *
 * @returns true if BatteryManufacturer is supported
 * @returns false if BatteryManufacturer is not supported
 */
bool dotdot_is_supported_power_configuration_battery_manufacturer (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryManufacturer attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryManufacturer attribute
 */
const char* dotdot_get_power_configuration_battery_manufacturer(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryManufacturer attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_manufacturer new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_manufacturer(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_battery_manufacturer);

// PowerConfiguration BatterySize
/**
 * @brief Verifies if the DotDot PowerConfiguration BatterySize is supported
 *
 * @returns true if BatterySize is supported
 * @returns false if BatterySize is not supported
 */
bool dotdot_is_supported_power_configuration_battery_size (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatterySize attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatterySize attribute
 */
BatterySize dotdot_get_power_configuration_battery_size(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatterySize attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_size new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_size(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  BatterySize new_battery_size);

// PowerConfiguration BatteryAHrRating
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryAHrRating is supported
 *
 * @returns true if BatteryAHrRating is supported
 * @returns false if BatteryAHrRating is not supported
 */
bool dotdot_is_supported_power_configuration_batterya_hr_rating (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryAHrRating attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryAHrRating attribute
 */
uint16_t dotdot_get_power_configuration_batterya_hr_rating(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryAHrRating attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_batterya_hr_rating new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_batterya_hr_rating(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_batterya_hr_rating);

// PowerConfiguration BatteryQuantity
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryQuantity is supported
 *
 * @returns true if BatteryQuantity is supported
 * @returns false if BatteryQuantity is not supported
 */
bool dotdot_is_supported_power_configuration_battery_quantity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryQuantity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryQuantity attribute
 */
uint8_t dotdot_get_power_configuration_battery_quantity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryQuantity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_quantity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_quantity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_quantity);

// PowerConfiguration BatteryRatedVoltage
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryRatedVoltage is supported
 *
 * @returns true if BatteryRatedVoltage is supported
 * @returns false if BatteryRatedVoltage is not supported
 */
bool dotdot_is_supported_power_configuration_battery_rated_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryRatedVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryRatedVoltage attribute
 */
uint8_t dotdot_get_power_configuration_battery_rated_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryRatedVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_rated_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_rated_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_rated_voltage);

// PowerConfiguration BatteryAlarmMask
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryAlarmMask is supported
 *
 * @returns true if BatteryAlarmMask is supported
 * @returns false if BatteryAlarmMask is not supported
 */
bool dotdot_is_supported_power_configuration_battery_alarm_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryAlarmMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryAlarmMask attribute
 */
uint8_t dotdot_get_power_configuration_battery_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryAlarmMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_alarm_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_alarm_mask);

// PowerConfiguration BatteryVoltageMinThreshold
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryVoltageMinThreshold is supported
 *
 * @returns true if BatteryVoltageMinThreshold is supported
 * @returns false if BatteryVoltageMinThreshold is not supported
 */
bool dotdot_is_supported_power_configuration_battery_voltage_min_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryVoltageMinThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryVoltageMinThreshold attribute
 */
uint8_t dotdot_get_power_configuration_battery_voltage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryVoltageMinThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_voltage_min_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_voltage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_voltage_min_threshold);

// PowerConfiguration BatteryVoltageThreshold1
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryVoltageThreshold1 is supported
 *
 * @returns true if BatteryVoltageThreshold1 is supported
 * @returns false if BatteryVoltageThreshold1 is not supported
 */
bool dotdot_is_supported_power_configuration_battery_voltage_threshold1 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryVoltageThreshold1 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryVoltageThreshold1 attribute
 */
uint8_t dotdot_get_power_configuration_battery_voltage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryVoltageThreshold1 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_voltage_threshold1 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_voltage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_voltage_threshold1);

// PowerConfiguration BatteryVoltageThreshold2
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryVoltageThreshold2 is supported
 *
 * @returns true if BatteryVoltageThreshold2 is supported
 * @returns false if BatteryVoltageThreshold2 is not supported
 */
bool dotdot_is_supported_power_configuration_battery_voltage_threshold2 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryVoltageThreshold2 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryVoltageThreshold2 attribute
 */
uint8_t dotdot_get_power_configuration_battery_voltage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryVoltageThreshold2 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_voltage_threshold2 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_voltage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_voltage_threshold2);

// PowerConfiguration BatteryVoltageThreshold3
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryVoltageThreshold3 is supported
 *
 * @returns true if BatteryVoltageThreshold3 is supported
 * @returns false if BatteryVoltageThreshold3 is not supported
 */
bool dotdot_is_supported_power_configuration_battery_voltage_threshold3 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryVoltageThreshold3 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryVoltageThreshold3 attribute
 */
uint8_t dotdot_get_power_configuration_battery_voltage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryVoltageThreshold3 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_voltage_threshold3 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_voltage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_voltage_threshold3);

// PowerConfiguration BatteryPercentageMinThreshold
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryPercentageMinThreshold is supported
 *
 * @returns true if BatteryPercentageMinThreshold is supported
 * @returns false if BatteryPercentageMinThreshold is not supported
 */
bool dotdot_is_supported_power_configuration_battery_percentage_min_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryPercentageMinThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryPercentageMinThreshold attribute
 */
uint8_t dotdot_get_power_configuration_battery_percentage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryPercentageMinThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_percentage_min_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_percentage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_percentage_min_threshold);

// PowerConfiguration BatteryPercentageThreshold1
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryPercentageThreshold1 is supported
 *
 * @returns true if BatteryPercentageThreshold1 is supported
 * @returns false if BatteryPercentageThreshold1 is not supported
 */
bool dotdot_is_supported_power_configuration_battery_percentage_threshold1 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryPercentageThreshold1 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryPercentageThreshold1 attribute
 */
uint8_t dotdot_get_power_configuration_battery_percentage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryPercentageThreshold1 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_percentage_threshold1 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_percentage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_percentage_threshold1);

// PowerConfiguration BatteryPercentageThreshold2
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryPercentageThreshold2 is supported
 *
 * @returns true if BatteryPercentageThreshold2 is supported
 * @returns false if BatteryPercentageThreshold2 is not supported
 */
bool dotdot_is_supported_power_configuration_battery_percentage_threshold2 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryPercentageThreshold2 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryPercentageThreshold2 attribute
 */
uint8_t dotdot_get_power_configuration_battery_percentage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryPercentageThreshold2 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_percentage_threshold2 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_percentage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_percentage_threshold2);

// PowerConfiguration BatteryPercentageThreshold3
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryPercentageThreshold3 is supported
 *
 * @returns true if BatteryPercentageThreshold3 is supported
 * @returns false if BatteryPercentageThreshold3 is not supported
 */
bool dotdot_is_supported_power_configuration_battery_percentage_threshold3 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryPercentageThreshold3 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryPercentageThreshold3 attribute
 */
uint8_t dotdot_get_power_configuration_battery_percentage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryPercentageThreshold3 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_percentage_threshold3 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_percentage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery_percentage_threshold3);

// PowerConfiguration BatteryAlarmState
/**
 * @brief Verifies if the DotDot PowerConfiguration BatteryAlarmState is supported
 *
 * @returns true if BatteryAlarmState is supported
 * @returns false if BatteryAlarmState is not supported
 */
bool dotdot_is_supported_power_configuration_battery_alarm_state (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryAlarmState attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryAlarmState attribute
 */
uint32_t dotdot_get_power_configuration_battery_alarm_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryAlarmState attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_alarm_state new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery_alarm_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_battery_alarm_state);

// PowerConfiguration Battery2Voltage
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2Voltage is supported
 *
 * @returns true if Battery2Voltage is supported
 * @returns false if Battery2Voltage is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2Voltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2Voltage attribute
 */
uint8_t dotdot_get_power_configuration_battery2_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2Voltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_voltage);

// PowerConfiguration Battery2PercentageRemaining
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2PercentageRemaining is supported
 *
 * @returns true if Battery2PercentageRemaining is supported
 * @returns false if Battery2PercentageRemaining is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_percentage_remaining (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2PercentageRemaining attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2PercentageRemaining attribute
 */
uint8_t dotdot_get_power_configuration_battery2_percentage_remaining(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2PercentageRemaining attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_percentage_remaining new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_percentage_remaining(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_percentage_remaining);

// PowerConfiguration Battery2Manufacturer
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2Manufacturer is supported
 *
 * @returns true if Battery2Manufacturer is supported
 * @returns false if Battery2Manufacturer is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_manufacturer (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2Manufacturer attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2Manufacturer attribute
 */
const char* dotdot_get_power_configuration_battery2_manufacturer(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2Manufacturer attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_manufacturer new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_manufacturer(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_battery2_manufacturer);

// PowerConfiguration Battery2Size
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2Size is supported
 *
 * @returns true if Battery2Size is supported
 * @returns false if Battery2Size is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_size (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2Size attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2Size attribute
 */
BatterySize dotdot_get_power_configuration_battery2_size(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2Size attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_size new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_size(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  BatterySize new_battery2_size);

// PowerConfiguration Battery2AHrRating
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2AHrRating is supported
 *
 * @returns true if Battery2AHrRating is supported
 * @returns false if Battery2AHrRating is not supported
 */
bool dotdot_is_supported_power_configuration_battery2a_hr_rating (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2AHrRating attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2AHrRating attribute
 */
uint16_t dotdot_get_power_configuration_battery2a_hr_rating(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2AHrRating attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2a_hr_rating new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2a_hr_rating(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_battery2a_hr_rating);

// PowerConfiguration Battery2Quantity
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2Quantity is supported
 *
 * @returns true if Battery2Quantity is supported
 * @returns false if Battery2Quantity is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_quantity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2Quantity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2Quantity attribute
 */
uint8_t dotdot_get_power_configuration_battery2_quantity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2Quantity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_quantity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_quantity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_quantity);

// PowerConfiguration Battery2RatedVoltage
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2RatedVoltage is supported
 *
 * @returns true if Battery2RatedVoltage is supported
 * @returns false if Battery2RatedVoltage is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_rated_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2RatedVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2RatedVoltage attribute
 */
uint8_t dotdot_get_power_configuration_battery2_rated_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2RatedVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_rated_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_rated_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_rated_voltage);

// PowerConfiguration Battery2AlarmMask
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2AlarmMask is supported
 *
 * @returns true if Battery2AlarmMask is supported
 * @returns false if Battery2AlarmMask is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_alarm_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2AlarmMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2AlarmMask attribute
 */
uint8_t dotdot_get_power_configuration_battery2_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2AlarmMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_alarm_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_alarm_mask);

// PowerConfiguration Battery2VoltageMinThreshold
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2VoltageMinThreshold is supported
 *
 * @returns true if Battery2VoltageMinThreshold is supported
 * @returns false if Battery2VoltageMinThreshold is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_voltage_min_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2VoltageMinThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2VoltageMinThreshold attribute
 */
uint8_t dotdot_get_power_configuration_battery2_voltage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2VoltageMinThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_voltage_min_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_voltage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_voltage_min_threshold);

// PowerConfiguration Battery2VoltageThreshold1
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2VoltageThreshold1 is supported
 *
 * @returns true if Battery2VoltageThreshold1 is supported
 * @returns false if Battery2VoltageThreshold1 is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_voltage_threshold1 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2VoltageThreshold1 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2VoltageThreshold1 attribute
 */
uint8_t dotdot_get_power_configuration_battery2_voltage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2VoltageThreshold1 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_voltage_threshold1 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_voltage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_voltage_threshold1);

// PowerConfiguration Battery2VoltageThreshold2
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2VoltageThreshold2 is supported
 *
 * @returns true if Battery2VoltageThreshold2 is supported
 * @returns false if Battery2VoltageThreshold2 is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_voltage_threshold2 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2VoltageThreshold2 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2VoltageThreshold2 attribute
 */
uint8_t dotdot_get_power_configuration_battery2_voltage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2VoltageThreshold2 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_voltage_threshold2 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_voltage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_voltage_threshold2);

// PowerConfiguration Battery2VoltageThreshold3
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2VoltageThreshold3 is supported
 *
 * @returns true if Battery2VoltageThreshold3 is supported
 * @returns false if Battery2VoltageThreshold3 is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_voltage_threshold3 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2VoltageThreshold3 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2VoltageThreshold3 attribute
 */
uint8_t dotdot_get_power_configuration_battery2_voltage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2VoltageThreshold3 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_voltage_threshold3 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_voltage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_voltage_threshold3);

// PowerConfiguration Battery2PercentageMinThreshold
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2PercentageMinThreshold is supported
 *
 * @returns true if Battery2PercentageMinThreshold is supported
 * @returns false if Battery2PercentageMinThreshold is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_percentage_min_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2PercentageMinThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2PercentageMinThreshold attribute
 */
uint8_t dotdot_get_power_configuration_battery2_percentage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2PercentageMinThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_percentage_min_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_percentage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_percentage_min_threshold);

// PowerConfiguration Battery2PercentageThreshold1
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2PercentageThreshold1 is supported
 *
 * @returns true if Battery2PercentageThreshold1 is supported
 * @returns false if Battery2PercentageThreshold1 is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_percentage_threshold1 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2PercentageThreshold1 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2PercentageThreshold1 attribute
 */
uint8_t dotdot_get_power_configuration_battery2_percentage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2PercentageThreshold1 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_percentage_threshold1 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_percentage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_percentage_threshold1);

// PowerConfiguration Battery2PercentageThreshold2
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2PercentageThreshold2 is supported
 *
 * @returns true if Battery2PercentageThreshold2 is supported
 * @returns false if Battery2PercentageThreshold2 is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_percentage_threshold2 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2PercentageThreshold2 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2PercentageThreshold2 attribute
 */
uint8_t dotdot_get_power_configuration_battery2_percentage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2PercentageThreshold2 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_percentage_threshold2 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_percentage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_percentage_threshold2);

// PowerConfiguration Battery2PercentageThreshold3
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2PercentageThreshold3 is supported
 *
 * @returns true if Battery2PercentageThreshold3 is supported
 * @returns false if Battery2PercentageThreshold3 is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_percentage_threshold3 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2PercentageThreshold3 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2PercentageThreshold3 attribute
 */
uint8_t dotdot_get_power_configuration_battery2_percentage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2PercentageThreshold3 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_percentage_threshold3 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_percentage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery2_percentage_threshold3);

// PowerConfiguration Battery2AlarmState
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery2AlarmState is supported
 *
 * @returns true if Battery2AlarmState is supported
 * @returns false if Battery2AlarmState is not supported
 */
bool dotdot_is_supported_power_configuration_battery2_alarm_state (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery2AlarmState attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery2AlarmState attribute
 */
uint32_t dotdot_get_power_configuration_battery2_alarm_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery2AlarmState attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery2_alarm_state new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery2_alarm_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_battery2_alarm_state);

// PowerConfiguration Battery3Voltage
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3Voltage is supported
 *
 * @returns true if Battery3Voltage is supported
 * @returns false if Battery3Voltage is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3Voltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3Voltage attribute
 */
uint8_t dotdot_get_power_configuration_battery3_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3Voltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_voltage);

// PowerConfiguration Battery3PercentageRemaining
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3PercentageRemaining is supported
 *
 * @returns true if Battery3PercentageRemaining is supported
 * @returns false if Battery3PercentageRemaining is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_percentage_remaining (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3PercentageRemaining attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3PercentageRemaining attribute
 */
uint8_t dotdot_get_power_configuration_battery3_percentage_remaining(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3PercentageRemaining attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_percentage_remaining new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_percentage_remaining(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_percentage_remaining);

// PowerConfiguration Battery3Manufacturer
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3Manufacturer is supported
 *
 * @returns true if Battery3Manufacturer is supported
 * @returns false if Battery3Manufacturer is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_manufacturer (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3Manufacturer attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3Manufacturer attribute
 */
const char* dotdot_get_power_configuration_battery3_manufacturer(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3Manufacturer attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_manufacturer new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_manufacturer(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_battery3_manufacturer);

// PowerConfiguration Battery3Size
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3Size is supported
 *
 * @returns true if Battery3Size is supported
 * @returns false if Battery3Size is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_size (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3Size attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3Size attribute
 */
BatterySize dotdot_get_power_configuration_battery3_size(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3Size attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_size new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_size(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  BatterySize new_battery3_size);

// PowerConfiguration Battery3AHrRating
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3AHrRating is supported
 *
 * @returns true if Battery3AHrRating is supported
 * @returns false if Battery3AHrRating is not supported
 */
bool dotdot_is_supported_power_configuration_battery3a_hr_rating (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3AHrRating attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3AHrRating attribute
 */
uint16_t dotdot_get_power_configuration_battery3a_hr_rating(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3AHrRating attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3a_hr_rating new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3a_hr_rating(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_battery3a_hr_rating);

// PowerConfiguration Battery3Quantity
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3Quantity is supported
 *
 * @returns true if Battery3Quantity is supported
 * @returns false if Battery3Quantity is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_quantity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3Quantity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3Quantity attribute
 */
uint8_t dotdot_get_power_configuration_battery3_quantity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3Quantity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_quantity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_quantity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_quantity);

// PowerConfiguration Battery3RatedVoltage
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3RatedVoltage is supported
 *
 * @returns true if Battery3RatedVoltage is supported
 * @returns false if Battery3RatedVoltage is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_rated_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3RatedVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3RatedVoltage attribute
 */
uint8_t dotdot_get_power_configuration_battery3_rated_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3RatedVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_rated_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_rated_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_rated_voltage);

// PowerConfiguration Battery3AlarmMask
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3AlarmMask is supported
 *
 * @returns true if Battery3AlarmMask is supported
 * @returns false if Battery3AlarmMask is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_alarm_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3AlarmMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3AlarmMask attribute
 */
uint8_t dotdot_get_power_configuration_battery3_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3AlarmMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_alarm_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_alarm_mask);

// PowerConfiguration Battery3VoltageMinThreshold
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3VoltageMinThreshold is supported
 *
 * @returns true if Battery3VoltageMinThreshold is supported
 * @returns false if Battery3VoltageMinThreshold is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_voltage_min_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3VoltageMinThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3VoltageMinThreshold attribute
 */
uint8_t dotdot_get_power_configuration_battery3_voltage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3VoltageMinThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_voltage_min_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_voltage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_voltage_min_threshold);

// PowerConfiguration Battery3VoltageThreshold1
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3VoltageThreshold1 is supported
 *
 * @returns true if Battery3VoltageThreshold1 is supported
 * @returns false if Battery3VoltageThreshold1 is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_voltage_threshold1 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3VoltageThreshold1 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3VoltageThreshold1 attribute
 */
uint8_t dotdot_get_power_configuration_battery3_voltage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3VoltageThreshold1 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_voltage_threshold1 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_voltage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_voltage_threshold1);

// PowerConfiguration Battery3VoltageThreshold2
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3VoltageThreshold2 is supported
 *
 * @returns true if Battery3VoltageThreshold2 is supported
 * @returns false if Battery3VoltageThreshold2 is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_voltage_threshold2 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3VoltageThreshold2 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3VoltageThreshold2 attribute
 */
uint8_t dotdot_get_power_configuration_battery3_voltage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3VoltageThreshold2 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_voltage_threshold2 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_voltage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_voltage_threshold2);

// PowerConfiguration Battery3VoltageThreshold3
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3VoltageThreshold3 is supported
 *
 * @returns true if Battery3VoltageThreshold3 is supported
 * @returns false if Battery3VoltageThreshold3 is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_voltage_threshold3 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3VoltageThreshold3 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3VoltageThreshold3 attribute
 */
uint8_t dotdot_get_power_configuration_battery3_voltage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3VoltageThreshold3 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_voltage_threshold3 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_voltage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_voltage_threshold3);

// PowerConfiguration Battery3PercentageMinThreshold
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3PercentageMinThreshold is supported
 *
 * @returns true if Battery3PercentageMinThreshold is supported
 * @returns false if Battery3PercentageMinThreshold is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_percentage_min_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3PercentageMinThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3PercentageMinThreshold attribute
 */
uint8_t dotdot_get_power_configuration_battery3_percentage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3PercentageMinThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_percentage_min_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_percentage_min_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_percentage_min_threshold);

// PowerConfiguration Battery3PercentageThreshold1
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3PercentageThreshold1 is supported
 *
 * @returns true if Battery3PercentageThreshold1 is supported
 * @returns false if Battery3PercentageThreshold1 is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_percentage_threshold1 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3PercentageThreshold1 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3PercentageThreshold1 attribute
 */
uint8_t dotdot_get_power_configuration_battery3_percentage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3PercentageThreshold1 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_percentage_threshold1 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_percentage_threshold1(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_percentage_threshold1);

// PowerConfiguration Battery3PercentageThreshold2
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3PercentageThreshold2 is supported
 *
 * @returns true if Battery3PercentageThreshold2 is supported
 * @returns false if Battery3PercentageThreshold2 is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_percentage_threshold2 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3PercentageThreshold2 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3PercentageThreshold2 attribute
 */
uint8_t dotdot_get_power_configuration_battery3_percentage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3PercentageThreshold2 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_percentage_threshold2 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_percentage_threshold2(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_percentage_threshold2);

// PowerConfiguration Battery3PercentageThreshold3
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3PercentageThreshold3 is supported
 *
 * @returns true if Battery3PercentageThreshold3 is supported
 * @returns false if Battery3PercentageThreshold3 is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_percentage_threshold3 (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3PercentageThreshold3 attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3PercentageThreshold3 attribute
 */
uint8_t dotdot_get_power_configuration_battery3_percentage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3PercentageThreshold3 attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_percentage_threshold3 new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_percentage_threshold3(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_battery3_percentage_threshold3);

// PowerConfiguration Battery3AlarmState
/**
 * @brief Verifies if the DotDot PowerConfiguration Battery3AlarmState is supported
 *
 * @returns true if Battery3AlarmState is supported
 * @returns false if Battery3AlarmState is not supported
 */
bool dotdot_is_supported_power_configuration_battery3_alarm_state (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Battery3AlarmState attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Battery3AlarmState attribute
 */
uint32_t dotdot_get_power_configuration_battery3_alarm_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Battery3AlarmState attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery3_alarm_state new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_power_configuration_battery3_alarm_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_battery3_alarm_state);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster DeviceTemperatureConfiguration
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for DeviceTemperatureConfiguration
#define DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_CURRENT_TEMPERATURE ((attribute_store_type_t) 0x00020000)
///< This represents the CurrentTemperature attribute in the DotDot DeviceTemperatureConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MIN_TEMP_EXPERIENCED ((attribute_store_type_t) 0x00020001)
///< This represents the MinTempExperienced attribute in the DotDot DeviceTemperatureConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_MAX_TEMP_EXPERIENCED ((attribute_store_type_t) 0x00020002)
///< This represents the MaxTempExperienced attribute in the DotDot DeviceTemperatureConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_OVER_TEMP_TOTAL_DWELL ((attribute_store_type_t) 0x00020003)
///< This represents the OverTempTotalDwell attribute in the DotDot DeviceTemperatureConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_DEVICE_TEMP_ALARM_MASK ((attribute_store_type_t) 0x00020010)
///< This represents the DeviceTempAlarmMask attribute in the DotDot DeviceTemperatureConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_THRESHOLD ((attribute_store_type_t) 0x00020011)
///< This represents the LowTempThreshold attribute in the DotDot DeviceTemperatureConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_THRESHOLD ((attribute_store_type_t) 0x00020012)
///< This represents the HighTempThreshold attribute in the DotDot DeviceTemperatureConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_LOW_TEMP_DWELL_TRIP_POINT ((attribute_store_type_t) 0x00020013)
///< This represents the LowTempDwellTripPoint attribute in the DotDot DeviceTemperatureConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_DEVICE_TEMPERATURE_CONFIGURATION_HIGH_TEMP_DWELL_TRIP_POINT ((attribute_store_type_t) 0x00020014)
///< This represents the HighTempDwellTripPoint attribute in the DotDot DeviceTemperatureConfiguration cluster

// DeviceTemperatureConfiguration CurrentTemperature
/**
 * @brief Verifies if the DotDot DeviceTemperatureConfiguration CurrentTemperature is supported
 *
 * @returns true if CurrentTemperature is supported
 * @returns false if CurrentTemperature is not supported
 */
bool dotdot_is_supported_device_temperature_configuration_current_temperature (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentTemperature attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentTemperature attribute
 */
int16_t dotdot_get_device_temperature_configuration_current_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentTemperature attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_temperature new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_device_temperature_configuration_current_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_current_temperature);

// DeviceTemperatureConfiguration MinTempExperienced
/**
 * @brief Verifies if the DotDot DeviceTemperatureConfiguration MinTempExperienced is supported
 *
 * @returns true if MinTempExperienced is supported
 * @returns false if MinTempExperienced is not supported
 */
bool dotdot_is_supported_device_temperature_configuration_min_temp_experienced (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinTempExperienced attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinTempExperienced attribute
 */
int16_t dotdot_get_device_temperature_configuration_min_temp_experienced(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinTempExperienced attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_temp_experienced new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_device_temperature_configuration_min_temp_experienced(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_min_temp_experienced);

// DeviceTemperatureConfiguration MaxTempExperienced
/**
 * @brief Verifies if the DotDot DeviceTemperatureConfiguration MaxTempExperienced is supported
 *
 * @returns true if MaxTempExperienced is supported
 * @returns false if MaxTempExperienced is not supported
 */
bool dotdot_is_supported_device_temperature_configuration_max_temp_experienced (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxTempExperienced attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxTempExperienced attribute
 */
int16_t dotdot_get_device_temperature_configuration_max_temp_experienced(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxTempExperienced attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_temp_experienced new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_device_temperature_configuration_max_temp_experienced(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_max_temp_experienced);

// DeviceTemperatureConfiguration OverTempTotalDwell
/**
 * @brief Verifies if the DotDot DeviceTemperatureConfiguration OverTempTotalDwell is supported
 *
 * @returns true if OverTempTotalDwell is supported
 * @returns false if OverTempTotalDwell is not supported
 */
bool dotdot_is_supported_device_temperature_configuration_over_temp_total_dwell (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OverTempTotalDwell attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OverTempTotalDwell attribute
 */
uint16_t dotdot_get_device_temperature_configuration_over_temp_total_dwell(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OverTempTotalDwell attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_over_temp_total_dwell new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_device_temperature_configuration_over_temp_total_dwell(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_over_temp_total_dwell);

// DeviceTemperatureConfiguration DeviceTempAlarmMask
/**
 * @brief Verifies if the DotDot DeviceTemperatureConfiguration DeviceTempAlarmMask is supported
 *
 * @returns true if DeviceTempAlarmMask is supported
 * @returns false if DeviceTempAlarmMask is not supported
 */
bool dotdot_is_supported_device_temperature_configuration_device_temp_alarm_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DeviceTempAlarmMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DeviceTempAlarmMask attribute
 */
uint8_t dotdot_get_device_temperature_configuration_device_temp_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DeviceTempAlarmMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_device_temp_alarm_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_device_temperature_configuration_device_temp_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_device_temp_alarm_mask);

// DeviceTemperatureConfiguration LowTempThreshold
/**
 * @brief Verifies if the DotDot DeviceTemperatureConfiguration LowTempThreshold is supported
 *
 * @returns true if LowTempThreshold is supported
 * @returns false if LowTempThreshold is not supported
 */
bool dotdot_is_supported_device_temperature_configuration_low_temp_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LowTempThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LowTempThreshold attribute
 */
int16_t dotdot_get_device_temperature_configuration_low_temp_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LowTempThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_low_temp_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_device_temperature_configuration_low_temp_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_low_temp_threshold);

// DeviceTemperatureConfiguration HighTempThreshold
/**
 * @brief Verifies if the DotDot DeviceTemperatureConfiguration HighTempThreshold is supported
 *
 * @returns true if HighTempThreshold is supported
 * @returns false if HighTempThreshold is not supported
 */
bool dotdot_is_supported_device_temperature_configuration_high_temp_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot HighTempThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns HighTempThreshold attribute
 */
int16_t dotdot_get_device_temperature_configuration_high_temp_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot HighTempThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_high_temp_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_device_temperature_configuration_high_temp_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_high_temp_threshold);

// DeviceTemperatureConfiguration LowTempDwellTripPoint
/**
 * @brief Verifies if the DotDot DeviceTemperatureConfiguration LowTempDwellTripPoint is supported
 *
 * @returns true if LowTempDwellTripPoint is supported
 * @returns false if LowTempDwellTripPoint is not supported
 */
bool dotdot_is_supported_device_temperature_configuration_low_temp_dwell_trip_point (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LowTempDwellTripPoint attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LowTempDwellTripPoint attribute
 */
uint32_t dotdot_get_device_temperature_configuration_low_temp_dwell_trip_point(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LowTempDwellTripPoint attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_low_temp_dwell_trip_point new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_device_temperature_configuration_low_temp_dwell_trip_point(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_low_temp_dwell_trip_point);

// DeviceTemperatureConfiguration HighTempDwellTripPoint
/**
 * @brief Verifies if the DotDot DeviceTemperatureConfiguration HighTempDwellTripPoint is supported
 *
 * @returns true if HighTempDwellTripPoint is supported
 * @returns false if HighTempDwellTripPoint is not supported
 */
bool dotdot_is_supported_device_temperature_configuration_high_temp_dwell_trip_point (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot HighTempDwellTripPoint attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns HighTempDwellTripPoint attribute
 */
uint32_t dotdot_get_device_temperature_configuration_high_temp_dwell_trip_point(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot HighTempDwellTripPoint attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_high_temp_dwell_trip_point new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_device_temperature_configuration_high_temp_dwell_trip_point(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_high_temp_dwell_trip_point);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Identify
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Identify
#define DOTDOT_ATTRIBUTE_ID_IDENTIFY_IDENTIFY_TIME ((attribute_store_type_t) 0x00030000)
///< This represents the IdentifyTime attribute in the DotDot Identify cluster

// Identify IdentifyTime
/**
 * @brief Verifies if the DotDot Identify IdentifyTime is supported
 *
 * @returns true if IdentifyTime is supported
 * @returns false if IdentifyTime is not supported
 */
bool dotdot_is_supported_identify_identify_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot IdentifyTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns IdentifyTime attribute
 */
uint16_t dotdot_get_identify_identify_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot IdentifyTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_identify_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_identify_identify_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_identify_time);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Groups
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Groups
#define DOTDOT_ATTRIBUTE_ID_GROUPS_NAME_SUPPORT ((attribute_store_type_t) 0x00040000)
///< This represents the NameSupport attribute in the DotDot Groups cluster

// Groups NameSupport
/**
 * @brief Verifies if the DotDot Groups NameSupport is supported
 *
 * @returns true if NameSupport is supported
 * @returns false if NameSupport is not supported
 */
bool dotdot_is_supported_groups_name_support (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NameSupport attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NameSupport attribute
 */
uint8_t dotdot_get_groups_name_support(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NameSupport attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_name_support new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_groups_name_support(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_name_support);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Scenes
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Scenes
#define DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_COUNT ((attribute_store_type_t) 0x00050000)
///< This represents the SceneCount attribute in the DotDot Scenes cluster

#define DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_SCENE ((attribute_store_type_t) 0x00050001)
///< This represents the CurrentScene attribute in the DotDot Scenes cluster

#define DOTDOT_ATTRIBUTE_ID_SCENES_CURRENT_GROUP ((attribute_store_type_t) 0x00050002)
///< This represents the CurrentGroup attribute in the DotDot Scenes cluster

#define DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_VALID ((attribute_store_type_t) 0x00050003)
///< This represents the SceneValid attribute in the DotDot Scenes cluster

#define DOTDOT_ATTRIBUTE_ID_SCENES_NAME_SUPPORT ((attribute_store_type_t) 0x00050004)
///< This represents the NameSupport attribute in the DotDot Scenes cluster

#define DOTDOT_ATTRIBUTE_ID_SCENES_LAST_CONFIGURED_BY ((attribute_store_type_t) 0x00050005)
///< This represents the LastConfiguredBy attribute in the DotDot Scenes cluster

// Scenes SceneCount
/**
 * @brief Verifies if the DotDot Scenes SceneCount is supported
 *
 * @returns true if SceneCount is supported
 * @returns false if SceneCount is not supported
 */
bool dotdot_is_supported_scenes_scene_count (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SceneCount attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SceneCount attribute
 */
uint8_t dotdot_get_scenes_scene_count(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SceneCount attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_scene_count new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_scenes_scene_count(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_scene_count);

// Scenes CurrentScene
/**
 * @brief Verifies if the DotDot Scenes CurrentScene is supported
 *
 * @returns true if CurrentScene is supported
 * @returns false if CurrentScene is not supported
 */
bool dotdot_is_supported_scenes_current_scene (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentScene attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentScene attribute
 */
uint8_t dotdot_get_scenes_current_scene(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentScene attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_scene new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_scenes_current_scene(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_current_scene);

// Scenes CurrentGroup
/**
 * @brief Verifies if the DotDot Scenes CurrentGroup is supported
 *
 * @returns true if CurrentGroup is supported
 * @returns false if CurrentGroup is not supported
 */
bool dotdot_is_supported_scenes_current_group (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentGroup attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentGroup attribute
 */
SGroupId dotdot_get_scenes_current_group(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentGroup attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_group new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_scenes_current_group(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  SGroupId new_current_group);

// Scenes SceneValid
/**
 * @brief Verifies if the DotDot Scenes SceneValid is supported
 *
 * @returns true if SceneValid is supported
 * @returns false if SceneValid is not supported
 */
bool dotdot_is_supported_scenes_scene_valid (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SceneValid attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SceneValid attribute
 */
bool dotdot_get_scenes_scene_valid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SceneValid attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_scene_valid new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_scenes_scene_valid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_scene_valid);

// Scenes NameSupport
/**
 * @brief Verifies if the DotDot Scenes NameSupport is supported
 *
 * @returns true if NameSupport is supported
 * @returns false if NameSupport is not supported
 */
bool dotdot_is_supported_scenes_name_support (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NameSupport attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NameSupport attribute
 */
uint8_t dotdot_get_scenes_name_support(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NameSupport attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_name_support new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_scenes_name_support(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_name_support);

// Scenes LastConfiguredBy
/**
 * @brief Verifies if the DotDot Scenes LastConfiguredBy is supported
 *
 * @returns true if LastConfiguredBy is supported
 * @returns false if LastConfiguredBy is not supported
 */
bool dotdot_is_supported_scenes_last_configured_by (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LastConfiguredBy attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LastConfiguredBy attribute
 */
EUI64 dotdot_get_scenes_last_configured_by(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LastConfiguredBy attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_last_configured_by new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_scenes_last_configured_by(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  EUI64 new_last_configured_by);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster OnOff
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for OnOff
#define DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF ((attribute_store_type_t) 0x00060000)
///< This represents the OnOff attribute in the DotDot OnOff cluster

#define DOTDOT_ATTRIBUTE_ID_ON_OFF_GLOBAL_SCENE_CONTROL ((attribute_store_type_t) 0x00064000)
///< This represents the GlobalSceneControl attribute in the DotDot OnOff cluster

#define DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_TIME ((attribute_store_type_t) 0x00064001)
///< This represents the OnTime attribute in the DotDot OnOff cluster

#define DOTDOT_ATTRIBUTE_ID_ON_OFF_OFF_WAIT_TIME ((attribute_store_type_t) 0x00064002)
///< This represents the OffWaitTime attribute in the DotDot OnOff cluster

#define DOTDOT_ATTRIBUTE_ID_ON_OFF_START_UP_ON_OFF ((attribute_store_type_t) 0x00064003)
///< This represents the StartUpOnOff attribute in the DotDot OnOff cluster

// OnOff OnOff
/**
 * @brief Verifies if the DotDot OnOff OnOff is supported
 *
 * @returns true if OnOff is supported
 * @returns false if OnOff is not supported
 */
bool dotdot_is_supported_on_off_on_off (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OnOff attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OnOff attribute
 */
bool dotdot_get_on_off_on_off(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OnOff attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_on_off new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_on_off_on_off(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_on_off);

// OnOff GlobalSceneControl
/**
 * @brief Verifies if the DotDot OnOff GlobalSceneControl is supported
 *
 * @returns true if GlobalSceneControl is supported
 * @returns false if GlobalSceneControl is not supported
 */
bool dotdot_is_supported_on_off_global_scene_control (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot GlobalSceneControl attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns GlobalSceneControl attribute
 */
bool dotdot_get_on_off_global_scene_control(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot GlobalSceneControl attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_global_scene_control new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_on_off_global_scene_control(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_global_scene_control);

// OnOff OnTime
/**
 * @brief Verifies if the DotDot OnOff OnTime is supported
 *
 * @returns true if OnTime is supported
 * @returns false if OnTime is not supported
 */
bool dotdot_is_supported_on_off_on_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OnTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OnTime attribute
 */
uint16_t dotdot_get_on_off_on_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OnTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_on_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_on_off_on_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_on_time);

// OnOff OffWaitTime
/**
 * @brief Verifies if the DotDot OnOff OffWaitTime is supported
 *
 * @returns true if OffWaitTime is supported
 * @returns false if OffWaitTime is not supported
 */
bool dotdot_is_supported_on_off_off_wait_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OffWaitTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OffWaitTime attribute
 */
uint16_t dotdot_get_on_off_off_wait_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OffWaitTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_off_wait_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_on_off_off_wait_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_off_wait_time);

// OnOff StartUpOnOff
/**
 * @brief Verifies if the DotDot OnOff StartUpOnOff is supported
 *
 * @returns true if StartUpOnOff is supported
 * @returns false if StartUpOnOff is not supported
 */
bool dotdot_is_supported_on_off_start_up_on_off (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot StartUpOnOff attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns StartUpOnOff attribute
 */
uint8_t dotdot_get_on_off_start_up_on_off(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot StartUpOnOff attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_start_up_on_off new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_on_off_start_up_on_off(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_start_up_on_off);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Level
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Level
#define DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_LEVEL ((attribute_store_type_t) 0x00080000)
///< This represents the CurrentLevel attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_REMAINING_TIME ((attribute_store_type_t) 0x00080001)
///< This represents the RemainingTime attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_LEVEL ((attribute_store_type_t) 0x00080002)
///< This represents the MinLevel attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_LEVEL ((attribute_store_type_t) 0x00080003)
///< This represents the MaxLevel attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_CURRENT_FREQUENCY ((attribute_store_type_t) 0x00080004)
///< This represents the CurrentFrequency attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_MIN_FREQUENCY ((attribute_store_type_t) 0x00080005)
///< This represents the MinFrequency attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_MAX_FREQUENCY ((attribute_store_type_t) 0x00080006)
///< This represents the MaxFrequency attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_OPTIONS ((attribute_store_type_t) 0x0008000f)
///< This represents the Options attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_ON_OFF_TRANSITION_TIME ((attribute_store_type_t) 0x00080010)
///< This represents the OnOffTransitionTime attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_ON_LEVEL ((attribute_store_type_t) 0x00080011)
///< This represents the OnLevel attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_ON_TRANSITION_TIME ((attribute_store_type_t) 0x00080012)
///< This represents the OnTransitionTime attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_OFF_TRANSITION_TIME ((attribute_store_type_t) 0x00080013)
///< This represents the OffTransitionTime attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_DEFAULT_MOVE_RATE ((attribute_store_type_t) 0x00080014)
///< This represents the DefaultMoveRate attribute in the DotDot Level cluster

#define DOTDOT_ATTRIBUTE_ID_LEVEL_START_UP_CURRENT_LEVEL ((attribute_store_type_t) 0x00084000)
///< This represents the StartUpCurrentLevel attribute in the DotDot Level cluster

// Level CurrentLevel
/**
 * @brief Verifies if the DotDot Level CurrentLevel is supported
 *
 * @returns true if CurrentLevel is supported
 * @returns false if CurrentLevel is not supported
 */
bool dotdot_is_supported_level_current_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentLevel attribute
 */
uint8_t dotdot_get_level_current_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_current_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_current_level);

// Level RemainingTime
/**
 * @brief Verifies if the DotDot Level RemainingTime is supported
 *
 * @returns true if RemainingTime is supported
 * @returns false if RemainingTime is not supported
 */
bool dotdot_is_supported_level_remaining_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RemainingTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RemainingTime attribute
 */
uint16_t dotdot_get_level_remaining_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RemainingTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_remaining_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_remaining_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_remaining_time);

// Level MinLevel
/**
 * @brief Verifies if the DotDot Level MinLevel is supported
 *
 * @returns true if MinLevel is supported
 * @returns false if MinLevel is not supported
 */
bool dotdot_is_supported_level_min_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinLevel attribute
 */
uint8_t dotdot_get_level_min_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_min_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_min_level);

// Level MaxLevel
/**
 * @brief Verifies if the DotDot Level MaxLevel is supported
 *
 * @returns true if MaxLevel is supported
 * @returns false if MaxLevel is not supported
 */
bool dotdot_is_supported_level_max_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxLevel attribute
 */
uint8_t dotdot_get_level_max_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_max_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_max_level);

// Level CurrentFrequency
/**
 * @brief Verifies if the DotDot Level CurrentFrequency is supported
 *
 * @returns true if CurrentFrequency is supported
 * @returns false if CurrentFrequency is not supported
 */
bool dotdot_is_supported_level_current_frequency (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentFrequency attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentFrequency attribute
 */
uint16_t dotdot_get_level_current_frequency(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentFrequency attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_frequency new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_current_frequency(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_current_frequency);

// Level MinFrequency
/**
 * @brief Verifies if the DotDot Level MinFrequency is supported
 *
 * @returns true if MinFrequency is supported
 * @returns false if MinFrequency is not supported
 */
bool dotdot_is_supported_level_min_frequency (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinFrequency attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinFrequency attribute
 */
uint16_t dotdot_get_level_min_frequency(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinFrequency attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_frequency new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_min_frequency(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_min_frequency);

// Level MaxFrequency
/**
 * @brief Verifies if the DotDot Level MaxFrequency is supported
 *
 * @returns true if MaxFrequency is supported
 * @returns false if MaxFrequency is not supported
 */
bool dotdot_is_supported_level_max_frequency (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxFrequency attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxFrequency attribute
 */
uint16_t dotdot_get_level_max_frequency(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxFrequency attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_frequency new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_max_frequency(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_frequency);

// Level Options
/**
 * @brief Verifies if the DotDot Level Options is supported
 *
 * @returns true if Options is supported
 * @returns false if Options is not supported
 */
bool dotdot_is_supported_level_options (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Options attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Options attribute
 */
uint8_t dotdot_get_level_options(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Options attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_options new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_options(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_options);

// Level OnOffTransitionTime
/**
 * @brief Verifies if the DotDot Level OnOffTransitionTime is supported
 *
 * @returns true if OnOffTransitionTime is supported
 * @returns false if OnOffTransitionTime is not supported
 */
bool dotdot_is_supported_level_on_off_transition_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OnOffTransitionTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OnOffTransitionTime attribute
 */
uint16_t dotdot_get_level_on_off_transition_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OnOffTransitionTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_on_off_transition_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_on_off_transition_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_on_off_transition_time);

// Level OnLevel
/**
 * @brief Verifies if the DotDot Level OnLevel is supported
 *
 * @returns true if OnLevel is supported
 * @returns false if OnLevel is not supported
 */
bool dotdot_is_supported_level_on_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OnLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OnLevel attribute
 */
uint8_t dotdot_get_level_on_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OnLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_on_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_on_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_on_level);

// Level OnTransitionTime
/**
 * @brief Verifies if the DotDot Level OnTransitionTime is supported
 *
 * @returns true if OnTransitionTime is supported
 * @returns false if OnTransitionTime is not supported
 */
bool dotdot_is_supported_level_on_transition_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OnTransitionTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OnTransitionTime attribute
 */
uint16_t dotdot_get_level_on_transition_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OnTransitionTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_on_transition_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_on_transition_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_on_transition_time);

// Level OffTransitionTime
/**
 * @brief Verifies if the DotDot Level OffTransitionTime is supported
 *
 * @returns true if OffTransitionTime is supported
 * @returns false if OffTransitionTime is not supported
 */
bool dotdot_is_supported_level_off_transition_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OffTransitionTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OffTransitionTime attribute
 */
uint16_t dotdot_get_level_off_transition_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OffTransitionTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_off_transition_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_off_transition_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_off_transition_time);

// Level DefaultMoveRate
/**
 * @brief Verifies if the DotDot Level DefaultMoveRate is supported
 *
 * @returns true if DefaultMoveRate is supported
 * @returns false if DefaultMoveRate is not supported
 */
bool dotdot_is_supported_level_default_move_rate (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DefaultMoveRate attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DefaultMoveRate attribute
 */
uint16_t dotdot_get_level_default_move_rate(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DefaultMoveRate attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_default_move_rate new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_default_move_rate(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_default_move_rate);

// Level StartUpCurrentLevel
/**
 * @brief Verifies if the DotDot Level StartUpCurrentLevel is supported
 *
 * @returns true if StartUpCurrentLevel is supported
 * @returns false if StartUpCurrentLevel is not supported
 */
bool dotdot_is_supported_level_start_up_current_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot StartUpCurrentLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns StartUpCurrentLevel attribute
 */
uint8_t dotdot_get_level_start_up_current_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot StartUpCurrentLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_start_up_current_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_level_start_up_current_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_start_up_current_level);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Alarms
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Alarms
#define DOTDOT_ATTRIBUTE_ID_ALARMS_ALARM_COUNT ((attribute_store_type_t) 0x00090000)
///< This represents the AlarmCount attribute in the DotDot Alarms cluster

// Alarms AlarmCount
/**
 * @brief Verifies if the DotDot Alarms AlarmCount is supported
 *
 * @returns true if AlarmCount is supported
 * @returns false if AlarmCount is not supported
 */
bool dotdot_is_supported_alarms_alarm_count (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AlarmCount attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AlarmCount attribute
 */
uint16_t dotdot_get_alarms_alarm_count(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AlarmCount attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_alarm_count new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_alarms_alarm_count(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_alarm_count);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Time
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Time
#define DOTDOT_ATTRIBUTE_ID_TIME_TIME ((attribute_store_type_t) 0x000a0000)
///< This represents the Time attribute in the DotDot Time cluster

#define DOTDOT_ATTRIBUTE_ID_TIME_TIME_STATUS ((attribute_store_type_t) 0x000a0001)
///< This represents the TimeStatus attribute in the DotDot Time cluster

#define DOTDOT_ATTRIBUTE_ID_TIME_TIME_ZONE ((attribute_store_type_t) 0x000a0002)
///< This represents the TimeZone attribute in the DotDot Time cluster

#define DOTDOT_ATTRIBUTE_ID_TIME_DST_START ((attribute_store_type_t) 0x000a0003)
///< This represents the DstStart attribute in the DotDot Time cluster

#define DOTDOT_ATTRIBUTE_ID_TIME_DST_END ((attribute_store_type_t) 0x000a0004)
///< This represents the DstEnd attribute in the DotDot Time cluster

#define DOTDOT_ATTRIBUTE_ID_TIME_DST_SHIFT ((attribute_store_type_t) 0x000a0005)
///< This represents the DstShift attribute in the DotDot Time cluster

#define DOTDOT_ATTRIBUTE_ID_TIME_STANDARD_TIME ((attribute_store_type_t) 0x000a0006)
///< This represents the StandardTime attribute in the DotDot Time cluster

#define DOTDOT_ATTRIBUTE_ID_TIME_LOCAL_TIME ((attribute_store_type_t) 0x000a0007)
///< This represents the LocalTime attribute in the DotDot Time cluster

#define DOTDOT_ATTRIBUTE_ID_TIME_LAST_SET_TIME ((attribute_store_type_t) 0x000a0008)
///< This represents the LastSetTime attribute in the DotDot Time cluster

#define DOTDOT_ATTRIBUTE_ID_TIME_VALID_UNTIL_TIME ((attribute_store_type_t) 0x000a0009)
///< This represents the ValidUntilTime attribute in the DotDot Time cluster

// Time Time
/**
 * @brief Verifies if the DotDot Time Time is supported
 *
 * @returns true if Time is supported
 * @returns false if Time is not supported
 */
bool dotdot_is_supported_time_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Time attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Time attribute
 */
UTC dotdot_get_time_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Time attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_time_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  UTC new_time);

// Time TimeStatus
/**
 * @brief Verifies if the DotDot Time TimeStatus is supported
 *
 * @returns true if TimeStatus is supported
 * @returns false if TimeStatus is not supported
 */
bool dotdot_is_supported_time_time_status (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TimeStatus attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TimeStatus attribute
 */
uint8_t dotdot_get_time_time_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TimeStatus attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_time_status new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_time_time_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_time_status);

// Time TimeZone
/**
 * @brief Verifies if the DotDot Time TimeZone is supported
 *
 * @returns true if TimeZone is supported
 * @returns false if TimeZone is not supported
 */
bool dotdot_is_supported_time_time_zone (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TimeZone attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TimeZone attribute
 */
int32_t dotdot_get_time_time_zone(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TimeZone attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_time_zone new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_time_time_zone(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int32_t new_time_zone);

// Time DstStart
/**
 * @brief Verifies if the DotDot Time DstStart is supported
 *
 * @returns true if DstStart is supported
 * @returns false if DstStart is not supported
 */
bool dotdot_is_supported_time_dst_start (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DstStart attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DstStart attribute
 */
uint32_t dotdot_get_time_dst_start(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DstStart attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dst_start new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_time_dst_start(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_dst_start);

// Time DstEnd
/**
 * @brief Verifies if the DotDot Time DstEnd is supported
 *
 * @returns true if DstEnd is supported
 * @returns false if DstEnd is not supported
 */
bool dotdot_is_supported_time_dst_end (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DstEnd attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DstEnd attribute
 */
uint32_t dotdot_get_time_dst_end(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DstEnd attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dst_end new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_time_dst_end(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_dst_end);

// Time DstShift
/**
 * @brief Verifies if the DotDot Time DstShift is supported
 *
 * @returns true if DstShift is supported
 * @returns false if DstShift is not supported
 */
bool dotdot_is_supported_time_dst_shift (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DstShift attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DstShift attribute
 */
int32_t dotdot_get_time_dst_shift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DstShift attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dst_shift new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_time_dst_shift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int32_t new_dst_shift);

// Time StandardTime
/**
 * @brief Verifies if the DotDot Time StandardTime is supported
 *
 * @returns true if StandardTime is supported
 * @returns false if StandardTime is not supported
 */
bool dotdot_is_supported_time_standard_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot StandardTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns StandardTime attribute
 */
uint32_t dotdot_get_time_standard_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot StandardTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_standard_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_time_standard_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_standard_time);

// Time LocalTime
/**
 * @brief Verifies if the DotDot Time LocalTime is supported
 *
 * @returns true if LocalTime is supported
 * @returns false if LocalTime is not supported
 */
bool dotdot_is_supported_time_local_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LocalTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LocalTime attribute
 */
uint32_t dotdot_get_time_local_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LocalTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_local_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_time_local_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_local_time);

// Time LastSetTime
/**
 * @brief Verifies if the DotDot Time LastSetTime is supported
 *
 * @returns true if LastSetTime is supported
 * @returns false if LastSetTime is not supported
 */
bool dotdot_is_supported_time_last_set_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LastSetTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LastSetTime attribute
 */
UTC dotdot_get_time_last_set_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LastSetTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_last_set_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_time_last_set_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  UTC new_last_set_time);

// Time ValidUntilTime
/**
 * @brief Verifies if the DotDot Time ValidUntilTime is supported
 *
 * @returns true if ValidUntilTime is supported
 * @returns false if ValidUntilTime is not supported
 */
bool dotdot_is_supported_time_valid_until_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ValidUntilTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ValidUntilTime attribute
 */
UTC dotdot_get_time_valid_until_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ValidUntilTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_valid_until_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_time_valid_until_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  UTC new_valid_until_time);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster OTAUpgrade
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for OTAUpgrade
#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_SERVERID ((attribute_store_type_t) 0x00190000)
///< This represents the UpgradeServerID attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_FILE_OFFSET ((attribute_store_type_t) 0x00190001)
///< This represents the FileOffset attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_FILE_VERSION ((attribute_store_type_t) 0x00190002)
///< This represents the CurrentFileVersion attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_CURRENT_ZIG_BEE_STACK_VERSION ((attribute_store_type_t) 0x00190003)
///< This represents the CurrentZigBeeStackVersion attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_FILE_VERSION ((attribute_store_type_t) 0x00190004)
///< This represents the DownloadedFileVersion attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_DOWNLOADED_ZIG_BEE_STACK_VERSION ((attribute_store_type_t) 0x00190005)
///< This represents the DownloadedZigBeeStackVersion attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_UPGRADE_STATUS ((attribute_store_type_t) 0x00190006)
///< This represents the ImageUpgradeStatus attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MANUFACTURERID ((attribute_store_type_t) 0x00190007)
///< This represents the ManufacturerID attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_TYPEID ((attribute_store_type_t) 0x00190008)
///< This represents the ImageTypeID attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_MINIMUM_BLOCK_PERIOD ((attribute_store_type_t) 0x00190009)
///< This represents the MinimumBlockPeriod attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_IMAGE_STAMP ((attribute_store_type_t) 0x0019000a)
///< This represents the ImageStamp attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_ACTIVATION_POLICY ((attribute_store_type_t) 0x0019000b)
///< This represents the UpgradeActivationPolicy attribute in the DotDot OTAUpgrade cluster

#define DOTDOT_ATTRIBUTE_ID_OTA_UPGRADE_UPGRADE_TIMEOUT_POLICY ((attribute_store_type_t) 0x0019000c)
///< This represents the UpgradeTimeoutPolicy attribute in the DotDot OTAUpgrade cluster

// OTAUpgrade UpgradeServerID
/**
 * @brief Verifies if the DotDot OTAUpgrade UpgradeServerID is supported
 *
 * @returns true if UpgradeServerID is supported
 * @returns false if UpgradeServerID is not supported
 */
bool dotdot_is_supported_ota_upgrade_upgrade_serverid (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UpgradeServerID attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UpgradeServerID attribute
 */
EUI64 dotdot_get_ota_upgrade_upgrade_serverid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UpgradeServerID attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_upgrade_serverid new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_upgrade_serverid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  EUI64 new_upgrade_serverid);

// OTAUpgrade FileOffset
/**
 * @brief Verifies if the DotDot OTAUpgrade FileOffset is supported
 *
 * @returns true if FileOffset is supported
 * @returns false if FileOffset is not supported
 */
bool dotdot_is_supported_ota_upgrade_file_offset (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot FileOffset attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns FileOffset attribute
 */
uint32_t dotdot_get_ota_upgrade_file_offset(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot FileOffset attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_file_offset new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_file_offset(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_file_offset);

// OTAUpgrade CurrentFileVersion
/**
 * @brief Verifies if the DotDot OTAUpgrade CurrentFileVersion is supported
 *
 * @returns true if CurrentFileVersion is supported
 * @returns false if CurrentFileVersion is not supported
 */
bool dotdot_is_supported_ota_upgrade_current_file_version (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentFileVersion attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentFileVersion attribute
 */
uint32_t dotdot_get_ota_upgrade_current_file_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentFileVersion attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_file_version new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_current_file_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_current_file_version);

// OTAUpgrade CurrentZigBeeStackVersion
/**
 * @brief Verifies if the DotDot OTAUpgrade CurrentZigBeeStackVersion is supported
 *
 * @returns true if CurrentZigBeeStackVersion is supported
 * @returns false if CurrentZigBeeStackVersion is not supported
 */
bool dotdot_is_supported_ota_upgrade_current_zig_bee_stack_version (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentZigBeeStackVersion attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentZigBeeStackVersion attribute
 */
uint16_t dotdot_get_ota_upgrade_current_zig_bee_stack_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentZigBeeStackVersion attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_zig_bee_stack_version new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_current_zig_bee_stack_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_current_zig_bee_stack_version);

// OTAUpgrade DownloadedFileVersion
/**
 * @brief Verifies if the DotDot OTAUpgrade DownloadedFileVersion is supported
 *
 * @returns true if DownloadedFileVersion is supported
 * @returns false if DownloadedFileVersion is not supported
 */
bool dotdot_is_supported_ota_upgrade_downloaded_file_version (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DownloadedFileVersion attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DownloadedFileVersion attribute
 */
uint32_t dotdot_get_ota_upgrade_downloaded_file_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DownloadedFileVersion attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_downloaded_file_version new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_downloaded_file_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_downloaded_file_version);

// OTAUpgrade DownloadedZigBeeStackVersion
/**
 * @brief Verifies if the DotDot OTAUpgrade DownloadedZigBeeStackVersion is supported
 *
 * @returns true if DownloadedZigBeeStackVersion is supported
 * @returns false if DownloadedZigBeeStackVersion is not supported
 */
bool dotdot_is_supported_ota_upgrade_downloaded_zig_bee_stack_version (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DownloadedZigBeeStackVersion attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DownloadedZigBeeStackVersion attribute
 */
uint16_t dotdot_get_ota_upgrade_downloaded_zig_bee_stack_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DownloadedZigBeeStackVersion attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_downloaded_zig_bee_stack_version new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_downloaded_zig_bee_stack_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_downloaded_zig_bee_stack_version);

// OTAUpgrade ImageUpgradeStatus
/**
 * @brief Verifies if the DotDot OTAUpgrade ImageUpgradeStatus is supported
 *
 * @returns true if ImageUpgradeStatus is supported
 * @returns false if ImageUpgradeStatus is not supported
 */
bool dotdot_is_supported_ota_upgrade_image_upgrade_status (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ImageUpgradeStatus attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ImageUpgradeStatus attribute
 */
uint8_t dotdot_get_ota_upgrade_image_upgrade_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ImageUpgradeStatus attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_image_upgrade_status new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_image_upgrade_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_image_upgrade_status);

// OTAUpgrade ManufacturerID
/**
 * @brief Verifies if the DotDot OTAUpgrade ManufacturerID is supported
 *
 * @returns true if ManufacturerID is supported
 * @returns false if ManufacturerID is not supported
 */
bool dotdot_is_supported_ota_upgrade_manufacturerid (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ManufacturerID attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ManufacturerID attribute
 */
uint16_t dotdot_get_ota_upgrade_manufacturerid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ManufacturerID attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_manufacturerid new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_manufacturerid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_manufacturerid);

// OTAUpgrade ImageTypeID
/**
 * @brief Verifies if the DotDot OTAUpgrade ImageTypeID is supported
 *
 * @returns true if ImageTypeID is supported
 * @returns false if ImageTypeID is not supported
 */
bool dotdot_is_supported_ota_upgrade_image_typeid (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ImageTypeID attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ImageTypeID attribute
 */
uint16_t dotdot_get_ota_upgrade_image_typeid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ImageTypeID attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_image_typeid new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_image_typeid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_image_typeid);

// OTAUpgrade MinimumBlockPeriod
/**
 * @brief Verifies if the DotDot OTAUpgrade MinimumBlockPeriod is supported
 *
 * @returns true if MinimumBlockPeriod is supported
 * @returns false if MinimumBlockPeriod is not supported
 */
bool dotdot_is_supported_ota_upgrade_minimum_block_period (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinimumBlockPeriod attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinimumBlockPeriod attribute
 */
uint16_t dotdot_get_ota_upgrade_minimum_block_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinimumBlockPeriod attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_minimum_block_period new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_minimum_block_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_minimum_block_period);

// OTAUpgrade ImageStamp
/**
 * @brief Verifies if the DotDot OTAUpgrade ImageStamp is supported
 *
 * @returns true if ImageStamp is supported
 * @returns false if ImageStamp is not supported
 */
bool dotdot_is_supported_ota_upgrade_image_stamp (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ImageStamp attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ImageStamp attribute
 */
uint32_t dotdot_get_ota_upgrade_image_stamp(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ImageStamp attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_image_stamp new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_image_stamp(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_image_stamp);

// OTAUpgrade UpgradeActivationPolicy
/**
 * @brief Verifies if the DotDot OTAUpgrade UpgradeActivationPolicy is supported
 *
 * @returns true if UpgradeActivationPolicy is supported
 * @returns false if UpgradeActivationPolicy is not supported
 */
bool dotdot_is_supported_ota_upgrade_upgrade_activation_policy (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UpgradeActivationPolicy attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UpgradeActivationPolicy attribute
 */
uint8_t dotdot_get_ota_upgrade_upgrade_activation_policy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UpgradeActivationPolicy attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_upgrade_activation_policy new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_upgrade_activation_policy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_upgrade_activation_policy);

// OTAUpgrade UpgradeTimeoutPolicy
/**
 * @brief Verifies if the DotDot OTAUpgrade UpgradeTimeoutPolicy is supported
 *
 * @returns true if UpgradeTimeoutPolicy is supported
 * @returns false if UpgradeTimeoutPolicy is not supported
 */
bool dotdot_is_supported_ota_upgrade_upgrade_timeout_policy (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UpgradeTimeoutPolicy attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UpgradeTimeoutPolicy attribute
 */
uint8_t dotdot_get_ota_upgrade_upgrade_timeout_policy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UpgradeTimeoutPolicy attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_upgrade_timeout_policy new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ota_upgrade_upgrade_timeout_policy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_upgrade_timeout_policy);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster PollControl
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for PollControl
#define DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL ((attribute_store_type_t) 0x00200000)
///< This represents the CheckInInterval attribute in the DotDot PollControl cluster

#define DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL ((attribute_store_type_t) 0x00200001)
///< This represents the LongPollInterval attribute in the DotDot PollControl cluster

#define DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_SHORT_POLL_INTERVAL ((attribute_store_type_t) 0x00200002)
///< This represents the ShortPollInterval attribute in the DotDot PollControl cluster

#define DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT ((attribute_store_type_t) 0x00200003)
///< This represents the FastPollTimeout attribute in the DotDot PollControl cluster

#define DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_CHECK_IN_INTERVAL_MIN ((attribute_store_type_t) 0x00200004)
///< This represents the CheckInIntervalMin attribute in the DotDot PollControl cluster

#define DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_LONG_POLL_INTERVAL_MIN ((attribute_store_type_t) 0x00200005)
///< This represents the LongPollIntervalMin attribute in the DotDot PollControl cluster

#define DOTDOT_ATTRIBUTE_ID_POLL_CONTROL_FAST_POLL_TIMEOUT_MAX ((attribute_store_type_t) 0x00200006)
///< This represents the FastPollTimeoutMax attribute in the DotDot PollControl cluster

// PollControl CheckInInterval
/**
 * @brief Verifies if the DotDot PollControl CheckInInterval is supported
 *
 * @returns true if CheckInInterval is supported
 * @returns false if CheckInInterval is not supported
 */
bool dotdot_is_supported_poll_control_check_in_interval (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CheckInInterval attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CheckInInterval attribute
 */
uint32_t dotdot_get_poll_control_check_in_interval(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CheckInInterval attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_check_in_interval new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_poll_control_check_in_interval(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_check_in_interval);

// PollControl LongPollInterval
/**
 * @brief Verifies if the DotDot PollControl LongPollInterval is supported
 *
 * @returns true if LongPollInterval is supported
 * @returns false if LongPollInterval is not supported
 */
bool dotdot_is_supported_poll_control_long_poll_interval (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LongPollInterval attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LongPollInterval attribute
 */
uint32_t dotdot_get_poll_control_long_poll_interval(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LongPollInterval attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_long_poll_interval new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_poll_control_long_poll_interval(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_long_poll_interval);

// PollControl ShortPollInterval
/**
 * @brief Verifies if the DotDot PollControl ShortPollInterval is supported
 *
 * @returns true if ShortPollInterval is supported
 * @returns false if ShortPollInterval is not supported
 */
bool dotdot_is_supported_poll_control_short_poll_interval (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ShortPollInterval attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ShortPollInterval attribute
 */
uint16_t dotdot_get_poll_control_short_poll_interval(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ShortPollInterval attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_short_poll_interval new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_poll_control_short_poll_interval(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_short_poll_interval);

// PollControl FastPollTimeout
/**
 * @brief Verifies if the DotDot PollControl FastPollTimeout is supported
 *
 * @returns true if FastPollTimeout is supported
 * @returns false if FastPollTimeout is not supported
 */
bool dotdot_is_supported_poll_control_fast_poll_timeout (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot FastPollTimeout attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns FastPollTimeout attribute
 */
uint16_t dotdot_get_poll_control_fast_poll_timeout(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot FastPollTimeout attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_fast_poll_timeout new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_poll_control_fast_poll_timeout(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_fast_poll_timeout);

// PollControl CheckInIntervalMin
/**
 * @brief Verifies if the DotDot PollControl CheckInIntervalMin is supported
 *
 * @returns true if CheckInIntervalMin is supported
 * @returns false if CheckInIntervalMin is not supported
 */
bool dotdot_is_supported_poll_control_check_in_interval_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CheckInIntervalMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CheckInIntervalMin attribute
 */
uint32_t dotdot_get_poll_control_check_in_interval_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CheckInIntervalMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_check_in_interval_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_poll_control_check_in_interval_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_check_in_interval_min);

// PollControl LongPollIntervalMin
/**
 * @brief Verifies if the DotDot PollControl LongPollIntervalMin is supported
 *
 * @returns true if LongPollIntervalMin is supported
 * @returns false if LongPollIntervalMin is not supported
 */
bool dotdot_is_supported_poll_control_long_poll_interval_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LongPollIntervalMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LongPollIntervalMin attribute
 */
uint32_t dotdot_get_poll_control_long_poll_interval_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LongPollIntervalMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_long_poll_interval_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_poll_control_long_poll_interval_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_long_poll_interval_min);

// PollControl FastPollTimeoutMax
/**
 * @brief Verifies if the DotDot PollControl FastPollTimeoutMax is supported
 *
 * @returns true if FastPollTimeoutMax is supported
 * @returns false if FastPollTimeoutMax is not supported
 */
bool dotdot_is_supported_poll_control_fast_poll_timeout_max (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot FastPollTimeoutMax attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns FastPollTimeoutMax attribute
 */
uint16_t dotdot_get_poll_control_fast_poll_timeout_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot FastPollTimeoutMax attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_fast_poll_timeout_max new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_poll_control_fast_poll_timeout_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_fast_poll_timeout_max);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster ShadeConfiguration
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for ShadeConfiguration
#define DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_PHYSICAL_CLOSED_LIMIT ((attribute_store_type_t) 0x01000000)
///< This represents the PhysicalClosedLimit attribute in the DotDot ShadeConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MOTOR_STEP_SIZE ((attribute_store_type_t) 0x01000001)
///< This represents the MotorStepSize attribute in the DotDot ShadeConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_STATUS ((attribute_store_type_t) 0x01000002)
///< This represents the Status attribute in the DotDot ShadeConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_CLOSED_LIMIT ((attribute_store_type_t) 0x01000010)
///< This represents the ClosedLimit attribute in the DotDot ShadeConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_SHADE_CONFIGURATION_MODE ((attribute_store_type_t) 0x01000011)
///< This represents the Mode attribute in the DotDot ShadeConfiguration cluster

// ShadeConfiguration PhysicalClosedLimit
/**
 * @brief Verifies if the DotDot ShadeConfiguration PhysicalClosedLimit is supported
 *
 * @returns true if PhysicalClosedLimit is supported
 * @returns false if PhysicalClosedLimit is not supported
 */
bool dotdot_is_supported_shade_configuration_physical_closed_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PhysicalClosedLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PhysicalClosedLimit attribute
 */
uint16_t dotdot_get_shade_configuration_physical_closed_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PhysicalClosedLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_physical_closed_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_shade_configuration_physical_closed_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_physical_closed_limit);

// ShadeConfiguration MotorStepSize
/**
 * @brief Verifies if the DotDot ShadeConfiguration MotorStepSize is supported
 *
 * @returns true if MotorStepSize is supported
 * @returns false if MotorStepSize is not supported
 */
bool dotdot_is_supported_shade_configuration_motor_step_size (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MotorStepSize attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MotorStepSize attribute
 */
uint8_t dotdot_get_shade_configuration_motor_step_size(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MotorStepSize attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_motor_step_size new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_shade_configuration_motor_step_size(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_motor_step_size);

// ShadeConfiguration Status
/**
 * @brief Verifies if the DotDot ShadeConfiguration Status is supported
 *
 * @returns true if Status is supported
 * @returns false if Status is not supported
 */
bool dotdot_is_supported_shade_configuration_status (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Status attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Status attribute
 */
uint8_t dotdot_get_shade_configuration_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Status attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_status new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_shade_configuration_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_status);

// ShadeConfiguration ClosedLimit
/**
 * @brief Verifies if the DotDot ShadeConfiguration ClosedLimit is supported
 *
 * @returns true if ClosedLimit is supported
 * @returns false if ClosedLimit is not supported
 */
bool dotdot_is_supported_shade_configuration_closed_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ClosedLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ClosedLimit attribute
 */
uint16_t dotdot_get_shade_configuration_closed_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ClosedLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_closed_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_shade_configuration_closed_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_closed_limit);

// ShadeConfiguration Mode
/**
 * @brief Verifies if the DotDot ShadeConfiguration Mode is supported
 *
 * @returns true if Mode is supported
 * @returns false if Mode is not supported
 */
bool dotdot_is_supported_shade_configuration_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Mode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Mode attribute
 */
uint8_t dotdot_get_shade_configuration_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Mode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_shade_configuration_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_mode);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster DoorLock
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for DoorLock
#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_STATE ((attribute_store_type_t) 0x01010000)
///< This represents the LockState attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LOCK_TYPE ((attribute_store_type_t) 0x01010001)
///< This represents the LockType attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ACTUATOR_ENABLED ((attribute_store_type_t) 0x01010002)
///< This represents the ActuatorEnabled attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_STATE ((attribute_store_type_t) 0x01010003)
///< This represents the DoorState attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_OPEN_EVENTS ((attribute_store_type_t) 0x01010004)
///< This represents the DoorOpenEvents attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DOOR_CLOSED_EVENTS ((attribute_store_type_t) 0x01010005)
///< This represents the DoorClosedEvents attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPEN_PERIOD ((attribute_store_type_t) 0x01010006)
///< This represents the OpenPeriod attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_LOG_RECORDS_SUPPORTED ((attribute_store_type_t) 0x01010010)
///< This represents the NumberOfLogRecordsSupported attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_TOTAL_USERS_SUPPORTED ((attribute_store_type_t) 0x01010011)
///< This represents the NumberOfTotalUsersSupported attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFPIN_USERS_SUPPORTED ((attribute_store_type_t) 0x01010012)
///< This represents the NumberOfPINUsersSupported attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OFRFID_USERS_SUPPORTED ((attribute_store_type_t) 0x01010013)
///< This represents the NumberOfRFIDUsersSupported attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER ((attribute_store_type_t) 0x01010014)
///< This represents the NumberOfWeekDaySchedulesSupportedPerUser attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER ((attribute_store_type_t) 0x01010015)
///< This represents the NumberOfYearDaySchedulesSupportedPerUser attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED ((attribute_store_type_t) 0x01010016)
///< This represents the NumberOfHolidaySchedulesSupported attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXPIN_CODE_LENGTH ((attribute_store_type_t) 0x01010017)
///< This represents the MaxPINCodeLength attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINPIN_CODE_LENGTH ((attribute_store_type_t) 0x01010018)
///< This represents the MinPINCodeLength attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MAXRFID_CODE_LENGTH ((attribute_store_type_t) 0x01010019)
///< This represents the MaxRFIDCodeLength attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MINRFID_CODE_LENGTH ((attribute_store_type_t) 0x0101001a)
///< This represents the MinRFIDCodeLength attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOGGING ((attribute_store_type_t) 0x01010020)
///< This represents the EnableLogging attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LANGUAGE ((attribute_store_type_t) 0x01010021)
///< This represents the Language attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_LED_SETTINGS ((attribute_store_type_t) 0x01010022)
///< This represents the LEDSettings attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_AUTO_RELOCK_TIME ((attribute_store_type_t) 0x01010023)
///< This represents the AutoRelockTime attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SOUND_VOLUME ((attribute_store_type_t) 0x01010024)
///< This represents the SoundVolume attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_OPERATING_MODE ((attribute_store_type_t) 0x01010025)
///< This represents the OperatingMode attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SUPPORTED_OPERATING_MODES ((attribute_store_type_t) 0x01010026)
///< This represents the SupportedOperatingModes attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_DEFAULT_CONFIGURATION_REGISTER ((attribute_store_type_t) 0x01010027)
///< This represents the DefaultConfigurationRegister attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_LOCAL_PROGRAMMING ((attribute_store_type_t) 0x01010028)
///< This represents the EnableLocalProgramming attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_ONE_TOUCH_LOCKING ((attribute_store_type_t) 0x01010029)
///< This represents the EnableOneTouchLocking attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_INSIDE_STATUSLED ((attribute_store_type_t) 0x0101002a)
///< This represents the EnableInsideStatusLED attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ENABLE_PRIVACY_MODE_BUTTON ((attribute_store_type_t) 0x0101002b)
///< This represents the EnablePrivacyModeButton attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_WRONG_CODE_ENTRY_LIMIT ((attribute_store_type_t) 0x01010030)
///< This represents the WrongCodeEntryLimit attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_USER_CODE_TEMPORARY_DISABLE_TIME ((attribute_store_type_t) 0x01010031)
///< This represents the UserCodeTemporaryDisableTime attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SENDPIN_OVER_THE_AIR ((attribute_store_type_t) 0x01010032)
///< This represents the SendPINOverTheAir attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_REQUIREPI_NFORRF_OPERATION ((attribute_store_type_t) 0x01010033)
///< This represents the RequirePINforRFOperation attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_SECURITY_LEVEL ((attribute_store_type_t) 0x01010034)
///< This represents the SecurityLevel attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_ALARM_MASK ((attribute_store_type_t) 0x01010040)
///< This represents the AlarmMask attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_OPERATION_EVENT_MASK ((attribute_store_type_t) 0x01010041)
///< This represents the KeypadOperationEventMask attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_OPERATION_EVENT_MASK ((attribute_store_type_t) 0x01010042)
///< This represents the RFOperationEventMask attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_MANUAL_OPERATION_EVENT_MASK ((attribute_store_type_t) 0x01010043)
///< This represents the ManualOperationEventMask attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_OPERATION_EVENT_MASK ((attribute_store_type_t) 0x01010044)
///< This represents the RFIDOperationEventMask attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_KEYPAD_PROGRAMMING_EVENT_MASK ((attribute_store_type_t) 0x01010045)
///< This represents the KeypadProgrammingEventMask attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RF_PROGRAMMING_EVENT_MASK ((attribute_store_type_t) 0x01010046)
///< This represents the RFProgrammingEventMask attribute in the DotDot DoorLock cluster

#define DOTDOT_ATTRIBUTE_ID_DOOR_LOCK_RFID_PROGRAMMING_EVENT_MASK ((attribute_store_type_t) 0x01010047)
///< This represents the RFIDProgrammingEventMask attribute in the DotDot DoorLock cluster

// DoorLock LockState
/**
 * @brief Verifies if the DotDot DoorLock LockState is supported
 *
 * @returns true if LockState is supported
 * @returns false if LockState is not supported
 */
bool dotdot_is_supported_door_lock_lock_state (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LockState attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LockState attribute
 */
uint8_t dotdot_get_door_lock_lock_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LockState attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lock_state new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_lock_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_lock_state);

// DoorLock LockType
/**
 * @brief Verifies if the DotDot DoorLock LockType is supported
 *
 * @returns true if LockType is supported
 * @returns false if LockType is not supported
 */
bool dotdot_is_supported_door_lock_lock_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LockType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LockType attribute
 */
uint8_t dotdot_get_door_lock_lock_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LockType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lock_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_lock_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_lock_type);

// DoorLock ActuatorEnabled
/**
 * @brief Verifies if the DotDot DoorLock ActuatorEnabled is supported
 *
 * @returns true if ActuatorEnabled is supported
 * @returns false if ActuatorEnabled is not supported
 */
bool dotdot_is_supported_door_lock_actuator_enabled (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActuatorEnabled attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActuatorEnabled attribute
 */
bool dotdot_get_door_lock_actuator_enabled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActuatorEnabled attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_actuator_enabled new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_actuator_enabled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_actuator_enabled);

// DoorLock DoorState
/**
 * @brief Verifies if the DotDot DoorLock DoorState is supported
 *
 * @returns true if DoorState is supported
 * @returns false if DoorState is not supported
 */
bool dotdot_is_supported_door_lock_door_state (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DoorState attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DoorState attribute
 */
uint8_t dotdot_get_door_lock_door_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DoorState attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_door_state new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_door_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_door_state);

// DoorLock DoorOpenEvents
/**
 * @brief Verifies if the DotDot DoorLock DoorOpenEvents is supported
 *
 * @returns true if DoorOpenEvents is supported
 * @returns false if DoorOpenEvents is not supported
 */
bool dotdot_is_supported_door_lock_door_open_events (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DoorOpenEvents attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DoorOpenEvents attribute
 */
uint32_t dotdot_get_door_lock_door_open_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DoorOpenEvents attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_door_open_events new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_door_open_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_door_open_events);

// DoorLock DoorClosedEvents
/**
 * @brief Verifies if the DotDot DoorLock DoorClosedEvents is supported
 *
 * @returns true if DoorClosedEvents is supported
 * @returns false if DoorClosedEvents is not supported
 */
bool dotdot_is_supported_door_lock_door_closed_events (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DoorClosedEvents attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DoorClosedEvents attribute
 */
uint32_t dotdot_get_door_lock_door_closed_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DoorClosedEvents attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_door_closed_events new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_door_closed_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_door_closed_events);

// DoorLock OpenPeriod
/**
 * @brief Verifies if the DotDot DoorLock OpenPeriod is supported
 *
 * @returns true if OpenPeriod is supported
 * @returns false if OpenPeriod is not supported
 */
bool dotdot_is_supported_door_lock_open_period (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OpenPeriod attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OpenPeriod attribute
 */
uint16_t dotdot_get_door_lock_open_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OpenPeriod attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_open_period new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_open_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_open_period);

// DoorLock NumberOfLogRecordsSupported
/**
 * @brief Verifies if the DotDot DoorLock NumberOfLogRecordsSupported is supported
 *
 * @returns true if NumberOfLogRecordsSupported is supported
 * @returns false if NumberOfLogRecordsSupported is not supported
 */
bool dotdot_is_supported_door_lock_number_of_log_records_supported (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfLogRecordsSupported attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfLogRecordsSupported attribute
 */
uint16_t dotdot_get_door_lock_number_of_log_records_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfLogRecordsSupported attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_log_records_supported new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_number_of_log_records_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_number_of_log_records_supported);

// DoorLock NumberOfTotalUsersSupported
/**
 * @brief Verifies if the DotDot DoorLock NumberOfTotalUsersSupported is supported
 *
 * @returns true if NumberOfTotalUsersSupported is supported
 * @returns false if NumberOfTotalUsersSupported is not supported
 */
bool dotdot_is_supported_door_lock_number_of_total_users_supported (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfTotalUsersSupported attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfTotalUsersSupported attribute
 */
uint16_t dotdot_get_door_lock_number_of_total_users_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfTotalUsersSupported attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_total_users_supported new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_number_of_total_users_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_number_of_total_users_supported);

// DoorLock NumberOfPINUsersSupported
/**
 * @brief Verifies if the DotDot DoorLock NumberOfPINUsersSupported is supported
 *
 * @returns true if NumberOfPINUsersSupported is supported
 * @returns false if NumberOfPINUsersSupported is not supported
 */
bool dotdot_is_supported_door_lock_number_ofpin_users_supported (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfPINUsersSupported attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfPINUsersSupported attribute
 */
uint16_t dotdot_get_door_lock_number_ofpin_users_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfPINUsersSupported attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_ofpin_users_supported new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_number_ofpin_users_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_number_ofpin_users_supported);

// DoorLock NumberOfRFIDUsersSupported
/**
 * @brief Verifies if the DotDot DoorLock NumberOfRFIDUsersSupported is supported
 *
 * @returns true if NumberOfRFIDUsersSupported is supported
 * @returns false if NumberOfRFIDUsersSupported is not supported
 */
bool dotdot_is_supported_door_lock_number_ofrfid_users_supported (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfRFIDUsersSupported attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfRFIDUsersSupported attribute
 */
uint16_t dotdot_get_door_lock_number_ofrfid_users_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfRFIDUsersSupported attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_ofrfid_users_supported new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_number_ofrfid_users_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_number_ofrfid_users_supported);

// DoorLock NumberOfWeekDaySchedulesSupportedPerUser
/**
 * @brief Verifies if the DotDot DoorLock NumberOfWeekDaySchedulesSupportedPerUser is supported
 *
 * @returns true if NumberOfWeekDaySchedulesSupportedPerUser is supported
 * @returns false if NumberOfWeekDaySchedulesSupportedPerUser is not supported
 */
bool dotdot_is_supported_door_lock_number_of_week_day_schedules_supported_per_user (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfWeekDaySchedulesSupportedPerUser attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfWeekDaySchedulesSupportedPerUser attribute
 */
uint8_t dotdot_get_door_lock_number_of_week_day_schedules_supported_per_user(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfWeekDaySchedulesSupportedPerUser attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_week_day_schedules_supported_per_user new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_number_of_week_day_schedules_supported_per_user(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_number_of_week_day_schedules_supported_per_user);

// DoorLock NumberOfYearDaySchedulesSupportedPerUser
/**
 * @brief Verifies if the DotDot DoorLock NumberOfYearDaySchedulesSupportedPerUser is supported
 *
 * @returns true if NumberOfYearDaySchedulesSupportedPerUser is supported
 * @returns false if NumberOfYearDaySchedulesSupportedPerUser is not supported
 */
bool dotdot_is_supported_door_lock_number_of_year_day_schedules_supported_per_user (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfYearDaySchedulesSupportedPerUser attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfYearDaySchedulesSupportedPerUser attribute
 */
uint8_t dotdot_get_door_lock_number_of_year_day_schedules_supported_per_user(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfYearDaySchedulesSupportedPerUser attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_year_day_schedules_supported_per_user new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_number_of_year_day_schedules_supported_per_user(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_number_of_year_day_schedules_supported_per_user);

// DoorLock NumberOfHolidaySchedulesSupported
/**
 * @brief Verifies if the DotDot DoorLock NumberOfHolidaySchedulesSupported is supported
 *
 * @returns true if NumberOfHolidaySchedulesSupported is supported
 * @returns false if NumberOfHolidaySchedulesSupported is not supported
 */
bool dotdot_is_supported_door_lock_number_of_holiday_schedules_supported (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfHolidaySchedulesSupported attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfHolidaySchedulesSupported attribute
 */
uint8_t dotdot_get_door_lock_number_of_holiday_schedules_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfHolidaySchedulesSupported attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_holiday_schedules_supported new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_number_of_holiday_schedules_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_number_of_holiday_schedules_supported);

// DoorLock MaxPINCodeLength
/**
 * @brief Verifies if the DotDot DoorLock MaxPINCodeLength is supported
 *
 * @returns true if MaxPINCodeLength is supported
 * @returns false if MaxPINCodeLength is not supported
 */
bool dotdot_is_supported_door_lock_maxpin_code_length (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxPINCodeLength attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxPINCodeLength attribute
 */
uint8_t dotdot_get_door_lock_maxpin_code_length(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxPINCodeLength attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_maxpin_code_length new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_maxpin_code_length(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_maxpin_code_length);

// DoorLock MinPINCodeLength
/**
 * @brief Verifies if the DotDot DoorLock MinPINCodeLength is supported
 *
 * @returns true if MinPINCodeLength is supported
 * @returns false if MinPINCodeLength is not supported
 */
bool dotdot_is_supported_door_lock_minpin_code_length (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinPINCodeLength attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinPINCodeLength attribute
 */
uint8_t dotdot_get_door_lock_minpin_code_length(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinPINCodeLength attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_minpin_code_length new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_minpin_code_length(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_minpin_code_length);

// DoorLock MaxRFIDCodeLength
/**
 * @brief Verifies if the DotDot DoorLock MaxRFIDCodeLength is supported
 *
 * @returns true if MaxRFIDCodeLength is supported
 * @returns false if MaxRFIDCodeLength is not supported
 */
bool dotdot_is_supported_door_lock_maxrfid_code_length (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxRFIDCodeLength attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxRFIDCodeLength attribute
 */
uint8_t dotdot_get_door_lock_maxrfid_code_length(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxRFIDCodeLength attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_maxrfid_code_length new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_maxrfid_code_length(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_maxrfid_code_length);

// DoorLock MinRFIDCodeLength
/**
 * @brief Verifies if the DotDot DoorLock MinRFIDCodeLength is supported
 *
 * @returns true if MinRFIDCodeLength is supported
 * @returns false if MinRFIDCodeLength is not supported
 */
bool dotdot_is_supported_door_lock_minrfid_code_length (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinRFIDCodeLength attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinRFIDCodeLength attribute
 */
uint8_t dotdot_get_door_lock_minrfid_code_length(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinRFIDCodeLength attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_minrfid_code_length new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_minrfid_code_length(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_minrfid_code_length);

// DoorLock EnableLogging
/**
 * @brief Verifies if the DotDot DoorLock EnableLogging is supported
 *
 * @returns true if EnableLogging is supported
 * @returns false if EnableLogging is not supported
 */
bool dotdot_is_supported_door_lock_enable_logging (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EnableLogging attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EnableLogging attribute
 */
bool dotdot_get_door_lock_enable_logging(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EnableLogging attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_enable_logging new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_enable_logging(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_enable_logging);

// DoorLock Language
/**
 * @brief Verifies if the DotDot DoorLock Language is supported
 *
 * @returns true if Language is supported
 * @returns false if Language is not supported
 */
bool dotdot_is_supported_door_lock_language (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Language attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Language attribute
 */
const char* dotdot_get_door_lock_language(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Language attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_language new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_language(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_language);

// DoorLock LEDSettings
/**
 * @brief Verifies if the DotDot DoorLock LEDSettings is supported
 *
 * @returns true if LEDSettings is supported
 * @returns false if LEDSettings is not supported
 */
bool dotdot_is_supported_door_lock_led_settings (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LEDSettings attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LEDSettings attribute
 */
uint8_t dotdot_get_door_lock_led_settings(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LEDSettings attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_led_settings new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_led_settings(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_led_settings);

// DoorLock AutoRelockTime
/**
 * @brief Verifies if the DotDot DoorLock AutoRelockTime is supported
 *
 * @returns true if AutoRelockTime is supported
 * @returns false if AutoRelockTime is not supported
 */
bool dotdot_is_supported_door_lock_auto_relock_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AutoRelockTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AutoRelockTime attribute
 */
uint32_t dotdot_get_door_lock_auto_relock_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AutoRelockTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_auto_relock_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_auto_relock_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_auto_relock_time);

// DoorLock SoundVolume
/**
 * @brief Verifies if the DotDot DoorLock SoundVolume is supported
 *
 * @returns true if SoundVolume is supported
 * @returns false if SoundVolume is not supported
 */
bool dotdot_is_supported_door_lock_sound_volume (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SoundVolume attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SoundVolume attribute
 */
uint8_t dotdot_get_door_lock_sound_volume(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SoundVolume attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_sound_volume new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_sound_volume(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_sound_volume);

// DoorLock OperatingMode
/**
 * @brief Verifies if the DotDot DoorLock OperatingMode is supported
 *
 * @returns true if OperatingMode is supported
 * @returns false if OperatingMode is not supported
 */
bool dotdot_is_supported_door_lock_operating_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OperatingMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OperatingMode attribute
 */
DrlkOperMode dotdot_get_door_lock_operating_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OperatingMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_operating_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_operating_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  DrlkOperMode new_operating_mode);

// DoorLock SupportedOperatingModes
/**
 * @brief Verifies if the DotDot DoorLock SupportedOperatingModes is supported
 *
 * @returns true if SupportedOperatingModes is supported
 * @returns false if SupportedOperatingModes is not supported
 */
bool dotdot_is_supported_door_lock_supported_operating_modes (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SupportedOperatingModes attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SupportedOperatingModes attribute
 */
uint16_t dotdot_get_door_lock_supported_operating_modes(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SupportedOperatingModes attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_supported_operating_modes new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_supported_operating_modes(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_supported_operating_modes);

// DoorLock DefaultConfigurationRegister
/**
 * @brief Verifies if the DotDot DoorLock DefaultConfigurationRegister is supported
 *
 * @returns true if DefaultConfigurationRegister is supported
 * @returns false if DefaultConfigurationRegister is not supported
 */
bool dotdot_is_supported_door_lock_default_configuration_register (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DefaultConfigurationRegister attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DefaultConfigurationRegister attribute
 */
uint16_t dotdot_get_door_lock_default_configuration_register(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DefaultConfigurationRegister attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_default_configuration_register new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_default_configuration_register(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_default_configuration_register);

// DoorLock EnableLocalProgramming
/**
 * @brief Verifies if the DotDot DoorLock EnableLocalProgramming is supported
 *
 * @returns true if EnableLocalProgramming is supported
 * @returns false if EnableLocalProgramming is not supported
 */
bool dotdot_is_supported_door_lock_enable_local_programming (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EnableLocalProgramming attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EnableLocalProgramming attribute
 */
bool dotdot_get_door_lock_enable_local_programming(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EnableLocalProgramming attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_enable_local_programming new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_enable_local_programming(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_enable_local_programming);

// DoorLock EnableOneTouchLocking
/**
 * @brief Verifies if the DotDot DoorLock EnableOneTouchLocking is supported
 *
 * @returns true if EnableOneTouchLocking is supported
 * @returns false if EnableOneTouchLocking is not supported
 */
bool dotdot_is_supported_door_lock_enable_one_touch_locking (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EnableOneTouchLocking attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EnableOneTouchLocking attribute
 */
bool dotdot_get_door_lock_enable_one_touch_locking(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EnableOneTouchLocking attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_enable_one_touch_locking new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_enable_one_touch_locking(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_enable_one_touch_locking);

// DoorLock EnableInsideStatusLED
/**
 * @brief Verifies if the DotDot DoorLock EnableInsideStatusLED is supported
 *
 * @returns true if EnableInsideStatusLED is supported
 * @returns false if EnableInsideStatusLED is not supported
 */
bool dotdot_is_supported_door_lock_enable_inside_statusled (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EnableInsideStatusLED attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EnableInsideStatusLED attribute
 */
bool dotdot_get_door_lock_enable_inside_statusled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EnableInsideStatusLED attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_enable_inside_statusled new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_enable_inside_statusled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_enable_inside_statusled);

// DoorLock EnablePrivacyModeButton
/**
 * @brief Verifies if the DotDot DoorLock EnablePrivacyModeButton is supported
 *
 * @returns true if EnablePrivacyModeButton is supported
 * @returns false if EnablePrivacyModeButton is not supported
 */
bool dotdot_is_supported_door_lock_enable_privacy_mode_button (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EnablePrivacyModeButton attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EnablePrivacyModeButton attribute
 */
bool dotdot_get_door_lock_enable_privacy_mode_button(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EnablePrivacyModeButton attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_enable_privacy_mode_button new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_enable_privacy_mode_button(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_enable_privacy_mode_button);

// DoorLock WrongCodeEntryLimit
/**
 * @brief Verifies if the DotDot DoorLock WrongCodeEntryLimit is supported
 *
 * @returns true if WrongCodeEntryLimit is supported
 * @returns false if WrongCodeEntryLimit is not supported
 */
bool dotdot_is_supported_door_lock_wrong_code_entry_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot WrongCodeEntryLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns WrongCodeEntryLimit attribute
 */
uint8_t dotdot_get_door_lock_wrong_code_entry_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot WrongCodeEntryLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_wrong_code_entry_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_wrong_code_entry_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_wrong_code_entry_limit);

// DoorLock UserCodeTemporaryDisableTime
/**
 * @brief Verifies if the DotDot DoorLock UserCodeTemporaryDisableTime is supported
 *
 * @returns true if UserCodeTemporaryDisableTime is supported
 * @returns false if UserCodeTemporaryDisableTime is not supported
 */
bool dotdot_is_supported_door_lock_user_code_temporary_disable_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UserCodeTemporaryDisableTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UserCodeTemporaryDisableTime attribute
 */
uint8_t dotdot_get_door_lock_user_code_temporary_disable_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UserCodeTemporaryDisableTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_user_code_temporary_disable_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_user_code_temporary_disable_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_user_code_temporary_disable_time);

// DoorLock SendPINOverTheAir
/**
 * @brief Verifies if the DotDot DoorLock SendPINOverTheAir is supported
 *
 * @returns true if SendPINOverTheAir is supported
 * @returns false if SendPINOverTheAir is not supported
 */
bool dotdot_is_supported_door_lock_sendpin_over_the_air (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SendPINOverTheAir attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SendPINOverTheAir attribute
 */
bool dotdot_get_door_lock_sendpin_over_the_air(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SendPINOverTheAir attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_sendpin_over_the_air new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_sendpin_over_the_air(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_sendpin_over_the_air);

// DoorLock RequirePINforRFOperation
/**
 * @brief Verifies if the DotDot DoorLock RequirePINforRFOperation is supported
 *
 * @returns true if RequirePINforRFOperation is supported
 * @returns false if RequirePINforRFOperation is not supported
 */
bool dotdot_is_supported_door_lock_requirepi_nforrf_operation (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RequirePINforRFOperation attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RequirePINforRFOperation attribute
 */
bool dotdot_get_door_lock_requirepi_nforrf_operation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RequirePINforRFOperation attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_requirepi_nforrf_operation new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_requirepi_nforrf_operation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_requirepi_nforrf_operation);

// DoorLock SecurityLevel
/**
 * @brief Verifies if the DotDot DoorLock SecurityLevel is supported
 *
 * @returns true if SecurityLevel is supported
 * @returns false if SecurityLevel is not supported
 */
bool dotdot_is_supported_door_lock_security_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SecurityLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SecurityLevel attribute
 */
uint8_t dotdot_get_door_lock_security_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SecurityLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_security_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_security_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_security_level);

// DoorLock AlarmMask
/**
 * @brief Verifies if the DotDot DoorLock AlarmMask is supported
 *
 * @returns true if AlarmMask is supported
 * @returns false if AlarmMask is not supported
 */
bool dotdot_is_supported_door_lock_alarm_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AlarmMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AlarmMask attribute
 */
uint16_t dotdot_get_door_lock_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AlarmMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_alarm_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_alarm_mask);

// DoorLock KeypadOperationEventMask
/**
 * @brief Verifies if the DotDot DoorLock KeypadOperationEventMask is supported
 *
 * @returns true if KeypadOperationEventMask is supported
 * @returns false if KeypadOperationEventMask is not supported
 */
bool dotdot_is_supported_door_lock_keypad_operation_event_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot KeypadOperationEventMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns KeypadOperationEventMask attribute
 */
uint16_t dotdot_get_door_lock_keypad_operation_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot KeypadOperationEventMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_keypad_operation_event_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_keypad_operation_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_keypad_operation_event_mask);

// DoorLock RFOperationEventMask
/**
 * @brief Verifies if the DotDot DoorLock RFOperationEventMask is supported
 *
 * @returns true if RFOperationEventMask is supported
 * @returns false if RFOperationEventMask is not supported
 */
bool dotdot_is_supported_door_lock_rf_operation_event_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RFOperationEventMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RFOperationEventMask attribute
 */
uint16_t dotdot_get_door_lock_rf_operation_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RFOperationEventMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rf_operation_event_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_rf_operation_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rf_operation_event_mask);

// DoorLock ManualOperationEventMask
/**
 * @brief Verifies if the DotDot DoorLock ManualOperationEventMask is supported
 *
 * @returns true if ManualOperationEventMask is supported
 * @returns false if ManualOperationEventMask is not supported
 */
bool dotdot_is_supported_door_lock_manual_operation_event_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ManualOperationEventMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ManualOperationEventMask attribute
 */
uint16_t dotdot_get_door_lock_manual_operation_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ManualOperationEventMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_manual_operation_event_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_manual_operation_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_manual_operation_event_mask);

// DoorLock RFIDOperationEventMask
/**
 * @brief Verifies if the DotDot DoorLock RFIDOperationEventMask is supported
 *
 * @returns true if RFIDOperationEventMask is supported
 * @returns false if RFIDOperationEventMask is not supported
 */
bool dotdot_is_supported_door_lock_rfid_operation_event_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RFIDOperationEventMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RFIDOperationEventMask attribute
 */
uint16_t dotdot_get_door_lock_rfid_operation_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RFIDOperationEventMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rfid_operation_event_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_rfid_operation_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rfid_operation_event_mask);

// DoorLock KeypadProgrammingEventMask
/**
 * @brief Verifies if the DotDot DoorLock KeypadProgrammingEventMask is supported
 *
 * @returns true if KeypadProgrammingEventMask is supported
 * @returns false if KeypadProgrammingEventMask is not supported
 */
bool dotdot_is_supported_door_lock_keypad_programming_event_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot KeypadProgrammingEventMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns KeypadProgrammingEventMask attribute
 */
uint16_t dotdot_get_door_lock_keypad_programming_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot KeypadProgrammingEventMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_keypad_programming_event_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_keypad_programming_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_keypad_programming_event_mask);

// DoorLock RFProgrammingEventMask
/**
 * @brief Verifies if the DotDot DoorLock RFProgrammingEventMask is supported
 *
 * @returns true if RFProgrammingEventMask is supported
 * @returns false if RFProgrammingEventMask is not supported
 */
bool dotdot_is_supported_door_lock_rf_programming_event_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RFProgrammingEventMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RFProgrammingEventMask attribute
 */
uint16_t dotdot_get_door_lock_rf_programming_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RFProgrammingEventMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rf_programming_event_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_rf_programming_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rf_programming_event_mask);

// DoorLock RFIDProgrammingEventMask
/**
 * @brief Verifies if the DotDot DoorLock RFIDProgrammingEventMask is supported
 *
 * @returns true if RFIDProgrammingEventMask is supported
 * @returns false if RFIDProgrammingEventMask is not supported
 */
bool dotdot_is_supported_door_lock_rfid_programming_event_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RFIDProgrammingEventMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RFIDProgrammingEventMask attribute
 */
uint16_t dotdot_get_door_lock_rfid_programming_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RFIDProgrammingEventMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rfid_programming_event_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_door_lock_rfid_programming_event_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rfid_programming_event_mask);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster WindowCovering
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for WindowCovering
#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_WINDOW_COVERING_TYPE ((attribute_store_type_t) 0x01020000)
///< This represents the WindowCoveringType attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_LIFT ((attribute_store_type_t) 0x01020001)
///< This represents the PhysicalClosedLimitLift attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_PHYSICAL_CLOSED_LIMIT_TILT ((attribute_store_type_t) 0x01020002)
///< This represents the PhysicalClosedLimitTilt attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT ((attribute_store_type_t) 0x01020003)
///< This represents the CurrentPositionLift attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT ((attribute_store_type_t) 0x01020004)
///< This represents the CurrentPositionTilt attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_LIFT ((attribute_store_type_t) 0x01020005)
///< This represents the NumberOfActuationsLift attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_NUMBER_OF_ACTUATIONS_TILT ((attribute_store_type_t) 0x01020006)
///< This represents the NumberOfActuationsTilt attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CONFIG_OR_STATUS ((attribute_store_type_t) 0x01020007)
///< This represents the ConfigOrStatus attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_LIFT_PERCENTAGE ((attribute_store_type_t) 0x01020008)
///< This represents the CurrentPositionLiftPercentage attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_CURRENT_POSITION_TILT_PERCENTAGE ((attribute_store_type_t) 0x01020009)
///< This represents the CurrentPositionTiltPercentage attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_LIFT ((attribute_store_type_t) 0x01020100)
///< This represents the InstalledOpenLimitLift attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_LIFT ((attribute_store_type_t) 0x01020101)
///< This represents the InstalledClosedLimitLift attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_OPEN_LIMIT_TILT ((attribute_store_type_t) 0x01020102)
///< This represents the InstalledOpenLimitTilt attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INSTALLED_CLOSED_LIMIT_TILT ((attribute_store_type_t) 0x01020103)
///< This represents the InstalledClosedLimitTilt attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_VELOCITY_LIFT ((attribute_store_type_t) 0x01020104)
///< This represents the VelocityLift attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_ACCELERATION_TIME_LIFT ((attribute_store_type_t) 0x01020105)
///< This represents the AccelerationTimeLift attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_DECELERATION_TIME_LIFT ((attribute_store_type_t) 0x01020106)
///< This represents the DecelerationTimeLift attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_MODE ((attribute_store_type_t) 0x01020107)
///< This represents the Mode attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_LIFT ((attribute_store_type_t) 0x01020108)
///< This represents the IntermediateSetpointsLift attribute in the DotDot WindowCovering cluster

#define DOTDOT_ATTRIBUTE_ID_WINDOW_COVERING_INTERMEDIATE_SETPOINTS_TILT ((attribute_store_type_t) 0x01020109)
///< This represents the IntermediateSetpointsTilt attribute in the DotDot WindowCovering cluster

// WindowCovering WindowCoveringType
/**
 * @brief Verifies if the DotDot WindowCovering WindowCoveringType is supported
 *
 * @returns true if WindowCoveringType is supported
 * @returns false if WindowCoveringType is not supported
 */
bool dotdot_is_supported_window_covering_window_covering_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot WindowCoveringType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns WindowCoveringType attribute
 */
uint8_t dotdot_get_window_covering_window_covering_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot WindowCoveringType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_window_covering_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_window_covering_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_window_covering_type);

// WindowCovering PhysicalClosedLimitLift
/**
 * @brief Verifies if the DotDot WindowCovering PhysicalClosedLimitLift is supported
 *
 * @returns true if PhysicalClosedLimitLift is supported
 * @returns false if PhysicalClosedLimitLift is not supported
 */
bool dotdot_is_supported_window_covering_physical_closed_limit_lift (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PhysicalClosedLimitLift attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PhysicalClosedLimitLift attribute
 */
uint16_t dotdot_get_window_covering_physical_closed_limit_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PhysicalClosedLimitLift attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_physical_closed_limit_lift new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_physical_closed_limit_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_physical_closed_limit_lift);

// WindowCovering PhysicalClosedLimitTilt
/**
 * @brief Verifies if the DotDot WindowCovering PhysicalClosedLimitTilt is supported
 *
 * @returns true if PhysicalClosedLimitTilt is supported
 * @returns false if PhysicalClosedLimitTilt is not supported
 */
bool dotdot_is_supported_window_covering_physical_closed_limit_tilt (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PhysicalClosedLimitTilt attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PhysicalClosedLimitTilt attribute
 */
uint16_t dotdot_get_window_covering_physical_closed_limit_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PhysicalClosedLimitTilt attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_physical_closed_limit_tilt new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_physical_closed_limit_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_physical_closed_limit_tilt);

// WindowCovering CurrentPositionLift
/**
 * @brief Verifies if the DotDot WindowCovering CurrentPositionLift is supported
 *
 * @returns true if CurrentPositionLift is supported
 * @returns false if CurrentPositionLift is not supported
 */
bool dotdot_is_supported_window_covering_current_position_lift (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentPositionLift attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentPositionLift attribute
 */
uint16_t dotdot_get_window_covering_current_position_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentPositionLift attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_position_lift new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_current_position_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_current_position_lift);

// WindowCovering CurrentPositionTilt
/**
 * @brief Verifies if the DotDot WindowCovering CurrentPositionTilt is supported
 *
 * @returns true if CurrentPositionTilt is supported
 * @returns false if CurrentPositionTilt is not supported
 */
bool dotdot_is_supported_window_covering_current_position_tilt (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentPositionTilt attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentPositionTilt attribute
 */
uint16_t dotdot_get_window_covering_current_position_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentPositionTilt attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_position_tilt new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_current_position_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_current_position_tilt);

// WindowCovering NumberOfActuationsLift
/**
 * @brief Verifies if the DotDot WindowCovering NumberOfActuationsLift is supported
 *
 * @returns true if NumberOfActuationsLift is supported
 * @returns false if NumberOfActuationsLift is not supported
 */
bool dotdot_is_supported_window_covering_number_of_actuations_lift (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfActuationsLift attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfActuationsLift attribute
 */
uint16_t dotdot_get_window_covering_number_of_actuations_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfActuationsLift attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_actuations_lift new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_number_of_actuations_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_number_of_actuations_lift);

// WindowCovering NumberOfActuationsTilt
/**
 * @brief Verifies if the DotDot WindowCovering NumberOfActuationsTilt is supported
 *
 * @returns true if NumberOfActuationsTilt is supported
 * @returns false if NumberOfActuationsTilt is not supported
 */
bool dotdot_is_supported_window_covering_number_of_actuations_tilt (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfActuationsTilt attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfActuationsTilt attribute
 */
uint16_t dotdot_get_window_covering_number_of_actuations_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfActuationsTilt attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_actuations_tilt new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_number_of_actuations_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_number_of_actuations_tilt);

// WindowCovering ConfigOrStatus
/**
 * @brief Verifies if the DotDot WindowCovering ConfigOrStatus is supported
 *
 * @returns true if ConfigOrStatus is supported
 * @returns false if ConfigOrStatus is not supported
 */
bool dotdot_is_supported_window_covering_config_or_status (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ConfigOrStatus attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ConfigOrStatus attribute
 */
uint8_t dotdot_get_window_covering_config_or_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ConfigOrStatus attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_config_or_status new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_config_or_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_config_or_status);

// WindowCovering CurrentPositionLiftPercentage
/**
 * @brief Verifies if the DotDot WindowCovering CurrentPositionLiftPercentage is supported
 *
 * @returns true if CurrentPositionLiftPercentage is supported
 * @returns false if CurrentPositionLiftPercentage is not supported
 */
bool dotdot_is_supported_window_covering_current_position_lift_percentage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentPositionLiftPercentage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentPositionLiftPercentage attribute
 */
uint8_t dotdot_get_window_covering_current_position_lift_percentage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentPositionLiftPercentage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_position_lift_percentage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_current_position_lift_percentage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_current_position_lift_percentage);

// WindowCovering CurrentPositionTiltPercentage
/**
 * @brief Verifies if the DotDot WindowCovering CurrentPositionTiltPercentage is supported
 *
 * @returns true if CurrentPositionTiltPercentage is supported
 * @returns false if CurrentPositionTiltPercentage is not supported
 */
bool dotdot_is_supported_window_covering_current_position_tilt_percentage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentPositionTiltPercentage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentPositionTiltPercentage attribute
 */
uint8_t dotdot_get_window_covering_current_position_tilt_percentage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentPositionTiltPercentage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_position_tilt_percentage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_current_position_tilt_percentage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_current_position_tilt_percentage);

// WindowCovering InstalledOpenLimitLift
/**
 * @brief Verifies if the DotDot WindowCovering InstalledOpenLimitLift is supported
 *
 * @returns true if InstalledOpenLimitLift is supported
 * @returns false if InstalledOpenLimitLift is not supported
 */
bool dotdot_is_supported_window_covering_installed_open_limit_lift (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot InstalledOpenLimitLift attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns InstalledOpenLimitLift attribute
 */
uint16_t dotdot_get_window_covering_installed_open_limit_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot InstalledOpenLimitLift attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_installed_open_limit_lift new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_installed_open_limit_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_installed_open_limit_lift);

// WindowCovering InstalledClosedLimitLift
/**
 * @brief Verifies if the DotDot WindowCovering InstalledClosedLimitLift is supported
 *
 * @returns true if InstalledClosedLimitLift is supported
 * @returns false if InstalledClosedLimitLift is not supported
 */
bool dotdot_is_supported_window_covering_installed_closed_limit_lift (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot InstalledClosedLimitLift attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns InstalledClosedLimitLift attribute
 */
uint16_t dotdot_get_window_covering_installed_closed_limit_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot InstalledClosedLimitLift attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_installed_closed_limit_lift new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_installed_closed_limit_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_installed_closed_limit_lift);

// WindowCovering InstalledOpenLimitTilt
/**
 * @brief Verifies if the DotDot WindowCovering InstalledOpenLimitTilt is supported
 *
 * @returns true if InstalledOpenLimitTilt is supported
 * @returns false if InstalledOpenLimitTilt is not supported
 */
bool dotdot_is_supported_window_covering_installed_open_limit_tilt (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot InstalledOpenLimitTilt attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns InstalledOpenLimitTilt attribute
 */
uint16_t dotdot_get_window_covering_installed_open_limit_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot InstalledOpenLimitTilt attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_installed_open_limit_tilt new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_installed_open_limit_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_installed_open_limit_tilt);

// WindowCovering InstalledClosedLimitTilt
/**
 * @brief Verifies if the DotDot WindowCovering InstalledClosedLimitTilt is supported
 *
 * @returns true if InstalledClosedLimitTilt is supported
 * @returns false if InstalledClosedLimitTilt is not supported
 */
bool dotdot_is_supported_window_covering_installed_closed_limit_tilt (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot InstalledClosedLimitTilt attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns InstalledClosedLimitTilt attribute
 */
uint16_t dotdot_get_window_covering_installed_closed_limit_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot InstalledClosedLimitTilt attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_installed_closed_limit_tilt new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_installed_closed_limit_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_installed_closed_limit_tilt);

// WindowCovering VelocityLift
/**
 * @brief Verifies if the DotDot WindowCovering VelocityLift is supported
 *
 * @returns true if VelocityLift is supported
 * @returns false if VelocityLift is not supported
 */
bool dotdot_is_supported_window_covering_velocity_lift (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot VelocityLift attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns VelocityLift attribute
 */
uint16_t dotdot_get_window_covering_velocity_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot VelocityLift attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_velocity_lift new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_velocity_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_velocity_lift);

// WindowCovering AccelerationTimeLift
/**
 * @brief Verifies if the DotDot WindowCovering AccelerationTimeLift is supported
 *
 * @returns true if AccelerationTimeLift is supported
 * @returns false if AccelerationTimeLift is not supported
 */
bool dotdot_is_supported_window_covering_acceleration_time_lift (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AccelerationTimeLift attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AccelerationTimeLift attribute
 */
uint16_t dotdot_get_window_covering_acceleration_time_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AccelerationTimeLift attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_acceleration_time_lift new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_acceleration_time_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_acceleration_time_lift);

// WindowCovering DecelerationTimeLift
/**
 * @brief Verifies if the DotDot WindowCovering DecelerationTimeLift is supported
 *
 * @returns true if DecelerationTimeLift is supported
 * @returns false if DecelerationTimeLift is not supported
 */
bool dotdot_is_supported_window_covering_deceleration_time_lift (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DecelerationTimeLift attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DecelerationTimeLift attribute
 */
uint16_t dotdot_get_window_covering_deceleration_time_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DecelerationTimeLift attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_deceleration_time_lift new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_deceleration_time_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_deceleration_time_lift);

// WindowCovering Mode
/**
 * @brief Verifies if the DotDot WindowCovering Mode is supported
 *
 * @returns true if Mode is supported
 * @returns false if Mode is not supported
 */
bool dotdot_is_supported_window_covering_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Mode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Mode attribute
 */
uint8_t dotdot_get_window_covering_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Mode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_mode);

// WindowCovering IntermediateSetpointsLift
/**
 * @brief Verifies if the DotDot WindowCovering IntermediateSetpointsLift is supported
 *
 * @returns true if IntermediateSetpointsLift is supported
 * @returns false if IntermediateSetpointsLift is not supported
 */
bool dotdot_is_supported_window_covering_intermediate_setpoints_lift (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot IntermediateSetpointsLift attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns IntermediateSetpointsLift attribute
 */
const char* dotdot_get_window_covering_intermediate_setpoints_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot IntermediateSetpointsLift attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_intermediate_setpoints_lift new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_intermediate_setpoints_lift(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_intermediate_setpoints_lift);

// WindowCovering IntermediateSetpointsTilt
/**
 * @brief Verifies if the DotDot WindowCovering IntermediateSetpointsTilt is supported
 *
 * @returns true if IntermediateSetpointsTilt is supported
 * @returns false if IntermediateSetpointsTilt is not supported
 */
bool dotdot_is_supported_window_covering_intermediate_setpoints_tilt (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot IntermediateSetpointsTilt attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns IntermediateSetpointsTilt attribute
 */
const char* dotdot_get_window_covering_intermediate_setpoints_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot IntermediateSetpointsTilt attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_intermediate_setpoints_tilt new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_window_covering_intermediate_setpoints_tilt(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_intermediate_setpoints_tilt);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster BarrierControl
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for BarrierControl
#define DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_MOVING_STATE ((attribute_store_type_t) 0x01030001)
///< This represents the MovingState attribute in the DotDot BarrierControl cluster

#define DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_SAFETY_STATUS ((attribute_store_type_t) 0x01030002)
///< This represents the SafetyStatus attribute in the DotDot BarrierControl cluster

#define DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CAPABILITIES ((attribute_store_type_t) 0x01030003)
///< This represents the Capabilities attribute in the DotDot BarrierControl cluster

#define DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_EVENTS ((attribute_store_type_t) 0x01030004)
///< This represents the OpenEvents attribute in the DotDot BarrierControl cluster

#define DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_EVENTS ((attribute_store_type_t) 0x01030005)
///< This represents the CloseEvents attribute in the DotDot BarrierControl cluster

#define DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_OPEN_EVENTS ((attribute_store_type_t) 0x01030006)
///< This represents the CommandOpenEvents attribute in the DotDot BarrierControl cluster

#define DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_COMMAND_CLOSE_EVENTS ((attribute_store_type_t) 0x01030007)
///< This represents the CommandCloseEvents attribute in the DotDot BarrierControl cluster

#define DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_OPEN_PERIOD ((attribute_store_type_t) 0x01030008)
///< This represents the OpenPeriod attribute in the DotDot BarrierControl cluster

#define DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_CLOSE_PERIOD ((attribute_store_type_t) 0x01030009)
///< This represents the ClosePeriod attribute in the DotDot BarrierControl cluster

#define DOTDOT_ATTRIBUTE_ID_BARRIER_CONTROL_BARRIER_POSITION ((attribute_store_type_t) 0x0103000a)
///< This represents the BarrierPosition attribute in the DotDot BarrierControl cluster

// BarrierControl MovingState
/**
 * @brief Verifies if the DotDot BarrierControl MovingState is supported
 *
 * @returns true if MovingState is supported
 * @returns false if MovingState is not supported
 */
bool dotdot_is_supported_barrier_control_moving_state (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MovingState attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MovingState attribute
 */
uint8_t dotdot_get_barrier_control_moving_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MovingState attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_moving_state new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_barrier_control_moving_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_moving_state);

// BarrierControl SafetyStatus
/**
 * @brief Verifies if the DotDot BarrierControl SafetyStatus is supported
 *
 * @returns true if SafetyStatus is supported
 * @returns false if SafetyStatus is not supported
 */
bool dotdot_is_supported_barrier_control_safety_status (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SafetyStatus attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SafetyStatus attribute
 */
uint16_t dotdot_get_barrier_control_safety_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SafetyStatus attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_safety_status new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_barrier_control_safety_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_safety_status);

// BarrierControl Capabilities
/**
 * @brief Verifies if the DotDot BarrierControl Capabilities is supported
 *
 * @returns true if Capabilities is supported
 * @returns false if Capabilities is not supported
 */
bool dotdot_is_supported_barrier_control_capabilities (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Capabilities attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Capabilities attribute
 */
uint8_t dotdot_get_barrier_control_capabilities(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Capabilities attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_capabilities new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_barrier_control_capabilities(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_capabilities);

// BarrierControl OpenEvents
/**
 * @brief Verifies if the DotDot BarrierControl OpenEvents is supported
 *
 * @returns true if OpenEvents is supported
 * @returns false if OpenEvents is not supported
 */
bool dotdot_is_supported_barrier_control_open_events (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OpenEvents attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OpenEvents attribute
 */
uint16_t dotdot_get_barrier_control_open_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OpenEvents attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_open_events new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_barrier_control_open_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_open_events);

// BarrierControl CloseEvents
/**
 * @brief Verifies if the DotDot BarrierControl CloseEvents is supported
 *
 * @returns true if CloseEvents is supported
 * @returns false if CloseEvents is not supported
 */
bool dotdot_is_supported_barrier_control_close_events (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CloseEvents attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CloseEvents attribute
 */
uint16_t dotdot_get_barrier_control_close_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CloseEvents attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_close_events new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_barrier_control_close_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_close_events);

// BarrierControl CommandOpenEvents
/**
 * @brief Verifies if the DotDot BarrierControl CommandOpenEvents is supported
 *
 * @returns true if CommandOpenEvents is supported
 * @returns false if CommandOpenEvents is not supported
 */
bool dotdot_is_supported_barrier_control_command_open_events (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CommandOpenEvents attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CommandOpenEvents attribute
 */
uint16_t dotdot_get_barrier_control_command_open_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CommandOpenEvents attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_command_open_events new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_barrier_control_command_open_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_command_open_events);

// BarrierControl CommandCloseEvents
/**
 * @brief Verifies if the DotDot BarrierControl CommandCloseEvents is supported
 *
 * @returns true if CommandCloseEvents is supported
 * @returns false if CommandCloseEvents is not supported
 */
bool dotdot_is_supported_barrier_control_command_close_events (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CommandCloseEvents attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CommandCloseEvents attribute
 */
uint16_t dotdot_get_barrier_control_command_close_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CommandCloseEvents attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_command_close_events new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_barrier_control_command_close_events(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_command_close_events);

// BarrierControl OpenPeriod
/**
 * @brief Verifies if the DotDot BarrierControl OpenPeriod is supported
 *
 * @returns true if OpenPeriod is supported
 * @returns false if OpenPeriod is not supported
 */
bool dotdot_is_supported_barrier_control_open_period (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OpenPeriod attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OpenPeriod attribute
 */
uint16_t dotdot_get_barrier_control_open_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OpenPeriod attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_open_period new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_barrier_control_open_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_open_period);

// BarrierControl ClosePeriod
/**
 * @brief Verifies if the DotDot BarrierControl ClosePeriod is supported
 *
 * @returns true if ClosePeriod is supported
 * @returns false if ClosePeriod is not supported
 */
bool dotdot_is_supported_barrier_control_close_period (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ClosePeriod attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ClosePeriod attribute
 */
uint16_t dotdot_get_barrier_control_close_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ClosePeriod attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_close_period new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_barrier_control_close_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_close_period);

// BarrierControl BarrierPosition
/**
 * @brief Verifies if the DotDot BarrierControl BarrierPosition is supported
 *
 * @returns true if BarrierPosition is supported
 * @returns false if BarrierPosition is not supported
 */
bool dotdot_is_supported_barrier_control_barrier_position (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BarrierPosition attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BarrierPosition attribute
 */
uint8_t dotdot_get_barrier_control_barrier_position(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BarrierPosition attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_barrier_position new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_barrier_control_barrier_position(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_barrier_position);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster PumpConfigurationAndControl
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for PumpConfigurationAndControl
#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_PRESSURE ((attribute_store_type_t) 0x02000000)
///< This represents the MaxPressure attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_SPEED ((attribute_store_type_t) 0x02000001)
///< This represents the MaxSpeed attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_FLOW ((attribute_store_type_t) 0x02000002)
///< This represents the MaxFlow attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_PRESSURE ((attribute_store_type_t) 0x02000003)
///< This represents the MinConstPressure attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_PRESSURE ((attribute_store_type_t) 0x02000004)
///< This represents the MaxConstPressure attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_COMP_PRESSURE ((attribute_store_type_t) 0x02000005)
///< This represents the MinCompPressure attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_COMP_PRESSURE ((attribute_store_type_t) 0x02000006)
///< This represents the MaxCompPressure attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_SPEED ((attribute_store_type_t) 0x02000007)
///< This represents the MinConstSpeed attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_SPEED ((attribute_store_type_t) 0x02000008)
///< This represents the MaxConstSpeed attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_FLOW ((attribute_store_type_t) 0x02000009)
///< This represents the MinConstFlow attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_FLOW ((attribute_store_type_t) 0x0200000a)
///< This represents the MaxConstFlow attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MIN_CONST_TEMP ((attribute_store_type_t) 0x0200000b)
///< This represents the MinConstTemp attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_MAX_CONST_TEMP ((attribute_store_type_t) 0x0200000c)
///< This represents the MaxConstTemp attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_PUMP_STATUS ((attribute_store_type_t) 0x02000010)
///< This represents the PumpStatus attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_OPERATION_MODE ((attribute_store_type_t) 0x02000011)
///< This represents the EffectiveOperationMode attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_EFFECTIVE_CONTROL_MODE ((attribute_store_type_t) 0x02000012)
///< This represents the EffectiveControlMode attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CAPACITY ((attribute_store_type_t) 0x02000013)
///< This represents the Capacity attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_SPEED ((attribute_store_type_t) 0x02000014)
///< This represents the Speed attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_RUNNING_HOURS ((attribute_store_type_t) 0x02000015)
///< This represents the LifetimeRunningHours attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_POWER ((attribute_store_type_t) 0x02000016)
///< This represents the Power attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_LIFETIME_ENERGY_CONSUMED ((attribute_store_type_t) 0x02000017)
///< This represents the LifetimeEnergyConsumed attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_OPERATION_MODE ((attribute_store_type_t) 0x02000020)
///< This represents the OperationMode attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_CONTROL_MODE ((attribute_store_type_t) 0x02000021)
///< This represents the ControlMode attribute in the DotDot PumpConfigurationAndControl cluster

#define DOTDOT_ATTRIBUTE_ID_PUMP_CONFIGURATION_AND_CONTROL_ALARM_MASK ((attribute_store_type_t) 0x02000022)
///< This represents the AlarmMask attribute in the DotDot PumpConfigurationAndControl cluster

// PumpConfigurationAndControl MaxPressure
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MaxPressure is supported
 *
 * @returns true if MaxPressure is supported
 * @returns false if MaxPressure is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_max_pressure (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxPressure attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxPressure attribute
 */
int16_t dotdot_get_pump_configuration_and_control_max_pressure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxPressure attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_pressure new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_max_pressure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_max_pressure);

// PumpConfigurationAndControl MaxSpeed
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MaxSpeed is supported
 *
 * @returns true if MaxSpeed is supported
 * @returns false if MaxSpeed is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_max_speed (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxSpeed attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxSpeed attribute
 */
uint16_t dotdot_get_pump_configuration_and_control_max_speed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxSpeed attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_speed new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_max_speed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_speed);

// PumpConfigurationAndControl MaxFlow
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MaxFlow is supported
 *
 * @returns true if MaxFlow is supported
 * @returns false if MaxFlow is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_max_flow (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxFlow attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxFlow attribute
 */
uint16_t dotdot_get_pump_configuration_and_control_max_flow(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxFlow attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_flow new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_max_flow(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_flow);

// PumpConfigurationAndControl MinConstPressure
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MinConstPressure is supported
 *
 * @returns true if MinConstPressure is supported
 * @returns false if MinConstPressure is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_min_const_pressure (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinConstPressure attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinConstPressure attribute
 */
int16_t dotdot_get_pump_configuration_and_control_min_const_pressure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinConstPressure attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_const_pressure new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_min_const_pressure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_min_const_pressure);

// PumpConfigurationAndControl MaxConstPressure
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MaxConstPressure is supported
 *
 * @returns true if MaxConstPressure is supported
 * @returns false if MaxConstPressure is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_max_const_pressure (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxConstPressure attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxConstPressure attribute
 */
int16_t dotdot_get_pump_configuration_and_control_max_const_pressure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxConstPressure attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_const_pressure new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_max_const_pressure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_max_const_pressure);

// PumpConfigurationAndControl MinCompPressure
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MinCompPressure is supported
 *
 * @returns true if MinCompPressure is supported
 * @returns false if MinCompPressure is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_min_comp_pressure (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinCompPressure attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinCompPressure attribute
 */
int16_t dotdot_get_pump_configuration_and_control_min_comp_pressure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinCompPressure attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_comp_pressure new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_min_comp_pressure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_min_comp_pressure);

// PumpConfigurationAndControl MaxCompPressure
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MaxCompPressure is supported
 *
 * @returns true if MaxCompPressure is supported
 * @returns false if MaxCompPressure is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_max_comp_pressure (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxCompPressure attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxCompPressure attribute
 */
int16_t dotdot_get_pump_configuration_and_control_max_comp_pressure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxCompPressure attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_comp_pressure new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_max_comp_pressure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_max_comp_pressure);

// PumpConfigurationAndControl MinConstSpeed
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MinConstSpeed is supported
 *
 * @returns true if MinConstSpeed is supported
 * @returns false if MinConstSpeed is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_min_const_speed (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinConstSpeed attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinConstSpeed attribute
 */
uint16_t dotdot_get_pump_configuration_and_control_min_const_speed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinConstSpeed attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_const_speed new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_min_const_speed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_min_const_speed);

// PumpConfigurationAndControl MaxConstSpeed
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MaxConstSpeed is supported
 *
 * @returns true if MaxConstSpeed is supported
 * @returns false if MaxConstSpeed is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_max_const_speed (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxConstSpeed attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxConstSpeed attribute
 */
uint16_t dotdot_get_pump_configuration_and_control_max_const_speed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxConstSpeed attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_const_speed new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_max_const_speed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_const_speed);

// PumpConfigurationAndControl MinConstFlow
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MinConstFlow is supported
 *
 * @returns true if MinConstFlow is supported
 * @returns false if MinConstFlow is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_min_const_flow (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinConstFlow attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinConstFlow attribute
 */
uint16_t dotdot_get_pump_configuration_and_control_min_const_flow(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinConstFlow attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_const_flow new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_min_const_flow(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_min_const_flow);

// PumpConfigurationAndControl MaxConstFlow
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MaxConstFlow is supported
 *
 * @returns true if MaxConstFlow is supported
 * @returns false if MaxConstFlow is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_max_const_flow (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxConstFlow attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxConstFlow attribute
 */
uint16_t dotdot_get_pump_configuration_and_control_max_const_flow(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxConstFlow attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_const_flow new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_max_const_flow(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_const_flow);

// PumpConfigurationAndControl MinConstTemp
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MinConstTemp is supported
 *
 * @returns true if MinConstTemp is supported
 * @returns false if MinConstTemp is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_min_const_temp (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinConstTemp attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinConstTemp attribute
 */
int16_t dotdot_get_pump_configuration_and_control_min_const_temp(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinConstTemp attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_const_temp new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_min_const_temp(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_min_const_temp);

// PumpConfigurationAndControl MaxConstTemp
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl MaxConstTemp is supported
 *
 * @returns true if MaxConstTemp is supported
 * @returns false if MaxConstTemp is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_max_const_temp (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxConstTemp attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxConstTemp attribute
 */
int16_t dotdot_get_pump_configuration_and_control_max_const_temp(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxConstTemp attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_const_temp new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_max_const_temp(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_max_const_temp);

// PumpConfigurationAndControl PumpStatus
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl PumpStatus is supported
 *
 * @returns true if PumpStatus is supported
 * @returns false if PumpStatus is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_pump_status (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PumpStatus attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PumpStatus attribute
 */
uint16_t dotdot_get_pump_configuration_and_control_pump_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PumpStatus attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_pump_status new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_pump_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_pump_status);

// PumpConfigurationAndControl EffectiveOperationMode
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl EffectiveOperationMode is supported
 *
 * @returns true if EffectiveOperationMode is supported
 * @returns false if EffectiveOperationMode is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_effective_operation_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EffectiveOperationMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EffectiveOperationMode attribute
 */
PumpOperationMode dotdot_get_pump_configuration_and_control_effective_operation_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EffectiveOperationMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_effective_operation_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_effective_operation_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  PumpOperationMode new_effective_operation_mode);

// PumpConfigurationAndControl EffectiveControlMode
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl EffectiveControlMode is supported
 *
 * @returns true if EffectiveControlMode is supported
 * @returns false if EffectiveControlMode is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_effective_control_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EffectiveControlMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EffectiveControlMode attribute
 */
PumpControlMode dotdot_get_pump_configuration_and_control_effective_control_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EffectiveControlMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_effective_control_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_effective_control_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  PumpControlMode new_effective_control_mode);

// PumpConfigurationAndControl Capacity
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl Capacity is supported
 *
 * @returns true if Capacity is supported
 * @returns false if Capacity is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_capacity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Capacity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Capacity attribute
 */
int16_t dotdot_get_pump_configuration_and_control_capacity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Capacity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_capacity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_capacity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_capacity);

// PumpConfigurationAndControl Speed
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl Speed is supported
 *
 * @returns true if Speed is supported
 * @returns false if Speed is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_speed (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Speed attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Speed attribute
 */
uint16_t dotdot_get_pump_configuration_and_control_speed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Speed attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_speed new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_speed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_speed);

// PumpConfigurationAndControl LifetimeRunningHours
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl LifetimeRunningHours is supported
 *
 * @returns true if LifetimeRunningHours is supported
 * @returns false if LifetimeRunningHours is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_lifetime_running_hours (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LifetimeRunningHours attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LifetimeRunningHours attribute
 */
uint32_t dotdot_get_pump_configuration_and_control_lifetime_running_hours(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LifetimeRunningHours attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lifetime_running_hours new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_lifetime_running_hours(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_lifetime_running_hours);

// PumpConfigurationAndControl Power
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl Power is supported
 *
 * @returns true if Power is supported
 * @returns false if Power is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_power (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Power attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Power attribute
 */
uint32_t dotdot_get_pump_configuration_and_control_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Power attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_power);

// PumpConfigurationAndControl LifetimeEnergyConsumed
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl LifetimeEnergyConsumed is supported
 *
 * @returns true if LifetimeEnergyConsumed is supported
 * @returns false if LifetimeEnergyConsumed is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_lifetime_energy_consumed (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LifetimeEnergyConsumed attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LifetimeEnergyConsumed attribute
 */
uint32_t dotdot_get_pump_configuration_and_control_lifetime_energy_consumed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LifetimeEnergyConsumed attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lifetime_energy_consumed new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_lifetime_energy_consumed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_lifetime_energy_consumed);

// PumpConfigurationAndControl OperationMode
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl OperationMode is supported
 *
 * @returns true if OperationMode is supported
 * @returns false if OperationMode is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_operation_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OperationMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OperationMode attribute
 */
PumpOperationMode dotdot_get_pump_configuration_and_control_operation_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OperationMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_operation_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_operation_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  PumpOperationMode new_operation_mode);

// PumpConfigurationAndControl ControlMode
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl ControlMode is supported
 *
 * @returns true if ControlMode is supported
 * @returns false if ControlMode is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_control_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ControlMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ControlMode attribute
 */
PumpControlMode dotdot_get_pump_configuration_and_control_control_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ControlMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_control_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_control_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  PumpControlMode new_control_mode);

// PumpConfigurationAndControl AlarmMask
/**
 * @brief Verifies if the DotDot PumpConfigurationAndControl AlarmMask is supported
 *
 * @returns true if AlarmMask is supported
 * @returns false if AlarmMask is not supported
 */
bool dotdot_is_supported_pump_configuration_and_control_alarm_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AlarmMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AlarmMask attribute
 */
uint16_t dotdot_get_pump_configuration_and_control_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AlarmMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_alarm_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pump_configuration_and_control_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_alarm_mask);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Thermostat
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Thermostat
#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE ((attribute_store_type_t) 0x02010000)
///< This represents the LocalTemperature attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OUTDOOR_TEMPERATURE ((attribute_store_type_t) 0x02010001)
///< This represents the OutdoorTemperature attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPANCY ((attribute_store_type_t) 0x02010002)
///< This represents the Occupancy attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_HEAT_SETPOINT_LIMIT ((attribute_store_type_t) 0x02010003)
///< This represents the AbsMinHeatSetpointLimit attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_HEAT_SETPOINT_LIMIT ((attribute_store_type_t) 0x02010004)
///< This represents the AbsMaxHeatSetpointLimit attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MIN_COOL_SETPOINT_LIMIT ((attribute_store_type_t) 0x02010005)
///< This represents the AbsMinCoolSetpointLimit attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ABS_MAX_COOL_SETPOINT_LIMIT ((attribute_store_type_t) 0x02010006)
///< This represents the AbsMaxCoolSetpointLimit attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_COOLING_DEMAND ((attribute_store_type_t) 0x02010007)
///< This represents the PICoolingDemand attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_PI_HEATING_DEMAND ((attribute_store_type_t) 0x02010008)
///< This represents the PIHeatingDemand attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_HVAC_SYSTEM_TYPE_CONFIGURATION ((attribute_store_type_t) 0x02010009)
///< This represents the HVACSystemTypeConfiguration attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_LOCAL_TEMPERATURE_CALIBRATION ((attribute_store_type_t) 0x02010010)
///< This represents the LocalTemperatureCalibration attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_COOLING_SETPOINT ((attribute_store_type_t) 0x02010011)
///< This represents the OccupiedCoolingSetpoint attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_HEATING_SETPOINT ((attribute_store_type_t) 0x02010012)
///< This represents the OccupiedHeatingSetpoint attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_COOLING_SETPOINT ((attribute_store_type_t) 0x02010013)
///< This represents the UnoccupiedCoolingSetpoint attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_HEATING_SETPOINT ((attribute_store_type_t) 0x02010014)
///< This represents the UnoccupiedHeatingSetpoint attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_HEAT_SETPOINT_LIMIT ((attribute_store_type_t) 0x02010015)
///< This represents the MinHeatSetpointLimit attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_HEAT_SETPOINT_LIMIT ((attribute_store_type_t) 0x02010016)
///< This represents the MaxHeatSetpointLimit attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_COOL_SETPOINT_LIMIT ((attribute_store_type_t) 0x02010017)
///< This represents the MinCoolSetpointLimit attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MAX_COOL_SETPOINT_LIMIT ((attribute_store_type_t) 0x02010018)
///< This represents the MaxCoolSetpointLimit attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_MIN_SETPOINT_DEAD_BAND ((attribute_store_type_t) 0x02010019)
///< This represents the MinSetpointDeadBand attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_REMOTE_SENSING ((attribute_store_type_t) 0x0201001a)
///< This represents the RemoteSensing attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_CONTROL_SEQUENCE_OF_OPERATION ((attribute_store_type_t) 0x0201001b)
///< This represents the ControlSequenceOfOperation attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SYSTEM_MODE ((attribute_store_type_t) 0x0201001c)
///< This represents the SystemMode attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_ALARM_MASK ((attribute_store_type_t) 0x0201001d)
///< This represents the AlarmMask attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_MODE ((attribute_store_type_t) 0x0201001e)
///< This represents the ThermostatRunningMode attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_START_OF_WEEK ((attribute_store_type_t) 0x02010020)
///< This represents the StartOfWeek attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_WEEKLY_TRANSITIONS ((attribute_store_type_t) 0x02010021)
///< This represents the NumberOfWeeklyTransitions attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_NUMBER_OF_DAILY_TRANSITIONS ((attribute_store_type_t) 0x02010022)
///< This represents the NumberOfDailyTransitions attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD ((attribute_store_type_t) 0x02010023)
///< This represents the TemperatureSetpointHold attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_TEMPERATURE_SETPOINT_HOLD_DURATION ((attribute_store_type_t) 0x02010024)
///< This represents the TemperatureSetpointHoldDuration attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_PROGRAMMING_OPERATION_MODE ((attribute_store_type_t) 0x02010025)
///< This represents the ThermostatProgrammingOperationMode attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_THERMOSTAT_RUNNING_STATE ((attribute_store_type_t) 0x02010029)
///< This represents the ThermostatRunningState attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE ((attribute_store_type_t) 0x02010030)
///< This represents the SetpointChangeSource attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_AMOUNT ((attribute_store_type_t) 0x02010031)
///< This represents the SetpointChangeAmount attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_SETPOINT_CHANGE_SOURCE_TIMESTAMP ((attribute_store_type_t) 0x02010032)
///< This represents the SetpointChangeSourceTimestamp attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK ((attribute_store_type_t) 0x02010034)
///< This represents the OccupiedSetback attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MIN ((attribute_store_type_t) 0x02010035)
///< This represents the OccupiedSetbackMin attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_OCCUPIED_SETBACK_MAX ((attribute_store_type_t) 0x02010036)
///< This represents the OccupiedSetbackMax attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK ((attribute_store_type_t) 0x02010037)
///< This represents the UnoccupiedSetback attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MIN ((attribute_store_type_t) 0x02010038)
///< This represents the UnoccupiedSetbackMin attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_UNOCCUPIED_SETBACK_MAX ((attribute_store_type_t) 0x02010039)
///< This represents the UnoccupiedSetbackMax attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_EMERGENCY_HEAT_DELTA ((attribute_store_type_t) 0x0201003a)
///< This represents the EmergencyHeatDelta attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_TYPE ((attribute_store_type_t) 0x02010040)
///< This represents the ACType attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY ((attribute_store_type_t) 0x02010041)
///< This represents the ACCapacity attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_REFRIGERANT_TYPE ((attribute_store_type_t) 0x02010042)
///< This represents the ACRefrigerantType attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COMPRESSOR_TYPE ((attribute_store_type_t) 0x02010043)
///< This represents the ACCompressorType attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_ERROR_CODE ((attribute_store_type_t) 0x02010044)
///< This represents the ACErrorCode attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_LOUVER_POSITION ((attribute_store_type_t) 0x02010045)
///< This represents the ACLouverPosition attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_COIL_TEMPERATURE ((attribute_store_type_t) 0x02010046)
///< This represents the ACCoilTemperature attribute in the DotDot Thermostat cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_AC_CAPACITY_FORMAT ((attribute_store_type_t) 0x02010047)
///< This represents the ACCapacityFormat attribute in the DotDot Thermostat cluster

// Thermostat LocalTemperature
/**
 * @brief Verifies if the DotDot Thermostat LocalTemperature is supported
 *
 * @returns true if LocalTemperature is supported
 * @returns false if LocalTemperature is not supported
 */
bool dotdot_is_supported_thermostat_local_temperature (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LocalTemperature attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LocalTemperature attribute
 */
int16_t dotdot_get_thermostat_local_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LocalTemperature attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_local_temperature new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_local_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_local_temperature);

// Thermostat OutdoorTemperature
/**
 * @brief Verifies if the DotDot Thermostat OutdoorTemperature is supported
 *
 * @returns true if OutdoorTemperature is supported
 * @returns false if OutdoorTemperature is not supported
 */
bool dotdot_is_supported_thermostat_outdoor_temperature (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OutdoorTemperature attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OutdoorTemperature attribute
 */
int16_t dotdot_get_thermostat_outdoor_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OutdoorTemperature attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_outdoor_temperature new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_outdoor_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_outdoor_temperature);

// Thermostat Occupancy
/**
 * @brief Verifies if the DotDot Thermostat Occupancy is supported
 *
 * @returns true if Occupancy is supported
 * @returns false if Occupancy is not supported
 */
bool dotdot_is_supported_thermostat_occupancy (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Occupancy attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Occupancy attribute
 */
uint8_t dotdot_get_thermostat_occupancy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Occupancy attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_occupancy new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_occupancy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_occupancy);

// Thermostat AbsMinHeatSetpointLimit
/**
 * @brief Verifies if the DotDot Thermostat AbsMinHeatSetpointLimit is supported
 *
 * @returns true if AbsMinHeatSetpointLimit is supported
 * @returns false if AbsMinHeatSetpointLimit is not supported
 */
bool dotdot_is_supported_thermostat_abs_min_heat_setpoint_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AbsMinHeatSetpointLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AbsMinHeatSetpointLimit attribute
 */
int16_t dotdot_get_thermostat_abs_min_heat_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AbsMinHeatSetpointLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_abs_min_heat_setpoint_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_abs_min_heat_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_abs_min_heat_setpoint_limit);

// Thermostat AbsMaxHeatSetpointLimit
/**
 * @brief Verifies if the DotDot Thermostat AbsMaxHeatSetpointLimit is supported
 *
 * @returns true if AbsMaxHeatSetpointLimit is supported
 * @returns false if AbsMaxHeatSetpointLimit is not supported
 */
bool dotdot_is_supported_thermostat_abs_max_heat_setpoint_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AbsMaxHeatSetpointLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AbsMaxHeatSetpointLimit attribute
 */
int16_t dotdot_get_thermostat_abs_max_heat_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AbsMaxHeatSetpointLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_abs_max_heat_setpoint_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_abs_max_heat_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_abs_max_heat_setpoint_limit);

// Thermostat AbsMinCoolSetpointLimit
/**
 * @brief Verifies if the DotDot Thermostat AbsMinCoolSetpointLimit is supported
 *
 * @returns true if AbsMinCoolSetpointLimit is supported
 * @returns false if AbsMinCoolSetpointLimit is not supported
 */
bool dotdot_is_supported_thermostat_abs_min_cool_setpoint_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AbsMinCoolSetpointLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AbsMinCoolSetpointLimit attribute
 */
int16_t dotdot_get_thermostat_abs_min_cool_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AbsMinCoolSetpointLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_abs_min_cool_setpoint_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_abs_min_cool_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_abs_min_cool_setpoint_limit);

// Thermostat AbsMaxCoolSetpointLimit
/**
 * @brief Verifies if the DotDot Thermostat AbsMaxCoolSetpointLimit is supported
 *
 * @returns true if AbsMaxCoolSetpointLimit is supported
 * @returns false if AbsMaxCoolSetpointLimit is not supported
 */
bool dotdot_is_supported_thermostat_abs_max_cool_setpoint_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AbsMaxCoolSetpointLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AbsMaxCoolSetpointLimit attribute
 */
int16_t dotdot_get_thermostat_abs_max_cool_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AbsMaxCoolSetpointLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_abs_max_cool_setpoint_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_abs_max_cool_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_abs_max_cool_setpoint_limit);

// Thermostat PICoolingDemand
/**
 * @brief Verifies if the DotDot Thermostat PICoolingDemand is supported
 *
 * @returns true if PICoolingDemand is supported
 * @returns false if PICoolingDemand is not supported
 */
bool dotdot_is_supported_thermostat_pi_cooling_demand (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PICoolingDemand attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PICoolingDemand attribute
 */
uint8_t dotdot_get_thermostat_pi_cooling_demand(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PICoolingDemand attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_pi_cooling_demand new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_pi_cooling_demand(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_pi_cooling_demand);

// Thermostat PIHeatingDemand
/**
 * @brief Verifies if the DotDot Thermostat PIHeatingDemand is supported
 *
 * @returns true if PIHeatingDemand is supported
 * @returns false if PIHeatingDemand is not supported
 */
bool dotdot_is_supported_thermostat_pi_heating_demand (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PIHeatingDemand attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PIHeatingDemand attribute
 */
uint8_t dotdot_get_thermostat_pi_heating_demand(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PIHeatingDemand attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_pi_heating_demand new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_pi_heating_demand(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_pi_heating_demand);

// Thermostat HVACSystemTypeConfiguration
/**
 * @brief Verifies if the DotDot Thermostat HVACSystemTypeConfiguration is supported
 *
 * @returns true if HVACSystemTypeConfiguration is supported
 * @returns false if HVACSystemTypeConfiguration is not supported
 */
bool dotdot_is_supported_thermostat_hvac_system_type_configuration (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot HVACSystemTypeConfiguration attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns HVACSystemTypeConfiguration attribute
 */
uint8_t dotdot_get_thermostat_hvac_system_type_configuration(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot HVACSystemTypeConfiguration attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_hvac_system_type_configuration new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_hvac_system_type_configuration(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_hvac_system_type_configuration);

// Thermostat LocalTemperatureCalibration
/**
 * @brief Verifies if the DotDot Thermostat LocalTemperatureCalibration is supported
 *
 * @returns true if LocalTemperatureCalibration is supported
 * @returns false if LocalTemperatureCalibration is not supported
 */
bool dotdot_is_supported_thermostat_local_temperature_calibration (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LocalTemperatureCalibration attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LocalTemperatureCalibration attribute
 */
int8_t dotdot_get_thermostat_local_temperature_calibration(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LocalTemperatureCalibration attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_local_temperature_calibration new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_local_temperature_calibration(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_local_temperature_calibration);

// Thermostat OccupiedCoolingSetpoint
/**
 * @brief Verifies if the DotDot Thermostat OccupiedCoolingSetpoint is supported
 *
 * @returns true if OccupiedCoolingSetpoint is supported
 * @returns false if OccupiedCoolingSetpoint is not supported
 */
bool dotdot_is_supported_thermostat_occupied_cooling_setpoint (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OccupiedCoolingSetpoint attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OccupiedCoolingSetpoint attribute
 */
int16_t dotdot_get_thermostat_occupied_cooling_setpoint(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OccupiedCoolingSetpoint attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_occupied_cooling_setpoint new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_occupied_cooling_setpoint(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_occupied_cooling_setpoint);

// Thermostat OccupiedHeatingSetpoint
/**
 * @brief Verifies if the DotDot Thermostat OccupiedHeatingSetpoint is supported
 *
 * @returns true if OccupiedHeatingSetpoint is supported
 * @returns false if OccupiedHeatingSetpoint is not supported
 */
bool dotdot_is_supported_thermostat_occupied_heating_setpoint (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OccupiedHeatingSetpoint attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OccupiedHeatingSetpoint attribute
 */
int16_t dotdot_get_thermostat_occupied_heating_setpoint(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OccupiedHeatingSetpoint attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_occupied_heating_setpoint new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_occupied_heating_setpoint(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_occupied_heating_setpoint);

// Thermostat UnoccupiedCoolingSetpoint
/**
 * @brief Verifies if the DotDot Thermostat UnoccupiedCoolingSetpoint is supported
 *
 * @returns true if UnoccupiedCoolingSetpoint is supported
 * @returns false if UnoccupiedCoolingSetpoint is not supported
 */
bool dotdot_is_supported_thermostat_unoccupied_cooling_setpoint (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UnoccupiedCoolingSetpoint attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UnoccupiedCoolingSetpoint attribute
 */
int16_t dotdot_get_thermostat_unoccupied_cooling_setpoint(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UnoccupiedCoolingSetpoint attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_unoccupied_cooling_setpoint new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_unoccupied_cooling_setpoint(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_unoccupied_cooling_setpoint);

// Thermostat UnoccupiedHeatingSetpoint
/**
 * @brief Verifies if the DotDot Thermostat UnoccupiedHeatingSetpoint is supported
 *
 * @returns true if UnoccupiedHeatingSetpoint is supported
 * @returns false if UnoccupiedHeatingSetpoint is not supported
 */
bool dotdot_is_supported_thermostat_unoccupied_heating_setpoint (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UnoccupiedHeatingSetpoint attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UnoccupiedHeatingSetpoint attribute
 */
int16_t dotdot_get_thermostat_unoccupied_heating_setpoint(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UnoccupiedHeatingSetpoint attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_unoccupied_heating_setpoint new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_unoccupied_heating_setpoint(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_unoccupied_heating_setpoint);

// Thermostat MinHeatSetpointLimit
/**
 * @brief Verifies if the DotDot Thermostat MinHeatSetpointLimit is supported
 *
 * @returns true if MinHeatSetpointLimit is supported
 * @returns false if MinHeatSetpointLimit is not supported
 */
bool dotdot_is_supported_thermostat_min_heat_setpoint_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinHeatSetpointLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinHeatSetpointLimit attribute
 */
int16_t dotdot_get_thermostat_min_heat_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinHeatSetpointLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_heat_setpoint_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_min_heat_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_min_heat_setpoint_limit);

// Thermostat MaxHeatSetpointLimit
/**
 * @brief Verifies if the DotDot Thermostat MaxHeatSetpointLimit is supported
 *
 * @returns true if MaxHeatSetpointLimit is supported
 * @returns false if MaxHeatSetpointLimit is not supported
 */
bool dotdot_is_supported_thermostat_max_heat_setpoint_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxHeatSetpointLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxHeatSetpointLimit attribute
 */
int16_t dotdot_get_thermostat_max_heat_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxHeatSetpointLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_heat_setpoint_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_max_heat_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_max_heat_setpoint_limit);

// Thermostat MinCoolSetpointLimit
/**
 * @brief Verifies if the DotDot Thermostat MinCoolSetpointLimit is supported
 *
 * @returns true if MinCoolSetpointLimit is supported
 * @returns false if MinCoolSetpointLimit is not supported
 */
bool dotdot_is_supported_thermostat_min_cool_setpoint_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinCoolSetpointLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinCoolSetpointLimit attribute
 */
int16_t dotdot_get_thermostat_min_cool_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinCoolSetpointLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_cool_setpoint_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_min_cool_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_min_cool_setpoint_limit);

// Thermostat MaxCoolSetpointLimit
/**
 * @brief Verifies if the DotDot Thermostat MaxCoolSetpointLimit is supported
 *
 * @returns true if MaxCoolSetpointLimit is supported
 * @returns false if MaxCoolSetpointLimit is not supported
 */
bool dotdot_is_supported_thermostat_max_cool_setpoint_limit (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxCoolSetpointLimit attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxCoolSetpointLimit attribute
 */
int16_t dotdot_get_thermostat_max_cool_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxCoolSetpointLimit attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_cool_setpoint_limit new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_max_cool_setpoint_limit(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_max_cool_setpoint_limit);

// Thermostat MinSetpointDeadBand
/**
 * @brief Verifies if the DotDot Thermostat MinSetpointDeadBand is supported
 *
 * @returns true if MinSetpointDeadBand is supported
 * @returns false if MinSetpointDeadBand is not supported
 */
bool dotdot_is_supported_thermostat_min_setpoint_dead_band (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinSetpointDeadBand attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinSetpointDeadBand attribute
 */
int8_t dotdot_get_thermostat_min_setpoint_dead_band(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinSetpointDeadBand attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_setpoint_dead_band new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_min_setpoint_dead_band(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_min_setpoint_dead_band);

// Thermostat RemoteSensing
/**
 * @brief Verifies if the DotDot Thermostat RemoteSensing is supported
 *
 * @returns true if RemoteSensing is supported
 * @returns false if RemoteSensing is not supported
 */
bool dotdot_is_supported_thermostat_remote_sensing (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RemoteSensing attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RemoteSensing attribute
 */
uint8_t dotdot_get_thermostat_remote_sensing(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RemoteSensing attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_remote_sensing new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_remote_sensing(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_remote_sensing);

// Thermostat ControlSequenceOfOperation
/**
 * @brief Verifies if the DotDot Thermostat ControlSequenceOfOperation is supported
 *
 * @returns true if ControlSequenceOfOperation is supported
 * @returns false if ControlSequenceOfOperation is not supported
 */
bool dotdot_is_supported_thermostat_control_sequence_of_operation (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ControlSequenceOfOperation attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ControlSequenceOfOperation attribute
 */
uint8_t dotdot_get_thermostat_control_sequence_of_operation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ControlSequenceOfOperation attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_control_sequence_of_operation new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_control_sequence_of_operation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_control_sequence_of_operation);

// Thermostat SystemMode
/**
 * @brief Verifies if the DotDot Thermostat SystemMode is supported
 *
 * @returns true if SystemMode is supported
 * @returns false if SystemMode is not supported
 */
bool dotdot_is_supported_thermostat_system_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SystemMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SystemMode attribute
 */
uint8_t dotdot_get_thermostat_system_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SystemMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_system_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_system_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_system_mode);

// Thermostat AlarmMask
/**
 * @brief Verifies if the DotDot Thermostat AlarmMask is supported
 *
 * @returns true if AlarmMask is supported
 * @returns false if AlarmMask is not supported
 */
bool dotdot_is_supported_thermostat_alarm_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AlarmMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AlarmMask attribute
 */
uint8_t dotdot_get_thermostat_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AlarmMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_alarm_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_alarm_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_alarm_mask);

// Thermostat ThermostatRunningMode
/**
 * @brief Verifies if the DotDot Thermostat ThermostatRunningMode is supported
 *
 * @returns true if ThermostatRunningMode is supported
 * @returns false if ThermostatRunningMode is not supported
 */
bool dotdot_is_supported_thermostat_thermostat_running_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ThermostatRunningMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ThermostatRunningMode attribute
 */
uint8_t dotdot_get_thermostat_thermostat_running_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ThermostatRunningMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_thermostat_running_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_thermostat_running_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_thermostat_running_mode);

// Thermostat StartOfWeek
/**
 * @brief Verifies if the DotDot Thermostat StartOfWeek is supported
 *
 * @returns true if StartOfWeek is supported
 * @returns false if StartOfWeek is not supported
 */
bool dotdot_is_supported_thermostat_start_of_week (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot StartOfWeek attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns StartOfWeek attribute
 */
uint8_t dotdot_get_thermostat_start_of_week(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot StartOfWeek attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_start_of_week new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_start_of_week(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_start_of_week);

// Thermostat NumberOfWeeklyTransitions
/**
 * @brief Verifies if the DotDot Thermostat NumberOfWeeklyTransitions is supported
 *
 * @returns true if NumberOfWeeklyTransitions is supported
 * @returns false if NumberOfWeeklyTransitions is not supported
 */
bool dotdot_is_supported_thermostat_number_of_weekly_transitions (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfWeeklyTransitions attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfWeeklyTransitions attribute
 */
uint8_t dotdot_get_thermostat_number_of_weekly_transitions(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfWeeklyTransitions attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_weekly_transitions new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_number_of_weekly_transitions(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_number_of_weekly_transitions);

// Thermostat NumberOfDailyTransitions
/**
 * @brief Verifies if the DotDot Thermostat NumberOfDailyTransitions is supported
 *
 * @returns true if NumberOfDailyTransitions is supported
 * @returns false if NumberOfDailyTransitions is not supported
 */
bool dotdot_is_supported_thermostat_number_of_daily_transitions (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfDailyTransitions attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfDailyTransitions attribute
 */
uint8_t dotdot_get_thermostat_number_of_daily_transitions(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfDailyTransitions attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_daily_transitions new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_number_of_daily_transitions(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_number_of_daily_transitions);

// Thermostat TemperatureSetpointHold
/**
 * @brief Verifies if the DotDot Thermostat TemperatureSetpointHold is supported
 *
 * @returns true if TemperatureSetpointHold is supported
 * @returns false if TemperatureSetpointHold is not supported
 */
bool dotdot_is_supported_thermostat_temperature_setpoint_hold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TemperatureSetpointHold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TemperatureSetpointHold attribute
 */
uint8_t dotdot_get_thermostat_temperature_setpoint_hold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TemperatureSetpointHold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_temperature_setpoint_hold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_temperature_setpoint_hold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_temperature_setpoint_hold);

// Thermostat TemperatureSetpointHoldDuration
/**
 * @brief Verifies if the DotDot Thermostat TemperatureSetpointHoldDuration is supported
 *
 * @returns true if TemperatureSetpointHoldDuration is supported
 * @returns false if TemperatureSetpointHoldDuration is not supported
 */
bool dotdot_is_supported_thermostat_temperature_setpoint_hold_duration (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TemperatureSetpointHoldDuration attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TemperatureSetpointHoldDuration attribute
 */
uint16_t dotdot_get_thermostat_temperature_setpoint_hold_duration(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TemperatureSetpointHoldDuration attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_temperature_setpoint_hold_duration new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_temperature_setpoint_hold_duration(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_temperature_setpoint_hold_duration);

// Thermostat ThermostatProgrammingOperationMode
/**
 * @brief Verifies if the DotDot Thermostat ThermostatProgrammingOperationMode is supported
 *
 * @returns true if ThermostatProgrammingOperationMode is supported
 * @returns false if ThermostatProgrammingOperationMode is not supported
 */
bool dotdot_is_supported_thermostat_thermostat_programming_operation_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ThermostatProgrammingOperationMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ThermostatProgrammingOperationMode attribute
 */
uint8_t dotdot_get_thermostat_thermostat_programming_operation_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ThermostatProgrammingOperationMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_thermostat_programming_operation_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_thermostat_programming_operation_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_thermostat_programming_operation_mode);

// Thermostat ThermostatRunningState
/**
 * @brief Verifies if the DotDot Thermostat ThermostatRunningState is supported
 *
 * @returns true if ThermostatRunningState is supported
 * @returns false if ThermostatRunningState is not supported
 */
bool dotdot_is_supported_thermostat_thermostat_running_state (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ThermostatRunningState attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ThermostatRunningState attribute
 */
uint16_t dotdot_get_thermostat_thermostat_running_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ThermostatRunningState attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_thermostat_running_state new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_thermostat_running_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_thermostat_running_state);

// Thermostat SetpointChangeSource
/**
 * @brief Verifies if the DotDot Thermostat SetpointChangeSource is supported
 *
 * @returns true if SetpointChangeSource is supported
 * @returns false if SetpointChangeSource is not supported
 */
bool dotdot_is_supported_thermostat_setpoint_change_source (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SetpointChangeSource attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SetpointChangeSource attribute
 */
uint8_t dotdot_get_thermostat_setpoint_change_source(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SetpointChangeSource attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_setpoint_change_source new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_setpoint_change_source(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_setpoint_change_source);

// Thermostat SetpointChangeAmount
/**
 * @brief Verifies if the DotDot Thermostat SetpointChangeAmount is supported
 *
 * @returns true if SetpointChangeAmount is supported
 * @returns false if SetpointChangeAmount is not supported
 */
bool dotdot_is_supported_thermostat_setpoint_change_amount (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SetpointChangeAmount attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SetpointChangeAmount attribute
 */
int16_t dotdot_get_thermostat_setpoint_change_amount(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SetpointChangeAmount attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_setpoint_change_amount new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_setpoint_change_amount(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_setpoint_change_amount);

// Thermostat SetpointChangeSourceTimestamp
/**
 * @brief Verifies if the DotDot Thermostat SetpointChangeSourceTimestamp is supported
 *
 * @returns true if SetpointChangeSourceTimestamp is supported
 * @returns false if SetpointChangeSourceTimestamp is not supported
 */
bool dotdot_is_supported_thermostat_setpoint_change_source_timestamp (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SetpointChangeSourceTimestamp attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SetpointChangeSourceTimestamp attribute
 */
UTC dotdot_get_thermostat_setpoint_change_source_timestamp(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SetpointChangeSourceTimestamp attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_setpoint_change_source_timestamp new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_setpoint_change_source_timestamp(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  UTC new_setpoint_change_source_timestamp);

// Thermostat OccupiedSetback
/**
 * @brief Verifies if the DotDot Thermostat OccupiedSetback is supported
 *
 * @returns true if OccupiedSetback is supported
 * @returns false if OccupiedSetback is not supported
 */
bool dotdot_is_supported_thermostat_occupied_setback (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OccupiedSetback attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OccupiedSetback attribute
 */
uint8_t dotdot_get_thermostat_occupied_setback(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OccupiedSetback attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_occupied_setback new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_occupied_setback(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_occupied_setback);

// Thermostat OccupiedSetbackMin
/**
 * @brief Verifies if the DotDot Thermostat OccupiedSetbackMin is supported
 *
 * @returns true if OccupiedSetbackMin is supported
 * @returns false if OccupiedSetbackMin is not supported
 */
bool dotdot_is_supported_thermostat_occupied_setback_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OccupiedSetbackMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OccupiedSetbackMin attribute
 */
uint8_t dotdot_get_thermostat_occupied_setback_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OccupiedSetbackMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_occupied_setback_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_occupied_setback_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_occupied_setback_min);

// Thermostat OccupiedSetbackMax
/**
 * @brief Verifies if the DotDot Thermostat OccupiedSetbackMax is supported
 *
 * @returns true if OccupiedSetbackMax is supported
 * @returns false if OccupiedSetbackMax is not supported
 */
bool dotdot_is_supported_thermostat_occupied_setback_max (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OccupiedSetbackMax attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OccupiedSetbackMax attribute
 */
uint8_t dotdot_get_thermostat_occupied_setback_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OccupiedSetbackMax attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_occupied_setback_max new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_occupied_setback_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_occupied_setback_max);

// Thermostat UnoccupiedSetback
/**
 * @brief Verifies if the DotDot Thermostat UnoccupiedSetback is supported
 *
 * @returns true if UnoccupiedSetback is supported
 * @returns false if UnoccupiedSetback is not supported
 */
bool dotdot_is_supported_thermostat_unoccupied_setback (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UnoccupiedSetback attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UnoccupiedSetback attribute
 */
uint8_t dotdot_get_thermostat_unoccupied_setback(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UnoccupiedSetback attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_unoccupied_setback new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_unoccupied_setback(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_unoccupied_setback);

// Thermostat UnoccupiedSetbackMin
/**
 * @brief Verifies if the DotDot Thermostat UnoccupiedSetbackMin is supported
 *
 * @returns true if UnoccupiedSetbackMin is supported
 * @returns false if UnoccupiedSetbackMin is not supported
 */
bool dotdot_is_supported_thermostat_unoccupied_setback_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UnoccupiedSetbackMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UnoccupiedSetbackMin attribute
 */
uint8_t dotdot_get_thermostat_unoccupied_setback_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UnoccupiedSetbackMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_unoccupied_setback_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_unoccupied_setback_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_unoccupied_setback_min);

// Thermostat UnoccupiedSetbackMax
/**
 * @brief Verifies if the DotDot Thermostat UnoccupiedSetbackMax is supported
 *
 * @returns true if UnoccupiedSetbackMax is supported
 * @returns false if UnoccupiedSetbackMax is not supported
 */
bool dotdot_is_supported_thermostat_unoccupied_setback_max (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UnoccupiedSetbackMax attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UnoccupiedSetbackMax attribute
 */
uint8_t dotdot_get_thermostat_unoccupied_setback_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UnoccupiedSetbackMax attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_unoccupied_setback_max new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_unoccupied_setback_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_unoccupied_setback_max);

// Thermostat EmergencyHeatDelta
/**
 * @brief Verifies if the DotDot Thermostat EmergencyHeatDelta is supported
 *
 * @returns true if EmergencyHeatDelta is supported
 * @returns false if EmergencyHeatDelta is not supported
 */
bool dotdot_is_supported_thermostat_emergency_heat_delta (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EmergencyHeatDelta attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EmergencyHeatDelta attribute
 */
uint8_t dotdot_get_thermostat_emergency_heat_delta(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EmergencyHeatDelta attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_emergency_heat_delta new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_emergency_heat_delta(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_emergency_heat_delta);

// Thermostat ACType
/**
 * @brief Verifies if the DotDot Thermostat ACType is supported
 *
 * @returns true if ACType is supported
 * @returns false if ACType is not supported
 */
bool dotdot_is_supported_thermostat_ac_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACType attribute
 */
uint8_t dotdot_get_thermostat_ac_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_ac_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_ac_type);

// Thermostat ACCapacity
/**
 * @brief Verifies if the DotDot Thermostat ACCapacity is supported
 *
 * @returns true if ACCapacity is supported
 * @returns false if ACCapacity is not supported
 */
bool dotdot_is_supported_thermostat_ac_capacity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACCapacity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACCapacity attribute
 */
uint16_t dotdot_get_thermostat_ac_capacity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACCapacity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_capacity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_ac_capacity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_capacity);

// Thermostat ACRefrigerantType
/**
 * @brief Verifies if the DotDot Thermostat ACRefrigerantType is supported
 *
 * @returns true if ACRefrigerantType is supported
 * @returns false if ACRefrigerantType is not supported
 */
bool dotdot_is_supported_thermostat_ac_refrigerant_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACRefrigerantType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACRefrigerantType attribute
 */
uint8_t dotdot_get_thermostat_ac_refrigerant_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACRefrigerantType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_refrigerant_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_ac_refrigerant_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_ac_refrigerant_type);

// Thermostat ACCompressorType
/**
 * @brief Verifies if the DotDot Thermostat ACCompressorType is supported
 *
 * @returns true if ACCompressorType is supported
 * @returns false if ACCompressorType is not supported
 */
bool dotdot_is_supported_thermostat_ac_compressor_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACCompressorType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACCompressorType attribute
 */
uint8_t dotdot_get_thermostat_ac_compressor_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACCompressorType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_compressor_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_ac_compressor_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_ac_compressor_type);

// Thermostat ACErrorCode
/**
 * @brief Verifies if the DotDot Thermostat ACErrorCode is supported
 *
 * @returns true if ACErrorCode is supported
 * @returns false if ACErrorCode is not supported
 */
bool dotdot_is_supported_thermostat_ac_error_code (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACErrorCode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACErrorCode attribute
 */
uint32_t dotdot_get_thermostat_ac_error_code(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACErrorCode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_error_code new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_ac_error_code(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_ac_error_code);

// Thermostat ACLouverPosition
/**
 * @brief Verifies if the DotDot Thermostat ACLouverPosition is supported
 *
 * @returns true if ACLouverPosition is supported
 * @returns false if ACLouverPosition is not supported
 */
bool dotdot_is_supported_thermostat_ac_louver_position (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACLouverPosition attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACLouverPosition attribute
 */
uint8_t dotdot_get_thermostat_ac_louver_position(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACLouverPosition attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_louver_position new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_ac_louver_position(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_ac_louver_position);

// Thermostat ACCoilTemperature
/**
 * @brief Verifies if the DotDot Thermostat ACCoilTemperature is supported
 *
 * @returns true if ACCoilTemperature is supported
 * @returns false if ACCoilTemperature is not supported
 */
bool dotdot_is_supported_thermostat_ac_coil_temperature (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACCoilTemperature attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACCoilTemperature attribute
 */
int16_t dotdot_get_thermostat_ac_coil_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACCoilTemperature attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_coil_temperature new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_ac_coil_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_ac_coil_temperature);

// Thermostat ACCapacityFormat
/**
 * @brief Verifies if the DotDot Thermostat ACCapacityFormat is supported
 *
 * @returns true if ACCapacityFormat is supported
 * @returns false if ACCapacityFormat is not supported
 */
bool dotdot_is_supported_thermostat_ac_capacity_format (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACCapacityFormat attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACCapacityFormat attribute
 */
uint8_t dotdot_get_thermostat_ac_capacity_format(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACCapacityFormat attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_capacity_format new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_ac_capacity_format(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_ac_capacity_format);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster FanControl
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for FanControl
#define DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE ((attribute_store_type_t) 0x02020000)
///< This represents the FanMode attribute in the DotDot FanControl cluster

#define DOTDOT_ATTRIBUTE_ID_FAN_CONTROL_FAN_MODE_SEQUENCE ((attribute_store_type_t) 0x02020001)
///< This represents the FanModeSequence attribute in the DotDot FanControl cluster

// FanControl FanMode
/**
 * @brief Verifies if the DotDot FanControl FanMode is supported
 *
 * @returns true if FanMode is supported
 * @returns false if FanMode is not supported
 */
bool dotdot_is_supported_fan_control_fan_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot FanMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns FanMode attribute
 */
uint8_t dotdot_get_fan_control_fan_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot FanMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_fan_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_fan_control_fan_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_fan_mode);

// FanControl FanModeSequence
/**
 * @brief Verifies if the DotDot FanControl FanModeSequence is supported
 *
 * @returns true if FanModeSequence is supported
 * @returns false if FanModeSequence is not supported
 */
bool dotdot_is_supported_fan_control_fan_mode_sequence (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot FanModeSequence attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns FanModeSequence attribute
 */
uint8_t dotdot_get_fan_control_fan_mode_sequence(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot FanModeSequence attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_fan_mode_sequence new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_fan_control_fan_mode_sequence(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_fan_mode_sequence);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster DehumidificationControl
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for DehumidificationControl
#define DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY ((attribute_store_type_t) 0x02030000)
///< This represents the RelativeHumidity attribute in the DotDot DehumidificationControl cluster

#define DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_COOLING ((attribute_store_type_t) 0x02030001)
///< This represents the DehumidificationCooling attribute in the DotDot DehumidificationControl cluster

#define DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RH_DEHUMIDIFICATION_SETPOINT ((attribute_store_type_t) 0x02030010)
///< This represents the RHDehumidificationSetpoint attribute in the DotDot DehumidificationControl cluster

#define DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_MODE ((attribute_store_type_t) 0x02030011)
///< This represents the RelativeHumidityMode attribute in the DotDot DehumidificationControl cluster

#define DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_LOCKOUT ((attribute_store_type_t) 0x02030012)
///< This represents the DehumidificationLockout attribute in the DotDot DehumidificationControl cluster

#define DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_HYSTERESIS ((attribute_store_type_t) 0x02030013)
///< This represents the DehumidificationHysteresis attribute in the DotDot DehumidificationControl cluster

#define DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_DEHUMIDIFICATION_MAX_COOL ((attribute_store_type_t) 0x02030014)
///< This represents the DehumidificationMaxCool attribute in the DotDot DehumidificationControl cluster

#define DOTDOT_ATTRIBUTE_ID_DEHUMIDIFICATION_CONTROL_RELATIVE_HUMIDITY_DISPLAY ((attribute_store_type_t) 0x02030015)
///< This represents the RelativeHumidityDisplay attribute in the DotDot DehumidificationControl cluster

// DehumidificationControl RelativeHumidity
/**
 * @brief Verifies if the DotDot DehumidificationControl RelativeHumidity is supported
 *
 * @returns true if RelativeHumidity is supported
 * @returns false if RelativeHumidity is not supported
 */
bool dotdot_is_supported_dehumidification_control_relative_humidity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RelativeHumidity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RelativeHumidity attribute
 */
uint8_t dotdot_get_dehumidification_control_relative_humidity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RelativeHumidity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_relative_humidity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_dehumidification_control_relative_humidity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_relative_humidity);

// DehumidificationControl DehumidificationCooling
/**
 * @brief Verifies if the DotDot DehumidificationControl DehumidificationCooling is supported
 *
 * @returns true if DehumidificationCooling is supported
 * @returns false if DehumidificationCooling is not supported
 */
bool dotdot_is_supported_dehumidification_control_dehumidification_cooling (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DehumidificationCooling attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DehumidificationCooling attribute
 */
uint8_t dotdot_get_dehumidification_control_dehumidification_cooling(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DehumidificationCooling attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dehumidification_cooling new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_dehumidification_control_dehumidification_cooling(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_dehumidification_cooling);

// DehumidificationControl RHDehumidificationSetpoint
/**
 * @brief Verifies if the DotDot DehumidificationControl RHDehumidificationSetpoint is supported
 *
 * @returns true if RHDehumidificationSetpoint is supported
 * @returns false if RHDehumidificationSetpoint is not supported
 */
bool dotdot_is_supported_dehumidification_control_rh_dehumidification_setpoint (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RHDehumidificationSetpoint attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RHDehumidificationSetpoint attribute
 */
uint8_t dotdot_get_dehumidification_control_rh_dehumidification_setpoint(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RHDehumidificationSetpoint attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rh_dehumidification_setpoint new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_dehumidification_control_rh_dehumidification_setpoint(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_rh_dehumidification_setpoint);

// DehumidificationControl RelativeHumidityMode
/**
 * @brief Verifies if the DotDot DehumidificationControl RelativeHumidityMode is supported
 *
 * @returns true if RelativeHumidityMode is supported
 * @returns false if RelativeHumidityMode is not supported
 */
bool dotdot_is_supported_dehumidification_control_relative_humidity_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RelativeHumidityMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RelativeHumidityMode attribute
 */
uint8_t dotdot_get_dehumidification_control_relative_humidity_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RelativeHumidityMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_relative_humidity_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_dehumidification_control_relative_humidity_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_relative_humidity_mode);

// DehumidificationControl DehumidificationLockout
/**
 * @brief Verifies if the DotDot DehumidificationControl DehumidificationLockout is supported
 *
 * @returns true if DehumidificationLockout is supported
 * @returns false if DehumidificationLockout is not supported
 */
bool dotdot_is_supported_dehumidification_control_dehumidification_lockout (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DehumidificationLockout attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DehumidificationLockout attribute
 */
uint8_t dotdot_get_dehumidification_control_dehumidification_lockout(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DehumidificationLockout attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dehumidification_lockout new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_dehumidification_control_dehumidification_lockout(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_dehumidification_lockout);

// DehumidificationControl DehumidificationHysteresis
/**
 * @brief Verifies if the DotDot DehumidificationControl DehumidificationHysteresis is supported
 *
 * @returns true if DehumidificationHysteresis is supported
 * @returns false if DehumidificationHysteresis is not supported
 */
bool dotdot_is_supported_dehumidification_control_dehumidification_hysteresis (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DehumidificationHysteresis attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DehumidificationHysteresis attribute
 */
uint8_t dotdot_get_dehumidification_control_dehumidification_hysteresis(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DehumidificationHysteresis attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dehumidification_hysteresis new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_dehumidification_control_dehumidification_hysteresis(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_dehumidification_hysteresis);

// DehumidificationControl DehumidificationMaxCool
/**
 * @brief Verifies if the DotDot DehumidificationControl DehumidificationMaxCool is supported
 *
 * @returns true if DehumidificationMaxCool is supported
 * @returns false if DehumidificationMaxCool is not supported
 */
bool dotdot_is_supported_dehumidification_control_dehumidification_max_cool (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DehumidificationMaxCool attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DehumidificationMaxCool attribute
 */
uint8_t dotdot_get_dehumidification_control_dehumidification_max_cool(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DehumidificationMaxCool attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dehumidification_max_cool new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_dehumidification_control_dehumidification_max_cool(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_dehumidification_max_cool);

// DehumidificationControl RelativeHumidityDisplay
/**
 * @brief Verifies if the DotDot DehumidificationControl RelativeHumidityDisplay is supported
 *
 * @returns true if RelativeHumidityDisplay is supported
 * @returns false if RelativeHumidityDisplay is not supported
 */
bool dotdot_is_supported_dehumidification_control_relative_humidity_display (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RelativeHumidityDisplay attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RelativeHumidityDisplay attribute
 */
uint8_t dotdot_get_dehumidification_control_relative_humidity_display(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RelativeHumidityDisplay attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_relative_humidity_display new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_dehumidification_control_relative_humidity_display(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_relative_humidity_display);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster ThermostatUserInterfaceConfiguration
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for ThermostatUserInterfaceConfiguration
#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_TEMPERATURE_DISPLAY_MODE ((attribute_store_type_t) 0x02040000)
///< This represents the TemperatureDisplayMode attribute in the DotDot ThermostatUserInterfaceConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_KEYPAD_LOCKOUT ((attribute_store_type_t) 0x02040001)
///< This represents the KeypadLockout attribute in the DotDot ThermostatUserInterfaceConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_THERMOSTAT_USER_INTERFACE_CONFIGURATION_SCHEDULE_PROGRAMMING_VISIBILITY ((attribute_store_type_t) 0x02040002)
///< This represents the ScheduleProgrammingVisibility attribute in the DotDot ThermostatUserInterfaceConfiguration cluster

// ThermostatUserInterfaceConfiguration TemperatureDisplayMode
/**
 * @brief Verifies if the DotDot ThermostatUserInterfaceConfiguration TemperatureDisplayMode is supported
 *
 * @returns true if TemperatureDisplayMode is supported
 * @returns false if TemperatureDisplayMode is not supported
 */
bool dotdot_is_supported_thermostat_user_interface_configuration_temperature_display_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TemperatureDisplayMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TemperatureDisplayMode attribute
 */
uint8_t dotdot_get_thermostat_user_interface_configuration_temperature_display_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TemperatureDisplayMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_temperature_display_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_user_interface_configuration_temperature_display_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_temperature_display_mode);

// ThermostatUserInterfaceConfiguration KeypadLockout
/**
 * @brief Verifies if the DotDot ThermostatUserInterfaceConfiguration KeypadLockout is supported
 *
 * @returns true if KeypadLockout is supported
 * @returns false if KeypadLockout is not supported
 */
bool dotdot_is_supported_thermostat_user_interface_configuration_keypad_lockout (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot KeypadLockout attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns KeypadLockout attribute
 */
uint8_t dotdot_get_thermostat_user_interface_configuration_keypad_lockout(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot KeypadLockout attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_keypad_lockout new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_user_interface_configuration_keypad_lockout(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_keypad_lockout);

// ThermostatUserInterfaceConfiguration ScheduleProgrammingVisibility
/**
 * @brief Verifies if the DotDot ThermostatUserInterfaceConfiguration ScheduleProgrammingVisibility is supported
 *
 * @returns true if ScheduleProgrammingVisibility is supported
 * @returns false if ScheduleProgrammingVisibility is not supported
 */
bool dotdot_is_supported_thermostat_user_interface_configuration_schedule_programming_visibility (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ScheduleProgrammingVisibility attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ScheduleProgrammingVisibility attribute
 */
uint8_t dotdot_get_thermostat_user_interface_configuration_schedule_programming_visibility(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ScheduleProgrammingVisibility attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_schedule_programming_visibility new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_thermostat_user_interface_configuration_schedule_programming_visibility(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_schedule_programming_visibility);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster ColorControl
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for ColorControl
#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_HUE ((attribute_store_type_t) 0x03000000)
///< This represents the CurrentHue attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENT_SATURATION ((attribute_store_type_t) 0x03000001)
///< This represents the CurrentSaturation attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_REMAINING_TIME ((attribute_store_type_t) 0x03000002)
///< This represents the RemainingTime attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTX ((attribute_store_type_t) 0x03000003)
///< This represents the CurrentX attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_CURRENTY ((attribute_store_type_t) 0x03000004)
///< This represents the CurrentY attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_DRIFT_COMPENSATION ((attribute_store_type_t) 0x03000005)
///< This represents the DriftCompensation attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COMPENSATION_TEXT ((attribute_store_type_t) 0x03000006)
///< This represents the CompensationText attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMPERATURE_MIREDS ((attribute_store_type_t) 0x03000007)
///< This represents the ColorTemperatureMireds attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_MODE ((attribute_store_type_t) 0x03000008)
///< This represents the ColorMode attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_OPTIONS ((attribute_store_type_t) 0x0300000f)
///< This represents the Options attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_NUMBER_OF_PRIMARIES ((attribute_store_type_t) 0x03000010)
///< This represents the NumberOfPrimaries attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1X ((attribute_store_type_t) 0x03000011)
///< This represents the Primary1X attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1Y ((attribute_store_type_t) 0x03000012)
///< This represents the Primary1Y attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY1_INTENSITY ((attribute_store_type_t) 0x03000013)
///< This represents the Primary1Intensity attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2X ((attribute_store_type_t) 0x03000015)
///< This represents the Primary2X attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2Y ((attribute_store_type_t) 0x03000016)
///< This represents the Primary2Y attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY2_INTENSITY ((attribute_store_type_t) 0x03000017)
///< This represents the Primary2Intensity attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3X ((attribute_store_type_t) 0x03000019)
///< This represents the Primary3X attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3Y ((attribute_store_type_t) 0x0300001a)
///< This represents the Primary3Y attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY3_INTENSITY ((attribute_store_type_t) 0x0300001b)
///< This represents the Primary3Intensity attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4X ((attribute_store_type_t) 0x03000020)
///< This represents the Primary4X attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4Y ((attribute_store_type_t) 0x03000021)
///< This represents the Primary4Y attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY4_INTENSITY ((attribute_store_type_t) 0x03000022)
///< This represents the Primary4Intensity attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5X ((attribute_store_type_t) 0x03000024)
///< This represents the Primary5X attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5Y ((attribute_store_type_t) 0x03000025)
///< This represents the Primary5Y attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY5_INTENSITY ((attribute_store_type_t) 0x03000026)
///< This represents the Primary5Intensity attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6X ((attribute_store_type_t) 0x03000028)
///< This represents the Primary6X attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6Y ((attribute_store_type_t) 0x03000029)
///< This represents the Primary6Y attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_PRIMARY6_INTENSITY ((attribute_store_type_t) 0x0300002a)
///< This represents the Primary6Intensity attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTX ((attribute_store_type_t) 0x03000030)
///< This represents the WhitePointX attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_WHITE_POINTY ((attribute_store_type_t) 0x03000031)
///< This represents the WhitePointY attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRX ((attribute_store_type_t) 0x03000032)
///< This represents the ColorPointRX attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTRY ((attribute_store_type_t) 0x03000033)
///< This represents the ColorPointRY attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTR_INTENSITY ((attribute_store_type_t) 0x03000034)
///< This represents the ColorPointRIntensity attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGX ((attribute_store_type_t) 0x03000036)
///< This represents the ColorPointGX attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTGY ((attribute_store_type_t) 0x03000037)
///< This represents the ColorPointGY attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTG_INTENSITY ((attribute_store_type_t) 0x03000038)
///< This represents the ColorPointGIntensity attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBX ((attribute_store_type_t) 0x0300003a)
///< This represents the ColorPointBX attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTBY ((attribute_store_type_t) 0x0300003b)
///< This represents the ColorPointBY attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_POINTB_INTENSITY ((attribute_store_type_t) 0x0300003c)
///< This represents the ColorPointBIntensity attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_CURRENT_HUE ((attribute_store_type_t) 0x03004000)
///< This represents the EnhancedCurrentHue attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_ENHANCED_COLOR_MODE ((attribute_store_type_t) 0x03004001)
///< This represents the EnhancedColorMode attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_ACTIVE ((attribute_store_type_t) 0x03004002)
///< This represents the ColorLoopActive attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_DIRECTION ((attribute_store_type_t) 0x03004003)
///< This represents the ColorLoopDirection attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_TIME ((attribute_store_type_t) 0x03004004)
///< This represents the ColorLoopTime attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_START_ENHANCED_HUE ((attribute_store_type_t) 0x03004005)
///< This represents the ColorLoopStartEnhancedHue attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_LOOP_STORED_ENHANCED_HUE ((attribute_store_type_t) 0x03004006)
///< This represents the ColorLoopStoredEnhancedHue attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_CAPABILITIES ((attribute_store_type_t) 0x0300400a)
///< This represents the ColorCapabilities attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_MIREDS ((attribute_store_type_t) 0x0300400b)
///< This represents the ColorTempPhysicalMinMireds attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_MIREDS ((attribute_store_type_t) 0x0300400c)
///< This represents the ColorTempPhysicalMaxMireds attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS ((attribute_store_type_t) 0x0300400d)
///< This represents the CoupleColorTempToLevelMinMireds attribute in the DotDot ColorControl cluster

#define DOTDOT_ATTRIBUTE_ID_COLOR_CONTROL_START_UP_COLOR_TEMPERATURE_MIREDS ((attribute_store_type_t) 0x03004010)
///< This represents the StartUpColorTemperatureMireds attribute in the DotDot ColorControl cluster

// ColorControl CurrentHue
/**
 * @brief Verifies if the DotDot ColorControl CurrentHue is supported
 *
 * @returns true if CurrentHue is supported
 * @returns false if CurrentHue is not supported
 */
bool dotdot_is_supported_color_control_current_hue (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentHue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentHue attribute
 */
uint8_t dotdot_get_color_control_current_hue(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentHue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_hue new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_current_hue(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_current_hue);

// ColorControl CurrentSaturation
/**
 * @brief Verifies if the DotDot ColorControl CurrentSaturation is supported
 *
 * @returns true if CurrentSaturation is supported
 * @returns false if CurrentSaturation is not supported
 */
bool dotdot_is_supported_color_control_current_saturation (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentSaturation attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentSaturation attribute
 */
uint8_t dotdot_get_color_control_current_saturation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentSaturation attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_saturation new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_current_saturation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_current_saturation);

// ColorControl RemainingTime
/**
 * @brief Verifies if the DotDot ColorControl RemainingTime is supported
 *
 * @returns true if RemainingTime is supported
 * @returns false if RemainingTime is not supported
 */
bool dotdot_is_supported_color_control_remaining_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RemainingTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RemainingTime attribute
 */
uint16_t dotdot_get_color_control_remaining_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RemainingTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_remaining_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_remaining_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_remaining_time);

// ColorControl CurrentX
/**
 * @brief Verifies if the DotDot ColorControl CurrentX is supported
 *
 * @returns true if CurrentX is supported
 * @returns false if CurrentX is not supported
 */
bool dotdot_is_supported_color_control_currentx (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentX attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentX attribute
 */
uint16_t dotdot_get_color_control_currentx(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentX attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_currentx new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_currentx(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_currentx);

// ColorControl CurrentY
/**
 * @brief Verifies if the DotDot ColorControl CurrentY is supported
 *
 * @returns true if CurrentY is supported
 * @returns false if CurrentY is not supported
 */
bool dotdot_is_supported_color_control_currenty (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentY attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentY attribute
 */
uint16_t dotdot_get_color_control_currenty(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentY attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_currenty new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_currenty(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_currenty);

// ColorControl DriftCompensation
/**
 * @brief Verifies if the DotDot ColorControl DriftCompensation is supported
 *
 * @returns true if DriftCompensation is supported
 * @returns false if DriftCompensation is not supported
 */
bool dotdot_is_supported_color_control_drift_compensation (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DriftCompensation attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DriftCompensation attribute
 */
uint8_t dotdot_get_color_control_drift_compensation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DriftCompensation attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_drift_compensation new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_drift_compensation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_drift_compensation);

// ColorControl CompensationText
/**
 * @brief Verifies if the DotDot ColorControl CompensationText is supported
 *
 * @returns true if CompensationText is supported
 * @returns false if CompensationText is not supported
 */
bool dotdot_is_supported_color_control_compensation_text (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CompensationText attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CompensationText attribute
 */
const char* dotdot_get_color_control_compensation_text(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CompensationText attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_compensation_text new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_compensation_text(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_compensation_text);

// ColorControl ColorTemperatureMireds
/**
 * @brief Verifies if the DotDot ColorControl ColorTemperatureMireds is supported
 *
 * @returns true if ColorTemperatureMireds is supported
 * @returns false if ColorTemperatureMireds is not supported
 */
bool dotdot_is_supported_color_control_color_temperature_mireds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorTemperatureMireds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorTemperatureMireds attribute
 */
uint16_t dotdot_get_color_control_color_temperature_mireds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorTemperatureMireds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_temperature_mireds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_temperature_mireds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_temperature_mireds);

// ColorControl ColorMode
/**
 * @brief Verifies if the DotDot ColorControl ColorMode is supported
 *
 * @returns true if ColorMode is supported
 * @returns false if ColorMode is not supported
 */
bool dotdot_is_supported_color_control_color_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorMode attribute
 */
uint8_t dotdot_get_color_control_color_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_color_mode);

// ColorControl Options
/**
 * @brief Verifies if the DotDot ColorControl Options is supported
 *
 * @returns true if Options is supported
 * @returns false if Options is not supported
 */
bool dotdot_is_supported_color_control_options (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Options attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Options attribute
 */
uint8_t dotdot_get_color_control_options(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Options attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_options new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_options(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_options);

// ColorControl NumberOfPrimaries
/**
 * @brief Verifies if the DotDot ColorControl NumberOfPrimaries is supported
 *
 * @returns true if NumberOfPrimaries is supported
 * @returns false if NumberOfPrimaries is not supported
 */
bool dotdot_is_supported_color_control_number_of_primaries (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfPrimaries attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfPrimaries attribute
 */
uint8_t dotdot_get_color_control_number_of_primaries(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfPrimaries attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_primaries new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_number_of_primaries(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_number_of_primaries);

// ColorControl Primary1X
/**
 * @brief Verifies if the DotDot ColorControl Primary1X is supported
 *
 * @returns true if Primary1X is supported
 * @returns false if Primary1X is not supported
 */
bool dotdot_is_supported_color_control_primary1x (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary1X attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary1X attribute
 */
uint16_t dotdot_get_color_control_primary1x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary1X attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary1x new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary1x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary1x);

// ColorControl Primary1Y
/**
 * @brief Verifies if the DotDot ColorControl Primary1Y is supported
 *
 * @returns true if Primary1Y is supported
 * @returns false if Primary1Y is not supported
 */
bool dotdot_is_supported_color_control_primary1y (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary1Y attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary1Y attribute
 */
uint16_t dotdot_get_color_control_primary1y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary1Y attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary1y new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary1y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary1y);

// ColorControl Primary1Intensity
/**
 * @brief Verifies if the DotDot ColorControl Primary1Intensity is supported
 *
 * @returns true if Primary1Intensity is supported
 * @returns false if Primary1Intensity is not supported
 */
bool dotdot_is_supported_color_control_primary1_intensity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary1Intensity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary1Intensity attribute
 */
uint8_t dotdot_get_color_control_primary1_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary1Intensity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary1_intensity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary1_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_primary1_intensity);

// ColorControl Primary2X
/**
 * @brief Verifies if the DotDot ColorControl Primary2X is supported
 *
 * @returns true if Primary2X is supported
 * @returns false if Primary2X is not supported
 */
bool dotdot_is_supported_color_control_primary2x (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary2X attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary2X attribute
 */
uint16_t dotdot_get_color_control_primary2x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary2X attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary2x new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary2x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary2x);

// ColorControl Primary2Y
/**
 * @brief Verifies if the DotDot ColorControl Primary2Y is supported
 *
 * @returns true if Primary2Y is supported
 * @returns false if Primary2Y is not supported
 */
bool dotdot_is_supported_color_control_primary2y (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary2Y attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary2Y attribute
 */
uint16_t dotdot_get_color_control_primary2y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary2Y attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary2y new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary2y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary2y);

// ColorControl Primary2Intensity
/**
 * @brief Verifies if the DotDot ColorControl Primary2Intensity is supported
 *
 * @returns true if Primary2Intensity is supported
 * @returns false if Primary2Intensity is not supported
 */
bool dotdot_is_supported_color_control_primary2_intensity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary2Intensity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary2Intensity attribute
 */
uint8_t dotdot_get_color_control_primary2_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary2Intensity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary2_intensity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary2_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_primary2_intensity);

// ColorControl Primary3X
/**
 * @brief Verifies if the DotDot ColorControl Primary3X is supported
 *
 * @returns true if Primary3X is supported
 * @returns false if Primary3X is not supported
 */
bool dotdot_is_supported_color_control_primary3x (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary3X attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary3X attribute
 */
uint16_t dotdot_get_color_control_primary3x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary3X attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary3x new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary3x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary3x);

// ColorControl Primary3Y
/**
 * @brief Verifies if the DotDot ColorControl Primary3Y is supported
 *
 * @returns true if Primary3Y is supported
 * @returns false if Primary3Y is not supported
 */
bool dotdot_is_supported_color_control_primary3y (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary3Y attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary3Y attribute
 */
uint16_t dotdot_get_color_control_primary3y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary3Y attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary3y new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary3y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary3y);

// ColorControl Primary3Intensity
/**
 * @brief Verifies if the DotDot ColorControl Primary3Intensity is supported
 *
 * @returns true if Primary3Intensity is supported
 * @returns false if Primary3Intensity is not supported
 */
bool dotdot_is_supported_color_control_primary3_intensity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary3Intensity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary3Intensity attribute
 */
uint8_t dotdot_get_color_control_primary3_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary3Intensity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary3_intensity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary3_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_primary3_intensity);

// ColorControl Primary4X
/**
 * @brief Verifies if the DotDot ColorControl Primary4X is supported
 *
 * @returns true if Primary4X is supported
 * @returns false if Primary4X is not supported
 */
bool dotdot_is_supported_color_control_primary4x (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary4X attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary4X attribute
 */
uint16_t dotdot_get_color_control_primary4x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary4X attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary4x new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary4x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary4x);

// ColorControl Primary4Y
/**
 * @brief Verifies if the DotDot ColorControl Primary4Y is supported
 *
 * @returns true if Primary4Y is supported
 * @returns false if Primary4Y is not supported
 */
bool dotdot_is_supported_color_control_primary4y (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary4Y attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary4Y attribute
 */
uint16_t dotdot_get_color_control_primary4y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary4Y attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary4y new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary4y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary4y);

// ColorControl Primary4Intensity
/**
 * @brief Verifies if the DotDot ColorControl Primary4Intensity is supported
 *
 * @returns true if Primary4Intensity is supported
 * @returns false if Primary4Intensity is not supported
 */
bool dotdot_is_supported_color_control_primary4_intensity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary4Intensity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary4Intensity attribute
 */
uint8_t dotdot_get_color_control_primary4_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary4Intensity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary4_intensity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary4_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_primary4_intensity);

// ColorControl Primary5X
/**
 * @brief Verifies if the DotDot ColorControl Primary5X is supported
 *
 * @returns true if Primary5X is supported
 * @returns false if Primary5X is not supported
 */
bool dotdot_is_supported_color_control_primary5x (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary5X attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary5X attribute
 */
uint16_t dotdot_get_color_control_primary5x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary5X attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary5x new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary5x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary5x);

// ColorControl Primary5Y
/**
 * @brief Verifies if the DotDot ColorControl Primary5Y is supported
 *
 * @returns true if Primary5Y is supported
 * @returns false if Primary5Y is not supported
 */
bool dotdot_is_supported_color_control_primary5y (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary5Y attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary5Y attribute
 */
uint16_t dotdot_get_color_control_primary5y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary5Y attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary5y new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary5y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary5y);

// ColorControl Primary5Intensity
/**
 * @brief Verifies if the DotDot ColorControl Primary5Intensity is supported
 *
 * @returns true if Primary5Intensity is supported
 * @returns false if Primary5Intensity is not supported
 */
bool dotdot_is_supported_color_control_primary5_intensity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary5Intensity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary5Intensity attribute
 */
uint8_t dotdot_get_color_control_primary5_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary5Intensity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary5_intensity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary5_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_primary5_intensity);

// ColorControl Primary6X
/**
 * @brief Verifies if the DotDot ColorControl Primary6X is supported
 *
 * @returns true if Primary6X is supported
 * @returns false if Primary6X is not supported
 */
bool dotdot_is_supported_color_control_primary6x (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary6X attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary6X attribute
 */
uint16_t dotdot_get_color_control_primary6x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary6X attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary6x new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary6x(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary6x);

// ColorControl Primary6Y
/**
 * @brief Verifies if the DotDot ColorControl Primary6Y is supported
 *
 * @returns true if Primary6Y is supported
 * @returns false if Primary6Y is not supported
 */
bool dotdot_is_supported_color_control_primary6y (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary6Y attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary6Y attribute
 */
uint16_t dotdot_get_color_control_primary6y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary6Y attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary6y new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary6y(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_primary6y);

// ColorControl Primary6Intensity
/**
 * @brief Verifies if the DotDot ColorControl Primary6Intensity is supported
 *
 * @returns true if Primary6Intensity is supported
 * @returns false if Primary6Intensity is not supported
 */
bool dotdot_is_supported_color_control_primary6_intensity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Primary6Intensity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Primary6Intensity attribute
 */
uint8_t dotdot_get_color_control_primary6_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Primary6Intensity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_primary6_intensity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_primary6_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_primary6_intensity);

// ColorControl WhitePointX
/**
 * @brief Verifies if the DotDot ColorControl WhitePointX is supported
 *
 * @returns true if WhitePointX is supported
 * @returns false if WhitePointX is not supported
 */
bool dotdot_is_supported_color_control_white_pointx (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot WhitePointX attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns WhitePointX attribute
 */
uint16_t dotdot_get_color_control_white_pointx(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot WhitePointX attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_white_pointx new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_white_pointx(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_white_pointx);

// ColorControl WhitePointY
/**
 * @brief Verifies if the DotDot ColorControl WhitePointY is supported
 *
 * @returns true if WhitePointY is supported
 * @returns false if WhitePointY is not supported
 */
bool dotdot_is_supported_color_control_white_pointy (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot WhitePointY attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns WhitePointY attribute
 */
uint16_t dotdot_get_color_control_white_pointy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot WhitePointY attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_white_pointy new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_white_pointy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_white_pointy);

// ColorControl ColorPointRX
/**
 * @brief Verifies if the DotDot ColorControl ColorPointRX is supported
 *
 * @returns true if ColorPointRX is supported
 * @returns false if ColorPointRX is not supported
 */
bool dotdot_is_supported_color_control_color_pointrx (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorPointRX attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorPointRX attribute
 */
uint16_t dotdot_get_color_control_color_pointrx(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorPointRX attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_pointrx new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_pointrx(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_pointrx);

// ColorControl ColorPointRY
/**
 * @brief Verifies if the DotDot ColorControl ColorPointRY is supported
 *
 * @returns true if ColorPointRY is supported
 * @returns false if ColorPointRY is not supported
 */
bool dotdot_is_supported_color_control_color_pointry (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorPointRY attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorPointRY attribute
 */
uint16_t dotdot_get_color_control_color_pointry(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorPointRY attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_pointry new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_pointry(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_pointry);

// ColorControl ColorPointRIntensity
/**
 * @brief Verifies if the DotDot ColorControl ColorPointRIntensity is supported
 *
 * @returns true if ColorPointRIntensity is supported
 * @returns false if ColorPointRIntensity is not supported
 */
bool dotdot_is_supported_color_control_color_pointr_intensity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorPointRIntensity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorPointRIntensity attribute
 */
uint8_t dotdot_get_color_control_color_pointr_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorPointRIntensity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_pointr_intensity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_pointr_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_color_pointr_intensity);

// ColorControl ColorPointGX
/**
 * @brief Verifies if the DotDot ColorControl ColorPointGX is supported
 *
 * @returns true if ColorPointGX is supported
 * @returns false if ColorPointGX is not supported
 */
bool dotdot_is_supported_color_control_color_pointgx (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorPointGX attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorPointGX attribute
 */
uint16_t dotdot_get_color_control_color_pointgx(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorPointGX attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_pointgx new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_pointgx(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_pointgx);

// ColorControl ColorPointGY
/**
 * @brief Verifies if the DotDot ColorControl ColorPointGY is supported
 *
 * @returns true if ColorPointGY is supported
 * @returns false if ColorPointGY is not supported
 */
bool dotdot_is_supported_color_control_color_pointgy (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorPointGY attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorPointGY attribute
 */
uint16_t dotdot_get_color_control_color_pointgy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorPointGY attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_pointgy new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_pointgy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_pointgy);

// ColorControl ColorPointGIntensity
/**
 * @brief Verifies if the DotDot ColorControl ColorPointGIntensity is supported
 *
 * @returns true if ColorPointGIntensity is supported
 * @returns false if ColorPointGIntensity is not supported
 */
bool dotdot_is_supported_color_control_color_pointg_intensity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorPointGIntensity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorPointGIntensity attribute
 */
uint8_t dotdot_get_color_control_color_pointg_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorPointGIntensity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_pointg_intensity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_pointg_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_color_pointg_intensity);

// ColorControl ColorPointBX
/**
 * @brief Verifies if the DotDot ColorControl ColorPointBX is supported
 *
 * @returns true if ColorPointBX is supported
 * @returns false if ColorPointBX is not supported
 */
bool dotdot_is_supported_color_control_color_pointbx (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorPointBX attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorPointBX attribute
 */
uint16_t dotdot_get_color_control_color_pointbx(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorPointBX attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_pointbx new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_pointbx(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_pointbx);

// ColorControl ColorPointBY
/**
 * @brief Verifies if the DotDot ColorControl ColorPointBY is supported
 *
 * @returns true if ColorPointBY is supported
 * @returns false if ColorPointBY is not supported
 */
bool dotdot_is_supported_color_control_color_pointby (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorPointBY attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorPointBY attribute
 */
uint16_t dotdot_get_color_control_color_pointby(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorPointBY attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_pointby new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_pointby(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_pointby);

// ColorControl ColorPointBIntensity
/**
 * @brief Verifies if the DotDot ColorControl ColorPointBIntensity is supported
 *
 * @returns true if ColorPointBIntensity is supported
 * @returns false if ColorPointBIntensity is not supported
 */
bool dotdot_is_supported_color_control_color_pointb_intensity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorPointBIntensity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorPointBIntensity attribute
 */
uint8_t dotdot_get_color_control_color_pointb_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorPointBIntensity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_pointb_intensity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_pointb_intensity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_color_pointb_intensity);

// ColorControl EnhancedCurrentHue
/**
 * @brief Verifies if the DotDot ColorControl EnhancedCurrentHue is supported
 *
 * @returns true if EnhancedCurrentHue is supported
 * @returns false if EnhancedCurrentHue is not supported
 */
bool dotdot_is_supported_color_control_enhanced_current_hue (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EnhancedCurrentHue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EnhancedCurrentHue attribute
 */
uint16_t dotdot_get_color_control_enhanced_current_hue(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EnhancedCurrentHue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_enhanced_current_hue new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_enhanced_current_hue(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_enhanced_current_hue);

// ColorControl EnhancedColorMode
/**
 * @brief Verifies if the DotDot ColorControl EnhancedColorMode is supported
 *
 * @returns true if EnhancedColorMode is supported
 * @returns false if EnhancedColorMode is not supported
 */
bool dotdot_is_supported_color_control_enhanced_color_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EnhancedColorMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EnhancedColorMode attribute
 */
uint8_t dotdot_get_color_control_enhanced_color_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EnhancedColorMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_enhanced_color_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_enhanced_color_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_enhanced_color_mode);

// ColorControl ColorLoopActive
/**
 * @brief Verifies if the DotDot ColorControl ColorLoopActive is supported
 *
 * @returns true if ColorLoopActive is supported
 * @returns false if ColorLoopActive is not supported
 */
bool dotdot_is_supported_color_control_color_loop_active (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorLoopActive attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorLoopActive attribute
 */
uint8_t dotdot_get_color_control_color_loop_active(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorLoopActive attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_loop_active new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_loop_active(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_color_loop_active);

// ColorControl ColorLoopDirection
/**
 * @brief Verifies if the DotDot ColorControl ColorLoopDirection is supported
 *
 * @returns true if ColorLoopDirection is supported
 * @returns false if ColorLoopDirection is not supported
 */
bool dotdot_is_supported_color_control_color_loop_direction (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorLoopDirection attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorLoopDirection attribute
 */
CCColorLoopDirection dotdot_get_color_control_color_loop_direction(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorLoopDirection attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_loop_direction new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_loop_direction(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  CCColorLoopDirection new_color_loop_direction);

// ColorControl ColorLoopTime
/**
 * @brief Verifies if the DotDot ColorControl ColorLoopTime is supported
 *
 * @returns true if ColorLoopTime is supported
 * @returns false if ColorLoopTime is not supported
 */
bool dotdot_is_supported_color_control_color_loop_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorLoopTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorLoopTime attribute
 */
uint16_t dotdot_get_color_control_color_loop_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorLoopTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_loop_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_loop_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_loop_time);

// ColorControl ColorLoopStartEnhancedHue
/**
 * @brief Verifies if the DotDot ColorControl ColorLoopStartEnhancedHue is supported
 *
 * @returns true if ColorLoopStartEnhancedHue is supported
 * @returns false if ColorLoopStartEnhancedHue is not supported
 */
bool dotdot_is_supported_color_control_color_loop_start_enhanced_hue (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorLoopStartEnhancedHue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorLoopStartEnhancedHue attribute
 */
uint16_t dotdot_get_color_control_color_loop_start_enhanced_hue(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorLoopStartEnhancedHue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_loop_start_enhanced_hue new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_loop_start_enhanced_hue(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_loop_start_enhanced_hue);

// ColorControl ColorLoopStoredEnhancedHue
/**
 * @brief Verifies if the DotDot ColorControl ColorLoopStoredEnhancedHue is supported
 *
 * @returns true if ColorLoopStoredEnhancedHue is supported
 * @returns false if ColorLoopStoredEnhancedHue is not supported
 */
bool dotdot_is_supported_color_control_color_loop_stored_enhanced_hue (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorLoopStoredEnhancedHue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorLoopStoredEnhancedHue attribute
 */
uint16_t dotdot_get_color_control_color_loop_stored_enhanced_hue(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorLoopStoredEnhancedHue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_loop_stored_enhanced_hue new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_loop_stored_enhanced_hue(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_loop_stored_enhanced_hue);

// ColorControl ColorCapabilities
/**
 * @brief Verifies if the DotDot ColorControl ColorCapabilities is supported
 *
 * @returns true if ColorCapabilities is supported
 * @returns false if ColorCapabilities is not supported
 */
bool dotdot_is_supported_color_control_color_capabilities (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorCapabilities attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorCapabilities attribute
 */
uint16_t dotdot_get_color_control_color_capabilities(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorCapabilities attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_capabilities new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_capabilities(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_capabilities);

// ColorControl ColorTempPhysicalMinMireds
/**
 * @brief Verifies if the DotDot ColorControl ColorTempPhysicalMinMireds is supported
 *
 * @returns true if ColorTempPhysicalMinMireds is supported
 * @returns false if ColorTempPhysicalMinMireds is not supported
 */
bool dotdot_is_supported_color_control_color_temp_physical_min_mireds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorTempPhysicalMinMireds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorTempPhysicalMinMireds attribute
 */
uint16_t dotdot_get_color_control_color_temp_physical_min_mireds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorTempPhysicalMinMireds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_temp_physical_min_mireds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_temp_physical_min_mireds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_temp_physical_min_mireds);

// ColorControl ColorTempPhysicalMaxMireds
/**
 * @brief Verifies if the DotDot ColorControl ColorTempPhysicalMaxMireds is supported
 *
 * @returns true if ColorTempPhysicalMaxMireds is supported
 * @returns false if ColorTempPhysicalMaxMireds is not supported
 */
bool dotdot_is_supported_color_control_color_temp_physical_max_mireds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ColorTempPhysicalMaxMireds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ColorTempPhysicalMaxMireds attribute
 */
uint16_t dotdot_get_color_control_color_temp_physical_max_mireds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ColorTempPhysicalMaxMireds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_color_temp_physical_max_mireds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_color_temp_physical_max_mireds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_color_temp_physical_max_mireds);

// ColorControl CoupleColorTempToLevelMinMireds
/**
 * @brief Verifies if the DotDot ColorControl CoupleColorTempToLevelMinMireds is supported
 *
 * @returns true if CoupleColorTempToLevelMinMireds is supported
 * @returns false if CoupleColorTempToLevelMinMireds is not supported
 */
bool dotdot_is_supported_color_control_couple_color_temp_to_level_min_mireds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CoupleColorTempToLevelMinMireds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CoupleColorTempToLevelMinMireds attribute
 */
uint16_t dotdot_get_color_control_couple_color_temp_to_level_min_mireds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CoupleColorTempToLevelMinMireds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_couple_color_temp_to_level_min_mireds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_couple_color_temp_to_level_min_mireds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_couple_color_temp_to_level_min_mireds);

// ColorControl StartUpColorTemperatureMireds
/**
 * @brief Verifies if the DotDot ColorControl StartUpColorTemperatureMireds is supported
 *
 * @returns true if StartUpColorTemperatureMireds is supported
 * @returns false if StartUpColorTemperatureMireds is not supported
 */
bool dotdot_is_supported_color_control_start_up_color_temperature_mireds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot StartUpColorTemperatureMireds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns StartUpColorTemperatureMireds attribute
 */
uint16_t dotdot_get_color_control_start_up_color_temperature_mireds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot StartUpColorTemperatureMireds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_start_up_color_temperature_mireds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_color_control_start_up_color_temperature_mireds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_start_up_color_temperature_mireds);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster BallastConfiguration
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for BallastConfiguration
#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MIN_LEVEL ((attribute_store_type_t) 0x03010000)
///< This represents the PhysicalMinLevel attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_PHYSICAL_MAX_LEVEL ((attribute_store_type_t) 0x03010001)
///< This represents the PhysicalMaxLevel attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_STATUS ((attribute_store_type_t) 0x03010002)
///< This represents the BallastStatus attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MIN_LEVEL ((attribute_store_type_t) 0x03010010)
///< This represents the MinLevel attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_MAX_LEVEL ((attribute_store_type_t) 0x03010011)
///< This represents the MaxLevel attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_LEVEL ((attribute_store_type_t) 0x03010012)
///< This represents the PowerOnLevel attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_POWER_ON_FADE_TIME ((attribute_store_type_t) 0x03010013)
///< This represents the PowerOnFadeTime attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_INTRINSIC_BALLAST_FACTOR ((attribute_store_type_t) 0x03010014)
///< This represents the IntrinsicBallastFactor attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_BALLAST_FACTOR_ADJUSTMENT ((attribute_store_type_t) 0x03010015)
///< This represents the BallastFactorAdjustment attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_QUANTITY ((attribute_store_type_t) 0x03010020)
///< This represents the LampQuantity attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_TYPE ((attribute_store_type_t) 0x03010030)
///< This represents the LampType attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_MANUFACTURER ((attribute_store_type_t) 0x03010031)
///< This represents the LampManufacturer attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_RATED_HOURS ((attribute_store_type_t) 0x03010032)
///< This represents the LampRatedHours attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS ((attribute_store_type_t) 0x03010033)
///< This represents the LampBurnHours attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_ALARM_MODE ((attribute_store_type_t) 0x03010034)
///< This represents the LampAlarmMode attribute in the DotDot BallastConfiguration cluster

#define DOTDOT_ATTRIBUTE_ID_BALLAST_CONFIGURATION_LAMP_BURN_HOURS_TRIP_POINT ((attribute_store_type_t) 0x03010035)
///< This represents the LampBurnHoursTripPoint attribute in the DotDot BallastConfiguration cluster

// BallastConfiguration PhysicalMinLevel
/**
 * @brief Verifies if the DotDot BallastConfiguration PhysicalMinLevel is supported
 *
 * @returns true if PhysicalMinLevel is supported
 * @returns false if PhysicalMinLevel is not supported
 */
bool dotdot_is_supported_ballast_configuration_physical_min_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PhysicalMinLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PhysicalMinLevel attribute
 */
uint8_t dotdot_get_ballast_configuration_physical_min_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PhysicalMinLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_physical_min_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_physical_min_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_physical_min_level);

// BallastConfiguration PhysicalMaxLevel
/**
 * @brief Verifies if the DotDot BallastConfiguration PhysicalMaxLevel is supported
 *
 * @returns true if PhysicalMaxLevel is supported
 * @returns false if PhysicalMaxLevel is not supported
 */
bool dotdot_is_supported_ballast_configuration_physical_max_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PhysicalMaxLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PhysicalMaxLevel attribute
 */
uint8_t dotdot_get_ballast_configuration_physical_max_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PhysicalMaxLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_physical_max_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_physical_max_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_physical_max_level);

// BallastConfiguration BallastStatus
/**
 * @brief Verifies if the DotDot BallastConfiguration BallastStatus is supported
 *
 * @returns true if BallastStatus is supported
 * @returns false if BallastStatus is not supported
 */
bool dotdot_is_supported_ballast_configuration_ballast_status (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BallastStatus attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BallastStatus attribute
 */
uint8_t dotdot_get_ballast_configuration_ballast_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BallastStatus attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ballast_status new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_ballast_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_ballast_status);

// BallastConfiguration MinLevel
/**
 * @brief Verifies if the DotDot BallastConfiguration MinLevel is supported
 *
 * @returns true if MinLevel is supported
 * @returns false if MinLevel is not supported
 */
bool dotdot_is_supported_ballast_configuration_min_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinLevel attribute
 */
uint8_t dotdot_get_ballast_configuration_min_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_min_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_min_level);

// BallastConfiguration MaxLevel
/**
 * @brief Verifies if the DotDot BallastConfiguration MaxLevel is supported
 *
 * @returns true if MaxLevel is supported
 * @returns false if MaxLevel is not supported
 */
bool dotdot_is_supported_ballast_configuration_max_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxLevel attribute
 */
uint8_t dotdot_get_ballast_configuration_max_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_max_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_max_level);

// BallastConfiguration PowerOnLevel
/**
 * @brief Verifies if the DotDot BallastConfiguration PowerOnLevel is supported
 *
 * @returns true if PowerOnLevel is supported
 * @returns false if PowerOnLevel is not supported
 */
bool dotdot_is_supported_ballast_configuration_power_on_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PowerOnLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PowerOnLevel attribute
 */
uint8_t dotdot_get_ballast_configuration_power_on_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PowerOnLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power_on_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_power_on_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_power_on_level);

// BallastConfiguration PowerOnFadeTime
/**
 * @brief Verifies if the DotDot BallastConfiguration PowerOnFadeTime is supported
 *
 * @returns true if PowerOnFadeTime is supported
 * @returns false if PowerOnFadeTime is not supported
 */
bool dotdot_is_supported_ballast_configuration_power_on_fade_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PowerOnFadeTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PowerOnFadeTime attribute
 */
uint16_t dotdot_get_ballast_configuration_power_on_fade_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PowerOnFadeTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power_on_fade_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_power_on_fade_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_power_on_fade_time);

// BallastConfiguration IntrinsicBallastFactor
/**
 * @brief Verifies if the DotDot BallastConfiguration IntrinsicBallastFactor is supported
 *
 * @returns true if IntrinsicBallastFactor is supported
 * @returns false if IntrinsicBallastFactor is not supported
 */
bool dotdot_is_supported_ballast_configuration_intrinsic_ballast_factor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot IntrinsicBallastFactor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns IntrinsicBallastFactor attribute
 */
uint8_t dotdot_get_ballast_configuration_intrinsic_ballast_factor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot IntrinsicBallastFactor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_intrinsic_ballast_factor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_intrinsic_ballast_factor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_intrinsic_ballast_factor);

// BallastConfiguration BallastFactorAdjustment
/**
 * @brief Verifies if the DotDot BallastConfiguration BallastFactorAdjustment is supported
 *
 * @returns true if BallastFactorAdjustment is supported
 * @returns false if BallastFactorAdjustment is not supported
 */
bool dotdot_is_supported_ballast_configuration_ballast_factor_adjustment (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BallastFactorAdjustment attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BallastFactorAdjustment attribute
 */
uint8_t dotdot_get_ballast_configuration_ballast_factor_adjustment(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BallastFactorAdjustment attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ballast_factor_adjustment new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_ballast_factor_adjustment(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_ballast_factor_adjustment);

// BallastConfiguration LampQuantity
/**
 * @brief Verifies if the DotDot BallastConfiguration LampQuantity is supported
 *
 * @returns true if LampQuantity is supported
 * @returns false if LampQuantity is not supported
 */
bool dotdot_is_supported_ballast_configuration_lamp_quantity (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LampQuantity attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LampQuantity attribute
 */
uint8_t dotdot_get_ballast_configuration_lamp_quantity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LampQuantity attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lamp_quantity new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_lamp_quantity(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_lamp_quantity);

// BallastConfiguration LampType
/**
 * @brief Verifies if the DotDot BallastConfiguration LampType is supported
 *
 * @returns true if LampType is supported
 * @returns false if LampType is not supported
 */
bool dotdot_is_supported_ballast_configuration_lamp_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LampType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LampType attribute
 */
const char* dotdot_get_ballast_configuration_lamp_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LampType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lamp_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_lamp_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_lamp_type);

// BallastConfiguration LampManufacturer
/**
 * @brief Verifies if the DotDot BallastConfiguration LampManufacturer is supported
 *
 * @returns true if LampManufacturer is supported
 * @returns false if LampManufacturer is not supported
 */
bool dotdot_is_supported_ballast_configuration_lamp_manufacturer (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LampManufacturer attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LampManufacturer attribute
 */
const char* dotdot_get_ballast_configuration_lamp_manufacturer(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LampManufacturer attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lamp_manufacturer new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_lamp_manufacturer(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_lamp_manufacturer);

// BallastConfiguration LampRatedHours
/**
 * @brief Verifies if the DotDot BallastConfiguration LampRatedHours is supported
 *
 * @returns true if LampRatedHours is supported
 * @returns false if LampRatedHours is not supported
 */
bool dotdot_is_supported_ballast_configuration_lamp_rated_hours (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LampRatedHours attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LampRatedHours attribute
 */
uint32_t dotdot_get_ballast_configuration_lamp_rated_hours(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LampRatedHours attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lamp_rated_hours new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_lamp_rated_hours(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_lamp_rated_hours);

// BallastConfiguration LampBurnHours
/**
 * @brief Verifies if the DotDot BallastConfiguration LampBurnHours is supported
 *
 * @returns true if LampBurnHours is supported
 * @returns false if LampBurnHours is not supported
 */
bool dotdot_is_supported_ballast_configuration_lamp_burn_hours (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LampBurnHours attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LampBurnHours attribute
 */
uint32_t dotdot_get_ballast_configuration_lamp_burn_hours(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LampBurnHours attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lamp_burn_hours new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_lamp_burn_hours(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_lamp_burn_hours);

// BallastConfiguration LampAlarmMode
/**
 * @brief Verifies if the DotDot BallastConfiguration LampAlarmMode is supported
 *
 * @returns true if LampAlarmMode is supported
 * @returns false if LampAlarmMode is not supported
 */
bool dotdot_is_supported_ballast_configuration_lamp_alarm_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LampAlarmMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LampAlarmMode attribute
 */
uint8_t dotdot_get_ballast_configuration_lamp_alarm_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LampAlarmMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lamp_alarm_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_lamp_alarm_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_lamp_alarm_mode);

// BallastConfiguration LampBurnHoursTripPoint
/**
 * @brief Verifies if the DotDot BallastConfiguration LampBurnHoursTripPoint is supported
 *
 * @returns true if LampBurnHoursTripPoint is supported
 * @returns false if LampBurnHoursTripPoint is not supported
 */
bool dotdot_is_supported_ballast_configuration_lamp_burn_hours_trip_point (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LampBurnHoursTripPoint attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LampBurnHoursTripPoint attribute
 */
uint32_t dotdot_get_ballast_configuration_lamp_burn_hours_trip_point(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LampBurnHoursTripPoint attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_lamp_burn_hours_trip_point new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ballast_configuration_lamp_burn_hours_trip_point(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_lamp_burn_hours_trip_point);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster IlluminanceMeasurement
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for IlluminanceMeasurement
#define DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MEASURED_VALUE ((attribute_store_type_t) 0x04000000)
///< This represents the MeasuredValue attribute in the DotDot IlluminanceMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MIN_MEASURED_VALUE ((attribute_store_type_t) 0x04000001)
///< This represents the MinMeasuredValue attribute in the DotDot IlluminanceMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_MAX_MEASURED_VALUE ((attribute_store_type_t) 0x04000002)
///< This represents the MaxMeasuredValue attribute in the DotDot IlluminanceMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_TOLERANCE ((attribute_store_type_t) 0x04000003)
///< This represents the Tolerance attribute in the DotDot IlluminanceMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_MEASUREMENT_LIGHT_SENSOR_TYPE ((attribute_store_type_t) 0x04000004)
///< This represents the LightSensorType attribute in the DotDot IlluminanceMeasurement cluster

// IlluminanceMeasurement MeasuredValue
/**
 * @brief Verifies if the DotDot IlluminanceMeasurement MeasuredValue is supported
 *
 * @returns true if MeasuredValue is supported
 * @returns false if MeasuredValue is not supported
 */
bool dotdot_is_supported_illuminance_measurement_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredValue attribute
 */
uint16_t dotdot_get_illuminance_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_illuminance_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_measured_value);

// IlluminanceMeasurement MinMeasuredValue
/**
 * @brief Verifies if the DotDot IlluminanceMeasurement MinMeasuredValue is supported
 *
 * @returns true if MinMeasuredValue is supported
 * @returns false if MinMeasuredValue is not supported
 */
bool dotdot_is_supported_illuminance_measurement_min_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinMeasuredValue attribute
 */
uint16_t dotdot_get_illuminance_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_illuminance_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_min_measured_value);

// IlluminanceMeasurement MaxMeasuredValue
/**
 * @brief Verifies if the DotDot IlluminanceMeasurement MaxMeasuredValue is supported
 *
 * @returns true if MaxMeasuredValue is supported
 * @returns false if MaxMeasuredValue is not supported
 */
bool dotdot_is_supported_illuminance_measurement_max_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxMeasuredValue attribute
 */
uint16_t dotdot_get_illuminance_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_illuminance_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_measured_value);

// IlluminanceMeasurement Tolerance
/**
 * @brief Verifies if the DotDot IlluminanceMeasurement Tolerance is supported
 *
 * @returns true if Tolerance is supported
 * @returns false if Tolerance is not supported
 */
bool dotdot_is_supported_illuminance_measurement_tolerance (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Tolerance attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Tolerance attribute
 */
uint16_t dotdot_get_illuminance_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Tolerance attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_tolerance new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_illuminance_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_tolerance);

// IlluminanceMeasurement LightSensorType
/**
 * @brief Verifies if the DotDot IlluminanceMeasurement LightSensorType is supported
 *
 * @returns true if LightSensorType is supported
 * @returns false if LightSensorType is not supported
 */
bool dotdot_is_supported_illuminance_measurement_light_sensor_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LightSensorType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LightSensorType attribute
 */
uint8_t dotdot_get_illuminance_measurement_light_sensor_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LightSensorType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_light_sensor_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_illuminance_measurement_light_sensor_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_light_sensor_type);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster IlluminanceLevelSensing
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for IlluminanceLevelSensing
#define DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LEVEL_STATUS ((attribute_store_type_t) 0x04010000)
///< This represents the LevelStatus attribute in the DotDot IlluminanceLevelSensing cluster

#define DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_LIGHT_SENSOR_TYPE ((attribute_store_type_t) 0x04010001)
///< This represents the LightSensorType attribute in the DotDot IlluminanceLevelSensing cluster

#define DOTDOT_ATTRIBUTE_ID_ILLUMINANCE_LEVEL_SENSING_ILLUMINANCE_TARGET_LEVEL ((attribute_store_type_t) 0x04010010)
///< This represents the IlluminanceTargetLevel attribute in the DotDot IlluminanceLevelSensing cluster

// IlluminanceLevelSensing LevelStatus
/**
 * @brief Verifies if the DotDot IlluminanceLevelSensing LevelStatus is supported
 *
 * @returns true if LevelStatus is supported
 * @returns false if LevelStatus is not supported
 */
bool dotdot_is_supported_illuminance_level_sensing_level_status (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LevelStatus attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LevelStatus attribute
 */
uint8_t dotdot_get_illuminance_level_sensing_level_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LevelStatus attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_level_status new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_illuminance_level_sensing_level_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_level_status);

// IlluminanceLevelSensing LightSensorType
/**
 * @brief Verifies if the DotDot IlluminanceLevelSensing LightSensorType is supported
 *
 * @returns true if LightSensorType is supported
 * @returns false if LightSensorType is not supported
 */
bool dotdot_is_supported_illuminance_level_sensing_light_sensor_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LightSensorType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LightSensorType attribute
 */
uint8_t dotdot_get_illuminance_level_sensing_light_sensor_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LightSensorType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_light_sensor_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_illuminance_level_sensing_light_sensor_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_light_sensor_type);

// IlluminanceLevelSensing IlluminanceTargetLevel
/**
 * @brief Verifies if the DotDot IlluminanceLevelSensing IlluminanceTargetLevel is supported
 *
 * @returns true if IlluminanceTargetLevel is supported
 * @returns false if IlluminanceTargetLevel is not supported
 */
bool dotdot_is_supported_illuminance_level_sensing_illuminance_target_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot IlluminanceTargetLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns IlluminanceTargetLevel attribute
 */
uint16_t dotdot_get_illuminance_level_sensing_illuminance_target_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot IlluminanceTargetLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_illuminance_target_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_illuminance_level_sensing_illuminance_target_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_illuminance_target_level);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster TemperatureMeasurement
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for TemperatureMeasurement
#define DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MEASURED_VALUE ((attribute_store_type_t) 0x04020000)
///< This represents the MeasuredValue attribute in the DotDot TemperatureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MIN_MEASURED_VALUE ((attribute_store_type_t) 0x04020001)
///< This represents the MinMeasuredValue attribute in the DotDot TemperatureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_MAX_MEASURED_VALUE ((attribute_store_type_t) 0x04020002)
///< This represents the MaxMeasuredValue attribute in the DotDot TemperatureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_TEMPERATURE_MEASUREMENT_TOLERANCE ((attribute_store_type_t) 0x04020003)
///< This represents the Tolerance attribute in the DotDot TemperatureMeasurement cluster

// TemperatureMeasurement MeasuredValue
/**
 * @brief Verifies if the DotDot TemperatureMeasurement MeasuredValue is supported
 *
 * @returns true if MeasuredValue is supported
 * @returns false if MeasuredValue is not supported
 */
bool dotdot_is_supported_temperature_measurement_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredValue attribute
 */
int16_t dotdot_get_temperature_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_temperature_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured_value);

// TemperatureMeasurement MinMeasuredValue
/**
 * @brief Verifies if the DotDot TemperatureMeasurement MinMeasuredValue is supported
 *
 * @returns true if MinMeasuredValue is supported
 * @returns false if MinMeasuredValue is not supported
 */
bool dotdot_is_supported_temperature_measurement_min_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinMeasuredValue attribute
 */
int16_t dotdot_get_temperature_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_temperature_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_min_measured_value);

// TemperatureMeasurement MaxMeasuredValue
/**
 * @brief Verifies if the DotDot TemperatureMeasurement MaxMeasuredValue is supported
 *
 * @returns true if MaxMeasuredValue is supported
 * @returns false if MaxMeasuredValue is not supported
 */
bool dotdot_is_supported_temperature_measurement_max_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxMeasuredValue attribute
 */
int16_t dotdot_get_temperature_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_temperature_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_max_measured_value);

// TemperatureMeasurement Tolerance
/**
 * @brief Verifies if the DotDot TemperatureMeasurement Tolerance is supported
 *
 * @returns true if Tolerance is supported
 * @returns false if Tolerance is not supported
 */
bool dotdot_is_supported_temperature_measurement_tolerance (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Tolerance attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Tolerance attribute
 */
uint16_t dotdot_get_temperature_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Tolerance attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_tolerance new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_temperature_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_tolerance);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster PressureMeasurement
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for PressureMeasurement
#define DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MEASURED_VALUE ((attribute_store_type_t) 0x04030000)
///< This represents the MeasuredValue attribute in the DotDot PressureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_MEASURED_VALUE ((attribute_store_type_t) 0x04030001)
///< This represents the MinMeasuredValue attribute in the DotDot PressureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_MEASURED_VALUE ((attribute_store_type_t) 0x04030002)
///< This represents the MaxMeasuredValue attribute in the DotDot PressureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_TOLERANCE ((attribute_store_type_t) 0x04030003)
///< This represents the Tolerance attribute in the DotDot PressureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_VALUE ((attribute_store_type_t) 0x04030010)
///< This represents the ScaledValue attribute in the DotDot PressureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MIN_SCALED_VALUE ((attribute_store_type_t) 0x04030011)
///< This represents the MinScaledValue attribute in the DotDot PressureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_MAX_SCALED_VALUE ((attribute_store_type_t) 0x04030012)
///< This represents the MaxScaledValue attribute in the DotDot PressureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALED_TOLERANCE ((attribute_store_type_t) 0x04030013)
///< This represents the ScaledTolerance attribute in the DotDot PressureMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PRESSURE_MEASUREMENT_SCALE ((attribute_store_type_t) 0x04030014)
///< This represents the Scale attribute in the DotDot PressureMeasurement cluster

// PressureMeasurement MeasuredValue
/**
 * @brief Verifies if the DotDot PressureMeasurement MeasuredValue is supported
 *
 * @returns true if MeasuredValue is supported
 * @returns false if MeasuredValue is not supported
 */
bool dotdot_is_supported_pressure_measurement_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredValue attribute
 */
int16_t dotdot_get_pressure_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pressure_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured_value);

// PressureMeasurement MinMeasuredValue
/**
 * @brief Verifies if the DotDot PressureMeasurement MinMeasuredValue is supported
 *
 * @returns true if MinMeasuredValue is supported
 * @returns false if MinMeasuredValue is not supported
 */
bool dotdot_is_supported_pressure_measurement_min_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinMeasuredValue attribute
 */
int16_t dotdot_get_pressure_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pressure_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_min_measured_value);

// PressureMeasurement MaxMeasuredValue
/**
 * @brief Verifies if the DotDot PressureMeasurement MaxMeasuredValue is supported
 *
 * @returns true if MaxMeasuredValue is supported
 * @returns false if MaxMeasuredValue is not supported
 */
bool dotdot_is_supported_pressure_measurement_max_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxMeasuredValue attribute
 */
int16_t dotdot_get_pressure_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pressure_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_max_measured_value);

// PressureMeasurement Tolerance
/**
 * @brief Verifies if the DotDot PressureMeasurement Tolerance is supported
 *
 * @returns true if Tolerance is supported
 * @returns false if Tolerance is not supported
 */
bool dotdot_is_supported_pressure_measurement_tolerance (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Tolerance attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Tolerance attribute
 */
uint16_t dotdot_get_pressure_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Tolerance attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_tolerance new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pressure_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_tolerance);

// PressureMeasurement ScaledValue
/**
 * @brief Verifies if the DotDot PressureMeasurement ScaledValue is supported
 *
 * @returns true if ScaledValue is supported
 * @returns false if ScaledValue is not supported
 */
bool dotdot_is_supported_pressure_measurement_scaled_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ScaledValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ScaledValue attribute
 */
int16_t dotdot_get_pressure_measurement_scaled_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ScaledValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_scaled_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pressure_measurement_scaled_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_scaled_value);

// PressureMeasurement MinScaledValue
/**
 * @brief Verifies if the DotDot PressureMeasurement MinScaledValue is supported
 *
 * @returns true if MinScaledValue is supported
 * @returns false if MinScaledValue is not supported
 */
bool dotdot_is_supported_pressure_measurement_min_scaled_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinScaledValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinScaledValue attribute
 */
int16_t dotdot_get_pressure_measurement_min_scaled_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinScaledValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_scaled_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pressure_measurement_min_scaled_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_min_scaled_value);

// PressureMeasurement MaxScaledValue
/**
 * @brief Verifies if the DotDot PressureMeasurement MaxScaledValue is supported
 *
 * @returns true if MaxScaledValue is supported
 * @returns false if MaxScaledValue is not supported
 */
bool dotdot_is_supported_pressure_measurement_max_scaled_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxScaledValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxScaledValue attribute
 */
int16_t dotdot_get_pressure_measurement_max_scaled_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxScaledValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_scaled_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pressure_measurement_max_scaled_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_max_scaled_value);

// PressureMeasurement ScaledTolerance
/**
 * @brief Verifies if the DotDot PressureMeasurement ScaledTolerance is supported
 *
 * @returns true if ScaledTolerance is supported
 * @returns false if ScaledTolerance is not supported
 */
bool dotdot_is_supported_pressure_measurement_scaled_tolerance (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ScaledTolerance attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ScaledTolerance attribute
 */
uint16_t dotdot_get_pressure_measurement_scaled_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ScaledTolerance attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_scaled_tolerance new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pressure_measurement_scaled_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_scaled_tolerance);

// PressureMeasurement Scale
/**
 * @brief Verifies if the DotDot PressureMeasurement Scale is supported
 *
 * @returns true if Scale is supported
 * @returns false if Scale is not supported
 */
bool dotdot_is_supported_pressure_measurement_scale (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Scale attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Scale attribute
 */
int8_t dotdot_get_pressure_measurement_scale(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Scale attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_scale new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_pressure_measurement_scale(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_scale);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster FlowMeasurement
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for FlowMeasurement
#define DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MEASURED_VALUE ((attribute_store_type_t) 0x04040000)
///< This represents the MeasuredValue attribute in the DotDot FlowMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MIN_MEASURED_VALUE ((attribute_store_type_t) 0x04040001)
///< This represents the MinMeasuredValue attribute in the DotDot FlowMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_MAX_MEASURED_VALUE ((attribute_store_type_t) 0x04040002)
///< This represents the MaxMeasuredValue attribute in the DotDot FlowMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_FLOW_MEASUREMENT_TOLERANCE ((attribute_store_type_t) 0x04040003)
///< This represents the Tolerance attribute in the DotDot FlowMeasurement cluster

// FlowMeasurement MeasuredValue
/**
 * @brief Verifies if the DotDot FlowMeasurement MeasuredValue is supported
 *
 * @returns true if MeasuredValue is supported
 * @returns false if MeasuredValue is not supported
 */
bool dotdot_is_supported_flow_measurement_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredValue attribute
 */
uint16_t dotdot_get_flow_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_flow_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_measured_value);

// FlowMeasurement MinMeasuredValue
/**
 * @brief Verifies if the DotDot FlowMeasurement MinMeasuredValue is supported
 *
 * @returns true if MinMeasuredValue is supported
 * @returns false if MinMeasuredValue is not supported
 */
bool dotdot_is_supported_flow_measurement_min_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinMeasuredValue attribute
 */
uint16_t dotdot_get_flow_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_flow_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_min_measured_value);

// FlowMeasurement MaxMeasuredValue
/**
 * @brief Verifies if the DotDot FlowMeasurement MaxMeasuredValue is supported
 *
 * @returns true if MaxMeasuredValue is supported
 * @returns false if MaxMeasuredValue is not supported
 */
bool dotdot_is_supported_flow_measurement_max_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxMeasuredValue attribute
 */
uint16_t dotdot_get_flow_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_flow_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_measured_value);

// FlowMeasurement Tolerance
/**
 * @brief Verifies if the DotDot FlowMeasurement Tolerance is supported
 *
 * @returns true if Tolerance is supported
 * @returns false if Tolerance is not supported
 */
bool dotdot_is_supported_flow_measurement_tolerance (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Tolerance attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Tolerance attribute
 */
uint16_t dotdot_get_flow_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Tolerance attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_tolerance new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_flow_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_tolerance);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster RelativityHumidity
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for RelativityHumidity
#define DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MEASURED_VALUE ((attribute_store_type_t) 0x04050000)
///< This represents the MeasuredValue attribute in the DotDot RelativityHumidity cluster

#define DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MIN_MEASURED_VALUE ((attribute_store_type_t) 0x04050001)
///< This represents the MinMeasuredValue attribute in the DotDot RelativityHumidity cluster

#define DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_MAX_MEASURED_VALUE ((attribute_store_type_t) 0x04050002)
///< This represents the MaxMeasuredValue attribute in the DotDot RelativityHumidity cluster

#define DOTDOT_ATTRIBUTE_ID_RELATIVITY_HUMIDITY_TOLERANCE ((attribute_store_type_t) 0x04050003)
///< This represents the Tolerance attribute in the DotDot RelativityHumidity cluster

// RelativityHumidity MeasuredValue
/**
 * @brief Verifies if the DotDot RelativityHumidity MeasuredValue is supported
 *
 * @returns true if MeasuredValue is supported
 * @returns false if MeasuredValue is not supported
 */
bool dotdot_is_supported_relativity_humidity_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredValue attribute
 */
uint16_t dotdot_get_relativity_humidity_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_relativity_humidity_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_measured_value);

// RelativityHumidity MinMeasuredValue
/**
 * @brief Verifies if the DotDot RelativityHumidity MinMeasuredValue is supported
 *
 * @returns true if MinMeasuredValue is supported
 * @returns false if MinMeasuredValue is not supported
 */
bool dotdot_is_supported_relativity_humidity_min_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinMeasuredValue attribute
 */
uint16_t dotdot_get_relativity_humidity_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_relativity_humidity_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_min_measured_value);

// RelativityHumidity MaxMeasuredValue
/**
 * @brief Verifies if the DotDot RelativityHumidity MaxMeasuredValue is supported
 *
 * @returns true if MaxMeasuredValue is supported
 * @returns false if MaxMeasuredValue is not supported
 */
bool dotdot_is_supported_relativity_humidity_max_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxMeasuredValue attribute
 */
uint16_t dotdot_get_relativity_humidity_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_relativity_humidity_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_measured_value);

// RelativityHumidity Tolerance
/**
 * @brief Verifies if the DotDot RelativityHumidity Tolerance is supported
 *
 * @returns true if Tolerance is supported
 * @returns false if Tolerance is not supported
 */
bool dotdot_is_supported_relativity_humidity_tolerance (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Tolerance attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Tolerance attribute
 */
uint16_t dotdot_get_relativity_humidity_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Tolerance attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_tolerance new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_relativity_humidity_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_tolerance);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster OccupancySensing
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for OccupancySensing
#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY ((attribute_store_type_t) 0x04060000)
///< This represents the Occupancy attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE ((attribute_store_type_t) 0x04060001)
///< This represents the OccupancySensorType attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_OCCUPANCY_SENSOR_TYPE_BITMAP ((attribute_store_type_t) 0x04060002)
///< This represents the OccupancySensorTypeBitmap attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY ((attribute_store_type_t) 0x04060010)
///< This represents the PIROccupiedToUnoccupiedDelay attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY ((attribute_store_type_t) 0x04060011)
///< This represents the PIRUnoccupiedToOccupiedDelay attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD ((attribute_store_type_t) 0x04060012)
///< This represents the PIRUnoccupiedToOccupiedThreshold attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY ((attribute_store_type_t) 0x04060020)
///< This represents the UltrasonicOccupiedToUnoccupiedDelay attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY ((attribute_store_type_t) 0x04060021)
///< This represents the UltrasonicUnoccupiedToOccupiedDelay attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD ((attribute_store_type_t) 0x04060022)
///< This represents the UltrasonicUnoccupiedToOccupiedThreshold attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY ((attribute_store_type_t) 0x04060030)
///< This represents the PhysicalContactOccupiedToUnoccupiedDelay attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY ((attribute_store_type_t) 0x04060031)
///< This represents the PhysicalContactUnoccupiedToOccupiedDelay attribute in the DotDot OccupancySensing cluster

#define DOTDOT_ATTRIBUTE_ID_OCCUPANCY_SENSING_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD ((attribute_store_type_t) 0x04060032)
///< This represents the PhysicalContactUnoccupiedToOccupiedThreshold attribute in the DotDot OccupancySensing cluster

// OccupancySensing Occupancy
/**
 * @brief Verifies if the DotDot OccupancySensing Occupancy is supported
 *
 * @returns true if Occupancy is supported
 * @returns false if Occupancy is not supported
 */
bool dotdot_is_supported_occupancy_sensing_occupancy (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Occupancy attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Occupancy attribute
 */
uint8_t dotdot_get_occupancy_sensing_occupancy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Occupancy attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_occupancy new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_occupancy(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_occupancy);

// OccupancySensing OccupancySensorType
/**
 * @brief Verifies if the DotDot OccupancySensing OccupancySensorType is supported
 *
 * @returns true if OccupancySensorType is supported
 * @returns false if OccupancySensorType is not supported
 */
bool dotdot_is_supported_occupancy_sensing_occupancy_sensor_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OccupancySensorType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OccupancySensorType attribute
 */
uint8_t dotdot_get_occupancy_sensing_occupancy_sensor_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OccupancySensorType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_occupancy_sensor_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_occupancy_sensor_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_occupancy_sensor_type);

// OccupancySensing OccupancySensorTypeBitmap
/**
 * @brief Verifies if the DotDot OccupancySensing OccupancySensorTypeBitmap is supported
 *
 * @returns true if OccupancySensorTypeBitmap is supported
 * @returns false if OccupancySensorTypeBitmap is not supported
 */
bool dotdot_is_supported_occupancy_sensing_occupancy_sensor_type_bitmap (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OccupancySensorTypeBitmap attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OccupancySensorTypeBitmap attribute
 */
uint8_t dotdot_get_occupancy_sensing_occupancy_sensor_type_bitmap(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OccupancySensorTypeBitmap attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_occupancy_sensor_type_bitmap new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_occupancy_sensor_type_bitmap(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_occupancy_sensor_type_bitmap);

// OccupancySensing PIROccupiedToUnoccupiedDelay
/**
 * @brief Verifies if the DotDot OccupancySensing PIROccupiedToUnoccupiedDelay is supported
 *
 * @returns true if PIROccupiedToUnoccupiedDelay is supported
 * @returns false if PIROccupiedToUnoccupiedDelay is not supported
 */
bool dotdot_is_supported_occupancy_sensing_pir_occupied_to_unoccupied_delay (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PIROccupiedToUnoccupiedDelay attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PIROccupiedToUnoccupiedDelay attribute
 */
uint16_t dotdot_get_occupancy_sensing_pir_occupied_to_unoccupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PIROccupiedToUnoccupiedDelay attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_pir_occupied_to_unoccupied_delay new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_pir_occupied_to_unoccupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_pir_occupied_to_unoccupied_delay);

// OccupancySensing PIRUnoccupiedToOccupiedDelay
/**
 * @brief Verifies if the DotDot OccupancySensing PIRUnoccupiedToOccupiedDelay is supported
 *
 * @returns true if PIRUnoccupiedToOccupiedDelay is supported
 * @returns false if PIRUnoccupiedToOccupiedDelay is not supported
 */
bool dotdot_is_supported_occupancy_sensing_pir_unoccupied_to_occupied_delay (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PIRUnoccupiedToOccupiedDelay attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PIRUnoccupiedToOccupiedDelay attribute
 */
uint16_t dotdot_get_occupancy_sensing_pir_unoccupied_to_occupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PIRUnoccupiedToOccupiedDelay attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_pir_unoccupied_to_occupied_delay new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_pir_unoccupied_to_occupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_pir_unoccupied_to_occupied_delay);

// OccupancySensing PIRUnoccupiedToOccupiedThreshold
/**
 * @brief Verifies if the DotDot OccupancySensing PIRUnoccupiedToOccupiedThreshold is supported
 *
 * @returns true if PIRUnoccupiedToOccupiedThreshold is supported
 * @returns false if PIRUnoccupiedToOccupiedThreshold is not supported
 */
bool dotdot_is_supported_occupancy_sensing_pir_unoccupied_to_occupied_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PIRUnoccupiedToOccupiedThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PIRUnoccupiedToOccupiedThreshold attribute
 */
uint8_t dotdot_get_occupancy_sensing_pir_unoccupied_to_occupied_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PIRUnoccupiedToOccupiedThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_pir_unoccupied_to_occupied_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_pir_unoccupied_to_occupied_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_pir_unoccupied_to_occupied_threshold);

// OccupancySensing UltrasonicOccupiedToUnoccupiedDelay
/**
 * @brief Verifies if the DotDot OccupancySensing UltrasonicOccupiedToUnoccupiedDelay is supported
 *
 * @returns true if UltrasonicOccupiedToUnoccupiedDelay is supported
 * @returns false if UltrasonicOccupiedToUnoccupiedDelay is not supported
 */
bool dotdot_is_supported_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UltrasonicOccupiedToUnoccupiedDelay attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UltrasonicOccupiedToUnoccupiedDelay attribute
 */
uint16_t dotdot_get_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UltrasonicOccupiedToUnoccupiedDelay attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ultrasonic_occupied_to_unoccupied_delay new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ultrasonic_occupied_to_unoccupied_delay);

// OccupancySensing UltrasonicUnoccupiedToOccupiedDelay
/**
 * @brief Verifies if the DotDot OccupancySensing UltrasonicUnoccupiedToOccupiedDelay is supported
 *
 * @returns true if UltrasonicUnoccupiedToOccupiedDelay is supported
 * @returns false if UltrasonicUnoccupiedToOccupiedDelay is not supported
 */
bool dotdot_is_supported_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UltrasonicUnoccupiedToOccupiedDelay attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UltrasonicUnoccupiedToOccupiedDelay attribute
 */
uint16_t dotdot_get_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UltrasonicUnoccupiedToOccupiedDelay attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ultrasonic_unoccupied_to_occupied_delay new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ultrasonic_unoccupied_to_occupied_delay);

// OccupancySensing UltrasonicUnoccupiedToOccupiedThreshold
/**
 * @brief Verifies if the DotDot OccupancySensing UltrasonicUnoccupiedToOccupiedThreshold is supported
 *
 * @returns true if UltrasonicUnoccupiedToOccupiedThreshold is supported
 * @returns false if UltrasonicUnoccupiedToOccupiedThreshold is not supported
 */
bool dotdot_is_supported_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UltrasonicUnoccupiedToOccupiedThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UltrasonicUnoccupiedToOccupiedThreshold attribute
 */
uint8_t dotdot_get_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UltrasonicUnoccupiedToOccupiedThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ultrasonic_unoccupied_to_occupied_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_ultrasonic_unoccupied_to_occupied_threshold);

// OccupancySensing PhysicalContactOccupiedToUnoccupiedDelay
/**
 * @brief Verifies if the DotDot OccupancySensing PhysicalContactOccupiedToUnoccupiedDelay is supported
 *
 * @returns true if PhysicalContactOccupiedToUnoccupiedDelay is supported
 * @returns false if PhysicalContactOccupiedToUnoccupiedDelay is not supported
 */
bool dotdot_is_supported_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PhysicalContactOccupiedToUnoccupiedDelay attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PhysicalContactOccupiedToUnoccupiedDelay attribute
 */
uint16_t dotdot_get_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PhysicalContactOccupiedToUnoccupiedDelay attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_physical_contact_occupied_to_unoccupied_delay new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_physical_contact_occupied_to_unoccupied_delay);

// OccupancySensing PhysicalContactUnoccupiedToOccupiedDelay
/**
 * @brief Verifies if the DotDot OccupancySensing PhysicalContactUnoccupiedToOccupiedDelay is supported
 *
 * @returns true if PhysicalContactUnoccupiedToOccupiedDelay is supported
 * @returns false if PhysicalContactUnoccupiedToOccupiedDelay is not supported
 */
bool dotdot_is_supported_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PhysicalContactUnoccupiedToOccupiedDelay attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PhysicalContactUnoccupiedToOccupiedDelay attribute
 */
uint16_t dotdot_get_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PhysicalContactUnoccupiedToOccupiedDelay attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_physical_contact_unoccupied_to_occupied_delay new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_physical_contact_unoccupied_to_occupied_delay);

// OccupancySensing PhysicalContactUnoccupiedToOccupiedThreshold
/**
 * @brief Verifies if the DotDot OccupancySensing PhysicalContactUnoccupiedToOccupiedThreshold is supported
 *
 * @returns true if PhysicalContactUnoccupiedToOccupiedThreshold is supported
 * @returns false if PhysicalContactUnoccupiedToOccupiedThreshold is not supported
 */
bool dotdot_is_supported_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PhysicalContactUnoccupiedToOccupiedThreshold attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PhysicalContactUnoccupiedToOccupiedThreshold attribute
 */
uint8_t dotdot_get_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PhysicalContactUnoccupiedToOccupiedThreshold attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_physical_contact_unoccupied_to_occupied_threshold new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_physical_contact_unoccupied_to_occupied_threshold);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster PhMeasurement
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for PhMeasurement
#define DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MEASURED_VALUE ((attribute_store_type_t) 0x04090000)
///< This represents the MeasuredValue attribute in the DotDot PhMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MIN_MEASURED_VALUE ((attribute_store_type_t) 0x04090001)
///< This represents the MinMeasuredValue attribute in the DotDot PhMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_MAX_MEASURED_VALUE ((attribute_store_type_t) 0x04090002)
///< This represents the MaxMeasuredValue attribute in the DotDot PhMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_PH_MEASUREMENT_TOLERANCE ((attribute_store_type_t) 0x04090003)
///< This represents the Tolerance attribute in the DotDot PhMeasurement cluster

// PhMeasurement MeasuredValue
/**
 * @brief Verifies if the DotDot PhMeasurement MeasuredValue is supported
 *
 * @returns true if MeasuredValue is supported
 * @returns false if MeasuredValue is not supported
 */
bool dotdot_is_supported_ph_measurement_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredValue attribute
 */
uint16_t dotdot_get_ph_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ph_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_measured_value);

// PhMeasurement MinMeasuredValue
/**
 * @brief Verifies if the DotDot PhMeasurement MinMeasuredValue is supported
 *
 * @returns true if MinMeasuredValue is supported
 * @returns false if MinMeasuredValue is not supported
 */
bool dotdot_is_supported_ph_measurement_min_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinMeasuredValue attribute
 */
uint16_t dotdot_get_ph_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ph_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_min_measured_value);

// PhMeasurement MaxMeasuredValue
/**
 * @brief Verifies if the DotDot PhMeasurement MaxMeasuredValue is supported
 *
 * @returns true if MaxMeasuredValue is supported
 * @returns false if MaxMeasuredValue is not supported
 */
bool dotdot_is_supported_ph_measurement_max_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxMeasuredValue attribute
 */
uint16_t dotdot_get_ph_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ph_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_measured_value);

// PhMeasurement Tolerance
/**
 * @brief Verifies if the DotDot PhMeasurement Tolerance is supported
 *
 * @returns true if Tolerance is supported
 * @returns false if Tolerance is not supported
 */
bool dotdot_is_supported_ph_measurement_tolerance (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Tolerance attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Tolerance attribute
 */
uint16_t dotdot_get_ph_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Tolerance attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_tolerance new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ph_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_tolerance);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster ElectricalConductivityMeasurement
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for ElectricalConductivityMeasurement
#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MEASURED_VALUE ((attribute_store_type_t) 0x040a0000)
///< This represents the MeasuredValue attribute in the DotDot ElectricalConductivityMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MIN_MEASURED_VALUE ((attribute_store_type_t) 0x040a0001)
///< This represents the MinMeasuredValue attribute in the DotDot ElectricalConductivityMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_MAX_MEASURED_VALUE ((attribute_store_type_t) 0x040a0002)
///< This represents the MaxMeasuredValue attribute in the DotDot ElectricalConductivityMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_CONDUCTIVITY_MEASUREMENT_TOLERANCE ((attribute_store_type_t) 0x040a0003)
///< This represents the Tolerance attribute in the DotDot ElectricalConductivityMeasurement cluster

// ElectricalConductivityMeasurement MeasuredValue
/**
 * @brief Verifies if the DotDot ElectricalConductivityMeasurement MeasuredValue is supported
 *
 * @returns true if MeasuredValue is supported
 * @returns false if MeasuredValue is not supported
 */
bool dotdot_is_supported_electrical_conductivity_measurement_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredValue attribute
 */
uint16_t dotdot_get_electrical_conductivity_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_conductivity_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_measured_value);

// ElectricalConductivityMeasurement MinMeasuredValue
/**
 * @brief Verifies if the DotDot ElectricalConductivityMeasurement MinMeasuredValue is supported
 *
 * @returns true if MinMeasuredValue is supported
 * @returns false if MinMeasuredValue is not supported
 */
bool dotdot_is_supported_electrical_conductivity_measurement_min_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinMeasuredValue attribute
 */
uint16_t dotdot_get_electrical_conductivity_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_conductivity_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_min_measured_value);

// ElectricalConductivityMeasurement MaxMeasuredValue
/**
 * @brief Verifies if the DotDot ElectricalConductivityMeasurement MaxMeasuredValue is supported
 *
 * @returns true if MaxMeasuredValue is supported
 * @returns false if MaxMeasuredValue is not supported
 */
bool dotdot_is_supported_electrical_conductivity_measurement_max_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxMeasuredValue attribute
 */
uint16_t dotdot_get_electrical_conductivity_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_conductivity_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_measured_value);

// ElectricalConductivityMeasurement Tolerance
/**
 * @brief Verifies if the DotDot ElectricalConductivityMeasurement Tolerance is supported
 *
 * @returns true if Tolerance is supported
 * @returns false if Tolerance is not supported
 */
bool dotdot_is_supported_electrical_conductivity_measurement_tolerance (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Tolerance attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Tolerance attribute
 */
uint16_t dotdot_get_electrical_conductivity_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Tolerance attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_tolerance new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_conductivity_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_tolerance);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster WindSpeedMeasurement
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for WindSpeedMeasurement
#define DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MEASURED_VALUE ((attribute_store_type_t) 0x040b0000)
///< This represents the MeasuredValue attribute in the DotDot WindSpeedMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MIN_MEASURED_VALUE ((attribute_store_type_t) 0x040b0001)
///< This represents the MinMeasuredValue attribute in the DotDot WindSpeedMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_MAX_MEASURED_VALUE ((attribute_store_type_t) 0x040b0002)
///< This represents the MaxMeasuredValue attribute in the DotDot WindSpeedMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_WIND_SPEED_MEASUREMENT_TOLERANCE ((attribute_store_type_t) 0x040b0003)
///< This represents the Tolerance attribute in the DotDot WindSpeedMeasurement cluster

// WindSpeedMeasurement MeasuredValue
/**
 * @brief Verifies if the DotDot WindSpeedMeasurement MeasuredValue is supported
 *
 * @returns true if MeasuredValue is supported
 * @returns false if MeasuredValue is not supported
 */
bool dotdot_is_supported_wind_speed_measurement_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredValue attribute
 */
uint16_t dotdot_get_wind_speed_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_wind_speed_measurement_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_measured_value);

// WindSpeedMeasurement MinMeasuredValue
/**
 * @brief Verifies if the DotDot WindSpeedMeasurement MinMeasuredValue is supported
 *
 * @returns true if MinMeasuredValue is supported
 * @returns false if MinMeasuredValue is not supported
 */
bool dotdot_is_supported_wind_speed_measurement_min_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinMeasuredValue attribute
 */
uint16_t dotdot_get_wind_speed_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_wind_speed_measurement_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_min_measured_value);

// WindSpeedMeasurement MaxMeasuredValue
/**
 * @brief Verifies if the DotDot WindSpeedMeasurement MaxMeasuredValue is supported
 *
 * @returns true if MaxMeasuredValue is supported
 * @returns false if MaxMeasuredValue is not supported
 */
bool dotdot_is_supported_wind_speed_measurement_max_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxMeasuredValue attribute
 */
uint16_t dotdot_get_wind_speed_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_wind_speed_measurement_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_measured_value);

// WindSpeedMeasurement Tolerance
/**
 * @brief Verifies if the DotDot WindSpeedMeasurement Tolerance is supported
 *
 * @returns true if Tolerance is supported
 * @returns false if Tolerance is not supported
 */
bool dotdot_is_supported_wind_speed_measurement_tolerance (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Tolerance attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Tolerance attribute
 */
uint16_t dotdot_get_wind_speed_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Tolerance attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_tolerance new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_wind_speed_measurement_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_tolerance);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster CarbonMonoxide
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for CarbonMonoxide
#define DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MEASURED_VALUE ((attribute_store_type_t) 0x040c0000)
///< This represents the MeasuredValue attribute in the DotDot CarbonMonoxide cluster

#define DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MIN_MEASURED_VALUE ((attribute_store_type_t) 0x040c0001)
///< This represents the MinMeasuredValue attribute in the DotDot CarbonMonoxide cluster

#define DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_MAX_MEASURED_VALUE ((attribute_store_type_t) 0x040c0002)
///< This represents the MaxMeasuredValue attribute in the DotDot CarbonMonoxide cluster

#define DOTDOT_ATTRIBUTE_ID_CARBON_MONOXIDE_TOLERANCE ((attribute_store_type_t) 0x040c0003)
///< This represents the Tolerance attribute in the DotDot CarbonMonoxide cluster

// CarbonMonoxide MeasuredValue
/**
 * @brief Verifies if the DotDot CarbonMonoxide MeasuredValue is supported
 *
 * @returns true if MeasuredValue is supported
 * @returns false if MeasuredValue is not supported
 */
bool dotdot_is_supported_carbon_monoxide_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredValue attribute
 */
float dotdot_get_carbon_monoxide_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_carbon_monoxide_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  float new_measured_value);

// CarbonMonoxide MinMeasuredValue
/**
 * @brief Verifies if the DotDot CarbonMonoxide MinMeasuredValue is supported
 *
 * @returns true if MinMeasuredValue is supported
 * @returns false if MinMeasuredValue is not supported
 */
bool dotdot_is_supported_carbon_monoxide_min_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinMeasuredValue attribute
 */
float dotdot_get_carbon_monoxide_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_carbon_monoxide_min_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  float new_min_measured_value);

// CarbonMonoxide MaxMeasuredValue
/**
 * @brief Verifies if the DotDot CarbonMonoxide MaxMeasuredValue is supported
 *
 * @returns true if MaxMeasuredValue is supported
 * @returns false if MaxMeasuredValue is not supported
 */
bool dotdot_is_supported_carbon_monoxide_max_measured_value (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxMeasuredValue attribute
 */
float dotdot_get_carbon_monoxide_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxMeasuredValue attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_measured_value new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_carbon_monoxide_max_measured_value(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  float new_max_measured_value);

// CarbonMonoxide Tolerance
/**
 * @brief Verifies if the DotDot CarbonMonoxide Tolerance is supported
 *
 * @returns true if Tolerance is supported
 * @returns false if Tolerance is not supported
 */
bool dotdot_is_supported_carbon_monoxide_tolerance (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Tolerance attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Tolerance attribute
 */
float dotdot_get_carbon_monoxide_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Tolerance attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_tolerance new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_carbon_monoxide_tolerance(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  float new_tolerance);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster IASZone
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for IASZone
#define DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATE ((attribute_store_type_t) 0x05000000)
///< This represents the ZoneState attribute in the DotDot IASZone cluster

#define DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_TYPE ((attribute_store_type_t) 0x05000001)
///< This represents the ZoneType attribute in the DotDot IASZone cluster

#define DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONE_STATUS ((attribute_store_type_t) 0x05000002)
///< This represents the ZoneStatus attribute in the DotDot IASZone cluster

#define DOTDOT_ATTRIBUTE_ID_IAS_ZONE_IASCIE_ADDRESS ((attribute_store_type_t) 0x05000010)
///< This represents the IASCIEAddress attribute in the DotDot IASZone cluster

#define DOTDOT_ATTRIBUTE_ID_IAS_ZONE_ZONEID ((attribute_store_type_t) 0x05000011)
///< This represents the ZoneID attribute in the DotDot IASZone cluster

#define DOTDOT_ATTRIBUTE_ID_IAS_ZONE_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED ((attribute_store_type_t) 0x05000012)
///< This represents the NumberOfZoneSensitivityLevelsSupported attribute in the DotDot IASZone cluster

#define DOTDOT_ATTRIBUTE_ID_IAS_ZONE_CURRENT_ZONE_SENSITIVITY_LEVEL ((attribute_store_type_t) 0x05000013)
///< This represents the CurrentZoneSensitivityLevel attribute in the DotDot IASZone cluster

// IASZone ZoneState
/**
 * @brief Verifies if the DotDot IASZone ZoneState is supported
 *
 * @returns true if ZoneState is supported
 * @returns false if ZoneState is not supported
 */
bool dotdot_is_supported_ias_zone_zone_state (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ZoneState attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ZoneState attribute
 */
uint8_t dotdot_get_ias_zone_zone_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ZoneState attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_zone_state new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ias_zone_zone_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_zone_state);

// IASZone ZoneType
/**
 * @brief Verifies if the DotDot IASZone ZoneType is supported
 *
 * @returns true if ZoneType is supported
 * @returns false if ZoneType is not supported
 */
bool dotdot_is_supported_ias_zone_zone_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ZoneType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ZoneType attribute
 */
IasZoneType dotdot_get_ias_zone_zone_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ZoneType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_zone_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ias_zone_zone_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  IasZoneType new_zone_type);

// IASZone ZoneStatus
/**
 * @brief Verifies if the DotDot IASZone ZoneStatus is supported
 *
 * @returns true if ZoneStatus is supported
 * @returns false if ZoneStatus is not supported
 */
bool dotdot_is_supported_ias_zone_zone_status (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ZoneStatus attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ZoneStatus attribute
 */
uint16_t dotdot_get_ias_zone_zone_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ZoneStatus attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_zone_status new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ias_zone_zone_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_zone_status);

// IASZone IASCIEAddress
/**
 * @brief Verifies if the DotDot IASZone IASCIEAddress is supported
 *
 * @returns true if IASCIEAddress is supported
 * @returns false if IASCIEAddress is not supported
 */
bool dotdot_is_supported_ias_zone_iascie_address (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot IASCIEAddress attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns IASCIEAddress attribute
 */
EUI64 dotdot_get_ias_zone_iascie_address(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot IASCIEAddress attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_iascie_address new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ias_zone_iascie_address(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  EUI64 new_iascie_address);

// IASZone ZoneID
/**
 * @brief Verifies if the DotDot IASZone ZoneID is supported
 *
 * @returns true if ZoneID is supported
 * @returns false if ZoneID is not supported
 */
bool dotdot_is_supported_ias_zone_zoneid (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ZoneID attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ZoneID attribute
 */
uint8_t dotdot_get_ias_zone_zoneid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ZoneID attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_zoneid new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ias_zone_zoneid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_zoneid);

// IASZone NumberOfZoneSensitivityLevelsSupported
/**
 * @brief Verifies if the DotDot IASZone NumberOfZoneSensitivityLevelsSupported is supported
 *
 * @returns true if NumberOfZoneSensitivityLevelsSupported is supported
 * @returns false if NumberOfZoneSensitivityLevelsSupported is not supported
 */
bool dotdot_is_supported_ias_zone_number_of_zone_sensitivity_levels_supported (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfZoneSensitivityLevelsSupported attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfZoneSensitivityLevelsSupported attribute
 */
uint8_t dotdot_get_ias_zone_number_of_zone_sensitivity_levels_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfZoneSensitivityLevelsSupported attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_zone_sensitivity_levels_supported new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ias_zone_number_of_zone_sensitivity_levels_supported(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_number_of_zone_sensitivity_levels_supported);

// IASZone CurrentZoneSensitivityLevel
/**
 * @brief Verifies if the DotDot IASZone CurrentZoneSensitivityLevel is supported
 *
 * @returns true if CurrentZoneSensitivityLevel is supported
 * @returns false if CurrentZoneSensitivityLevel is not supported
 */
bool dotdot_is_supported_ias_zone_current_zone_sensitivity_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentZoneSensitivityLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentZoneSensitivityLevel attribute
 */
uint8_t dotdot_get_ias_zone_current_zone_sensitivity_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentZoneSensitivityLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_zone_sensitivity_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_ias_zone_current_zone_sensitivity_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_current_zone_sensitivity_level);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster IASWD
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for IASWD
#define DOTDOT_ATTRIBUTE_ID_IASWD_MAX_DURATION ((attribute_store_type_t) 0x05020000)
///< This represents the MaxDuration attribute in the DotDot IASWD cluster

// IASWD MaxDuration
/**
 * @brief Verifies if the DotDot IASWD MaxDuration is supported
 *
 * @returns true if MaxDuration is supported
 * @returns false if MaxDuration is not supported
 */
bool dotdot_is_supported_iaswd_max_duration (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxDuration attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxDuration attribute
 */
uint16_t dotdot_get_iaswd_max_duration(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxDuration attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_duration new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_iaswd_max_duration(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_max_duration);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Metering
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Metering
#define DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_DELIVERED ((attribute_store_type_t) 0x07020000)
///< This represents the CurrentSummationDelivered attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_SUMMATION_RECEIVED ((attribute_store_type_t) 0x07020001)
///< This represents the CurrentSummationReceived attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED ((attribute_store_type_t) 0x07020002)
///< This represents the CurrentMaxDemandDelivered attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED ((attribute_store_type_t) 0x07020003)
///< This represents the CurrentMaxDemandReceived attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_POWER_FACTOR ((attribute_store_type_t) 0x07020006)
///< This represents the PowerFactor attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_READING_SNAP_SHOT_TIME ((attribute_store_type_t) 0x07020007)
///< This represents the ReadingSnapShotTime attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_DELIVERED_TIME ((attribute_store_type_t) 0x07020008)
///< This represents the CurrentMaxDemandDeliveredTime attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_MAX_DEMAND_RECEIVED_TIME ((attribute_store_type_t) 0x07020009)
///< This represents the CurrentMaxDemandReceivedTime attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_DEFAULT_UPDATE_PERIOD ((attribute_store_type_t) 0x0702000a)
///< This represents the DefaultUpdatePeriod attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_SUPPLY_STATUS ((attribute_store_type_t) 0x07020014)
///< This represents the SupplyStatus attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_INLET_ENERGY_CARRIER_SUMMATION ((attribute_store_type_t) 0x07020015)
///< This represents the CurrentInletEnergyCarrierSummation attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION ((attribute_store_type_t) 0x07020016)
///< This represents the CurrentOutletEnergyCarrierSummation attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_INLET_TEMPERATURE ((attribute_store_type_t) 0x07020017)
///< This represents the InletTemperature attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_OUTLET_TEMPERATURE ((attribute_store_type_t) 0x07020018)
///< This represents the OutletTemperature attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_UNITOF_MEASURE ((attribute_store_type_t) 0x07020300)
///< This represents the UnitofMeasure attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_MULTIPLIER ((attribute_store_type_t) 0x07020301)
///< This represents the Multiplier attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_DIVISOR ((attribute_store_type_t) 0x07020302)
///< This represents the Divisor attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_SUMMATION_FORMATTING ((attribute_store_type_t) 0x07020303)
///< This represents the SummationFormatting attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_DEMAND_FORMATTING ((attribute_store_type_t) 0x07020304)
///< This represents the DemandFormatting attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_HISTORICAL_CONSUMPTION_FORMATTING ((attribute_store_type_t) 0x07020305)
///< This represents the HistoricalConsumptionFormatting attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_METERING_DEVICE_TYPE ((attribute_store_type_t) 0x07020306)
///< This represents the MeteringDeviceType attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_UNIT_OF_MEASURE ((attribute_store_type_t) 0x07020309)
///< This represents the EnergyCarrierUnitOfMeasure attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_SUMMATION_FORMATTING ((attribute_store_type_t) 0x0702030a)
///< This represents the EnergyCarrierSummationFormatting attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_ENERGY_CARRIER_DEMAND_FORMATTING ((attribute_store_type_t) 0x0702030b)
///< This represents the EnergyCarrierDemandFormatting attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_UNIT_OF_MEASURE ((attribute_store_type_t) 0x0702030c)
///< This represents the TemperatureUnitOfMeasure attribute in the DotDot Metering cluster

#define DOTDOT_ATTRIBUTE_ID_METERING_TEMPERATURE_FORMATTING ((attribute_store_type_t) 0x0702030d)
///< This represents the TemperatureFormatting attribute in the DotDot Metering cluster

// Metering CurrentSummationDelivered
/**
 * @brief Verifies if the DotDot Metering CurrentSummationDelivered is supported
 *
 * @returns true if CurrentSummationDelivered is supported
 * @returns false if CurrentSummationDelivered is not supported
 */
bool dotdot_is_supported_metering_current_summation_delivered (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentSummationDelivered attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentSummationDelivered attribute
 */
uint64_t dotdot_get_metering_current_summation_delivered(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentSummationDelivered attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_summation_delivered new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_current_summation_delivered(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_current_summation_delivered);

// Metering CurrentSummationReceived
/**
 * @brief Verifies if the DotDot Metering CurrentSummationReceived is supported
 *
 * @returns true if CurrentSummationReceived is supported
 * @returns false if CurrentSummationReceived is not supported
 */
bool dotdot_is_supported_metering_current_summation_received (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentSummationReceived attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentSummationReceived attribute
 */
uint64_t dotdot_get_metering_current_summation_received(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentSummationReceived attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_summation_received new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_current_summation_received(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_current_summation_received);

// Metering CurrentMaxDemandDelivered
/**
 * @brief Verifies if the DotDot Metering CurrentMaxDemandDelivered is supported
 *
 * @returns true if CurrentMaxDemandDelivered is supported
 * @returns false if CurrentMaxDemandDelivered is not supported
 */
bool dotdot_is_supported_metering_current_max_demand_delivered (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentMaxDemandDelivered attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentMaxDemandDelivered attribute
 */
uint64_t dotdot_get_metering_current_max_demand_delivered(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentMaxDemandDelivered attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_max_demand_delivered new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_current_max_demand_delivered(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_current_max_demand_delivered);

// Metering CurrentMaxDemandReceived
/**
 * @brief Verifies if the DotDot Metering CurrentMaxDemandReceived is supported
 *
 * @returns true if CurrentMaxDemandReceived is supported
 * @returns false if CurrentMaxDemandReceived is not supported
 */
bool dotdot_is_supported_metering_current_max_demand_received (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentMaxDemandReceived attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentMaxDemandReceived attribute
 */
int8_t dotdot_get_metering_current_max_demand_received(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentMaxDemandReceived attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_max_demand_received new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_current_max_demand_received(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_current_max_demand_received);

// Metering PowerFactor
/**
 * @brief Verifies if the DotDot Metering PowerFactor is supported
 *
 * @returns true if PowerFactor is supported
 * @returns false if PowerFactor is not supported
 */
bool dotdot_is_supported_metering_power_factor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PowerFactor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PowerFactor attribute
 */
int8_t dotdot_get_metering_power_factor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PowerFactor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power_factor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_power_factor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_power_factor);

// Metering ReadingSnapShotTime
/**
 * @brief Verifies if the DotDot Metering ReadingSnapShotTime is supported
 *
 * @returns true if ReadingSnapShotTime is supported
 * @returns false if ReadingSnapShotTime is not supported
 */
bool dotdot_is_supported_metering_reading_snap_shot_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ReadingSnapShotTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ReadingSnapShotTime attribute
 */
UTC dotdot_get_metering_reading_snap_shot_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ReadingSnapShotTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_reading_snap_shot_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_reading_snap_shot_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  UTC new_reading_snap_shot_time);

// Metering CurrentMaxDemandDeliveredTime
/**
 * @brief Verifies if the DotDot Metering CurrentMaxDemandDeliveredTime is supported
 *
 * @returns true if CurrentMaxDemandDeliveredTime is supported
 * @returns false if CurrentMaxDemandDeliveredTime is not supported
 */
bool dotdot_is_supported_metering_current_max_demand_delivered_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentMaxDemandDeliveredTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentMaxDemandDeliveredTime attribute
 */
UTC dotdot_get_metering_current_max_demand_delivered_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentMaxDemandDeliveredTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_max_demand_delivered_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_current_max_demand_delivered_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  UTC new_current_max_demand_delivered_time);

// Metering CurrentMaxDemandReceivedTime
/**
 * @brief Verifies if the DotDot Metering CurrentMaxDemandReceivedTime is supported
 *
 * @returns true if CurrentMaxDemandReceivedTime is supported
 * @returns false if CurrentMaxDemandReceivedTime is not supported
 */
bool dotdot_is_supported_metering_current_max_demand_received_time (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentMaxDemandReceivedTime attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentMaxDemandReceivedTime attribute
 */
UTC dotdot_get_metering_current_max_demand_received_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentMaxDemandReceivedTime attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_max_demand_received_time new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_current_max_demand_received_time(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  UTC new_current_max_demand_received_time);

// Metering DefaultUpdatePeriod
/**
 * @brief Verifies if the DotDot Metering DefaultUpdatePeriod is supported
 *
 * @returns true if DefaultUpdatePeriod is supported
 * @returns false if DefaultUpdatePeriod is not supported
 */
bool dotdot_is_supported_metering_default_update_period (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DefaultUpdatePeriod attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DefaultUpdatePeriod attribute
 */
uint8_t dotdot_get_metering_default_update_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DefaultUpdatePeriod attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_default_update_period new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_default_update_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_default_update_period);

// Metering SupplyStatus
/**
 * @brief Verifies if the DotDot Metering SupplyStatus is supported
 *
 * @returns true if SupplyStatus is supported
 * @returns false if SupplyStatus is not supported
 */
bool dotdot_is_supported_metering_supply_status (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SupplyStatus attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SupplyStatus attribute
 */
uint8_t dotdot_get_metering_supply_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SupplyStatus attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_supply_status new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_supply_status(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_supply_status);

// Metering CurrentInletEnergyCarrierSummation
/**
 * @brief Verifies if the DotDot Metering CurrentInletEnergyCarrierSummation is supported
 *
 * @returns true if CurrentInletEnergyCarrierSummation is supported
 * @returns false if CurrentInletEnergyCarrierSummation is not supported
 */
bool dotdot_is_supported_metering_current_inlet_energy_carrier_summation (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentInletEnergyCarrierSummation attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentInletEnergyCarrierSummation attribute
 */
uint64_t dotdot_get_metering_current_inlet_energy_carrier_summation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentInletEnergyCarrierSummation attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_inlet_energy_carrier_summation new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_current_inlet_energy_carrier_summation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_current_inlet_energy_carrier_summation);

// Metering CurrentOutletEnergyCarrierSummation
/**
 * @brief Verifies if the DotDot Metering CurrentOutletEnergyCarrierSummation is supported
 *
 * @returns true if CurrentOutletEnergyCarrierSummation is supported
 * @returns false if CurrentOutletEnergyCarrierSummation is not supported
 */
bool dotdot_is_supported_metering_current_outlet_energy_carrier_summation (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentOutletEnergyCarrierSummation attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentOutletEnergyCarrierSummation attribute
 */
uint64_t dotdot_get_metering_current_outlet_energy_carrier_summation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentOutletEnergyCarrierSummation attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_outlet_energy_carrier_summation new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_current_outlet_energy_carrier_summation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_current_outlet_energy_carrier_summation);

// Metering InletTemperature
/**
 * @brief Verifies if the DotDot Metering InletTemperature is supported
 *
 * @returns true if InletTemperature is supported
 * @returns false if InletTemperature is not supported
 */
bool dotdot_is_supported_metering_inlet_temperature (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot InletTemperature attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns InletTemperature attribute
 */
uint32_t dotdot_get_metering_inlet_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot InletTemperature attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_inlet_temperature new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_inlet_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_inlet_temperature);

// Metering OutletTemperature
/**
 * @brief Verifies if the DotDot Metering OutletTemperature is supported
 *
 * @returns true if OutletTemperature is supported
 * @returns false if OutletTemperature is not supported
 */
bool dotdot_is_supported_metering_outlet_temperature (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot OutletTemperature attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns OutletTemperature attribute
 */
uint32_t dotdot_get_metering_outlet_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot OutletTemperature attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_outlet_temperature new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_outlet_temperature(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_outlet_temperature);

// Metering UnitofMeasure
/**
 * @brief Verifies if the DotDot Metering UnitofMeasure is supported
 *
 * @returns true if UnitofMeasure is supported
 * @returns false if UnitofMeasure is not supported
 */
bool dotdot_is_supported_metering_unitof_measure (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UnitofMeasure attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UnitofMeasure attribute
 */
uint8_t dotdot_get_metering_unitof_measure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UnitofMeasure attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_unitof_measure new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_unitof_measure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_unitof_measure);

// Metering Multiplier
/**
 * @brief Verifies if the DotDot Metering Multiplier is supported
 *
 * @returns true if Multiplier is supported
 * @returns false if Multiplier is not supported
 */
bool dotdot_is_supported_metering_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Multiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Multiplier attribute
 */
uint32_t dotdot_get_metering_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Multiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_multiplier);

// Metering Divisor
/**
 * @brief Verifies if the DotDot Metering Divisor is supported
 *
 * @returns true if Divisor is supported
 * @returns false if Divisor is not supported
 */
bool dotdot_is_supported_metering_divisor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Divisor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Divisor attribute
 */
uint32_t dotdot_get_metering_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Divisor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_divisor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_divisor);

// Metering SummationFormatting
/**
 * @brief Verifies if the DotDot Metering SummationFormatting is supported
 *
 * @returns true if SummationFormatting is supported
 * @returns false if SummationFormatting is not supported
 */
bool dotdot_is_supported_metering_summation_formatting (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SummationFormatting attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SummationFormatting attribute
 */
uint8_t dotdot_get_metering_summation_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SummationFormatting attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_summation_formatting new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_summation_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_summation_formatting);

// Metering DemandFormatting
/**
 * @brief Verifies if the DotDot Metering DemandFormatting is supported
 *
 * @returns true if DemandFormatting is supported
 * @returns false if DemandFormatting is not supported
 */
bool dotdot_is_supported_metering_demand_formatting (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DemandFormatting attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DemandFormatting attribute
 */
uint8_t dotdot_get_metering_demand_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DemandFormatting attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_demand_formatting new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_demand_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_demand_formatting);

// Metering HistoricalConsumptionFormatting
/**
 * @brief Verifies if the DotDot Metering HistoricalConsumptionFormatting is supported
 *
 * @returns true if HistoricalConsumptionFormatting is supported
 * @returns false if HistoricalConsumptionFormatting is not supported
 */
bool dotdot_is_supported_metering_historical_consumption_formatting (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot HistoricalConsumptionFormatting attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns HistoricalConsumptionFormatting attribute
 */
uint8_t dotdot_get_metering_historical_consumption_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot HistoricalConsumptionFormatting attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_historical_consumption_formatting new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_historical_consumption_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_historical_consumption_formatting);

// Metering MeteringDeviceType
/**
 * @brief Verifies if the DotDot Metering MeteringDeviceType is supported
 *
 * @returns true if MeteringDeviceType is supported
 * @returns false if MeteringDeviceType is not supported
 */
bool dotdot_is_supported_metering_metering_device_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeteringDeviceType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeteringDeviceType attribute
 */
uint8_t dotdot_get_metering_metering_device_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeteringDeviceType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_metering_device_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_metering_device_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_metering_device_type);

// Metering EnergyCarrierUnitOfMeasure
/**
 * @brief Verifies if the DotDot Metering EnergyCarrierUnitOfMeasure is supported
 *
 * @returns true if EnergyCarrierUnitOfMeasure is supported
 * @returns false if EnergyCarrierUnitOfMeasure is not supported
 */
bool dotdot_is_supported_metering_energy_carrier_unit_of_measure (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EnergyCarrierUnitOfMeasure attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EnergyCarrierUnitOfMeasure attribute
 */
uint8_t dotdot_get_metering_energy_carrier_unit_of_measure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EnergyCarrierUnitOfMeasure attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_energy_carrier_unit_of_measure new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_energy_carrier_unit_of_measure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_energy_carrier_unit_of_measure);

// Metering EnergyCarrierSummationFormatting
/**
 * @brief Verifies if the DotDot Metering EnergyCarrierSummationFormatting is supported
 *
 * @returns true if EnergyCarrierSummationFormatting is supported
 * @returns false if EnergyCarrierSummationFormatting is not supported
 */
bool dotdot_is_supported_metering_energy_carrier_summation_formatting (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EnergyCarrierSummationFormatting attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EnergyCarrierSummationFormatting attribute
 */
uint8_t dotdot_get_metering_energy_carrier_summation_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EnergyCarrierSummationFormatting attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_energy_carrier_summation_formatting new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_energy_carrier_summation_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_energy_carrier_summation_formatting);

// Metering EnergyCarrierDemandFormatting
/**
 * @brief Verifies if the DotDot Metering EnergyCarrierDemandFormatting is supported
 *
 * @returns true if EnergyCarrierDemandFormatting is supported
 * @returns false if EnergyCarrierDemandFormatting is not supported
 */
bool dotdot_is_supported_metering_energy_carrier_demand_formatting (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EnergyCarrierDemandFormatting attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EnergyCarrierDemandFormatting attribute
 */
uint8_t dotdot_get_metering_energy_carrier_demand_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EnergyCarrierDemandFormatting attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_energy_carrier_demand_formatting new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_energy_carrier_demand_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_energy_carrier_demand_formatting);

// Metering TemperatureUnitOfMeasure
/**
 * @brief Verifies if the DotDot Metering TemperatureUnitOfMeasure is supported
 *
 * @returns true if TemperatureUnitOfMeasure is supported
 * @returns false if TemperatureUnitOfMeasure is not supported
 */
bool dotdot_is_supported_metering_temperature_unit_of_measure (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TemperatureUnitOfMeasure attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TemperatureUnitOfMeasure attribute
 */
uint8_t dotdot_get_metering_temperature_unit_of_measure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TemperatureUnitOfMeasure attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_temperature_unit_of_measure new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_temperature_unit_of_measure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_temperature_unit_of_measure);

// Metering TemperatureFormatting
/**
 * @brief Verifies if the DotDot Metering TemperatureFormatting is supported
 *
 * @returns true if TemperatureFormatting is supported
 * @returns false if TemperatureFormatting is not supported
 */
bool dotdot_is_supported_metering_temperature_formatting (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TemperatureFormatting attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TemperatureFormatting attribute
 */
uint8_t dotdot_get_metering_temperature_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TemperatureFormatting attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_temperature_formatting new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_metering_temperature_formatting(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_temperature_formatting);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster ElectricalMeasurement
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for ElectricalMeasurement
#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASUREMENT_TYPE ((attribute_store_type_t) 0x0b040000)
///< This represents the MeasurementType attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE ((attribute_store_type_t) 0x0b040100)
///< This represents the DCVoltage attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MIN ((attribute_store_type_t) 0x0b040101)
///< This represents the DCVoltageMin attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MAX ((attribute_store_type_t) 0x0b040102)
///< This represents the DCVoltageMax attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT ((attribute_store_type_t) 0x0b040103)
///< This represents the DCCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MIN ((attribute_store_type_t) 0x0b040104)
///< This represents the DCCurrentMin attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MAX ((attribute_store_type_t) 0x0b040105)
///< This represents the DCCurrentMax attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER ((attribute_store_type_t) 0x0b040106)
///< This represents the DCPower attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MIN ((attribute_store_type_t) 0x0b040107)
///< This represents the DCPowerMin attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MAX ((attribute_store_type_t) 0x0b040108)
///< This represents the DCPowerMax attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_MULTIPLIER ((attribute_store_type_t) 0x0b040200)
///< This represents the DCVoltageMultiplier attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_DIVISOR ((attribute_store_type_t) 0x0b040201)
///< This represents the DCVoltageDivisor attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_MULTIPLIER ((attribute_store_type_t) 0x0b040202)
///< This represents the DCCurrentMultiplier attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_DIVISOR ((attribute_store_type_t) 0x0b040203)
///< This represents the DCCurrentDivisor attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_MULTIPLIER ((attribute_store_type_t) 0x0b040204)
///< This represents the DCPowerMultiplier attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_POWER_DIVISOR ((attribute_store_type_t) 0x0b040205)
///< This represents the DCPowerDivisor attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY ((attribute_store_type_t) 0x0b040300)
///< This represents the ACFrequency attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MIN ((attribute_store_type_t) 0x0b040301)
///< This represents the ACFrequencyMin attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MAX ((attribute_store_type_t) 0x0b040302)
///< This represents the ACFrequencyMax attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_NEUTRAL_CURRENT ((attribute_store_type_t) 0x0b040303)
///< This represents the NeutralCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_ACTIVE_POWER ((attribute_store_type_t) 0x0b040304)
///< This represents the TotalActivePower attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_REACTIVE_POWER ((attribute_store_type_t) 0x0b040305)
///< This represents the TotalReactivePower attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_TOTAL_APPARENT_POWER ((attribute_store_type_t) 0x0b040306)
///< This represents the TotalApparentPower attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED1ST_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b040307)
///< This represents the Measured1stHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED3RD_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b040308)
///< This represents the Measured3rdHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED5TH_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b040309)
///< This represents the Measured5thHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED7TH_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b04030a)
///< This represents the Measured7thHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED9TH_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b04030b)
///< This represents the Measured9thHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED11TH_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b04030c)
///< This represents the Measured11thHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE1ST_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b04030d)
///< This represents the MeasuredPhase1stHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE3RD_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b04030e)
///< This represents the MeasuredPhase3rdHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE5TH_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b04030f)
///< This represents the MeasuredPhase5thHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE7TH_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b040310)
///< This represents the MeasuredPhase7thHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE9TH_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b040311)
///< This represents the MeasuredPhase9thHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_MEASURED_PHASE11TH_HARMONIC_CURRENT ((attribute_store_type_t) 0x0b040312)
///< This represents the MeasuredPhase11thHarmonicCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_MULTIPLIER ((attribute_store_type_t) 0x0b040400)
///< This represents the ACFrequencyMultiplier attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_FREQUENCY_DIVISOR ((attribute_store_type_t) 0x0b040401)
///< This represents the ACFrequencyDivisor attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_MULTIPLIER ((attribute_store_type_t) 0x0b040402)
///< This represents the PowerMultiplier attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_DIVISOR ((attribute_store_type_t) 0x0b040403)
///< This represents the PowerDivisor attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_HARMONIC_CURRENT_MULTIPLIER ((attribute_store_type_t) 0x0b040404)
///< This represents the HarmonicCurrentMultiplier attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_PHASE_HARMONIC_CURRENT_MULTIPLIER ((attribute_store_type_t) 0x0b040405)
///< This represents the PhaseHarmonicCurrentMultiplier attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT ((attribute_store_type_t) 0x0b040501)
///< This represents the LineCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT ((attribute_store_type_t) 0x0b040502)
///< This represents the ActiveCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT ((attribute_store_type_t) 0x0b040503)
///< This represents the ReactiveCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE ((attribute_store_type_t) 0x0b040505)
///< This represents the RMSVoltage attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN ((attribute_store_type_t) 0x0b040506)
///< This represents the RMSVoltageMin attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX ((attribute_store_type_t) 0x0b040507)
///< This represents the RMSVoltageMax attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT ((attribute_store_type_t) 0x0b040508)
///< This represents the RMSCurrent attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN ((attribute_store_type_t) 0x0b040509)
///< This represents the RMSCurrentMin attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX ((attribute_store_type_t) 0x0b04050a)
///< This represents the RMSCurrentMax attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER ((attribute_store_type_t) 0x0b04050b)
///< This represents the ActivePower attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN ((attribute_store_type_t) 0x0b04050c)
///< This represents the ActivePowerMin attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX ((attribute_store_type_t) 0x0b04050d)
///< This represents the ActivePowerMax attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER ((attribute_store_type_t) 0x0b04050e)
///< This represents the ReactivePower attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER ((attribute_store_type_t) 0x0b04050f)
///< This represents the ApparentPower attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR ((attribute_store_type_t) 0x0b040510)
///< This represents the PowerFactor attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD ((attribute_store_type_t) 0x0b040511)
///< This represents the AverageRMSVoltageMeasurementPeriod attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER ((attribute_store_type_t) 0x0b040512)
///< This represents the AverageRMSOverVoltageCounter attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER ((attribute_store_type_t) 0x0b040513)
///< This represents the AverageRMSUnderVoltageCounter attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD ((attribute_store_type_t) 0x0b040514)
///< This represents the RMSExtremeOverVoltagePeriod attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD ((attribute_store_type_t) 0x0b040515)
///< This represents the RMSExtremeUnderVoltagePeriod attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD ((attribute_store_type_t) 0x0b040516)
///< This represents the RMSVoltageSagPeriod attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD ((attribute_store_type_t) 0x0b040517)
///< This represents the RMSVoltageSwellPeriod attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_MULTIPLIER ((attribute_store_type_t) 0x0b040600)
///< This represents the ACVoltageMultiplier attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_DIVISOR ((attribute_store_type_t) 0x0b040601)
///< This represents the ACVoltageDivisor attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_MULTIPLIER ((attribute_store_type_t) 0x0b040602)
///< This represents the ACCurrentMultiplier attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_DIVISOR ((attribute_store_type_t) 0x0b040603)
///< This represents the ACCurrentDivisor attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_MULTIPLIER ((attribute_store_type_t) 0x0b040604)
///< This represents the ACPowerMultiplier attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_POWER_DIVISOR ((attribute_store_type_t) 0x0b040605)
///< This represents the ACPowerDivisor attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_OVERLOAD_ALARMS_MASK ((attribute_store_type_t) 0x0b040700)
///< This represents the DCOverloadAlarmsMask attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_VOLTAGE_OVERLOAD ((attribute_store_type_t) 0x0b040701)
///< This represents the DCVoltageOverload attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_DC_CURRENT_OVERLOAD ((attribute_store_type_t) 0x0b040702)
///< This represents the DCCurrentOverload attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ALARMS_MASK ((attribute_store_type_t) 0x0b040800)
///< This represents the ACAlarmsMask attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_VOLTAGE_OVERLOAD ((attribute_store_type_t) 0x0b040801)
///< This represents the ACVoltageOverload attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_CURRENT_OVERLOAD ((attribute_store_type_t) 0x0b040802)
///< This represents the ACCurrentOverload attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_ACTIVE_POWER_OVERLOAD ((attribute_store_type_t) 0x0b040803)
///< This represents the ACActivePowerOverload attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AC_REACTIVE_POWER_OVERLOAD ((attribute_store_type_t) 0x0b040804)
///< This represents the ACReactivePowerOverload attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE ((attribute_store_type_t) 0x0b040805)
///< This represents the AverageRMSOverVoltage attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE ((attribute_store_type_t) 0x0b040806)
///< This represents the AverageRMSUnderVoltage attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE ((attribute_store_type_t) 0x0b040807)
///< This represents the RMSExtremeOverVoltage attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE ((attribute_store_type_t) 0x0b040808)
///< This represents the RMSExtremeUnderVoltage attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG ((attribute_store_type_t) 0x0b040809)
///< This represents the RMSVoltageSag attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL ((attribute_store_type_t) 0x0b04080a)
///< This represents the RMSVoltageSwell attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHB ((attribute_store_type_t) 0x0b040901)
///< This represents the LineCurrentPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHB ((attribute_store_type_t) 0x0b040902)
///< This represents the ActiveCurrentPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHB ((attribute_store_type_t) 0x0b040903)
///< This represents the ReactiveCurrentPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHB ((attribute_store_type_t) 0x0b040905)
///< This represents the RMSVoltagePhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHB ((attribute_store_type_t) 0x0b040906)
///< This represents the RMSVoltageMinPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHB ((attribute_store_type_t) 0x0b040907)
///< This represents the RMSVoltageMaxPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHB ((attribute_store_type_t) 0x0b040908)
///< This represents the RMSCurrentPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHB ((attribute_store_type_t) 0x0b040909)
///< This represents the RMSCurrentMinPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHB ((attribute_store_type_t) 0x0b04090a)
///< This represents the RMSCurrentMaxPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHB ((attribute_store_type_t) 0x0b04090b)
///< This represents the ActivePowerPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHB ((attribute_store_type_t) 0x0b04090c)
///< This represents the ActivePowerMinPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHB ((attribute_store_type_t) 0x0b04090d)
///< This represents the ActivePowerMaxPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHB ((attribute_store_type_t) 0x0b04090e)
///< This represents the ReactivePowerPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHB ((attribute_store_type_t) 0x0b04090f)
///< This represents the ApparentPowerPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHB ((attribute_store_type_t) 0x0b040910)
///< This represents the PowerFactorPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHB ((attribute_store_type_t) 0x0b040911)
///< This represents the AverageRMSVoltageMeasurementPeriodPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHB ((attribute_store_type_t) 0x0b040912)
///< This represents the AverageRMSOverVoltageCounterPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHB ((attribute_store_type_t) 0x0b040913)
///< This represents the AverageRMSUnderVoltageCounterPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB ((attribute_store_type_t) 0x0b040914)
///< This represents the RMSExtremeOverVoltagePeriodPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB ((attribute_store_type_t) 0x0b040915)
///< This represents the RMSExtremeUnderVoltagePeriodPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHB ((attribute_store_type_t) 0x0b040916)
///< This represents the RMSVoltageSagPeriodPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHB ((attribute_store_type_t) 0x0b040917)
///< This represents the RMSVoltageSwellPeriodPhB attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_LINE_CURRENT_PHC ((attribute_store_type_t) 0x0b040a01)
///< This represents the LineCurrentPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_CURRENT_PHC ((attribute_store_type_t) 0x0b040a02)
///< This represents the ActiveCurrentPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_CURRENT_PHC ((attribute_store_type_t) 0x0b040a03)
///< This represents the ReactiveCurrentPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_PHC ((attribute_store_type_t) 0x0b040a05)
///< This represents the RMSVoltagePhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MIN_PHC ((attribute_store_type_t) 0x0b040a06)
///< This represents the RMSVoltageMinPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_MAX_PHC ((attribute_store_type_t) 0x0b040a07)
///< This represents the RMSVoltageMaxPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_PHC ((attribute_store_type_t) 0x0b040a08)
///< This represents the RMSCurrentPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MIN_PHC ((attribute_store_type_t) 0x0b040a09)
///< This represents the RMSCurrentMinPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_CURRENT_MAX_PHC ((attribute_store_type_t) 0x0b040a0a)
///< This represents the RMSCurrentMaxPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_PHC ((attribute_store_type_t) 0x0b040a0b)
///< This represents the ActivePowerPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MIN_PHC ((attribute_store_type_t) 0x0b040a0c)
///< This represents the ActivePowerMinPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_ACTIVE_POWER_MAX_PHC ((attribute_store_type_t) 0x0b040a0d)
///< This represents the ActivePowerMaxPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_REACTIVE_POWER_PHC ((attribute_store_type_t) 0x0b040a0e)
///< This represents the ReactivePowerPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_APPARENT_POWER_PHC ((attribute_store_type_t) 0x0b040a0f)
///< This represents the ApparentPowerPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_POWER_FACTOR_PHC ((attribute_store_type_t) 0x0b040a10)
///< This represents the PowerFactorPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_VOLTAGE_MEASUREMENT_PERIOD_PHC ((attribute_store_type_t) 0x0b040a11)
///< This represents the AverageRMSVoltageMeasurementPeriodPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_OVER_VOLTAGE_COUNTER_PHC ((attribute_store_type_t) 0x0b040a12)
///< This represents the AverageRMSOverVoltageCounterPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_AVERAGERMS_UNDER_VOLTAGE_COUNTER_PHC ((attribute_store_type_t) 0x0b040a13)
///< This represents the AverageRMSUnderVoltageCounterPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC ((attribute_store_type_t) 0x0b040a14)
///< This represents the RMSExtremeOverVoltagePeriodPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC ((attribute_store_type_t) 0x0b040a15)
///< This represents the RMSExtremeUnderVoltagePeriodPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SAG_PERIOD_PHC ((attribute_store_type_t) 0x0b040a16)
///< This represents the RMSVoltageSagPeriodPhC attribute in the DotDot ElectricalMeasurement cluster

#define DOTDOT_ATTRIBUTE_ID_ELECTRICAL_MEASUREMENT_RMS_VOLTAGE_SWELL_PERIOD_PHC ((attribute_store_type_t) 0x0b040a17)
///< This represents the RMSVoltageSwellPeriodPhC attribute in the DotDot ElectricalMeasurement cluster

// ElectricalMeasurement MeasurementType
/**
 * @brief Verifies if the DotDot ElectricalMeasurement MeasurementType is supported
 *
 * @returns true if MeasurementType is supported
 * @returns false if MeasurementType is not supported
 */
bool dotdot_is_supported_electrical_measurement_measurement_type (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasurementType attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasurementType attribute
 */
uint32_t dotdot_get_electrical_measurement_measurement_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasurementType attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measurement_type new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measurement_type(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_measurement_type);

// ElectricalMeasurement DCVoltage
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCVoltage is supported
 *
 * @returns true if DCVoltage is supported
 * @returns false if DCVoltage is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCVoltage attribute
 */
int16_t dotdot_get_electrical_measurement_dc_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_voltage);

// ElectricalMeasurement DCVoltageMin
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCVoltageMin is supported
 *
 * @returns true if DCVoltageMin is supported
 * @returns false if DCVoltageMin is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_voltage_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCVoltageMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCVoltageMin attribute
 */
int16_t dotdot_get_electrical_measurement_dc_voltage_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCVoltageMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_voltage_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_voltage_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_voltage_min);

// ElectricalMeasurement DCVoltageMax
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCVoltageMax is supported
 *
 * @returns true if DCVoltageMax is supported
 * @returns false if DCVoltageMax is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_voltage_max (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCVoltageMax attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCVoltageMax attribute
 */
int16_t dotdot_get_electrical_measurement_dc_voltage_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCVoltageMax attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_voltage_max new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_voltage_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_voltage_max);

// ElectricalMeasurement DCCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCCurrent is supported
 *
 * @returns true if DCCurrent is supported
 * @returns false if DCCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_dc_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_current);

// ElectricalMeasurement DCCurrentMin
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCCurrentMin is supported
 *
 * @returns true if DCCurrentMin is supported
 * @returns false if DCCurrentMin is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_current_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCCurrentMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCCurrentMin attribute
 */
int16_t dotdot_get_electrical_measurement_dc_current_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCCurrentMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_current_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_current_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_current_min);

// ElectricalMeasurement DCCurrentMax
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCCurrentMax is supported
 *
 * @returns true if DCCurrentMax is supported
 * @returns false if DCCurrentMax is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_current_max (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCCurrentMax attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCCurrentMax attribute
 */
int16_t dotdot_get_electrical_measurement_dc_current_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCCurrentMax attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_current_max new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_current_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_current_max);

// ElectricalMeasurement DCPower
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCPower is supported
 *
 * @returns true if DCPower is supported
 * @returns false if DCPower is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_power (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCPower attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCPower attribute
 */
int16_t dotdot_get_electrical_measurement_dc_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCPower attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_power new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_power);

// ElectricalMeasurement DCPowerMin
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCPowerMin is supported
 *
 * @returns true if DCPowerMin is supported
 * @returns false if DCPowerMin is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_power_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCPowerMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCPowerMin attribute
 */
int16_t dotdot_get_electrical_measurement_dc_power_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCPowerMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_power_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_power_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_power_min);

// ElectricalMeasurement DCPowerMax
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCPowerMax is supported
 *
 * @returns true if DCPowerMax is supported
 * @returns false if DCPowerMax is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_power_max (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCPowerMax attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCPowerMax attribute
 */
int16_t dotdot_get_electrical_measurement_dc_power_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCPowerMax attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_power_max new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_power_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_power_max);

// ElectricalMeasurement DCVoltageMultiplier
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCVoltageMultiplier is supported
 *
 * @returns true if DCVoltageMultiplier is supported
 * @returns false if DCVoltageMultiplier is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_voltage_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCVoltageMultiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCVoltageMultiplier attribute
 */
uint16_t dotdot_get_electrical_measurement_dc_voltage_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCVoltageMultiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_voltage_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_voltage_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_dc_voltage_multiplier);

// ElectricalMeasurement DCVoltageDivisor
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCVoltageDivisor is supported
 *
 * @returns true if DCVoltageDivisor is supported
 * @returns false if DCVoltageDivisor is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_voltage_divisor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCVoltageDivisor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCVoltageDivisor attribute
 */
uint16_t dotdot_get_electrical_measurement_dc_voltage_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCVoltageDivisor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_voltage_divisor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_voltage_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_dc_voltage_divisor);

// ElectricalMeasurement DCCurrentMultiplier
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCCurrentMultiplier is supported
 *
 * @returns true if DCCurrentMultiplier is supported
 * @returns false if DCCurrentMultiplier is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_current_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCCurrentMultiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCCurrentMultiplier attribute
 */
uint16_t dotdot_get_electrical_measurement_dc_current_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCCurrentMultiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_current_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_current_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_dc_current_multiplier);

// ElectricalMeasurement DCCurrentDivisor
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCCurrentDivisor is supported
 *
 * @returns true if DCCurrentDivisor is supported
 * @returns false if DCCurrentDivisor is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_current_divisor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCCurrentDivisor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCCurrentDivisor attribute
 */
uint16_t dotdot_get_electrical_measurement_dc_current_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCCurrentDivisor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_current_divisor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_current_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_dc_current_divisor);

// ElectricalMeasurement DCPowerMultiplier
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCPowerMultiplier is supported
 *
 * @returns true if DCPowerMultiplier is supported
 * @returns false if DCPowerMultiplier is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_power_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCPowerMultiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCPowerMultiplier attribute
 */
uint16_t dotdot_get_electrical_measurement_dc_power_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCPowerMultiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_power_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_power_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_dc_power_multiplier);

// ElectricalMeasurement DCPowerDivisor
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCPowerDivisor is supported
 *
 * @returns true if DCPowerDivisor is supported
 * @returns false if DCPowerDivisor is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_power_divisor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCPowerDivisor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCPowerDivisor attribute
 */
uint16_t dotdot_get_electrical_measurement_dc_power_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCPowerDivisor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_power_divisor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_power_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_dc_power_divisor);

// ElectricalMeasurement ACFrequency
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACFrequency is supported
 *
 * @returns true if ACFrequency is supported
 * @returns false if ACFrequency is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_frequency (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACFrequency attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACFrequency attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_frequency(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACFrequency attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_frequency new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_frequency(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_frequency);

// ElectricalMeasurement ACFrequencyMin
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACFrequencyMin is supported
 *
 * @returns true if ACFrequencyMin is supported
 * @returns false if ACFrequencyMin is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_frequency_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACFrequencyMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACFrequencyMin attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_frequency_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACFrequencyMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_frequency_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_frequency_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_frequency_min);

// ElectricalMeasurement ACFrequencyMax
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACFrequencyMax is supported
 *
 * @returns true if ACFrequencyMax is supported
 * @returns false if ACFrequencyMax is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_frequency_max (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACFrequencyMax attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACFrequencyMax attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_frequency_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACFrequencyMax attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_frequency_max new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_frequency_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_frequency_max);

// ElectricalMeasurement NeutralCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement NeutralCurrent is supported
 *
 * @returns true if NeutralCurrent is supported
 * @returns false if NeutralCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_neutral_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NeutralCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NeutralCurrent attribute
 */
uint16_t dotdot_get_electrical_measurement_neutral_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NeutralCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_neutral_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_neutral_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_neutral_current);

// ElectricalMeasurement TotalActivePower
/**
 * @brief Verifies if the DotDot ElectricalMeasurement TotalActivePower is supported
 *
 * @returns true if TotalActivePower is supported
 * @returns false if TotalActivePower is not supported
 */
bool dotdot_is_supported_electrical_measurement_total_active_power (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TotalActivePower attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TotalActivePower attribute
 */
int32_t dotdot_get_electrical_measurement_total_active_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TotalActivePower attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_total_active_power new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_total_active_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int32_t new_total_active_power);

// ElectricalMeasurement TotalReactivePower
/**
 * @brief Verifies if the DotDot ElectricalMeasurement TotalReactivePower is supported
 *
 * @returns true if TotalReactivePower is supported
 * @returns false if TotalReactivePower is not supported
 */
bool dotdot_is_supported_electrical_measurement_total_reactive_power (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TotalReactivePower attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TotalReactivePower attribute
 */
int32_t dotdot_get_electrical_measurement_total_reactive_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TotalReactivePower attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_total_reactive_power new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_total_reactive_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int32_t new_total_reactive_power);

// ElectricalMeasurement TotalApparentPower
/**
 * @brief Verifies if the DotDot ElectricalMeasurement TotalApparentPower is supported
 *
 * @returns true if TotalApparentPower is supported
 * @returns false if TotalApparentPower is not supported
 */
bool dotdot_is_supported_electrical_measurement_total_apparent_power (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TotalApparentPower attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TotalApparentPower attribute
 */
uint32_t dotdot_get_electrical_measurement_total_apparent_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TotalApparentPower attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_total_apparent_power new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_total_apparent_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_total_apparent_power);

// ElectricalMeasurement Measured1stHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement Measured1stHarmonicCurrent is supported
 *
 * @returns true if Measured1stHarmonicCurrent is supported
 * @returns false if Measured1stHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured1st_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Measured1stHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Measured1stHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured1st_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Measured1stHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured1st_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured1st_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured1st_harmonic_current);

// ElectricalMeasurement Measured3rdHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement Measured3rdHarmonicCurrent is supported
 *
 * @returns true if Measured3rdHarmonicCurrent is supported
 * @returns false if Measured3rdHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured3rd_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Measured3rdHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Measured3rdHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured3rd_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Measured3rdHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured3rd_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured3rd_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured3rd_harmonic_current);

// ElectricalMeasurement Measured5thHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement Measured5thHarmonicCurrent is supported
 *
 * @returns true if Measured5thHarmonicCurrent is supported
 * @returns false if Measured5thHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured5th_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Measured5thHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Measured5thHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured5th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Measured5thHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured5th_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured5th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured5th_harmonic_current);

// ElectricalMeasurement Measured7thHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement Measured7thHarmonicCurrent is supported
 *
 * @returns true if Measured7thHarmonicCurrent is supported
 * @returns false if Measured7thHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured7th_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Measured7thHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Measured7thHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured7th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Measured7thHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured7th_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured7th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured7th_harmonic_current);

// ElectricalMeasurement Measured9thHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement Measured9thHarmonicCurrent is supported
 *
 * @returns true if Measured9thHarmonicCurrent is supported
 * @returns false if Measured9thHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured9th_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Measured9thHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Measured9thHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured9th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Measured9thHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured9th_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured9th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured9th_harmonic_current);

// ElectricalMeasurement Measured11thHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement Measured11thHarmonicCurrent is supported
 *
 * @returns true if Measured11thHarmonicCurrent is supported
 * @returns false if Measured11thHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured11th_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Measured11thHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Measured11thHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured11th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Measured11thHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured11th_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured11th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured11th_harmonic_current);

// ElectricalMeasurement MeasuredPhase1stHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement MeasuredPhase1stHarmonicCurrent is supported
 *
 * @returns true if MeasuredPhase1stHarmonicCurrent is supported
 * @returns false if MeasuredPhase1stHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured_phase1st_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredPhase1stHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredPhase1stHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured_phase1st_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredPhase1stHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_phase1st_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured_phase1st_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured_phase1st_harmonic_current);

// ElectricalMeasurement MeasuredPhase3rdHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement MeasuredPhase3rdHarmonicCurrent is supported
 *
 * @returns true if MeasuredPhase3rdHarmonicCurrent is supported
 * @returns false if MeasuredPhase3rdHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured_phase3rd_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredPhase3rdHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredPhase3rdHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured_phase3rd_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredPhase3rdHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_phase3rd_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured_phase3rd_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured_phase3rd_harmonic_current);

// ElectricalMeasurement MeasuredPhase5thHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement MeasuredPhase5thHarmonicCurrent is supported
 *
 * @returns true if MeasuredPhase5thHarmonicCurrent is supported
 * @returns false if MeasuredPhase5thHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured_phase5th_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredPhase5thHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredPhase5thHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured_phase5th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredPhase5thHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_phase5th_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured_phase5th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured_phase5th_harmonic_current);

// ElectricalMeasurement MeasuredPhase7thHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement MeasuredPhase7thHarmonicCurrent is supported
 *
 * @returns true if MeasuredPhase7thHarmonicCurrent is supported
 * @returns false if MeasuredPhase7thHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured_phase7th_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredPhase7thHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredPhase7thHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured_phase7th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredPhase7thHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_phase7th_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured_phase7th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured_phase7th_harmonic_current);

// ElectricalMeasurement MeasuredPhase9thHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement MeasuredPhase9thHarmonicCurrent is supported
 *
 * @returns true if MeasuredPhase9thHarmonicCurrent is supported
 * @returns false if MeasuredPhase9thHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured_phase9th_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredPhase9thHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredPhase9thHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured_phase9th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredPhase9thHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_phase9th_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured_phase9th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured_phase9th_harmonic_current);

// ElectricalMeasurement MeasuredPhase11thHarmonicCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement MeasuredPhase11thHarmonicCurrent is supported
 *
 * @returns true if MeasuredPhase11thHarmonicCurrent is supported
 * @returns false if MeasuredPhase11thHarmonicCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_measured_phase11th_harmonic_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MeasuredPhase11thHarmonicCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MeasuredPhase11thHarmonicCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_measured_phase11th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MeasuredPhase11thHarmonicCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_measured_phase11th_harmonic_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_measured_phase11th_harmonic_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_measured_phase11th_harmonic_current);

// ElectricalMeasurement ACFrequencyMultiplier
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACFrequencyMultiplier is supported
 *
 * @returns true if ACFrequencyMultiplier is supported
 * @returns false if ACFrequencyMultiplier is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_frequency_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACFrequencyMultiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACFrequencyMultiplier attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_frequency_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACFrequencyMultiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_frequency_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_frequency_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_frequency_multiplier);

// ElectricalMeasurement ACFrequencyDivisor
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACFrequencyDivisor is supported
 *
 * @returns true if ACFrequencyDivisor is supported
 * @returns false if ACFrequencyDivisor is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_frequency_divisor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACFrequencyDivisor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACFrequencyDivisor attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_frequency_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACFrequencyDivisor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_frequency_divisor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_frequency_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_frequency_divisor);

// ElectricalMeasurement PowerMultiplier
/**
 * @brief Verifies if the DotDot ElectricalMeasurement PowerMultiplier is supported
 *
 * @returns true if PowerMultiplier is supported
 * @returns false if PowerMultiplier is not supported
 */
bool dotdot_is_supported_electrical_measurement_power_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PowerMultiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PowerMultiplier attribute
 */
uint32_t dotdot_get_electrical_measurement_power_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PowerMultiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_power_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_power_multiplier);

// ElectricalMeasurement PowerDivisor
/**
 * @brief Verifies if the DotDot ElectricalMeasurement PowerDivisor is supported
 *
 * @returns true if PowerDivisor is supported
 * @returns false if PowerDivisor is not supported
 */
bool dotdot_is_supported_electrical_measurement_power_divisor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PowerDivisor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PowerDivisor attribute
 */
uint32_t dotdot_get_electrical_measurement_power_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PowerDivisor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power_divisor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_power_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_power_divisor);

// ElectricalMeasurement HarmonicCurrentMultiplier
/**
 * @brief Verifies if the DotDot ElectricalMeasurement HarmonicCurrentMultiplier is supported
 *
 * @returns true if HarmonicCurrentMultiplier is supported
 * @returns false if HarmonicCurrentMultiplier is not supported
 */
bool dotdot_is_supported_electrical_measurement_harmonic_current_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot HarmonicCurrentMultiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns HarmonicCurrentMultiplier attribute
 */
int8_t dotdot_get_electrical_measurement_harmonic_current_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot HarmonicCurrentMultiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_harmonic_current_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_harmonic_current_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_harmonic_current_multiplier);

// ElectricalMeasurement PhaseHarmonicCurrentMultiplier
/**
 * @brief Verifies if the DotDot ElectricalMeasurement PhaseHarmonicCurrentMultiplier is supported
 *
 * @returns true if PhaseHarmonicCurrentMultiplier is supported
 * @returns false if PhaseHarmonicCurrentMultiplier is not supported
 */
bool dotdot_is_supported_electrical_measurement_phase_harmonic_current_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PhaseHarmonicCurrentMultiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PhaseHarmonicCurrentMultiplier attribute
 */
int8_t dotdot_get_electrical_measurement_phase_harmonic_current_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PhaseHarmonicCurrentMultiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_phase_harmonic_current_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_phase_harmonic_current_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_phase_harmonic_current_multiplier);

// ElectricalMeasurement LineCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement LineCurrent is supported
 *
 * @returns true if LineCurrent is supported
 * @returns false if LineCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_line_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LineCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LineCurrent attribute
 */
uint16_t dotdot_get_electrical_measurement_line_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LineCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_line_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_line_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_line_current);

// ElectricalMeasurement ActiveCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActiveCurrent is supported
 *
 * @returns true if ActiveCurrent is supported
 * @returns false if ActiveCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActiveCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActiveCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_active_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActiveCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_current);

// ElectricalMeasurement ReactiveCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ReactiveCurrent is supported
 *
 * @returns true if ReactiveCurrent is supported
 * @returns false if ReactiveCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_reactive_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ReactiveCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ReactiveCurrent attribute
 */
int16_t dotdot_get_electrical_measurement_reactive_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ReactiveCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_reactive_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_reactive_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_reactive_current);

// ElectricalMeasurement RMSVoltage
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltage is supported
 *
 * @returns true if RMSVoltage is supported
 * @returns false if RMSVoltage is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltage attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage);

// ElectricalMeasurement RMSVoltageMin
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageMin is supported
 *
 * @returns true if RMSVoltageMin is supported
 * @returns false if RMSVoltageMin is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageMin attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_min);

// ElectricalMeasurement RMSVoltageMax
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageMax is supported
 *
 * @returns true if RMSVoltageMax is supported
 * @returns false if RMSVoltageMax is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_max (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageMax attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageMax attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageMax attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_max new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_max);

// ElectricalMeasurement RMSCurrent
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSCurrent is supported
 *
 * @returns true if RMSCurrent is supported
 * @returns false if RMSCurrent is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_current (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSCurrent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSCurrent attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSCurrent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_current new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_current(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_current);

// ElectricalMeasurement RMSCurrentMin
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSCurrentMin is supported
 *
 * @returns true if RMSCurrentMin is supported
 * @returns false if RMSCurrentMin is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_current_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSCurrentMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSCurrentMin attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_current_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSCurrentMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_current_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_current_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_current_min);

// ElectricalMeasurement RMSCurrentMax
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSCurrentMax is supported
 *
 * @returns true if RMSCurrentMax is supported
 * @returns false if RMSCurrentMax is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_current_max (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSCurrentMax attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSCurrentMax attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_current_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSCurrentMax attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_current_max new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_current_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_current_max);

// ElectricalMeasurement ActivePower
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActivePower is supported
 *
 * @returns true if ActivePower is supported
 * @returns false if ActivePower is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_power (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActivePower attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActivePower attribute
 */
int16_t dotdot_get_electrical_measurement_active_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActivePower attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_power new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_power);

// ElectricalMeasurement ActivePowerMin
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActivePowerMin is supported
 *
 * @returns true if ActivePowerMin is supported
 * @returns false if ActivePowerMin is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_power_min (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActivePowerMin attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActivePowerMin attribute
 */
int16_t dotdot_get_electrical_measurement_active_power_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActivePowerMin attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_power_min new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_power_min(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_power_min);

// ElectricalMeasurement ActivePowerMax
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActivePowerMax is supported
 *
 * @returns true if ActivePowerMax is supported
 * @returns false if ActivePowerMax is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_power_max (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActivePowerMax attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActivePowerMax attribute
 */
int16_t dotdot_get_electrical_measurement_active_power_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActivePowerMax attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_power_max new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_power_max(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_power_max);

// ElectricalMeasurement ReactivePower
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ReactivePower is supported
 *
 * @returns true if ReactivePower is supported
 * @returns false if ReactivePower is not supported
 */
bool dotdot_is_supported_electrical_measurement_reactive_power (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ReactivePower attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ReactivePower attribute
 */
int16_t dotdot_get_electrical_measurement_reactive_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ReactivePower attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_reactive_power new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_reactive_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_reactive_power);

// ElectricalMeasurement ApparentPower
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ApparentPower is supported
 *
 * @returns true if ApparentPower is supported
 * @returns false if ApparentPower is not supported
 */
bool dotdot_is_supported_electrical_measurement_apparent_power (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApparentPower attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApparentPower attribute
 */
uint16_t dotdot_get_electrical_measurement_apparent_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApparentPower attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_apparent_power new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_apparent_power(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_apparent_power);

// ElectricalMeasurement PowerFactor
/**
 * @brief Verifies if the DotDot ElectricalMeasurement PowerFactor is supported
 *
 * @returns true if PowerFactor is supported
 * @returns false if PowerFactor is not supported
 */
bool dotdot_is_supported_electrical_measurement_power_factor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PowerFactor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PowerFactor attribute
 */
int8_t dotdot_get_electrical_measurement_power_factor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PowerFactor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power_factor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_power_factor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_power_factor);

// ElectricalMeasurement AverageRMSVoltageMeasurementPeriod
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSVoltageMeasurementPeriod is supported
 *
 * @returns true if AverageRMSVoltageMeasurementPeriod is supported
 * @returns false if AverageRMSVoltageMeasurementPeriod is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_voltage_measurement_period (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSVoltageMeasurementPeriod attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSVoltageMeasurementPeriod attribute
 */
uint16_t dotdot_get_electrical_measurement_averagerms_voltage_measurement_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSVoltageMeasurementPeriod attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_voltage_measurement_period new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_voltage_measurement_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_averagerms_voltage_measurement_period);

// ElectricalMeasurement AverageRMSOverVoltageCounter
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSOverVoltageCounter is supported
 *
 * @returns true if AverageRMSOverVoltageCounter is supported
 * @returns false if AverageRMSOverVoltageCounter is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_over_voltage_counter (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSOverVoltageCounter attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSOverVoltageCounter attribute
 */
uint16_t dotdot_get_electrical_measurement_averagerms_over_voltage_counter(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSOverVoltageCounter attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_over_voltage_counter new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_over_voltage_counter(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_averagerms_over_voltage_counter);

// ElectricalMeasurement AverageRMSUnderVoltageCounter
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSUnderVoltageCounter is supported
 *
 * @returns true if AverageRMSUnderVoltageCounter is supported
 * @returns false if AverageRMSUnderVoltageCounter is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_under_voltage_counter (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSUnderVoltageCounter attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSUnderVoltageCounter attribute
 */
uint16_t dotdot_get_electrical_measurement_averagerms_under_voltage_counter(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSUnderVoltageCounter attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_under_voltage_counter new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_under_voltage_counter(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_averagerms_under_voltage_counter);

// ElectricalMeasurement RMSExtremeOverVoltagePeriod
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSExtremeOverVoltagePeriod is supported
 *
 * @returns true if RMSExtremeOverVoltagePeriod is supported
 * @returns false if RMSExtremeOverVoltagePeriod is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_extreme_over_voltage_period (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSExtremeOverVoltagePeriod attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSExtremeOverVoltagePeriod attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_extreme_over_voltage_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSExtremeOverVoltagePeriod attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_extreme_over_voltage_period new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_extreme_over_voltage_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_extreme_over_voltage_period);

// ElectricalMeasurement RMSExtremeUnderVoltagePeriod
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSExtremeUnderVoltagePeriod is supported
 *
 * @returns true if RMSExtremeUnderVoltagePeriod is supported
 * @returns false if RMSExtremeUnderVoltagePeriod is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_extreme_under_voltage_period (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSExtremeUnderVoltagePeriod attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSExtremeUnderVoltagePeriod attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_extreme_under_voltage_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSExtremeUnderVoltagePeriod attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_extreme_under_voltage_period new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_extreme_under_voltage_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_extreme_under_voltage_period);

// ElectricalMeasurement RMSVoltageSagPeriod
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageSagPeriod is supported
 *
 * @returns true if RMSVoltageSagPeriod is supported
 * @returns false if RMSVoltageSagPeriod is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_sag_period (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageSagPeriod attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageSagPeriod attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_sag_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageSagPeriod attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_sag_period new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_sag_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_sag_period);

// ElectricalMeasurement RMSVoltageSwellPeriod
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageSwellPeriod is supported
 *
 * @returns true if RMSVoltageSwellPeriod is supported
 * @returns false if RMSVoltageSwellPeriod is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_swell_period (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageSwellPeriod attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageSwellPeriod attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_swell_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageSwellPeriod attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_swell_period new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_swell_period(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_swell_period);

// ElectricalMeasurement ACVoltageMultiplier
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACVoltageMultiplier is supported
 *
 * @returns true if ACVoltageMultiplier is supported
 * @returns false if ACVoltageMultiplier is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_voltage_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACVoltageMultiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACVoltageMultiplier attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_voltage_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACVoltageMultiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_voltage_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_voltage_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_voltage_multiplier);

// ElectricalMeasurement ACVoltageDivisor
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACVoltageDivisor is supported
 *
 * @returns true if ACVoltageDivisor is supported
 * @returns false if ACVoltageDivisor is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_voltage_divisor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACVoltageDivisor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACVoltageDivisor attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_voltage_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACVoltageDivisor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_voltage_divisor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_voltage_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_voltage_divisor);

// ElectricalMeasurement ACCurrentMultiplier
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACCurrentMultiplier is supported
 *
 * @returns true if ACCurrentMultiplier is supported
 * @returns false if ACCurrentMultiplier is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_current_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACCurrentMultiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACCurrentMultiplier attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_current_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACCurrentMultiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_current_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_current_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_current_multiplier);

// ElectricalMeasurement ACCurrentDivisor
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACCurrentDivisor is supported
 *
 * @returns true if ACCurrentDivisor is supported
 * @returns false if ACCurrentDivisor is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_current_divisor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACCurrentDivisor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACCurrentDivisor attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_current_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACCurrentDivisor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_current_divisor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_current_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_current_divisor);

// ElectricalMeasurement ACPowerMultiplier
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACPowerMultiplier is supported
 *
 * @returns true if ACPowerMultiplier is supported
 * @returns false if ACPowerMultiplier is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_power_multiplier (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACPowerMultiplier attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACPowerMultiplier attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_power_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACPowerMultiplier attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_power_multiplier new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_power_multiplier(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_power_multiplier);

// ElectricalMeasurement ACPowerDivisor
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACPowerDivisor is supported
 *
 * @returns true if ACPowerDivisor is supported
 * @returns false if ACPowerDivisor is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_power_divisor (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACPowerDivisor attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACPowerDivisor attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_power_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACPowerDivisor attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_power_divisor new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_power_divisor(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_power_divisor);

// ElectricalMeasurement DCOverloadAlarmsMask
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCOverloadAlarmsMask is supported
 *
 * @returns true if DCOverloadAlarmsMask is supported
 * @returns false if DCOverloadAlarmsMask is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_overload_alarms_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCOverloadAlarmsMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCOverloadAlarmsMask attribute
 */
uint8_t dotdot_get_electrical_measurement_dc_overload_alarms_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCOverloadAlarmsMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_overload_alarms_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_overload_alarms_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_dc_overload_alarms_mask);

// ElectricalMeasurement DCVoltageOverload
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCVoltageOverload is supported
 *
 * @returns true if DCVoltageOverload is supported
 * @returns false if DCVoltageOverload is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_voltage_overload (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCVoltageOverload attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCVoltageOverload attribute
 */
int16_t dotdot_get_electrical_measurement_dc_voltage_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCVoltageOverload attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_voltage_overload new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_voltage_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_voltage_overload);

// ElectricalMeasurement DCCurrentOverload
/**
 * @brief Verifies if the DotDot ElectricalMeasurement DCCurrentOverload is supported
 *
 * @returns true if DCCurrentOverload is supported
 * @returns false if DCCurrentOverload is not supported
 */
bool dotdot_is_supported_electrical_measurement_dc_current_overload (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DCCurrentOverload attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DCCurrentOverload attribute
 */
int16_t dotdot_get_electrical_measurement_dc_current_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DCCurrentOverload attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_dc_current_overload new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_dc_current_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_dc_current_overload);

// ElectricalMeasurement ACAlarmsMask
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACAlarmsMask is supported
 *
 * @returns true if ACAlarmsMask is supported
 * @returns false if ACAlarmsMask is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_alarms_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACAlarmsMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACAlarmsMask attribute
 */
uint16_t dotdot_get_electrical_measurement_ac_alarms_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACAlarmsMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_alarms_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_alarms_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_ac_alarms_mask);

// ElectricalMeasurement ACVoltageOverload
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACVoltageOverload is supported
 *
 * @returns true if ACVoltageOverload is supported
 * @returns false if ACVoltageOverload is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_voltage_overload (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACVoltageOverload attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACVoltageOverload attribute
 */
int16_t dotdot_get_electrical_measurement_ac_voltage_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACVoltageOverload attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_voltage_overload new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_voltage_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_ac_voltage_overload);

// ElectricalMeasurement ACCurrentOverload
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACCurrentOverload is supported
 *
 * @returns true if ACCurrentOverload is supported
 * @returns false if ACCurrentOverload is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_current_overload (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACCurrentOverload attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACCurrentOverload attribute
 */
int16_t dotdot_get_electrical_measurement_ac_current_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACCurrentOverload attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_current_overload new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_current_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_ac_current_overload);

// ElectricalMeasurement ACActivePowerOverload
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACActivePowerOverload is supported
 *
 * @returns true if ACActivePowerOverload is supported
 * @returns false if ACActivePowerOverload is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_active_power_overload (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACActivePowerOverload attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACActivePowerOverload attribute
 */
int16_t dotdot_get_electrical_measurement_ac_active_power_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACActivePowerOverload attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_active_power_overload new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_active_power_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_ac_active_power_overload);

// ElectricalMeasurement ACReactivePowerOverload
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ACReactivePowerOverload is supported
 *
 * @returns true if ACReactivePowerOverload is supported
 * @returns false if ACReactivePowerOverload is not supported
 */
bool dotdot_is_supported_electrical_measurement_ac_reactive_power_overload (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ACReactivePowerOverload attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ACReactivePowerOverload attribute
 */
int16_t dotdot_get_electrical_measurement_ac_reactive_power_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ACReactivePowerOverload attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ac_reactive_power_overload new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_ac_reactive_power_overload(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_ac_reactive_power_overload);

// ElectricalMeasurement AverageRMSOverVoltage
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSOverVoltage is supported
 *
 * @returns true if AverageRMSOverVoltage is supported
 * @returns false if AverageRMSOverVoltage is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_over_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSOverVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSOverVoltage attribute
 */
int16_t dotdot_get_electrical_measurement_averagerms_over_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSOverVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_over_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_over_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_averagerms_over_voltage);

// ElectricalMeasurement AverageRMSUnderVoltage
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSUnderVoltage is supported
 *
 * @returns true if AverageRMSUnderVoltage is supported
 * @returns false if AverageRMSUnderVoltage is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_under_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSUnderVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSUnderVoltage attribute
 */
int16_t dotdot_get_electrical_measurement_averagerms_under_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSUnderVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_under_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_under_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_averagerms_under_voltage);

// ElectricalMeasurement RMSExtremeOverVoltage
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSExtremeOverVoltage is supported
 *
 * @returns true if RMSExtremeOverVoltage is supported
 * @returns false if RMSExtremeOverVoltage is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_extreme_over_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSExtremeOverVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSExtremeOverVoltage attribute
 */
int16_t dotdot_get_electrical_measurement_rms_extreme_over_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSExtremeOverVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_extreme_over_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_extreme_over_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_rms_extreme_over_voltage);

// ElectricalMeasurement RMSExtremeUnderVoltage
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSExtremeUnderVoltage is supported
 *
 * @returns true if RMSExtremeUnderVoltage is supported
 * @returns false if RMSExtremeUnderVoltage is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_extreme_under_voltage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSExtremeUnderVoltage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSExtremeUnderVoltage attribute
 */
int16_t dotdot_get_electrical_measurement_rms_extreme_under_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSExtremeUnderVoltage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_extreme_under_voltage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_extreme_under_voltage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_rms_extreme_under_voltage);

// ElectricalMeasurement RMSVoltageSag
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageSag is supported
 *
 * @returns true if RMSVoltageSag is supported
 * @returns false if RMSVoltageSag is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_sag (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageSag attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageSag attribute
 */
int16_t dotdot_get_electrical_measurement_rms_voltage_sag(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageSag attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_sag new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_sag(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_rms_voltage_sag);

// ElectricalMeasurement RMSVoltageSwell
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageSwell is supported
 *
 * @returns true if RMSVoltageSwell is supported
 * @returns false if RMSVoltageSwell is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_swell (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageSwell attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageSwell attribute
 */
int16_t dotdot_get_electrical_measurement_rms_voltage_swell(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageSwell attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_swell new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_swell(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_rms_voltage_swell);

// ElectricalMeasurement LineCurrentPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement LineCurrentPhB is supported
 *
 * @returns true if LineCurrentPhB is supported
 * @returns false if LineCurrentPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_line_current_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LineCurrentPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LineCurrentPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_line_current_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LineCurrentPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_line_current_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_line_current_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_line_current_phb);

// ElectricalMeasurement ActiveCurrentPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActiveCurrentPhB is supported
 *
 * @returns true if ActiveCurrentPhB is supported
 * @returns false if ActiveCurrentPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_current_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActiveCurrentPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActiveCurrentPhB attribute
 */
int16_t dotdot_get_electrical_measurement_active_current_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActiveCurrentPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_current_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_current_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_current_phb);

// ElectricalMeasurement ReactiveCurrentPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ReactiveCurrentPhB is supported
 *
 * @returns true if ReactiveCurrentPhB is supported
 * @returns false if ReactiveCurrentPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_reactive_current_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ReactiveCurrentPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ReactiveCurrentPhB attribute
 */
int16_t dotdot_get_electrical_measurement_reactive_current_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ReactiveCurrentPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_reactive_current_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_reactive_current_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_reactive_current_phb);

// ElectricalMeasurement RMSVoltagePhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltagePhB is supported
 *
 * @returns true if RMSVoltagePhB is supported
 * @returns false if RMSVoltagePhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltagePhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltagePhB attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltagePhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_phb);

// ElectricalMeasurement RMSVoltageMinPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageMinPhB is supported
 *
 * @returns true if RMSVoltageMinPhB is supported
 * @returns false if RMSVoltageMinPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_min_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageMinPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageMinPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_min_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageMinPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_min_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_min_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_min_phb);

// ElectricalMeasurement RMSVoltageMaxPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageMaxPhB is supported
 *
 * @returns true if RMSVoltageMaxPhB is supported
 * @returns false if RMSVoltageMaxPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_max_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageMaxPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageMaxPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_max_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageMaxPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_max_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_max_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_max_phb);

// ElectricalMeasurement RMSCurrentPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSCurrentPhB is supported
 *
 * @returns true if RMSCurrentPhB is supported
 * @returns false if RMSCurrentPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_current_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSCurrentPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSCurrentPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_current_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSCurrentPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_current_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_current_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_current_phb);

// ElectricalMeasurement RMSCurrentMinPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSCurrentMinPhB is supported
 *
 * @returns true if RMSCurrentMinPhB is supported
 * @returns false if RMSCurrentMinPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_current_min_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSCurrentMinPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSCurrentMinPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_current_min_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSCurrentMinPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_current_min_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_current_min_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_current_min_phb);

// ElectricalMeasurement RMSCurrentMaxPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSCurrentMaxPhB is supported
 *
 * @returns true if RMSCurrentMaxPhB is supported
 * @returns false if RMSCurrentMaxPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_current_max_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSCurrentMaxPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSCurrentMaxPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_current_max_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSCurrentMaxPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_current_max_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_current_max_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_current_max_phb);

// ElectricalMeasurement ActivePowerPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActivePowerPhB is supported
 *
 * @returns true if ActivePowerPhB is supported
 * @returns false if ActivePowerPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_power_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActivePowerPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActivePowerPhB attribute
 */
int16_t dotdot_get_electrical_measurement_active_power_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActivePowerPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_power_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_power_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_power_phb);

// ElectricalMeasurement ActivePowerMinPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActivePowerMinPhB is supported
 *
 * @returns true if ActivePowerMinPhB is supported
 * @returns false if ActivePowerMinPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_power_min_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActivePowerMinPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActivePowerMinPhB attribute
 */
int16_t dotdot_get_electrical_measurement_active_power_min_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActivePowerMinPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_power_min_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_power_min_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_power_min_phb);

// ElectricalMeasurement ActivePowerMaxPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActivePowerMaxPhB is supported
 *
 * @returns true if ActivePowerMaxPhB is supported
 * @returns false if ActivePowerMaxPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_power_max_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActivePowerMaxPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActivePowerMaxPhB attribute
 */
int16_t dotdot_get_electrical_measurement_active_power_max_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActivePowerMaxPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_power_max_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_power_max_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_power_max_phb);

// ElectricalMeasurement ReactivePowerPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ReactivePowerPhB is supported
 *
 * @returns true if ReactivePowerPhB is supported
 * @returns false if ReactivePowerPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_reactive_power_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ReactivePowerPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ReactivePowerPhB attribute
 */
int16_t dotdot_get_electrical_measurement_reactive_power_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ReactivePowerPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_reactive_power_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_reactive_power_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_reactive_power_phb);

// ElectricalMeasurement ApparentPowerPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ApparentPowerPhB is supported
 *
 * @returns true if ApparentPowerPhB is supported
 * @returns false if ApparentPowerPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_apparent_power_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApparentPowerPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApparentPowerPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_apparent_power_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApparentPowerPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_apparent_power_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_apparent_power_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_apparent_power_phb);

// ElectricalMeasurement PowerFactorPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement PowerFactorPhB is supported
 *
 * @returns true if PowerFactorPhB is supported
 * @returns false if PowerFactorPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_power_factor_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PowerFactorPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PowerFactorPhB attribute
 */
int8_t dotdot_get_electrical_measurement_power_factor_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PowerFactorPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power_factor_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_power_factor_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_power_factor_phb);

// ElectricalMeasurement AverageRMSVoltageMeasurementPeriodPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSVoltageMeasurementPeriodPhB is supported
 *
 * @returns true if AverageRMSVoltageMeasurementPeriodPhB is supported
 * @returns false if AverageRMSVoltageMeasurementPeriodPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_voltage_measurement_period_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSVoltageMeasurementPeriodPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSVoltageMeasurementPeriodPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_averagerms_voltage_measurement_period_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSVoltageMeasurementPeriodPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_voltage_measurement_period_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_voltage_measurement_period_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_averagerms_voltage_measurement_period_phb);

// ElectricalMeasurement AverageRMSOverVoltageCounterPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSOverVoltageCounterPhB is supported
 *
 * @returns true if AverageRMSOverVoltageCounterPhB is supported
 * @returns false if AverageRMSOverVoltageCounterPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_over_voltage_counter_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSOverVoltageCounterPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSOverVoltageCounterPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_averagerms_over_voltage_counter_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSOverVoltageCounterPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_over_voltage_counter_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_over_voltage_counter_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_averagerms_over_voltage_counter_phb);

// ElectricalMeasurement AverageRMSUnderVoltageCounterPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSUnderVoltageCounterPhB is supported
 *
 * @returns true if AverageRMSUnderVoltageCounterPhB is supported
 * @returns false if AverageRMSUnderVoltageCounterPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_under_voltage_counter_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSUnderVoltageCounterPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSUnderVoltageCounterPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_averagerms_under_voltage_counter_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSUnderVoltageCounterPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_under_voltage_counter_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_under_voltage_counter_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_averagerms_under_voltage_counter_phb);

// ElectricalMeasurement RMSExtremeOverVoltagePeriodPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSExtremeOverVoltagePeriodPhB is supported
 *
 * @returns true if RMSExtremeOverVoltagePeriodPhB is supported
 * @returns false if RMSExtremeOverVoltagePeriodPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_extreme_over_voltage_period_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSExtremeOverVoltagePeriodPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSExtremeOverVoltagePeriodPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_extreme_over_voltage_period_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSExtremeOverVoltagePeriodPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_extreme_over_voltage_period_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_extreme_over_voltage_period_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_extreme_over_voltage_period_phb);

// ElectricalMeasurement RMSExtremeUnderVoltagePeriodPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSExtremeUnderVoltagePeriodPhB is supported
 *
 * @returns true if RMSExtremeUnderVoltagePeriodPhB is supported
 * @returns false if RMSExtremeUnderVoltagePeriodPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_extreme_under_voltage_period_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSExtremeUnderVoltagePeriodPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSExtremeUnderVoltagePeriodPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_extreme_under_voltage_period_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSExtremeUnderVoltagePeriodPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_extreme_under_voltage_period_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_extreme_under_voltage_period_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_extreme_under_voltage_period_phb);

// ElectricalMeasurement RMSVoltageSagPeriodPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageSagPeriodPhB is supported
 *
 * @returns true if RMSVoltageSagPeriodPhB is supported
 * @returns false if RMSVoltageSagPeriodPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_sag_period_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageSagPeriodPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageSagPeriodPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_sag_period_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageSagPeriodPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_sag_period_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_sag_period_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_sag_period_phb);

// ElectricalMeasurement RMSVoltageSwellPeriodPhB
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageSwellPeriodPhB is supported
 *
 * @returns true if RMSVoltageSwellPeriodPhB is supported
 * @returns false if RMSVoltageSwellPeriodPhB is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_swell_period_phb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageSwellPeriodPhB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageSwellPeriodPhB attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_swell_period_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageSwellPeriodPhB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_swell_period_phb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_swell_period_phb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_swell_period_phb);

// ElectricalMeasurement LineCurrentPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement LineCurrentPhC is supported
 *
 * @returns true if LineCurrentPhC is supported
 * @returns false if LineCurrentPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_line_current_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LineCurrentPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LineCurrentPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_line_current_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LineCurrentPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_line_current_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_line_current_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_line_current_phc);

// ElectricalMeasurement ActiveCurrentPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActiveCurrentPhC is supported
 *
 * @returns true if ActiveCurrentPhC is supported
 * @returns false if ActiveCurrentPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_current_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActiveCurrentPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActiveCurrentPhC attribute
 */
int16_t dotdot_get_electrical_measurement_active_current_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActiveCurrentPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_current_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_current_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_current_phc);

// ElectricalMeasurement ReactiveCurrentPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ReactiveCurrentPhC is supported
 *
 * @returns true if ReactiveCurrentPhC is supported
 * @returns false if ReactiveCurrentPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_reactive_current_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ReactiveCurrentPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ReactiveCurrentPhC attribute
 */
int16_t dotdot_get_electrical_measurement_reactive_current_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ReactiveCurrentPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_reactive_current_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_reactive_current_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_reactive_current_phc);

// ElectricalMeasurement RMSVoltagePhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltagePhC is supported
 *
 * @returns true if RMSVoltagePhC is supported
 * @returns false if RMSVoltagePhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltagePhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltagePhC attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltagePhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_phc);

// ElectricalMeasurement RMSVoltageMinPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageMinPhC is supported
 *
 * @returns true if RMSVoltageMinPhC is supported
 * @returns false if RMSVoltageMinPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_min_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageMinPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageMinPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_min_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageMinPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_min_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_min_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_min_phc);

// ElectricalMeasurement RMSVoltageMaxPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageMaxPhC is supported
 *
 * @returns true if RMSVoltageMaxPhC is supported
 * @returns false if RMSVoltageMaxPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_max_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageMaxPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageMaxPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_max_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageMaxPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_max_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_max_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_max_phc);

// ElectricalMeasurement RMSCurrentPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSCurrentPhC is supported
 *
 * @returns true if RMSCurrentPhC is supported
 * @returns false if RMSCurrentPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_current_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSCurrentPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSCurrentPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_current_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSCurrentPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_current_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_current_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_current_phc);

// ElectricalMeasurement RMSCurrentMinPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSCurrentMinPhC is supported
 *
 * @returns true if RMSCurrentMinPhC is supported
 * @returns false if RMSCurrentMinPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_current_min_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSCurrentMinPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSCurrentMinPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_current_min_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSCurrentMinPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_current_min_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_current_min_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_current_min_phc);

// ElectricalMeasurement RMSCurrentMaxPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSCurrentMaxPhC is supported
 *
 * @returns true if RMSCurrentMaxPhC is supported
 * @returns false if RMSCurrentMaxPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_current_max_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSCurrentMaxPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSCurrentMaxPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_current_max_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSCurrentMaxPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_current_max_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_current_max_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_current_max_phc);

// ElectricalMeasurement ActivePowerPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActivePowerPhC is supported
 *
 * @returns true if ActivePowerPhC is supported
 * @returns false if ActivePowerPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_power_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActivePowerPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActivePowerPhC attribute
 */
int16_t dotdot_get_electrical_measurement_active_power_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActivePowerPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_power_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_power_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_power_phc);

// ElectricalMeasurement ActivePowerMinPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActivePowerMinPhC is supported
 *
 * @returns true if ActivePowerMinPhC is supported
 * @returns false if ActivePowerMinPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_power_min_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActivePowerMinPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActivePowerMinPhC attribute
 */
int16_t dotdot_get_electrical_measurement_active_power_min_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActivePowerMinPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_power_min_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_power_min_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_power_min_phc);

// ElectricalMeasurement ActivePowerMaxPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ActivePowerMaxPhC is supported
 *
 * @returns true if ActivePowerMaxPhC is supported
 * @returns false if ActivePowerMaxPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_active_power_max_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ActivePowerMaxPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ActivePowerMaxPhC attribute
 */
int16_t dotdot_get_electrical_measurement_active_power_max_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ActivePowerMaxPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_active_power_max_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_active_power_max_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_active_power_max_phc);

// ElectricalMeasurement ReactivePowerPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ReactivePowerPhC is supported
 *
 * @returns true if ReactivePowerPhC is supported
 * @returns false if ReactivePowerPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_reactive_power_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ReactivePowerPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ReactivePowerPhC attribute
 */
int16_t dotdot_get_electrical_measurement_reactive_power_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ReactivePowerPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_reactive_power_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_reactive_power_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int16_t new_reactive_power_phc);

// ElectricalMeasurement ApparentPowerPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement ApparentPowerPhC is supported
 *
 * @returns true if ApparentPowerPhC is supported
 * @returns false if ApparentPowerPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_apparent_power_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApparentPowerPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApparentPowerPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_apparent_power_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApparentPowerPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_apparent_power_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_apparent_power_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_apparent_power_phc);

// ElectricalMeasurement PowerFactorPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement PowerFactorPhC is supported
 *
 * @returns true if PowerFactorPhC is supported
 * @returns false if PowerFactorPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_power_factor_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PowerFactorPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PowerFactorPhC attribute
 */
int8_t dotdot_get_electrical_measurement_power_factor_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PowerFactorPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power_factor_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_power_factor_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_power_factor_phc);

// ElectricalMeasurement AverageRMSVoltageMeasurementPeriodPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSVoltageMeasurementPeriodPhC is supported
 *
 * @returns true if AverageRMSVoltageMeasurementPeriodPhC is supported
 * @returns false if AverageRMSVoltageMeasurementPeriodPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_voltage_measurement_period_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSVoltageMeasurementPeriodPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSVoltageMeasurementPeriodPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_averagerms_voltage_measurement_period_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSVoltageMeasurementPeriodPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_voltage_measurement_period_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_voltage_measurement_period_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_averagerms_voltage_measurement_period_phc);

// ElectricalMeasurement AverageRMSOverVoltageCounterPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSOverVoltageCounterPhC is supported
 *
 * @returns true if AverageRMSOverVoltageCounterPhC is supported
 * @returns false if AverageRMSOverVoltageCounterPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_over_voltage_counter_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSOverVoltageCounterPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSOverVoltageCounterPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_averagerms_over_voltage_counter_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSOverVoltageCounterPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_over_voltage_counter_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_over_voltage_counter_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_averagerms_over_voltage_counter_phc);

// ElectricalMeasurement AverageRMSUnderVoltageCounterPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement AverageRMSUnderVoltageCounterPhC is supported
 *
 * @returns true if AverageRMSUnderVoltageCounterPhC is supported
 * @returns false if AverageRMSUnderVoltageCounterPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_averagerms_under_voltage_counter_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageRMSUnderVoltageCounterPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageRMSUnderVoltageCounterPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_averagerms_under_voltage_counter_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageRMSUnderVoltageCounterPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagerms_under_voltage_counter_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_averagerms_under_voltage_counter_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_averagerms_under_voltage_counter_phc);

// ElectricalMeasurement RMSExtremeOverVoltagePeriodPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSExtremeOverVoltagePeriodPhC is supported
 *
 * @returns true if RMSExtremeOverVoltagePeriodPhC is supported
 * @returns false if RMSExtremeOverVoltagePeriodPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_extreme_over_voltage_period_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSExtremeOverVoltagePeriodPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSExtremeOverVoltagePeriodPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_extreme_over_voltage_period_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSExtremeOverVoltagePeriodPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_extreme_over_voltage_period_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_extreme_over_voltage_period_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_extreme_over_voltage_period_phc);

// ElectricalMeasurement RMSExtremeUnderVoltagePeriodPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSExtremeUnderVoltagePeriodPhC is supported
 *
 * @returns true if RMSExtremeUnderVoltagePeriodPhC is supported
 * @returns false if RMSExtremeUnderVoltagePeriodPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_extreme_under_voltage_period_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSExtremeUnderVoltagePeriodPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSExtremeUnderVoltagePeriodPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_extreme_under_voltage_period_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSExtremeUnderVoltagePeriodPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_extreme_under_voltage_period_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_extreme_under_voltage_period_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_extreme_under_voltage_period_phc);

// ElectricalMeasurement RMSVoltageSagPeriodPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageSagPeriodPhC is supported
 *
 * @returns true if RMSVoltageSagPeriodPhC is supported
 * @returns false if RMSVoltageSagPeriodPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_sag_period_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageSagPeriodPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageSagPeriodPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_sag_period_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageSagPeriodPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_sag_period_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_sag_period_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_sag_period_phc);

// ElectricalMeasurement RMSVoltageSwellPeriodPhC
/**
 * @brief Verifies if the DotDot ElectricalMeasurement RMSVoltageSwellPeriodPhC is supported
 *
 * @returns true if RMSVoltageSwellPeriodPhC is supported
 * @returns false if RMSVoltageSwellPeriodPhC is not supported
 */
bool dotdot_is_supported_electrical_measurement_rms_voltage_swell_period_phc (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RMSVoltageSwellPeriodPhC attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RMSVoltageSwellPeriodPhC attribute
 */
uint16_t dotdot_get_electrical_measurement_rms_voltage_swell_period_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RMSVoltageSwellPeriodPhC attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_rms_voltage_swell_period_phc new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_electrical_measurement_rms_voltage_swell_period_phc(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_rms_voltage_swell_period_phc);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Diagnostics
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Diagnostics
#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NUMBER_OF_RESETS ((attribute_store_type_t) 0x0b050000)
///< This represents the NumberOfResets attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PERSISTENT_MEMORY_WRITES ((attribute_store_type_t) 0x0b050001)
///< This represents the PersistentMemoryWrites attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_BCAST ((attribute_store_type_t) 0x0b050100)
///< This represents the MacRxBcast attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_BCAST ((attribute_store_type_t) 0x0b050101)
///< This represents the MacTxBcast attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_RX_UCAST ((attribute_store_type_t) 0x0b050102)
///< This represents the MacRxUcast attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST ((attribute_store_type_t) 0x0b050103)
///< This represents the MacTxUcast attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_RETRY ((attribute_store_type_t) 0x0b050104)
///< This represents the MacTxUcastRetry attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_MAC_TX_UCAST_FAIL ((attribute_store_type_t) 0x0b050105)
///< This represents the MacTxUcastFail attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_BCAST ((attribute_store_type_t) 0x0b050106)
///< This represents the APSRxBcast attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_BCAST ((attribute_store_type_t) 0x0b050107)
///< This represents the APSTxBcast attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_RX_UCAST ((attribute_store_type_t) 0x0b050108)
///< This represents the APSRxUcast attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_SUCCESS ((attribute_store_type_t) 0x0b050109)
///< This represents the APSTxUcastSuccess attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_RETRY ((attribute_store_type_t) 0x0b05010a)
///< This represents the APSTxUcastRetry attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_TX_UCAST_FAIL ((attribute_store_type_t) 0x0b05010b)
///< This represents the APSTxUcastFail attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_ROUTE_DISC_INITIATED ((attribute_store_type_t) 0x0b05010c)
///< This represents the RouteDiscInitiated attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_ADDED ((attribute_store_type_t) 0x0b05010d)
///< This represents the NeighborAdded attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_REMOVED ((attribute_store_type_t) 0x0b05010e)
///< This represents the NeighborRemoved attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NEIGHBOR_STALE ((attribute_store_type_t) 0x0b05010f)
///< This represents the NeighborStale attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_JOIN_INDICATION ((attribute_store_type_t) 0x0b050110)
///< This represents the JoinIndication attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_CHILD_MOVED ((attribute_store_type_t) 0x0b050111)
///< This represents the ChildMoved attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWKFC_FAILURE ((attribute_store_type_t) 0x0b050112)
///< This represents the NWKFCFailure attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APSFC_FAILURE ((attribute_store_type_t) 0x0b050113)
///< This represents the APSFCFailure attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_UNAUTHORIZED_KEY ((attribute_store_type_t) 0x0b050114)
///< This represents the APSUnauthorizedKey attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_NWK_DECRYPT_FAILURES ((attribute_store_type_t) 0x0b050115)
///< This represents the NWKDecryptFailures attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_APS_DECRYPT_FAILURES ((attribute_store_type_t) 0x0b050116)
///< This represents the APSDecryptFailures attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_BUFFER_ALLOCATE_FAILURES ((attribute_store_type_t) 0x0b050117)
///< This represents the PacketBufferAllocateFailures attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_RELAYED_UCAST ((attribute_store_type_t) 0x0b050118)
///< This represents the RelayedUcast attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PHY_TOMAC_QUEUE_LIMIT_REACHED ((attribute_store_type_t) 0x0b050119)
///< This represents the PHYToMACQueueLimitReached attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_PACKET_VALIDATE_DROP_COUNT ((attribute_store_type_t) 0x0b05011a)
///< This represents the PacketValidateDropCount attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_AVERAGEMAC_RETRY_PERAPS_MESSAGE_SENT ((attribute_store_type_t) 0x0b05011b)
///< This represents the AverageMACRetryPerAPSMessageSent attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGELQI ((attribute_store_type_t) 0x0b05011c)
///< This represents the LastMessageLQI attribute in the DotDot Diagnostics cluster

#define DOTDOT_ATTRIBUTE_ID_DIAGNOSTICS_LAST_MESSAGERSSI ((attribute_store_type_t) 0x0b05011d)
///< This represents the LastMessageRSSI attribute in the DotDot Diagnostics cluster

// Diagnostics NumberOfResets
/**
 * @brief Verifies if the DotDot Diagnostics NumberOfResets is supported
 *
 * @returns true if NumberOfResets is supported
 * @returns false if NumberOfResets is not supported
 */
bool dotdot_is_supported_diagnostics_number_of_resets (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NumberOfResets attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NumberOfResets attribute
 */
uint16_t dotdot_get_diagnostics_number_of_resets(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NumberOfResets attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_number_of_resets new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_number_of_resets(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_number_of_resets);

// Diagnostics PersistentMemoryWrites
/**
 * @brief Verifies if the DotDot Diagnostics PersistentMemoryWrites is supported
 *
 * @returns true if PersistentMemoryWrites is supported
 * @returns false if PersistentMemoryWrites is not supported
 */
bool dotdot_is_supported_diagnostics_persistent_memory_writes (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PersistentMemoryWrites attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PersistentMemoryWrites attribute
 */
uint16_t dotdot_get_diagnostics_persistent_memory_writes(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PersistentMemoryWrites attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_persistent_memory_writes new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_persistent_memory_writes(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_persistent_memory_writes);

// Diagnostics MacRxBcast
/**
 * @brief Verifies if the DotDot Diagnostics MacRxBcast is supported
 *
 * @returns true if MacRxBcast is supported
 * @returns false if MacRxBcast is not supported
 */
bool dotdot_is_supported_diagnostics_mac_rx_bcast (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MacRxBcast attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MacRxBcast attribute
 */
uint32_t dotdot_get_diagnostics_mac_rx_bcast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MacRxBcast attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mac_rx_bcast new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_mac_rx_bcast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_mac_rx_bcast);

// Diagnostics MacTxBcast
/**
 * @brief Verifies if the DotDot Diagnostics MacTxBcast is supported
 *
 * @returns true if MacTxBcast is supported
 * @returns false if MacTxBcast is not supported
 */
bool dotdot_is_supported_diagnostics_mac_tx_bcast (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MacTxBcast attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MacTxBcast attribute
 */
uint32_t dotdot_get_diagnostics_mac_tx_bcast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MacTxBcast attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mac_tx_bcast new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_mac_tx_bcast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_mac_tx_bcast);

// Diagnostics MacRxUcast
/**
 * @brief Verifies if the DotDot Diagnostics MacRxUcast is supported
 *
 * @returns true if MacRxUcast is supported
 * @returns false if MacRxUcast is not supported
 */
bool dotdot_is_supported_diagnostics_mac_rx_ucast (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MacRxUcast attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MacRxUcast attribute
 */
uint32_t dotdot_get_diagnostics_mac_rx_ucast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MacRxUcast attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mac_rx_ucast new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_mac_rx_ucast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_mac_rx_ucast);

// Diagnostics MacTxUcast
/**
 * @brief Verifies if the DotDot Diagnostics MacTxUcast is supported
 *
 * @returns true if MacTxUcast is supported
 * @returns false if MacTxUcast is not supported
 */
bool dotdot_is_supported_diagnostics_mac_tx_ucast (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MacTxUcast attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MacTxUcast attribute
 */
uint32_t dotdot_get_diagnostics_mac_tx_ucast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MacTxUcast attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mac_tx_ucast new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_mac_tx_ucast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_mac_tx_ucast);

// Diagnostics MacTxUcastRetry
/**
 * @brief Verifies if the DotDot Diagnostics MacTxUcastRetry is supported
 *
 * @returns true if MacTxUcastRetry is supported
 * @returns false if MacTxUcastRetry is not supported
 */
bool dotdot_is_supported_diagnostics_mac_tx_ucast_retry (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MacTxUcastRetry attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MacTxUcastRetry attribute
 */
uint16_t dotdot_get_diagnostics_mac_tx_ucast_retry(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MacTxUcastRetry attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mac_tx_ucast_retry new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_mac_tx_ucast_retry(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_mac_tx_ucast_retry);

// Diagnostics MacTxUcastFail
/**
 * @brief Verifies if the DotDot Diagnostics MacTxUcastFail is supported
 *
 * @returns true if MacTxUcastFail is supported
 * @returns false if MacTxUcastFail is not supported
 */
bool dotdot_is_supported_diagnostics_mac_tx_ucast_fail (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MacTxUcastFail attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MacTxUcastFail attribute
 */
uint16_t dotdot_get_diagnostics_mac_tx_ucast_fail(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MacTxUcastFail attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mac_tx_ucast_fail new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_mac_tx_ucast_fail(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_mac_tx_ucast_fail);

// Diagnostics APSRxBcast
/**
 * @brief Verifies if the DotDot Diagnostics APSRxBcast is supported
 *
 * @returns true if APSRxBcast is supported
 * @returns false if APSRxBcast is not supported
 */
bool dotdot_is_supported_diagnostics_aps_rx_bcast (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot APSRxBcast attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns APSRxBcast attribute
 */
uint16_t dotdot_get_diagnostics_aps_rx_bcast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot APSRxBcast attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_aps_rx_bcast new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_aps_rx_bcast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_aps_rx_bcast);

// Diagnostics APSTxBcast
/**
 * @brief Verifies if the DotDot Diagnostics APSTxBcast is supported
 *
 * @returns true if APSTxBcast is supported
 * @returns false if APSTxBcast is not supported
 */
bool dotdot_is_supported_diagnostics_aps_tx_bcast (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot APSTxBcast attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns APSTxBcast attribute
 */
uint16_t dotdot_get_diagnostics_aps_tx_bcast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot APSTxBcast attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_aps_tx_bcast new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_aps_tx_bcast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_aps_tx_bcast);

// Diagnostics APSRxUcast
/**
 * @brief Verifies if the DotDot Diagnostics APSRxUcast is supported
 *
 * @returns true if APSRxUcast is supported
 * @returns false if APSRxUcast is not supported
 */
bool dotdot_is_supported_diagnostics_aps_rx_ucast (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot APSRxUcast attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns APSRxUcast attribute
 */
uint16_t dotdot_get_diagnostics_aps_rx_ucast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot APSRxUcast attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_aps_rx_ucast new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_aps_rx_ucast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_aps_rx_ucast);

// Diagnostics APSTxUcastSuccess
/**
 * @brief Verifies if the DotDot Diagnostics APSTxUcastSuccess is supported
 *
 * @returns true if APSTxUcastSuccess is supported
 * @returns false if APSTxUcastSuccess is not supported
 */
bool dotdot_is_supported_diagnostics_aps_tx_ucast_success (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot APSTxUcastSuccess attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns APSTxUcastSuccess attribute
 */
uint16_t dotdot_get_diagnostics_aps_tx_ucast_success(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot APSTxUcastSuccess attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_aps_tx_ucast_success new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_aps_tx_ucast_success(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_aps_tx_ucast_success);

// Diagnostics APSTxUcastRetry
/**
 * @brief Verifies if the DotDot Diagnostics APSTxUcastRetry is supported
 *
 * @returns true if APSTxUcastRetry is supported
 * @returns false if APSTxUcastRetry is not supported
 */
bool dotdot_is_supported_diagnostics_aps_tx_ucast_retry (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot APSTxUcastRetry attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns APSTxUcastRetry attribute
 */
uint16_t dotdot_get_diagnostics_aps_tx_ucast_retry(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot APSTxUcastRetry attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_aps_tx_ucast_retry new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_aps_tx_ucast_retry(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_aps_tx_ucast_retry);

// Diagnostics APSTxUcastFail
/**
 * @brief Verifies if the DotDot Diagnostics APSTxUcastFail is supported
 *
 * @returns true if APSTxUcastFail is supported
 * @returns false if APSTxUcastFail is not supported
 */
bool dotdot_is_supported_diagnostics_aps_tx_ucast_fail (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot APSTxUcastFail attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns APSTxUcastFail attribute
 */
uint16_t dotdot_get_diagnostics_aps_tx_ucast_fail(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot APSTxUcastFail attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_aps_tx_ucast_fail new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_aps_tx_ucast_fail(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_aps_tx_ucast_fail);

// Diagnostics RouteDiscInitiated
/**
 * @brief Verifies if the DotDot Diagnostics RouteDiscInitiated is supported
 *
 * @returns true if RouteDiscInitiated is supported
 * @returns false if RouteDiscInitiated is not supported
 */
bool dotdot_is_supported_diagnostics_route_disc_initiated (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RouteDiscInitiated attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RouteDiscInitiated attribute
 */
uint16_t dotdot_get_diagnostics_route_disc_initiated(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RouteDiscInitiated attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_route_disc_initiated new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_route_disc_initiated(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_route_disc_initiated);

// Diagnostics NeighborAdded
/**
 * @brief Verifies if the DotDot Diagnostics NeighborAdded is supported
 *
 * @returns true if NeighborAdded is supported
 * @returns false if NeighborAdded is not supported
 */
bool dotdot_is_supported_diagnostics_neighbor_added (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NeighborAdded attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NeighborAdded attribute
 */
uint16_t dotdot_get_diagnostics_neighbor_added(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NeighborAdded attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_neighbor_added new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_neighbor_added(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_neighbor_added);

// Diagnostics NeighborRemoved
/**
 * @brief Verifies if the DotDot Diagnostics NeighborRemoved is supported
 *
 * @returns true if NeighborRemoved is supported
 * @returns false if NeighborRemoved is not supported
 */
bool dotdot_is_supported_diagnostics_neighbor_removed (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NeighborRemoved attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NeighborRemoved attribute
 */
uint16_t dotdot_get_diagnostics_neighbor_removed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NeighborRemoved attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_neighbor_removed new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_neighbor_removed(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_neighbor_removed);

// Diagnostics NeighborStale
/**
 * @brief Verifies if the DotDot Diagnostics NeighborStale is supported
 *
 * @returns true if NeighborStale is supported
 * @returns false if NeighborStale is not supported
 */
bool dotdot_is_supported_diagnostics_neighbor_stale (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NeighborStale attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NeighborStale attribute
 */
uint16_t dotdot_get_diagnostics_neighbor_stale(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NeighborStale attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_neighbor_stale new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_neighbor_stale(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_neighbor_stale);

// Diagnostics JoinIndication
/**
 * @brief Verifies if the DotDot Diagnostics JoinIndication is supported
 *
 * @returns true if JoinIndication is supported
 * @returns false if JoinIndication is not supported
 */
bool dotdot_is_supported_diagnostics_join_indication (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot JoinIndication attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns JoinIndication attribute
 */
uint16_t dotdot_get_diagnostics_join_indication(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot JoinIndication attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_join_indication new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_join_indication(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_join_indication);

// Diagnostics ChildMoved
/**
 * @brief Verifies if the DotDot Diagnostics ChildMoved is supported
 *
 * @returns true if ChildMoved is supported
 * @returns false if ChildMoved is not supported
 */
bool dotdot_is_supported_diagnostics_child_moved (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ChildMoved attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ChildMoved attribute
 */
uint16_t dotdot_get_diagnostics_child_moved(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ChildMoved attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_child_moved new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_child_moved(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_child_moved);

// Diagnostics NWKFCFailure
/**
 * @brief Verifies if the DotDot Diagnostics NWKFCFailure is supported
 *
 * @returns true if NWKFCFailure is supported
 * @returns false if NWKFCFailure is not supported
 */
bool dotdot_is_supported_diagnostics_nwkfc_failure (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NWKFCFailure attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NWKFCFailure attribute
 */
uint16_t dotdot_get_diagnostics_nwkfc_failure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NWKFCFailure attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_nwkfc_failure new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_nwkfc_failure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_nwkfc_failure);

// Diagnostics APSFCFailure
/**
 * @brief Verifies if the DotDot Diagnostics APSFCFailure is supported
 *
 * @returns true if APSFCFailure is supported
 * @returns false if APSFCFailure is not supported
 */
bool dotdot_is_supported_diagnostics_apsfc_failure (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot APSFCFailure attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns APSFCFailure attribute
 */
uint16_t dotdot_get_diagnostics_apsfc_failure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot APSFCFailure attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_apsfc_failure new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_apsfc_failure(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_apsfc_failure);

// Diagnostics APSUnauthorizedKey
/**
 * @brief Verifies if the DotDot Diagnostics APSUnauthorizedKey is supported
 *
 * @returns true if APSUnauthorizedKey is supported
 * @returns false if APSUnauthorizedKey is not supported
 */
bool dotdot_is_supported_diagnostics_aps_unauthorized_key (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot APSUnauthorizedKey attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns APSUnauthorizedKey attribute
 */
uint16_t dotdot_get_diagnostics_aps_unauthorized_key(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot APSUnauthorizedKey attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_aps_unauthorized_key new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_aps_unauthorized_key(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_aps_unauthorized_key);

// Diagnostics NWKDecryptFailures
/**
 * @brief Verifies if the DotDot Diagnostics NWKDecryptFailures is supported
 *
 * @returns true if NWKDecryptFailures is supported
 * @returns false if NWKDecryptFailures is not supported
 */
bool dotdot_is_supported_diagnostics_nwk_decrypt_failures (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NWKDecryptFailures attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NWKDecryptFailures attribute
 */
uint16_t dotdot_get_diagnostics_nwk_decrypt_failures(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NWKDecryptFailures attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_nwk_decrypt_failures new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_nwk_decrypt_failures(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_nwk_decrypt_failures);

// Diagnostics APSDecryptFailures
/**
 * @brief Verifies if the DotDot Diagnostics APSDecryptFailures is supported
 *
 * @returns true if APSDecryptFailures is supported
 * @returns false if APSDecryptFailures is not supported
 */
bool dotdot_is_supported_diagnostics_aps_decrypt_failures (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot APSDecryptFailures attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns APSDecryptFailures attribute
 */
uint16_t dotdot_get_diagnostics_aps_decrypt_failures(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot APSDecryptFailures attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_aps_decrypt_failures new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_aps_decrypt_failures(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_aps_decrypt_failures);

// Diagnostics PacketBufferAllocateFailures
/**
 * @brief Verifies if the DotDot Diagnostics PacketBufferAllocateFailures is supported
 *
 * @returns true if PacketBufferAllocateFailures is supported
 * @returns false if PacketBufferAllocateFailures is not supported
 */
bool dotdot_is_supported_diagnostics_packet_buffer_allocate_failures (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PacketBufferAllocateFailures attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PacketBufferAllocateFailures attribute
 */
uint16_t dotdot_get_diagnostics_packet_buffer_allocate_failures(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PacketBufferAllocateFailures attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_packet_buffer_allocate_failures new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_packet_buffer_allocate_failures(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_packet_buffer_allocate_failures);

// Diagnostics RelayedUcast
/**
 * @brief Verifies if the DotDot Diagnostics RelayedUcast is supported
 *
 * @returns true if RelayedUcast is supported
 * @returns false if RelayedUcast is not supported
 */
bool dotdot_is_supported_diagnostics_relayed_ucast (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RelayedUcast attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RelayedUcast attribute
 */
uint16_t dotdot_get_diagnostics_relayed_ucast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RelayedUcast attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_relayed_ucast new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_relayed_ucast(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_relayed_ucast);

// Diagnostics PHYToMACQueueLimitReached
/**
 * @brief Verifies if the DotDot Diagnostics PHYToMACQueueLimitReached is supported
 *
 * @returns true if PHYToMACQueueLimitReached is supported
 * @returns false if PHYToMACQueueLimitReached is not supported
 */
bool dotdot_is_supported_diagnostics_phy_tomac_queue_limit_reached (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PHYToMACQueueLimitReached attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PHYToMACQueueLimitReached attribute
 */
uint16_t dotdot_get_diagnostics_phy_tomac_queue_limit_reached(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PHYToMACQueueLimitReached attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_phy_tomac_queue_limit_reached new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_phy_tomac_queue_limit_reached(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_phy_tomac_queue_limit_reached);

// Diagnostics PacketValidateDropCount
/**
 * @brief Verifies if the DotDot Diagnostics PacketValidateDropCount is supported
 *
 * @returns true if PacketValidateDropCount is supported
 * @returns false if PacketValidateDropCount is not supported
 */
bool dotdot_is_supported_diagnostics_packet_validate_drop_count (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PacketValidateDropCount attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PacketValidateDropCount attribute
 */
uint16_t dotdot_get_diagnostics_packet_validate_drop_count(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PacketValidateDropCount attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_packet_validate_drop_count new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_packet_validate_drop_count(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_packet_validate_drop_count);

// Diagnostics AverageMACRetryPerAPSMessageSent
/**
 * @brief Verifies if the DotDot Diagnostics AverageMACRetryPerAPSMessageSent is supported
 *
 * @returns true if AverageMACRetryPerAPSMessageSent is supported
 * @returns false if AverageMACRetryPerAPSMessageSent is not supported
 */
bool dotdot_is_supported_diagnostics_averagemac_retry_peraps_message_sent (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageMACRetryPerAPSMessageSent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageMACRetryPerAPSMessageSent attribute
 */
uint16_t dotdot_get_diagnostics_averagemac_retry_peraps_message_sent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageMACRetryPerAPSMessageSent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_averagemac_retry_peraps_message_sent new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_averagemac_retry_peraps_message_sent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint16_t new_averagemac_retry_peraps_message_sent);

// Diagnostics LastMessageLQI
/**
 * @brief Verifies if the DotDot Diagnostics LastMessageLQI is supported
 *
 * @returns true if LastMessageLQI is supported
 * @returns false if LastMessageLQI is not supported
 */
bool dotdot_is_supported_diagnostics_last_messagelqi (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LastMessageLQI attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LastMessageLQI attribute
 */
uint8_t dotdot_get_diagnostics_last_messagelqi(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LastMessageLQI attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_last_messagelqi new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_last_messagelqi(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_last_messagelqi);

// Diagnostics LastMessageRSSI
/**
 * @brief Verifies if the DotDot Diagnostics LastMessageRSSI is supported
 *
 * @returns true if LastMessageRSSI is supported
 * @returns false if LastMessageRSSI is not supported
 */
bool dotdot_is_supported_diagnostics_last_messagerssi (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot LastMessageRSSI attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns LastMessageRSSI attribute
 */
int8_t dotdot_get_diagnostics_last_messagerssi(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot LastMessageRSSI attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_last_messagerssi new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_diagnostics_last_messagerssi(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_last_messagerssi);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster ProtocolController-RFTelemetry
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for ProtocolController-RFTelemetry
#define DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_TX_REPORT_ENABLED ((attribute_store_type_t) 0xfd010000)
///< This represents the TxReportEnabled attribute in the DotDot ProtocolController-RFTelemetry cluster

#define DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_RF_TELEMETRY_PTI_ENABLED ((attribute_store_type_t) 0xfd010001)
///< This represents the PTIEnabled attribute in the DotDot ProtocolController-RFTelemetry cluster

// ProtocolController-RFTelemetry TxReportEnabled
/**
 * @brief Verifies if the DotDot ProtocolController-RFTelemetry TxReportEnabled is supported
 *
 * @returns true if TxReportEnabled is supported
 * @returns false if TxReportEnabled is not supported
 */
bool dotdot_is_supported_protocol_controller_rf_telemetry_tx_report_enabled (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot TxReportEnabled attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns TxReportEnabled attribute
 */
bool dotdot_get_protocol_controller_rf_telemetry_tx_report_enabled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot TxReportEnabled attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_tx_report_enabled new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_protocol_controller_rf_telemetry_tx_report_enabled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_tx_report_enabled);

// ProtocolController-RFTelemetry PTIEnabled
/**
 * @brief Verifies if the DotDot ProtocolController-RFTelemetry PTIEnabled is supported
 *
 * @returns true if PTIEnabled is supported
 * @returns false if PTIEnabled is not supported
 */
bool dotdot_is_supported_protocol_controller_rf_telemetry_pti_enabled (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PTIEnabled attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PTIEnabled attribute
 */
bool dotdot_get_protocol_controller_rf_telemetry_pti_enabled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PTIEnabled attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_pti_enabled new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_protocol_controller_rf_telemetry_pti_enabled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_pti_enabled);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster State
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for State
#define DOTDOT_ATTRIBUTE_ID_STATE_ENDPOINT_ID_LIST ((attribute_store_type_t) 0xfd020000)
///< This represents the EndpointIdList attribute in the DotDot State cluster

// State EndpointIdList
/**
 * @brief Verifies if the DotDot State EndpointIdList is supported
 *
 * @returns true if EndpointIdList is supported
 * @returns false if EndpointIdList is not supported
 */
bool dotdot_is_supported_state_endpoint_id_list (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot EndpointIdList attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns EndpointIdList attribute
 */
uint8_t dotdot_get_state_endpoint_id_list(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot EndpointIdList attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_endpoint_id_list new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_state_endpoint_id_list(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_endpoint_id_list);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster Binding
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for Binding
#define DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE_FULL ((attribute_store_type_t) 0xfd030000)
///< This represents the BindingTableFull attribute in the DotDot Binding cluster

#define DOTDOT_ATTRIBUTE_ID_BINDING_BINDABLE_CLUSTER_LIST ((attribute_store_type_t) 0xfd030001)
///< This represents the BindableClusterList attribute in the DotDot Binding cluster

#define DOTDOT_ATTRIBUTE_ID_BINDING_BINDING_TABLE ((attribute_store_type_t) 0xfd030002)
///< This represents the BindingTable attribute in the DotDot Binding cluster

// Binding BindingTableFull
/**
 * @brief Verifies if the DotDot Binding BindingTableFull is supported
 *
 * @returns true if BindingTableFull is supported
 * @returns false if BindingTableFull is not supported
 */
bool dotdot_is_supported_binding_binding_table_full (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BindingTableFull attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BindingTableFull attribute
 */
bool dotdot_get_binding_binding_table_full(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BindingTableFull attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_binding_table_full new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_binding_binding_table_full(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_binding_table_full);

// Binding BindableClusterList
/**
 * @brief Verifies if the DotDot Binding BindableClusterList is supported
 *
 * @returns true if BindableClusterList is supported
 * @returns false if BindableClusterList is not supported
 */
bool dotdot_is_supported_binding_bindable_cluster_list (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BindableClusterList attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BindableClusterList attribute
 */
const char* dotdot_get_binding_bindable_cluster_list(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BindableClusterList attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_bindable_cluster_list new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_binding_bindable_cluster_list(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_bindable_cluster_list);

// Binding BindingTable
/**
 * @brief Verifies if the DotDot Binding BindingTable is supported
 *
 * @returns true if BindingTable is supported
 * @returns false if BindingTable is not supported
 */
bool dotdot_is_supported_binding_binding_table (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BindingTable attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BindingTable attribute
 */
BindingObject dotdot_get_binding_binding_table(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BindingTable attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_binding_table new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_binding_binding_table(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  BindingObject new_binding_table);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster SystemMetrics
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for SystemMetrics
#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_REPORTING_INTERVAL_SECONDS ((attribute_store_type_t) 0xfd040000)
///< This represents the ReportingIntervalSeconds attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_USAGE_PERCENT ((attribute_store_type_t) 0xfd040010)
///< This represents the CPUUsagePercent attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_FREQUENCYM_HZ ((attribute_store_type_t) 0xfd040011)
///< This represents the CPUFrequencyMHz attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_AVERAGE_USAGE_PERCENT ((attribute_store_type_t) 0xfd040012)
///< This represents the CPUAverageUsagePercent attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MIN_USAGE_PERCENT ((attribute_store_type_t) 0xfd040013)
///< This represents the CPUMinUsagePercent attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CPU_MAX_USAGE_PERCENT ((attribute_store_type_t) 0xfd040014)
///< This represents the CPUMaxUsagePercent attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_TOTALMB ((attribute_store_type_t) 0xfd040020)
///< This represents the RAMTotalMB attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_FREEMB ((attribute_store_type_t) 0xfd040021)
///< This represents the RAMFreeMB attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_RAM_AVAILABLEMB ((attribute_store_type_t) 0xfd040022)
///< This represents the RAMAvailableMB attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_TOTALMB ((attribute_store_type_t) 0xfd040023)
///< This represents the SWAPMemoryTotalMB attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SWAP_MEMORY_USEDMB ((attribute_store_type_t) 0xfd040024)
///< This represents the SWAPMemoryUsedMB attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_TOTALMB ((attribute_store_type_t) 0xfd040025)
///< This represents the VirtualMemoryTotalMB attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_VIRTUAL_MEMORY_USEDMB ((attribute_store_type_t) 0xfd040026)
///< This represents the VirtualMemoryUsedMB attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_USAGE ((attribute_store_type_t) 0xfd040027)
///< This represents the DisksUsage attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_DISKS_COUNTERS ((attribute_store_type_t) 0xfd040028)
///< This represents the DisksCounters attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_NETWORK_INTERFACES_DATA ((attribute_store_type_t) 0xfd040030)
///< This represents the NetworkInterfacesData attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_WIRELESS_NETWORK_INTERFACES_DATA ((attribute_store_type_t) 0xfd040031)
///< This represents the WirelessNetworkInterfacesData attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_HOSTNAME ((attribute_store_type_t) 0xfd040032)
///< This represents the Hostname attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_FQDN ((attribute_store_type_t) 0xfd040033)
///< This represents the FQDN attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_UPTIME_MINUTES ((attribute_store_type_t) 0xfd040040)
///< This represents the UptimeMinutes attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_CURRENT_TEMPERATURE_CELCIUS ((attribute_store_type_t) 0xfd040050)
///< This represents the CurrentTemperatureCelcius attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_AVERAGE_TEMPERATURE_CELCIUS ((attribute_store_type_t) 0xfd040051)
///< This represents the AverageTemperatureCelcius attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MIN_TEMPERATURE_CELCIUS ((attribute_store_type_t) 0xfd040052)
///< This represents the MinTemperatureCelcius attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_MAX_TEMPERATURE_CELCIUS ((attribute_store_type_t) 0xfd040053)
///< This represents the MaxTemperatureCelcius attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_POWER_PLUGGED ((attribute_store_type_t) 0xfd040060)
///< This represents the PowerPlugged attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_BATTERY_PERCENTAGE ((attribute_store_type_t) 0xfd040061)
///< This represents the BatteryPercentage attribute in the DotDot SystemMetrics cluster

#define DOTDOT_ATTRIBUTE_ID_SYSTEM_METRICS_SYSTEM_INTERRUPTS ((attribute_store_type_t) 0xfd040070)
///< This represents the SystemInterrupts attribute in the DotDot SystemMetrics cluster

// SystemMetrics ReportingIntervalSeconds
/**
 * @brief Verifies if the DotDot SystemMetrics ReportingIntervalSeconds is supported
 *
 * @returns true if ReportingIntervalSeconds is supported
 * @returns false if ReportingIntervalSeconds is not supported
 */
bool dotdot_is_supported_system_metrics_reporting_interval_seconds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ReportingIntervalSeconds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ReportingIntervalSeconds attribute
 */
uint32_t dotdot_get_system_metrics_reporting_interval_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ReportingIntervalSeconds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_reporting_interval_seconds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_reporting_interval_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_reporting_interval_seconds);

// SystemMetrics CPUUsagePercent
/**
 * @brief Verifies if the DotDot SystemMetrics CPUUsagePercent is supported
 *
 * @returns true if CPUUsagePercent is supported
 * @returns false if CPUUsagePercent is not supported
 */
bool dotdot_is_supported_system_metrics_cpu_usage_percent (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CPUUsagePercent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CPUUsagePercent attribute
 */
double dotdot_get_system_metrics_cpu_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CPUUsagePercent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_cpu_usage_percent new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_cpu_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_cpu_usage_percent);

// SystemMetrics CPUFrequencyMHz
/**
 * @brief Verifies if the DotDot SystemMetrics CPUFrequencyMHz is supported
 *
 * @returns true if CPUFrequencyMHz is supported
 * @returns false if CPUFrequencyMHz is not supported
 */
bool dotdot_is_supported_system_metrics_cpu_frequencym_hz (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CPUFrequencyMHz attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CPUFrequencyMHz attribute
 */
double dotdot_get_system_metrics_cpu_frequencym_hz(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CPUFrequencyMHz attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_cpu_frequencym_hz new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_cpu_frequencym_hz(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_cpu_frequencym_hz);

// SystemMetrics CPUAverageUsagePercent
/**
 * @brief Verifies if the DotDot SystemMetrics CPUAverageUsagePercent is supported
 *
 * @returns true if CPUAverageUsagePercent is supported
 * @returns false if CPUAverageUsagePercent is not supported
 */
bool dotdot_is_supported_system_metrics_cpu_average_usage_percent (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CPUAverageUsagePercent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CPUAverageUsagePercent attribute
 */
double dotdot_get_system_metrics_cpu_average_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CPUAverageUsagePercent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_cpu_average_usage_percent new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_cpu_average_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_cpu_average_usage_percent);

// SystemMetrics CPUMinUsagePercent
/**
 * @brief Verifies if the DotDot SystemMetrics CPUMinUsagePercent is supported
 *
 * @returns true if CPUMinUsagePercent is supported
 * @returns false if CPUMinUsagePercent is not supported
 */
bool dotdot_is_supported_system_metrics_cpu_min_usage_percent (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CPUMinUsagePercent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CPUMinUsagePercent attribute
 */
double dotdot_get_system_metrics_cpu_min_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CPUMinUsagePercent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_cpu_min_usage_percent new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_cpu_min_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_cpu_min_usage_percent);

// SystemMetrics CPUMaxUsagePercent
/**
 * @brief Verifies if the DotDot SystemMetrics CPUMaxUsagePercent is supported
 *
 * @returns true if CPUMaxUsagePercent is supported
 * @returns false if CPUMaxUsagePercent is not supported
 */
bool dotdot_is_supported_system_metrics_cpu_max_usage_percent (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CPUMaxUsagePercent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CPUMaxUsagePercent attribute
 */
double dotdot_get_system_metrics_cpu_max_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CPUMaxUsagePercent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_cpu_max_usage_percent new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_cpu_max_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_cpu_max_usage_percent);

// SystemMetrics RAMTotalMB
/**
 * @brief Verifies if the DotDot SystemMetrics RAMTotalMB is supported
 *
 * @returns true if RAMTotalMB is supported
 * @returns false if RAMTotalMB is not supported
 */
bool dotdot_is_supported_system_metrics_ram_totalmb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RAMTotalMB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RAMTotalMB attribute
 */
double dotdot_get_system_metrics_ram_totalmb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RAMTotalMB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ram_totalmb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_ram_totalmb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_ram_totalmb);

// SystemMetrics RAMFreeMB
/**
 * @brief Verifies if the DotDot SystemMetrics RAMFreeMB is supported
 *
 * @returns true if RAMFreeMB is supported
 * @returns false if RAMFreeMB is not supported
 */
bool dotdot_is_supported_system_metrics_ram_freemb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RAMFreeMB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RAMFreeMB attribute
 */
double dotdot_get_system_metrics_ram_freemb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RAMFreeMB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ram_freemb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_ram_freemb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_ram_freemb);

// SystemMetrics RAMAvailableMB
/**
 * @brief Verifies if the DotDot SystemMetrics RAMAvailableMB is supported
 *
 * @returns true if RAMAvailableMB is supported
 * @returns false if RAMAvailableMB is not supported
 */
bool dotdot_is_supported_system_metrics_ram_availablemb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot RAMAvailableMB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns RAMAvailableMB attribute
 */
double dotdot_get_system_metrics_ram_availablemb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot RAMAvailableMB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_ram_availablemb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_ram_availablemb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_ram_availablemb);

// SystemMetrics SWAPMemoryTotalMB
/**
 * @brief Verifies if the DotDot SystemMetrics SWAPMemoryTotalMB is supported
 *
 * @returns true if SWAPMemoryTotalMB is supported
 * @returns false if SWAPMemoryTotalMB is not supported
 */
bool dotdot_is_supported_system_metrics_swap_memory_totalmb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SWAPMemoryTotalMB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SWAPMemoryTotalMB attribute
 */
double dotdot_get_system_metrics_swap_memory_totalmb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SWAPMemoryTotalMB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_swap_memory_totalmb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_swap_memory_totalmb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_swap_memory_totalmb);

// SystemMetrics SWAPMemoryUsedMB
/**
 * @brief Verifies if the DotDot SystemMetrics SWAPMemoryUsedMB is supported
 *
 * @returns true if SWAPMemoryUsedMB is supported
 * @returns false if SWAPMemoryUsedMB is not supported
 */
bool dotdot_is_supported_system_metrics_swap_memory_usedmb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SWAPMemoryUsedMB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SWAPMemoryUsedMB attribute
 */
double dotdot_get_system_metrics_swap_memory_usedmb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SWAPMemoryUsedMB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_swap_memory_usedmb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_swap_memory_usedmb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_swap_memory_usedmb);

// SystemMetrics VirtualMemoryTotalMB
/**
 * @brief Verifies if the DotDot SystemMetrics VirtualMemoryTotalMB is supported
 *
 * @returns true if VirtualMemoryTotalMB is supported
 * @returns false if VirtualMemoryTotalMB is not supported
 */
bool dotdot_is_supported_system_metrics_virtual_memory_totalmb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot VirtualMemoryTotalMB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns VirtualMemoryTotalMB attribute
 */
double dotdot_get_system_metrics_virtual_memory_totalmb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot VirtualMemoryTotalMB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_virtual_memory_totalmb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_virtual_memory_totalmb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_virtual_memory_totalmb);

// SystemMetrics VirtualMemoryUsedMB
/**
 * @brief Verifies if the DotDot SystemMetrics VirtualMemoryUsedMB is supported
 *
 * @returns true if VirtualMemoryUsedMB is supported
 * @returns false if VirtualMemoryUsedMB is not supported
 */
bool dotdot_is_supported_system_metrics_virtual_memory_usedmb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot VirtualMemoryUsedMB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns VirtualMemoryUsedMB attribute
 */
double dotdot_get_system_metrics_virtual_memory_usedmb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot VirtualMemoryUsedMB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_virtual_memory_usedmb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_virtual_memory_usedmb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_virtual_memory_usedmb);

// SystemMetrics DisksUsage
/**
 * @brief Verifies if the DotDot SystemMetrics DisksUsage is supported
 *
 * @returns true if DisksUsage is supported
 * @returns false if DisksUsage is not supported
 */
bool dotdot_is_supported_system_metrics_disks_usage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DisksUsage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DisksUsage attribute
 */
DiskUsageData dotdot_get_system_metrics_disks_usage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DisksUsage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_disks_usage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_disks_usage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  DiskUsageData new_disks_usage);

// SystemMetrics DisksCounters
/**
 * @brief Verifies if the DotDot SystemMetrics DisksCounters is supported
 *
 * @returns true if DisksCounters is supported
 * @returns false if DisksCounters is not supported
 */
bool dotdot_is_supported_system_metrics_disks_counters (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot DisksCounters attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns DisksCounters attribute
 */
DiskIOCounters dotdot_get_system_metrics_disks_counters(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot DisksCounters attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_disks_counters new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_disks_counters(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  DiskIOCounters new_disks_counters);

// SystemMetrics NetworkInterfacesData
/**
 * @brief Verifies if the DotDot SystemMetrics NetworkInterfacesData is supported
 *
 * @returns true if NetworkInterfacesData is supported
 * @returns false if NetworkInterfacesData is not supported
 */
bool dotdot_is_supported_system_metrics_network_interfaces_data (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NetworkInterfacesData attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NetworkInterfacesData attribute
 */
NetworkInterfaceData dotdot_get_system_metrics_network_interfaces_data(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NetworkInterfacesData attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_network_interfaces_data new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_network_interfaces_data(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  NetworkInterfaceData new_network_interfaces_data);

// SystemMetrics WirelessNetworkInterfacesData
/**
 * @brief Verifies if the DotDot SystemMetrics WirelessNetworkInterfacesData is supported
 *
 * @returns true if WirelessNetworkInterfacesData is supported
 * @returns false if WirelessNetworkInterfacesData is not supported
 */
bool dotdot_is_supported_system_metrics_wireless_network_interfaces_data (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot WirelessNetworkInterfacesData attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns WirelessNetworkInterfacesData attribute
 */
WirelessNetworkInterfaceData dotdot_get_system_metrics_wireless_network_interfaces_data(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot WirelessNetworkInterfacesData attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_wireless_network_interfaces_data new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_wireless_network_interfaces_data(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  WirelessNetworkInterfaceData new_wireless_network_interfaces_data);

// SystemMetrics Hostname
/**
 * @brief Verifies if the DotDot SystemMetrics Hostname is supported
 *
 * @returns true if Hostname is supported
 * @returns false if Hostname is not supported
 */
bool dotdot_is_supported_system_metrics_hostname (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Hostname attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Hostname attribute
 */
const char* dotdot_get_system_metrics_hostname(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Hostname attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_hostname new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_hostname(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_hostname);

// SystemMetrics FQDN
/**
 * @brief Verifies if the DotDot SystemMetrics FQDN is supported
 *
 * @returns true if FQDN is supported
 * @returns false if FQDN is not supported
 */
bool dotdot_is_supported_system_metrics_fqdn (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot FQDN attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns FQDN attribute
 */
const char* dotdot_get_system_metrics_fqdn(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot FQDN attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_fqdn new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_fqdn(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_fqdn);

// SystemMetrics UptimeMinutes
/**
 * @brief Verifies if the DotDot SystemMetrics UptimeMinutes is supported
 *
 * @returns true if UptimeMinutes is supported
 * @returns false if UptimeMinutes is not supported
 */
bool dotdot_is_supported_system_metrics_uptime_minutes (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UptimeMinutes attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UptimeMinutes attribute
 */
uint64_t dotdot_get_system_metrics_uptime_minutes(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UptimeMinutes attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_uptime_minutes new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_uptime_minutes(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_uptime_minutes);

// SystemMetrics CurrentTemperatureCelcius
/**
 * @brief Verifies if the DotDot SystemMetrics CurrentTemperatureCelcius is supported
 *
 * @returns true if CurrentTemperatureCelcius is supported
 * @returns false if CurrentTemperatureCelcius is not supported
 */
bool dotdot_is_supported_system_metrics_current_temperature_celcius (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CurrentTemperatureCelcius attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CurrentTemperatureCelcius attribute
 */
double dotdot_get_system_metrics_current_temperature_celcius(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CurrentTemperatureCelcius attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_current_temperature_celcius new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_current_temperature_celcius(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_current_temperature_celcius);

// SystemMetrics AverageTemperatureCelcius
/**
 * @brief Verifies if the DotDot SystemMetrics AverageTemperatureCelcius is supported
 *
 * @returns true if AverageTemperatureCelcius is supported
 * @returns false if AverageTemperatureCelcius is not supported
 */
bool dotdot_is_supported_system_metrics_average_temperature_celcius (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AverageTemperatureCelcius attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AverageTemperatureCelcius attribute
 */
double dotdot_get_system_metrics_average_temperature_celcius(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AverageTemperatureCelcius attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_average_temperature_celcius new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_average_temperature_celcius(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_average_temperature_celcius);

// SystemMetrics MinTemperatureCelcius
/**
 * @brief Verifies if the DotDot SystemMetrics MinTemperatureCelcius is supported
 *
 * @returns true if MinTemperatureCelcius is supported
 * @returns false if MinTemperatureCelcius is not supported
 */
bool dotdot_is_supported_system_metrics_min_temperature_celcius (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MinTemperatureCelcius attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MinTemperatureCelcius attribute
 */
double dotdot_get_system_metrics_min_temperature_celcius(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MinTemperatureCelcius attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_min_temperature_celcius new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_min_temperature_celcius(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_min_temperature_celcius);

// SystemMetrics MaxTemperatureCelcius
/**
 * @brief Verifies if the DotDot SystemMetrics MaxTemperatureCelcius is supported
 *
 * @returns true if MaxTemperatureCelcius is supported
 * @returns false if MaxTemperatureCelcius is not supported
 */
bool dotdot_is_supported_system_metrics_max_temperature_celcius (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MaxTemperatureCelcius attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MaxTemperatureCelcius attribute
 */
double dotdot_get_system_metrics_max_temperature_celcius(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MaxTemperatureCelcius attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_max_temperature_celcius new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_max_temperature_celcius(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_max_temperature_celcius);

// SystemMetrics PowerPlugged
/**
 * @brief Verifies if the DotDot SystemMetrics PowerPlugged is supported
 *
 * @returns true if PowerPlugged is supported
 * @returns false if PowerPlugged is not supported
 */
bool dotdot_is_supported_system_metrics_power_plugged (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PowerPlugged attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PowerPlugged attribute
 */
bool dotdot_get_system_metrics_power_plugged(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PowerPlugged attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_power_plugged new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_power_plugged(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_power_plugged);

// SystemMetrics BatteryPercentage
/**
 * @brief Verifies if the DotDot SystemMetrics BatteryPercentage is supported
 *
 * @returns true if BatteryPercentage is supported
 * @returns false if BatteryPercentage is not supported
 */
bool dotdot_is_supported_system_metrics_battery_percentage (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot BatteryPercentage attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns BatteryPercentage attribute
 */
double dotdot_get_system_metrics_battery_percentage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot BatteryPercentage attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_battery_percentage new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_battery_percentage(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_battery_percentage);

// SystemMetrics SystemInterrupts
/**
 * @brief Verifies if the DotDot SystemMetrics SystemInterrupts is supported
 *
 * @returns true if SystemInterrupts is supported
 * @returns false if SystemInterrupts is not supported
 */
bool dotdot_is_supported_system_metrics_system_interrupts (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SystemInterrupts attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SystemInterrupts attribute
 */
uint64_t dotdot_get_system_metrics_system_interrupts(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SystemInterrupts attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_system_interrupts new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_system_metrics_system_interrupts(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_system_interrupts);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster ApplicationMonitoring
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for ApplicationMonitoring
#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_NAME ((attribute_store_type_t) 0xfd050000)
///< This represents the ApplicationName attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_VERSION ((attribute_store_type_t) 0xfd050001)
///< This represents the ApplicationVersion attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_CONNECTED ((attribute_store_type_t) 0xfd050002)
///< This represents the ApplicationConnected attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONMQTT_TOPICS ((attribute_store_type_t) 0xfd050005)
///< This represents the ApplicationMQTTTopics attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_UPTIME_MINUTES ((attribute_store_type_t) 0xfd050010)
///< This represents the UptimeMinutes attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_PROCESS_ID ((attribute_store_type_t) 0xfd050011)
///< This represents the ProcessId attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_HOSTNAME ((attribute_store_type_t) 0xfd050012)
///< This represents the Hostname attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_FQDN ((attribute_store_type_t) 0xfd050013)
///< This represents the FQDN attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_ENABLED ((attribute_store_type_t) 0xfd050021)
///< This represents the MQTTLoggingEnabled attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_LOGGING_LEVEL ((attribute_store_type_t) 0xfd050022)
///< This represents the MQTTLoggingLevel attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_STATISTICS_REPORTING_INTERVAL_SECONDS ((attribute_store_type_t) 0xfd050030)
///< This represents the MQTTStatisticsReportingIntervalSeconds attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_SENT ((attribute_store_type_t) 0xfd050031)
///< This represents the MQTTMessagesSent attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MESSAGES_RECEIVED ((attribute_store_type_t) 0xfd050032)
///< This represents the MQTTMessagesReceived attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_SUBSCRIPTION_COUNT ((attribute_store_type_t) 0xfd050033)
///< This represents the MQTTSubscriptionCount attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_AVERAGE_DELIVERY_TIME_SECONDS ((attribute_store_type_t) 0xfd050034)
///< This represents the MQTTAverageDeliveryTimeSeconds attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MIN_DELIVERY_TIME_SECONDS ((attribute_store_type_t) 0xfd050035)
///< This represents the MQTTMinDeliveryTimeSeconds attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_MQTT_MAX_DELIVERY_TIME_SECONDS ((attribute_store_type_t) 0xfd050036)
///< This represents the MQTTMaxDeliveryTimeSeconds attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATION_STATISTICS_REPORTING_INTERVAL_SECONDS ((attribute_store_type_t) 0xfd050040)
///< This represents the ApplicationStatisticsReportingIntervalSeconds attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_USAGE_PERCENT ((attribute_store_type_t) 0xfd050041)
///< This represents the ApplicationCPUUsagePercent attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_AVERAGE_USAGE_PERCENT ((attribute_store_type_t) 0xfd050042)
///< This represents the ApplicationCPUAverageUsagePercent attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MIN_USAGE_PERCENT ((attribute_store_type_t) 0xfd050043)
///< This represents the ApplicationCPUMinUsagePercent attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONCPU_MAX_USAGE_PERCENT ((attribute_store_type_t) 0xfd050044)
///< This represents the ApplicationCPUMaxUsagePercent attribute in the DotDot ApplicationMonitoring cluster

#define DOTDOT_ATTRIBUTE_ID_APPLICATION_MONITORING_APPLICATIONRAM_USAGEMB ((attribute_store_type_t) 0xfd050045)
///< This represents the ApplicationRAMUsageMB attribute in the DotDot ApplicationMonitoring cluster

// ApplicationMonitoring ApplicationName
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ApplicationName is supported
 *
 * @returns true if ApplicationName is supported
 * @returns false if ApplicationName is not supported
 */
bool dotdot_is_supported_application_monitoring_application_name (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationName attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationName attribute
 */
const char* dotdot_get_application_monitoring_application_name(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationName attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_application_name new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_application_name(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_application_name);

// ApplicationMonitoring ApplicationVersion
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ApplicationVersion is supported
 *
 * @returns true if ApplicationVersion is supported
 * @returns false if ApplicationVersion is not supported
 */
bool dotdot_is_supported_application_monitoring_application_version (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationVersion attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationVersion attribute
 */
const char* dotdot_get_application_monitoring_application_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationVersion attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_application_version new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_application_version(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_application_version);

// ApplicationMonitoring ApplicationConnected
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ApplicationConnected is supported
 *
 * @returns true if ApplicationConnected is supported
 * @returns false if ApplicationConnected is not supported
 */
bool dotdot_is_supported_application_monitoring_application_connected (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationConnected attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationConnected attribute
 */
bool dotdot_get_application_monitoring_application_connected(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationConnected attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_application_connected new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_application_connected(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_application_connected);

// ApplicationMonitoring ApplicationMQTTTopics
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ApplicationMQTTTopics is supported
 *
 * @returns true if ApplicationMQTTTopics is supported
 * @returns false if ApplicationMQTTTopics is not supported
 */
bool dotdot_is_supported_application_monitoring_applicationmqtt_topics (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationMQTTTopics attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationMQTTTopics attribute
 */
const char* dotdot_get_application_monitoring_applicationmqtt_topics(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationMQTTTopics attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_applicationmqtt_topics new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_applicationmqtt_topics(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_applicationmqtt_topics);

// ApplicationMonitoring UptimeMinutes
/**
 * @brief Verifies if the DotDot ApplicationMonitoring UptimeMinutes is supported
 *
 * @returns true if UptimeMinutes is supported
 * @returns false if UptimeMinutes is not supported
 */
bool dotdot_is_supported_application_monitoring_uptime_minutes (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot UptimeMinutes attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns UptimeMinutes attribute
 */
uint64_t dotdot_get_application_monitoring_uptime_minutes(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot UptimeMinutes attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_uptime_minutes new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_uptime_minutes(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_uptime_minutes);

// ApplicationMonitoring ProcessId
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ProcessId is supported
 *
 * @returns true if ProcessId is supported
 * @returns false if ProcessId is not supported
 */
bool dotdot_is_supported_application_monitoring_process_id (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ProcessId attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ProcessId attribute
 */
uint64_t dotdot_get_application_monitoring_process_id(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ProcessId attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_process_id new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_process_id(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_process_id);

// ApplicationMonitoring Hostname
/**
 * @brief Verifies if the DotDot ApplicationMonitoring Hostname is supported
 *
 * @returns true if Hostname is supported
 * @returns false if Hostname is not supported
 */
bool dotdot_is_supported_application_monitoring_hostname (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Hostname attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Hostname attribute
 */
const char* dotdot_get_application_monitoring_hostname(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Hostname attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_hostname new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_hostname(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_hostname);

// ApplicationMonitoring FQDN
/**
 * @brief Verifies if the DotDot ApplicationMonitoring FQDN is supported
 *
 * @returns true if FQDN is supported
 * @returns false if FQDN is not supported
 */
bool dotdot_is_supported_application_monitoring_fqdn (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot FQDN attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns FQDN attribute
 */
const char* dotdot_get_application_monitoring_fqdn(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot FQDN attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_fqdn new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_fqdn(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_fqdn);

// ApplicationMonitoring MQTTLoggingEnabled
/**
 * @brief Verifies if the DotDot ApplicationMonitoring MQTTLoggingEnabled is supported
 *
 * @returns true if MQTTLoggingEnabled is supported
 * @returns false if MQTTLoggingEnabled is not supported
 */
bool dotdot_is_supported_application_monitoring_mqtt_logging_enabled (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MQTTLoggingEnabled attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MQTTLoggingEnabled attribute
 */
bool dotdot_get_application_monitoring_mqtt_logging_enabled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MQTTLoggingEnabled attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mqtt_logging_enabled new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_mqtt_logging_enabled(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_mqtt_logging_enabled);

// ApplicationMonitoring MQTTLoggingLevel
/**
 * @brief Verifies if the DotDot ApplicationMonitoring MQTTLoggingLevel is supported
 *
 * @returns true if MQTTLoggingLevel is supported
 * @returns false if MQTTLoggingLevel is not supported
 */
bool dotdot_is_supported_application_monitoring_mqtt_logging_level (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MQTTLoggingLevel attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MQTTLoggingLevel attribute
 */
LoggingLevelEnum dotdot_get_application_monitoring_mqtt_logging_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MQTTLoggingLevel attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mqtt_logging_level new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_mqtt_logging_level(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  LoggingLevelEnum new_mqtt_logging_level);

// ApplicationMonitoring MQTTStatisticsReportingIntervalSeconds
/**
 * @brief Verifies if the DotDot ApplicationMonitoring MQTTStatisticsReportingIntervalSeconds is supported
 *
 * @returns true if MQTTStatisticsReportingIntervalSeconds is supported
 * @returns false if MQTTStatisticsReportingIntervalSeconds is not supported
 */
bool dotdot_is_supported_application_monitoring_mqtt_statistics_reporting_interval_seconds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MQTTStatisticsReportingIntervalSeconds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MQTTStatisticsReportingIntervalSeconds attribute
 */
uint32_t dotdot_get_application_monitoring_mqtt_statistics_reporting_interval_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MQTTStatisticsReportingIntervalSeconds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mqtt_statistics_reporting_interval_seconds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_mqtt_statistics_reporting_interval_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_mqtt_statistics_reporting_interval_seconds);

// ApplicationMonitoring MQTTMessagesSent
/**
 * @brief Verifies if the DotDot ApplicationMonitoring MQTTMessagesSent is supported
 *
 * @returns true if MQTTMessagesSent is supported
 * @returns false if MQTTMessagesSent is not supported
 */
bool dotdot_is_supported_application_monitoring_mqtt_messages_sent (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MQTTMessagesSent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MQTTMessagesSent attribute
 */
uint64_t dotdot_get_application_monitoring_mqtt_messages_sent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MQTTMessagesSent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mqtt_messages_sent new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_mqtt_messages_sent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_mqtt_messages_sent);

// ApplicationMonitoring MQTTMessagesReceived
/**
 * @brief Verifies if the DotDot ApplicationMonitoring MQTTMessagesReceived is supported
 *
 * @returns true if MQTTMessagesReceived is supported
 * @returns false if MQTTMessagesReceived is not supported
 */
bool dotdot_is_supported_application_monitoring_mqtt_messages_received (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MQTTMessagesReceived attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MQTTMessagesReceived attribute
 */
uint64_t dotdot_get_application_monitoring_mqtt_messages_received(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MQTTMessagesReceived attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mqtt_messages_received new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_mqtt_messages_received(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_mqtt_messages_received);

// ApplicationMonitoring MQTTSubscriptionCount
/**
 * @brief Verifies if the DotDot ApplicationMonitoring MQTTSubscriptionCount is supported
 *
 * @returns true if MQTTSubscriptionCount is supported
 * @returns false if MQTTSubscriptionCount is not supported
 */
bool dotdot_is_supported_application_monitoring_mqtt_subscription_count (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MQTTSubscriptionCount attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MQTTSubscriptionCount attribute
 */
uint64_t dotdot_get_application_monitoring_mqtt_subscription_count(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MQTTSubscriptionCount attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mqtt_subscription_count new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_mqtt_subscription_count(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint64_t new_mqtt_subscription_count);

// ApplicationMonitoring MQTTAverageDeliveryTimeSeconds
/**
 * @brief Verifies if the DotDot ApplicationMonitoring MQTTAverageDeliveryTimeSeconds is supported
 *
 * @returns true if MQTTAverageDeliveryTimeSeconds is supported
 * @returns false if MQTTAverageDeliveryTimeSeconds is not supported
 */
bool dotdot_is_supported_application_monitoring_mqtt_average_delivery_time_seconds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MQTTAverageDeliveryTimeSeconds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MQTTAverageDeliveryTimeSeconds attribute
 */
double dotdot_get_application_monitoring_mqtt_average_delivery_time_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MQTTAverageDeliveryTimeSeconds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mqtt_average_delivery_time_seconds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_mqtt_average_delivery_time_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_mqtt_average_delivery_time_seconds);

// ApplicationMonitoring MQTTMinDeliveryTimeSeconds
/**
 * @brief Verifies if the DotDot ApplicationMonitoring MQTTMinDeliveryTimeSeconds is supported
 *
 * @returns true if MQTTMinDeliveryTimeSeconds is supported
 * @returns false if MQTTMinDeliveryTimeSeconds is not supported
 */
bool dotdot_is_supported_application_monitoring_mqtt_min_delivery_time_seconds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MQTTMinDeliveryTimeSeconds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MQTTMinDeliveryTimeSeconds attribute
 */
double dotdot_get_application_monitoring_mqtt_min_delivery_time_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MQTTMinDeliveryTimeSeconds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mqtt_min_delivery_time_seconds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_mqtt_min_delivery_time_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_mqtt_min_delivery_time_seconds);

// ApplicationMonitoring MQTTMaxDeliveryTimeSeconds
/**
 * @brief Verifies if the DotDot ApplicationMonitoring MQTTMaxDeliveryTimeSeconds is supported
 *
 * @returns true if MQTTMaxDeliveryTimeSeconds is supported
 * @returns false if MQTTMaxDeliveryTimeSeconds is not supported
 */
bool dotdot_is_supported_application_monitoring_mqtt_max_delivery_time_seconds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot MQTTMaxDeliveryTimeSeconds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns MQTTMaxDeliveryTimeSeconds attribute
 */
double dotdot_get_application_monitoring_mqtt_max_delivery_time_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot MQTTMaxDeliveryTimeSeconds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_mqtt_max_delivery_time_seconds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_mqtt_max_delivery_time_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_mqtt_max_delivery_time_seconds);

// ApplicationMonitoring ApplicationStatisticsReportingIntervalSeconds
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ApplicationStatisticsReportingIntervalSeconds is supported
 *
 * @returns true if ApplicationStatisticsReportingIntervalSeconds is supported
 * @returns false if ApplicationStatisticsReportingIntervalSeconds is not supported
 */
bool dotdot_is_supported_application_monitoring_application_statistics_reporting_interval_seconds (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationStatisticsReportingIntervalSeconds attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationStatisticsReportingIntervalSeconds attribute
 */
uint32_t dotdot_get_application_monitoring_application_statistics_reporting_interval_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationStatisticsReportingIntervalSeconds attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_application_statistics_reporting_interval_seconds new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_application_statistics_reporting_interval_seconds(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint32_t new_application_statistics_reporting_interval_seconds);

// ApplicationMonitoring ApplicationCPUUsagePercent
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ApplicationCPUUsagePercent is supported
 *
 * @returns true if ApplicationCPUUsagePercent is supported
 * @returns false if ApplicationCPUUsagePercent is not supported
 */
bool dotdot_is_supported_application_monitoring_applicationcpu_usage_percent (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationCPUUsagePercent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationCPUUsagePercent attribute
 */
double dotdot_get_application_monitoring_applicationcpu_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationCPUUsagePercent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_applicationcpu_usage_percent new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_applicationcpu_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_applicationcpu_usage_percent);

// ApplicationMonitoring ApplicationCPUAverageUsagePercent
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ApplicationCPUAverageUsagePercent is supported
 *
 * @returns true if ApplicationCPUAverageUsagePercent is supported
 * @returns false if ApplicationCPUAverageUsagePercent is not supported
 */
bool dotdot_is_supported_application_monitoring_applicationcpu_average_usage_percent (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationCPUAverageUsagePercent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationCPUAverageUsagePercent attribute
 */
double dotdot_get_application_monitoring_applicationcpu_average_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationCPUAverageUsagePercent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_applicationcpu_average_usage_percent new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_applicationcpu_average_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_applicationcpu_average_usage_percent);

// ApplicationMonitoring ApplicationCPUMinUsagePercent
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ApplicationCPUMinUsagePercent is supported
 *
 * @returns true if ApplicationCPUMinUsagePercent is supported
 * @returns false if ApplicationCPUMinUsagePercent is not supported
 */
bool dotdot_is_supported_application_monitoring_applicationcpu_min_usage_percent (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationCPUMinUsagePercent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationCPUMinUsagePercent attribute
 */
double dotdot_get_application_monitoring_applicationcpu_min_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationCPUMinUsagePercent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_applicationcpu_min_usage_percent new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_applicationcpu_min_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_applicationcpu_min_usage_percent);

// ApplicationMonitoring ApplicationCPUMaxUsagePercent
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ApplicationCPUMaxUsagePercent is supported
 *
 * @returns true if ApplicationCPUMaxUsagePercent is supported
 * @returns false if ApplicationCPUMaxUsagePercent is not supported
 */
bool dotdot_is_supported_application_monitoring_applicationcpu_max_usage_percent (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationCPUMaxUsagePercent attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationCPUMaxUsagePercent attribute
 */
double dotdot_get_application_monitoring_applicationcpu_max_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationCPUMaxUsagePercent attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_applicationcpu_max_usage_percent new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_applicationcpu_max_usage_percent(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_applicationcpu_max_usage_percent);

// ApplicationMonitoring ApplicationRAMUsageMB
/**
 * @brief Verifies if the DotDot ApplicationMonitoring ApplicationRAMUsageMB is supported
 *
 * @returns true if ApplicationRAMUsageMB is supported
 * @returns false if ApplicationRAMUsageMB is not supported
 */
bool dotdot_is_supported_application_monitoring_applicationram_usagemb (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ApplicationRAMUsageMB attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ApplicationRAMUsageMB attribute
 */
double dotdot_get_application_monitoring_applicationram_usagemb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ApplicationRAMUsageMB attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_applicationram_usagemb new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_application_monitoring_applicationram_usagemb(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_applicationram_usagemb);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster NameAndLocation
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for NameAndLocation
#define DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_NAME ((attribute_store_type_t) 0xfd060000)
///< This represents the Name attribute in the DotDot NameAndLocation cluster

#define DOTDOT_ATTRIBUTE_ID_NAME_AND_LOCATION_LOCATION ((attribute_store_type_t) 0xfd060001)
///< This represents the Location attribute in the DotDot NameAndLocation cluster

// NameAndLocation Name
/**
 * @brief Verifies if the DotDot NameAndLocation Name is supported
 *
 * @returns true if Name is supported
 * @returns false if Name is not supported
 */
bool dotdot_is_supported_name_and_location_name (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Name attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Name attribute
 */
const char* dotdot_get_name_and_location_name(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Name attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_name new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_name_and_location_name(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_name);

// NameAndLocation Location
/**
 * @brief Verifies if the DotDot NameAndLocation Location is supported
 *
 * @returns true if Location is supported
 * @returns false if Location is not supported
 */
bool dotdot_is_supported_name_and_location_location (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Location attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Location attribute
 */
const char* dotdot_get_name_and_location_location(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Location attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_location new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_name_and_location_location(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_location);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster ConfigurationParameters
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for ConfigurationParameters
#define DOTDOT_ATTRIBUTE_ID_CONFIGURATION_PARAMETERS_CONFIGURATION_PARAMETERS ((attribute_store_type_t) 0xfd070000)
///< This represents the ConfigurationParameters attribute in the DotDot ConfigurationParameters cluster

// ConfigurationParameters ConfigurationParameters
/**
 * @brief Verifies if the DotDot ConfigurationParameters ConfigurationParameters is supported
 *
 * @returns true if ConfigurationParameters is supported
 * @returns false if ConfigurationParameters is not supported
 */
bool dotdot_is_supported_configuration_parameters_configuration_parameters (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ConfigurationParameters attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ConfigurationParameters attribute
 */
ConfigurationParameter dotdot_get_configuration_parameters_configuration_parameters(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ConfigurationParameters attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_configuration_parameters new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_configuration_parameters_configuration_parameters(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  ConfigurationParameter new_configuration_parameters);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster AoXLocator
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for AoXLocator
#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE ((attribute_store_type_t) 0xfd100001)
///< This represents the ReportingMode attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID ((attribute_store_type_t) 0xfd100002)
///< This represents the PositionAndOrientationValid attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION ((attribute_store_type_t) 0xfd100003)
///< This represents the PositionAndOrientation attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK ((attribute_store_type_t) 0xfd100005)
///< This represents the AzimuthMask attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK ((attribute_store_type_t) 0xfd100006)
///< This represents the ElevationMask attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST ((attribute_store_type_t) 0xfd100007)
///< This represents the AllowList attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE ((attribute_store_type_t) 0xfd100008)
///< This represents the AoXMode attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE ((attribute_store_type_t) 0xfd100009)
///< This represents the AntennaMode attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY ((attribute_store_type_t) 0xfd10000a)
///< This represents the AntennaArray attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES ((attribute_store_type_t) 0xfd10000b)
///< This represents the PeriodSamples attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING ((attribute_store_type_t) 0xfd10000c)
///< This represents the AngleFiltering attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT ((attribute_store_type_t) 0xfd10000d)
///< This represents the AngleFilteringWeight attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT ((attribute_store_type_t) 0xfd10000e)
///< This represents the AngleCorrectionTimeout attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY ((attribute_store_type_t) 0xfd10000f)
///< This represents the AngleCorrectionDelay attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE ((attribute_store_type_t) 0xfd100010)
///< This represents the CTEMode attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL ((attribute_store_type_t) 0xfd100011)
///< This represents the CTESamplingInterval attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH ((attribute_store_type_t) 0xfd100012)
///< This represents the CTELength attribute in the DotDot AoXLocator cluster

#define DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION ((attribute_store_type_t) 0xfd100013)
///< This represents the SlotDuration attribute in the DotDot AoXLocator cluster

// AoXLocator ReportingMode
/**
 * @brief Verifies if the DotDot AoXLocator ReportingMode is supported
 *
 * @returns true if ReportingMode is supported
 * @returns false if ReportingMode is not supported
 */
bool dotdot_is_supported_aox_locator_reporting_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ReportingMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ReportingMode attribute
 */
uint8_t dotdot_get_aox_locator_reporting_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ReportingMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_reporting_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_reporting_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_reporting_mode);

// AoXLocator PositionAndOrientationValid
/**
 * @brief Verifies if the DotDot AoXLocator PositionAndOrientationValid is supported
 *
 * @returns true if PositionAndOrientationValid is supported
 * @returns false if PositionAndOrientationValid is not supported
 */
bool dotdot_is_supported_aox_locator_position_and_orientation_valid (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PositionAndOrientationValid attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PositionAndOrientationValid attribute
 */
bool dotdot_get_aox_locator_position_and_orientation_valid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PositionAndOrientationValid attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_position_and_orientation_valid new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_position_and_orientation_valid(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_position_and_orientation_valid);

// AoXLocator PositionAndOrientation
/**
 * @brief Verifies if the DotDot AoXLocator PositionAndOrientation is supported
 *
 * @returns true if PositionAndOrientation is supported
 * @returns false if PositionAndOrientation is not supported
 */
bool dotdot_is_supported_aox_locator_position_and_orientation (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PositionAndOrientation attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PositionAndOrientation attribute
 */
CoordinateAndOrientation dotdot_get_aox_locator_position_and_orientation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PositionAndOrientation attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_position_and_orientation new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_position_and_orientation(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  CoordinateAndOrientation new_position_and_orientation);

// AoXLocator AzimuthMask
/**
 * @brief Verifies if the DotDot AoXLocator AzimuthMask is supported
 *
 * @returns true if AzimuthMask is supported
 * @returns false if AzimuthMask is not supported
 */
bool dotdot_is_supported_aox_locator_azimuth_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AzimuthMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AzimuthMask attribute
 */
MinMaxPair dotdot_get_aox_locator_azimuth_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AzimuthMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_azimuth_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_azimuth_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  MinMaxPair new_azimuth_mask);

// AoXLocator ElevationMask
/**
 * @brief Verifies if the DotDot AoXLocator ElevationMask is supported
 *
 * @returns true if ElevationMask is supported
 * @returns false if ElevationMask is not supported
 */
bool dotdot_is_supported_aox_locator_elevation_mask (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot ElevationMask attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns ElevationMask attribute
 */
MinMaxPair dotdot_get_aox_locator_elevation_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot ElevationMask attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_elevation_mask new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_elevation_mask(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  MinMaxPair new_elevation_mask);

// AoXLocator AllowList
/**
 * @brief Verifies if the DotDot AoXLocator AllowList is supported
 *
 * @returns true if AllowList is supported
 * @returns false if AllowList is not supported
 */
bool dotdot_is_supported_aox_locator_allow_list (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AllowList attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AllowList attribute
 */
const char* dotdot_get_aox_locator_allow_list(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AllowList attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_allow_list new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_allow_list(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  const char* new_allow_list);

// AoXLocator AoXMode
/**
 * @brief Verifies if the DotDot AoXLocator AoXMode is supported
 *
 * @returns true if AoXMode is supported
 * @returns false if AoXMode is not supported
 */
bool dotdot_is_supported_aox_locator_aox_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AoXMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AoXMode attribute
 */
uint8_t dotdot_get_aox_locator_aox_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AoXMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_aox_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_aox_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_aox_mode);

// AoXLocator AntennaMode
/**
 * @brief Verifies if the DotDot AoXLocator AntennaMode is supported
 *
 * @returns true if AntennaMode is supported
 * @returns false if AntennaMode is not supported
 */
bool dotdot_is_supported_aox_locator_antenna_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AntennaMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AntennaMode attribute
 */
uint8_t dotdot_get_aox_locator_antenna_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AntennaMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_antenna_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_antenna_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_antenna_mode);

// AoXLocator AntennaArray
/**
 * @brief Verifies if the DotDot AoXLocator AntennaArray is supported
 *
 * @returns true if AntennaArray is supported
 * @returns false if AntennaArray is not supported
 */
bool dotdot_is_supported_aox_locator_antenna_array (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AntennaArray attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AntennaArray attribute
 */
int8_t dotdot_get_aox_locator_antenna_array(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AntennaArray attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_antenna_array new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_antenna_array(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_antenna_array);

// AoXLocator PeriodSamples
/**
 * @brief Verifies if the DotDot AoXLocator PeriodSamples is supported
 *
 * @returns true if PeriodSamples is supported
 * @returns false if PeriodSamples is not supported
 */
bool dotdot_is_supported_aox_locator_period_samples (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot PeriodSamples attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns PeriodSamples attribute
 */
int8_t dotdot_get_aox_locator_period_samples(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot PeriodSamples attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_period_samples new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_period_samples(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_period_samples);

// AoXLocator AngleFiltering
/**
 * @brief Verifies if the DotDot AoXLocator AngleFiltering is supported
 *
 * @returns true if AngleFiltering is supported
 * @returns false if AngleFiltering is not supported
 */
bool dotdot_is_supported_aox_locator_angle_filtering (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AngleFiltering attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AngleFiltering attribute
 */
bool dotdot_get_aox_locator_angle_filtering(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AngleFiltering attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_angle_filtering new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_angle_filtering(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  bool new_angle_filtering);

// AoXLocator AngleFilteringWeight
/**
 * @brief Verifies if the DotDot AoXLocator AngleFilteringWeight is supported
 *
 * @returns true if AngleFilteringWeight is supported
 * @returns false if AngleFilteringWeight is not supported
 */
bool dotdot_is_supported_aox_locator_angle_filtering_weight (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AngleFilteringWeight attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AngleFilteringWeight attribute
 */
double dotdot_get_aox_locator_angle_filtering_weight(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AngleFilteringWeight attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_angle_filtering_weight new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_angle_filtering_weight(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  double new_angle_filtering_weight);

// AoXLocator AngleCorrectionTimeout
/**
 * @brief Verifies if the DotDot AoXLocator AngleCorrectionTimeout is supported
 *
 * @returns true if AngleCorrectionTimeout is supported
 * @returns false if AngleCorrectionTimeout is not supported
 */
bool dotdot_is_supported_aox_locator_angle_correction_timeout (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AngleCorrectionTimeout attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AngleCorrectionTimeout attribute
 */
int8_t dotdot_get_aox_locator_angle_correction_timeout(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AngleCorrectionTimeout attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_angle_correction_timeout new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_angle_correction_timeout(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_angle_correction_timeout);

// AoXLocator AngleCorrectionDelay
/**
 * @brief Verifies if the DotDot AoXLocator AngleCorrectionDelay is supported
 *
 * @returns true if AngleCorrectionDelay is supported
 * @returns false if AngleCorrectionDelay is not supported
 */
bool dotdot_is_supported_aox_locator_angle_correction_delay (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot AngleCorrectionDelay attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns AngleCorrectionDelay attribute
 */
int8_t dotdot_get_aox_locator_angle_correction_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot AngleCorrectionDelay attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_angle_correction_delay new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_angle_correction_delay(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_angle_correction_delay);

// AoXLocator CTEMode
/**
 * @brief Verifies if the DotDot AoXLocator CTEMode is supported
 *
 * @returns true if CTEMode is supported
 * @returns false if CTEMode is not supported
 */
bool dotdot_is_supported_aox_locator_cte_mode (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CTEMode attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CTEMode attribute
 */
uint8_t dotdot_get_aox_locator_cte_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CTEMode attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_cte_mode new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_cte_mode(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  uint8_t new_cte_mode);

// AoXLocator CTESamplingInterval
/**
 * @brief Verifies if the DotDot AoXLocator CTESamplingInterval is supported
 *
 * @returns true if CTESamplingInterval is supported
 * @returns false if CTESamplingInterval is not supported
 */
bool dotdot_is_supported_aox_locator_cte_sampling_interval (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CTESamplingInterval attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CTESamplingInterval attribute
 */
int8_t dotdot_get_aox_locator_cte_sampling_interval(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CTESamplingInterval attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_cte_sampling_interval new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_cte_sampling_interval(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_cte_sampling_interval);

// AoXLocator CTELength
/**
 * @brief Verifies if the DotDot AoXLocator CTELength is supported
 *
 * @returns true if CTELength is supported
 * @returns false if CTELength is not supported
 */
bool dotdot_is_supported_aox_locator_cte_length (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot CTELength attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns CTELength attribute
 */
int8_t dotdot_get_aox_locator_cte_length(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot CTELength attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_cte_length new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_cte_length(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_cte_length);

// AoXLocator SlotDuration
/**
 * @brief Verifies if the DotDot AoXLocator SlotDuration is supported
 *
 * @returns true if SlotDuration is supported
 * @returns false if SlotDuration is not supported
 */
bool dotdot_is_supported_aox_locator_slot_duration (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot SlotDuration attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns SlotDuration attribute
 */
int8_t dotdot_get_aox_locator_slot_duration(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot SlotDuration attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_slot_duration new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_locator_slot_duration(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  int8_t new_slot_duration);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster AoXPositionEstimation
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for AoXPositionEstimation
#define DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION ((attribute_store_type_t) 0xfd110001)
///< This represents the Position attribute in the DotDot AoXPositionEstimation cluster

// AoXPositionEstimation Position
/**
 * @brief Verifies if the DotDot AoXPositionEstimation Position is supported
 *
 * @returns true if Position is supported
 * @returns false if Position is not supported
 */
bool dotdot_is_supported_aox_position_estimation_position (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot Position attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns Position attribute
 */
EstimatedPosition dotdot_get_aox_position_estimation_position(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot Position attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_position new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_aox_position_estimation_position(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  EstimatedPosition new_position);

////////////////////////////////////////////////////////////////////////////////
// Start of cluster ProtocolController-NetworkManagement
////////////////////////////////////////////////////////////////////////////////

// Attribute Defines for ProtocolController-NetworkManagement
#define DOTDOT_ATTRIBUTE_ID_PROTOCOL_CONTROLLER_NETWORK_MANAGEMENT_NETWORK_MANAGEMENT_STATE ((attribute_store_type_t) 0xfd120001)
///< This represents the NetworkManagementState attribute in the DotDot ProtocolController-NetworkManagement cluster

// ProtocolController-NetworkManagement NetworkManagementState
/**
 * @brief Verifies if the DotDot ProtocolController-NetworkManagement NetworkManagementState is supported
 *
 * @returns true if NetworkManagementState is supported
 * @returns false if NetworkManagementState is not supported
 */
bool dotdot_is_supported_protocol_controller_network_management_network_management_state (
              const unid_t unid, const zwave_endpoint_id_t endpoint);

/**
 * @brief Gets the DotDot NetworkManagementState attribute
 *
 * @param unid UNID to get value for
 * @param endpoint Endpoint to get value for
 * @param value_state value state to get,
 *                    see \ref attribute_store_get_node_attribute_value
 * @returns NetworkManagementState attribute
 */
NetworkManagementState dotdot_get_protocol_controller_network_management_network_management_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state);

/**
 * @brief Set the DotDot NetworkManagementState attribute
 *
 * @param unid UNID to set value on
 * @param endpoint endpoint to set value on
 * @param value_state value state to write for the node,
 *                    see \ref attribute_store_set_node_attribute_value
 * @param new_network_management_state new value to set
 * @returns sl_status_t SL_STATUS_OK on success
 */
sl_status_t dotdot_set_protocol_controller_network_management_network_management_state(
  const unid_t unid,
  const zwave_endpoint_id_t endpoint,
  attribute_store_node_value_state_t value_state,
  NetworkManagementState new_network_management_state);

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // DOTDOT_ATTRIBUTES_H
/** @} end dotdot_attributes */
