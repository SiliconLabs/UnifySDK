/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.

#include <cstring>
#include <string>

// Unify shared includes
#include <sl_log.h>
#include <dotdot_mqtt.h>

// ZigPC includes
#include <zigpc_ucl.hpp>
#include <zigpc_common_zigbee.h>
#include <zcl_definitions.h>


// Component includes
#include "attribute_management_int.h"

static const char LOG_TAG[] = "zigpc_attrmgmt";

sl_status_t zigpc_attrmgmt_identify_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_IDENTIFY_ATTR_IDENTIFY_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_identify_identify_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 1) {
          value = 1; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_identify_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_groups_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_GROUPS_ATTR_NAME_SUPPORT:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_groups_name_support_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_groups_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_on_off_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_OFF:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_on_off_on_off_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_GLOBAL_SCENE_CONTROL:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_on_off_global_scene_control_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_on_off_on_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_OFF_WAIT_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_on_off_off_wait_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_START_UP_ON_OFF:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_on_off_start_up_on_off_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_on_off_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_level_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_CURRENT_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_current_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_REMAINING_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_remaining_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MIN_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_min_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MAX_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_max_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_CURRENT_FREQUENCY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_current_frequency_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MIN_FREQUENCY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_min_frequency_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MAX_FREQUENCY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_max_frequency_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OPTIONS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_options_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_OFF_TRANSITION_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_on_off_transition_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_on_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_TRANSITION_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_on_transition_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OFF_TRANSITION_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_off_transition_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_DEFAULT_MOVE_RATE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_default_move_rate_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_START_UP_CURRENT_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_start_up_current_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_level_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_poll_control_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_poll_control_check_in_interval_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_LONG_POLL_INTERVAL:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_poll_control_long_poll_interval_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_SHORT_POLL_INTERVAL:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_poll_control_short_poll_interval_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_poll_control_fast_poll_timeout_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL_MIN:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_poll_control_check_in_interval_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_LONG_POLL_INTERVAL_MIN:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_poll_control_long_poll_interval_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT_MAX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_poll_control_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_door_lock_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCK_STATE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_lock_state_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCK_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_lock_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ACTUATOR_ENABLED:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_actuator_enabled_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_STATE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_door_state_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_OPEN_EVENTS:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_door_lock_door_open_events_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_CLOSED_EVENTS:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_door_lock_door_closed_events_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPEN_PERIOD:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_open_period_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_LOG_RECORDS_SUPPORTED:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_number_of_log_records_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_TOTAL_USERS_SUPPORTED:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_number_of_total_users_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OFPIN_USERS_SUPPORTED:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_number_ofpin_users_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OFRFID_USERS_SUPPORTED:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_number_ofrfid_users_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MAXPIN_CODE_LENGTH:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_maxpin_code_length_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MINPIN_CODE_LENGTH:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_minpin_code_length_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MAXRFID_CODE_LENGTH:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_maxrfid_code_length_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MINRFID_CODE_LENGTH:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_minrfid_code_length_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOGGING:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_enable_logging_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LANGUAGE:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_door_lock_language_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LED_SETTINGS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_led_settings_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_AUTO_RELOCK_TIME:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_door_lock_auto_relock_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SOUND_VOLUME:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_sound_volume_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPERATING_MODE:
      {
        DrlkOperMode value;
        memcpy(&value, attr_value, sizeof(DrlkOperMode));
        status = uic_mqtt_dotdot_door_lock_operating_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SUPPORTED_OPERATING_MODES:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_supported_operating_modes_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DEFAULT_CONFIGURATION_REGISTER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_default_configuration_register_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOCAL_PROGRAMMING:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_enable_local_programming_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_ONE_TOUCH_LOCKING:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_enable_one_touch_locking_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_INSIDE_STATUSLED:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_enable_inside_statusled_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_PRIVACY_MODE_BUTTON:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_WRONG_CODE_ENTRY_LIMIT:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_USER_CODE_TEMPORARY_DISABLE_TIME:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SENDPIN_OVER_THE_AIR:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_sendpin_over_the_air_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_REQUIREPI_NFORRF_OPERATION:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_requirepi_nforrf_operation_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SECURITY_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_security_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ALARM_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_alarm_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_OPERATION_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_OPERATION_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_rf_operation_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MANUAL_OPERATION_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_manual_operation_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_OPERATION_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_PROGRAMMING_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_PROGRAMMING_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_rf_programming_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_PROGRAMMING_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_door_lock_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_thermostat_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_local_temperature_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OUTDOOR_TEMPERATURE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_outdoor_temperature_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPANCY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_occupancy_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MIN_HEAT_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MAX_HEAT_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MIN_COOL_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MAX_COOL_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_PI_COOLING_DEMAND:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_pi_cooling_demand_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_PI_HEATING_DEMAND:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_pi_heating_demand_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_HVAC_SYSTEM_TYPE_CONFIGURATION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE_CALIBRATION:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_thermostat_local_temperature_calibration_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_COOLING_SETPOINT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_HEATING_SETPOINT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_COOLING_SETPOINT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_HEATING_SETPOINT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_HEAT_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_HEAT_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_COOL_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_COOL_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_SETPOINT_DEAD_BAND:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_REMOTE_SENSING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_remote_sensing_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_CONTROL_SEQUENCE_OF_OPERATION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_control_sequence_of_operation_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SYSTEM_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_system_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ALARM_MASK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_alarm_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_RUNNING_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_thermostat_running_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_START_OF_WEEK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_start_of_week_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_NUMBER_OF_WEEKLY_TRANSITIONS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_NUMBER_OF_DAILY_TRANSITIONS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_number_of_daily_transitions_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD_DURATION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_PROGRAMMING_OPERATION_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_RUNNING_STATE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_thermostat_thermostat_running_state_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_SOURCE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_setpoint_change_source_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_AMOUNT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_setpoint_change_amount_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_SOURCE_TIMESTAMP:
      {
        UTC value;
        memcpy(&value, attr_value, sizeof(UTC));
        status = uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_occupied_setback_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK_MIN:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_occupied_setback_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK_MAX:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_occupied_setback_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_unoccupied_setback_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK_MIN:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_unoccupied_setback_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK_MAX:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_unoccupied_setback_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_EMERGENCY_HEAT_DELTA:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_emergency_heat_delta_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_ac_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_thermostat_ac_capacity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_REFRIGERANT_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_ac_refrigerant_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COMPRESSOR_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_ac_compressor_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_ERROR_CODE:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_thermostat_ac_error_code_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_LOUVER_POSITION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_ac_louver_position_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COIL_TEMPERATURE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_ac_coil_temperature_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY_FORMAT:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_ac_capacity_format_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_thermostat_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_color_control_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENT_HUE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_current_hue_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENT_SATURATION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_current_saturation_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_REMAINING_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_remaining_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENTX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_currentx_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENTY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_currenty_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_DRIFT_COMPENSATION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_drift_compensation_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COMPENSATION_TEXT:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_color_control_compensation_text_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMPERATURE_MIREDS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_temperature_mireds_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_OPTIONS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_options_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_NUMBER_OF_PRIMARIES:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_number_of_primaries_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary1x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary1y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary1_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary2x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary2y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary2_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary3x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary3y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary3_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary4x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary4y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary4_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary5x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary5y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary5_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary6x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary6y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary6_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_white_pointx_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_white_pointy_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointrx_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointry_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTR_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_pointr_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointgx_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointgy_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTG_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_pointg_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointbx_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointby_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTB_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_pointb_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_ENHANCED_CURRENT_HUE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_enhanced_current_hue_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_ENHANCED_COLOR_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_enhanced_color_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_ACTIVE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_loop_active_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_DIRECTION:
      {
        CCColorLoopDirection value;
        memcpy(&value, attr_value, sizeof(CCColorLoopDirection));
        status = uic_mqtt_dotdot_color_control_color_loop_direction_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_loop_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_START_ENHANCED_HUE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_STORED_ENHANCED_HUE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_CAPABILITIES:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_capabilities_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMP_PHYSICAL_MIN_MIREDS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMP_PHYSICAL_MAX_MIREDS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_START_UP_COLOR_TEMPERATURE_MIREDS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_color_control_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_occupancy_sensing_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_occupancy_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY_SENSOR_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY_SENSOR_TYPE_BITMAP:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_occupancy_sensing_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}

sl_status_t zigpc_attrmgmt_publish_reported(const zigbee_eui64_uint_t eui64, const zigbee_endpoint_id_t endpoint_id, const zcl_cluster_id_t cluster_id, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  zigpc_ucl::mqtt::topic_data_t topic_data = {
    .eui64 = eui64,
    .endpoint_id = endpoint_id,
  };

  std::string unid_ep_topic;
  sl_status_t status = zigpc_ucl::mqtt::build_topic(
    zigpc_ucl::mqtt::topic_type_t::BY_UNID_NODE_EP,
    topic_data,
    unid_ep_topic);
  if (status != SL_STATUS_OK) {
    sl_log_error(LOG_TAG, "Failed to build topic for publishing attribute update: 0x%X",status);
    return status;
  }

  switch(cluster_id) {
    case ZIGPC_ZCL_CLUSTER_IDENTIFY:
      status = zigpc_attrmgmt_identify_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_GROUPS:
      status = zigpc_attrmgmt_groups_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_ON_OFF:
      status = zigpc_attrmgmt_on_off_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL:
      status = zigpc_attrmgmt_level_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL:
      status = zigpc_attrmgmt_poll_control_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK:
      status = zigpc_attrmgmt_door_lock_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT:
      status = zigpc_attrmgmt_thermostat_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL:
      status = zigpc_attrmgmt_color_control_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING:
      status = zigpc_attrmgmt_occupancy_sensing_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  sl_log_info(LOG_TAG, "Unid:%s,Ep:%u,Cluster:0x%04X,Attr:0x%04X Reported publish status: 0x%X",
              zigpc_ucl::mqtt::build_unid(eui64).c_str(), endpoint_id, cluster_id, attr_id, status);

  return status;
}
