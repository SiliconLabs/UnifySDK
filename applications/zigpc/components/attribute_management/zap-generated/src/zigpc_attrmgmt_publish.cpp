/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.

#include <cstring>
#include <string>

// Unify shared includes
#include <sl_log.h>
#include <dotdot_mqtt.h>

// ZigPC includes
#include <zigpc_ucl.hpp>
#include <zigpc_common_zigbee.h>
#include <zcl_definitions.h>


// Component includes
#include "attribute_management_int.h"

static const char LOG_TAG[] = "zigpc_attrmgmt";

sl_status_t zigpc_attrmgmt_basic_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_ZCL_VERSION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_zcl_version_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_APPLICATION_VERSION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_application_version_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_STACK_VERSION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_stack_version_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_HW_VERSION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_hw_version_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_MANUFACTURER_NAME:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_basic_manufacturer_name_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_MODEL_IDENTIFIER:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_basic_model_identifier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_DATE_CODE:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_basic_date_code_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_POWER_SOURCE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_power_source_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_GENERIC_DEVICE_CLASS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_generic_device_class_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_GENERIC_DEVICE_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_generic_device_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_PRODUCT_CODE:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_basic_product_code_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_PRODUCTURL:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_basic_producturl_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_MANUFACTURER_VERSION_DETAILS:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_basic_manufacturer_version_details_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_SERIAL_NUMBER:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_basic_serial_number_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_PRODUCT_LABEL:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_basic_product_label_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_LOCATION_DESCRIPTION:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_basic_location_description_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_PHYSICAL_ENVIRONMENT:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_physical_environment_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_DEVICE_ENABLED:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_basic_device_enabled_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_ALARM_MASK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_alarm_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_DISABLE_LOCAL_CONFIG:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_disable_local_config_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_SW_BUILDID:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_basic_sw_buildid_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_Z_WAVE_GENERIC_DEVICE_CLASS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_z_wave_generic_device_class_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_BASIC_ATTR_Z_WAVE_SPECIFIC_DEVICE_CLASS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_basic_z_wave_specific_device_class_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_basic_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_power_configuration_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_power_configuration_mains_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_FREQUENCY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_mains_frequency_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_ALARM_MASK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_mains_alarm_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE_MIN_THRESHOLD:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_power_configuration_mains_voltage_min_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE_MAX_THRESHOLD:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_power_configuration_mains_voltage_max_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE_DWELL_TRIP_POINT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_power_configuration_mains_voltage_dwell_trip_point_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_REMAINING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_percentage_remaining_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_MANUFACTURER:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_power_configuration_battery_manufacturer_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_SIZE:
      {
        BatterySize value;
        memcpy(&value, attr_value, sizeof(BatterySize));
        status = uic_mqtt_dotdot_power_configuration_battery_size_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERYA_HR_RATING:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_power_configuration_batterya_hr_rating_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_QUANTITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_quantity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_RATED_VOLTAGE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_rated_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_ALARM_MASK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_alarm_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_MIN_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_voltage_min_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_THRESHOLD1:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_voltage_threshold1_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_THRESHOLD2:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_voltage_threshold2_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_THRESHOLD3:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_voltage_threshold3_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_MIN_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_percentage_min_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_THRESHOLD1:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_percentage_threshold1_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_THRESHOLD2:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_percentage_threshold2_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_THRESHOLD3:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery_percentage_threshold3_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_ALARM_STATE:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_power_configuration_battery_alarm_state_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_REMAINING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_percentage_remaining_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_MANUFACTURER:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_power_configuration_battery2_manufacturer_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_SIZE:
      {
        BatterySize value;
        memcpy(&value, attr_value, sizeof(BatterySize));
        status = uic_mqtt_dotdot_power_configuration_battery2_size_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2A_HR_RATING:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_power_configuration_battery2a_hr_rating_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_QUANTITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_quantity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_RATED_VOLTAGE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_rated_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_ALARM_MASK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_alarm_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_MIN_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_voltage_min_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_THRESHOLD1:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold1_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_THRESHOLD2:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold2_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_THRESHOLD3:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_voltage_threshold3_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_MIN_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_percentage_min_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_THRESHOLD1:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold1_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_THRESHOLD2:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold2_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_THRESHOLD3:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_percentage_threshold3_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_ALARM_STATE:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_power_configuration_battery2_alarm_state_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_REMAINING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_percentage_remaining_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_MANUFACTURER:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_power_configuration_battery3_manufacturer_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_SIZE:
      {
        BatterySize value;
        memcpy(&value, attr_value, sizeof(BatterySize));
        status = uic_mqtt_dotdot_power_configuration_battery3_size_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3A_HR_RATING:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_power_configuration_battery3a_hr_rating_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_QUANTITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_quantity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_RATED_VOLTAGE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_rated_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_ALARM_MASK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_alarm_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_MIN_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_voltage_min_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_THRESHOLD1:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold1_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_THRESHOLD2:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold2_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_THRESHOLD3:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_voltage_threshold3_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_MIN_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_percentage_min_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_THRESHOLD1:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold1_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_THRESHOLD2:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold2_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_THRESHOLD3:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_percentage_threshold3_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_ALARM_STATE:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_power_configuration_battery3_alarm_state_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 1) {
          value = 1; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_power_configuration_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_identify_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_IDENTIFY_ATTR_IDENTIFY_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_identify_identify_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 1) {
          value = 1; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_identify_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_groups_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_GROUPS_ATTR_NAME_SUPPORT:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_groups_name_support_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_groups_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_on_off_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_OFF:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_on_off_on_off_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_GLOBAL_SCENE_CONTROL:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_on_off_global_scene_control_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_on_off_on_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_OFF_WAIT_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_on_off_off_wait_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_START_UP_ON_OFF:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_on_off_start_up_on_off_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_on_off_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_level_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_CURRENT_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_current_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_REMAINING_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_remaining_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MIN_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_min_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MAX_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_max_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_CURRENT_FREQUENCY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_current_frequency_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MIN_FREQUENCY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_min_frequency_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MAX_FREQUENCY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_max_frequency_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OPTIONS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_options_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_OFF_TRANSITION_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_on_off_transition_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_on_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_TRANSITION_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_on_transition_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OFF_TRANSITION_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_off_transition_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_DEFAULT_MOVE_RATE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_level_default_move_rate_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_START_UP_CURRENT_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_level_start_up_current_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_level_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_poll_control_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_poll_control_check_in_interval_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_LONG_POLL_INTERVAL:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_poll_control_long_poll_interval_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_SHORT_POLL_INTERVAL:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_poll_control_short_poll_interval_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_poll_control_fast_poll_timeout_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL_MIN:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_poll_control_check_in_interval_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_LONG_POLL_INTERVAL_MIN:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_poll_control_long_poll_interval_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT_MAX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_poll_control_fast_poll_timeout_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_poll_control_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_door_lock_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCK_STATE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_lock_state_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCK_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_lock_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ACTUATOR_ENABLED:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_actuator_enabled_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_STATE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_door_state_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_OPEN_EVENTS:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_door_lock_door_open_events_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_CLOSED_EVENTS:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_door_lock_door_closed_events_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPEN_PERIOD:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_open_period_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_LOG_RECORDS_SUPPORTED:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_number_of_log_records_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_TOTAL_USERS_SUPPORTED:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_number_of_total_users_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_PIN_USERS_SUPPORTED:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_number_of_pin_users_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_RFID_USERS_SUPPORTED:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_number_of_rfid_users_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_number_of_week_day_schedules_supported_per_user_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_number_of_year_day_schedules_supported_per_user_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_number_of_holiday_schedules_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MAX_PIN_CODE_LENGTH:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_max_pin_code_length_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MIN_PIN_CODE_LENGTH:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_min_pin_code_length_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MAX_RFID_CODE_LENGTH:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_max_rfid_code_length_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MIN_RFID_CODE_LENGTH:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_min_rfid_code_length_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_CREDENTIAL_RULES_SUPPORT:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_credential_rules_support_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_CREDENTIALS_SUPPORTED_PER_USER:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_number_of_credentials_supported_per_user_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOGGING:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_enable_logging_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LANGUAGE:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_door_lock_language_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LED_SETTINGS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_led_settings_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_AUTO_RELOCK_TIME:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_door_lock_auto_relock_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SOUND_VOLUME:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_sound_volume_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPERATING_MODE:
      {
        DrlkOperMode value;
        memcpy(&value, attr_value, sizeof(DrlkOperMode));
        status = uic_mqtt_dotdot_door_lock_operating_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SUPPORTED_OPERATING_MODES:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_supported_operating_modes_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DEFAULT_CONFIGURATION_REGISTER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_default_configuration_register_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOCAL_PROGRAMMING:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_enable_local_programming_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_ONE_TOUCH_LOCKING:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_enable_one_touch_locking_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_INSIDE_STATUSLED:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_enable_inside_statusled_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_PRIVACY_MODE_BUTTON:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_enable_privacy_mode_button_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCAL_PROGRAMMING_FEATURES:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_local_programming_features_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_WRONG_CODE_ENTRY_LIMIT:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_wrong_code_entry_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_USER_CODE_TEMPORARY_DISABLE_TIME:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_user_code_temporary_disable_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SEND_PIN_OVER_THE_AIR:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_send_pin_over_the_air_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_REQUIRE_PI_NFOR_RF_OPERATION:
      {
        bool value;
        memcpy(&value, attr_value, sizeof(bool));
        status = uic_mqtt_dotdot_door_lock_require_pi_nfor_rf_operation_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SECURITY_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_door_lock_security_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_EXPIRING_USER_TIMEOUT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_expiring_user_timeout_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ALARM_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_alarm_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_OPERATION_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_keypad_operation_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_OPERATION_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_rf_operation_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MANUAL_OPERATION_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_manual_operation_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_OPERATION_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_rfid_operation_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_PROGRAMMING_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_keypad_programming_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_PROGRAMMING_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_rf_programming_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_PROGRAMMING_EVENT_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_rfid_programming_event_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_FEATURE_MAP:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_door_lock_feature_map_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_door_lock_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_window_covering_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_WINDOW_COVERING_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_window_covering_window_covering_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_PHYSICAL_CLOSED_LIMIT_LIFT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_physical_closed_limit_lift_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_PHYSICAL_CLOSED_LIMIT_TILT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_physical_closed_limit_tilt_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_CURRENT_POSITION_LIFT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_current_position_lift_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_CURRENT_POSITION_TILT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_current_position_tilt_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_NUMBER_OF_ACTUATIONS_LIFT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_number_of_actuations_lift_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_NUMBER_OF_ACTUATIONS_TILT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_number_of_actuations_tilt_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_CONFIG_OR_STATUS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_window_covering_config_or_status_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_CURRENT_POSITION_LIFT_PERCENTAGE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_window_covering_current_position_lift_percentage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_CURRENT_POSITION_TILT_PERCENTAGE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_window_covering_current_position_tilt_percentage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INSTALLED_OPEN_LIMIT_LIFT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_installed_open_limit_lift_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INSTALLED_CLOSED_LIMIT_LIFT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_installed_closed_limit_lift_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INSTALLED_OPEN_LIMIT_TILT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_installed_open_limit_tilt_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INSTALLED_CLOSED_LIMIT_TILT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_installed_closed_limit_tilt_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_VELOCITY_LIFT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_velocity_lift_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_ACCELERATION_TIME_LIFT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_acceleration_time_lift_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_DECELERATION_TIME_LIFT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_window_covering_deceleration_time_lift_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_window_covering_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INTERMEDIATE_SETPOINTS_LIFT:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_window_covering_intermediate_setpoints_lift_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INTERMEDIATE_SETPOINTS_TILT:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_window_covering_intermediate_setpoints_tilt_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_window_covering_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_thermostat_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_local_temperature_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OUTDOOR_TEMPERATURE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_outdoor_temperature_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPANCY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_occupancy_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MIN_HEAT_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_abs_min_heat_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MAX_HEAT_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_abs_max_heat_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MIN_COOL_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_abs_min_cool_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MAX_COOL_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_abs_max_cool_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_PI_COOLING_DEMAND:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_pi_cooling_demand_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_PI_HEATING_DEMAND:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_pi_heating_demand_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_HVAC_SYSTEM_TYPE_CONFIGURATION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_hvac_system_type_configuration_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE_CALIBRATION:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_thermostat_local_temperature_calibration_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_COOLING_SETPOINT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_occupied_cooling_setpoint_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_HEATING_SETPOINT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_occupied_heating_setpoint_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_COOLING_SETPOINT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_unoccupied_cooling_setpoint_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_HEATING_SETPOINT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_unoccupied_heating_setpoint_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_HEAT_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_min_heat_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_HEAT_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_max_heat_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_COOL_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_min_cool_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_COOL_SETPOINT_LIMIT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_max_cool_setpoint_limit_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_SETPOINT_DEAD_BAND:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_thermostat_min_setpoint_dead_band_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_REMOTE_SENSING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_remote_sensing_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_CONTROL_SEQUENCE_OF_OPERATION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_control_sequence_of_operation_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SYSTEM_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_system_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ALARM_MASK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_alarm_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_RUNNING_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_thermostat_running_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_START_OF_WEEK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_start_of_week_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_NUMBER_OF_WEEKLY_TRANSITIONS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_number_of_weekly_transitions_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_NUMBER_OF_DAILY_TRANSITIONS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_number_of_daily_transitions_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD_DURATION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_thermostat_temperature_setpoint_hold_duration_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_PROGRAMMING_OPERATION_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_thermostat_programming_operation_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_RUNNING_STATE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_thermostat_thermostat_running_state_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_SOURCE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_setpoint_change_source_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_AMOUNT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_setpoint_change_amount_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_SOURCE_TIMESTAMP:
      {
        UTC value;
        memcpy(&value, attr_value, sizeof(UTC));
        status = uic_mqtt_dotdot_thermostat_setpoint_change_source_timestamp_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_occupied_setback_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK_MIN:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_occupied_setback_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK_MAX:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_occupied_setback_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_unoccupied_setback_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK_MIN:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_unoccupied_setback_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK_MAX:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_unoccupied_setback_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_EMERGENCY_HEAT_DELTA:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_emergency_heat_delta_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_ac_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_thermostat_ac_capacity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_REFRIGERANT_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_ac_refrigerant_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COMPRESSOR_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_ac_compressor_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_ERROR_CODE:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_thermostat_ac_error_code_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_LOUVER_POSITION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_ac_louver_position_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COIL_TEMPERATURE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_thermostat_ac_coil_temperature_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY_FORMAT:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_thermostat_ac_capacity_format_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_thermostat_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_color_control_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENT_HUE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_current_hue_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENT_SATURATION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_current_saturation_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_REMAINING_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_remaining_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENTX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_currentx_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENTY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_currenty_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_DRIFT_COMPENSATION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_drift_compensation_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COMPENSATION_TEXT:
      {
        // NOTE: the first byte is the string length
        uint8_t value_strlen = *attr_value;
        char value[value_strlen + 1];
        memcpy(value, attr_value + 1, sizeof(char) * value_strlen);
        value[value_strlen] = '\0';
        status = uic_mqtt_dotdot_color_control_compensation_text_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMPERATURE_MIREDS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_temperature_mireds_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_OPTIONS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_options_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_NUMBER_OF_PRIMARIES:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_number_of_primaries_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary1x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary1y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary1_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary2x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary2y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary2_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary3x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary3y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary3_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary4x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary4y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary4_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary5x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary5y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary5_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6X:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary6x_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6Y:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_primary6y_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_primary6_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_white_pointx_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_white_pointy_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointrx_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointry_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTR_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_pointr_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointgx_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointgy_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTG_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_pointg_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointbx_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_pointby_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTB_INTENSITY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_pointb_intensity_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_ENHANCED_CURRENT_HUE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_enhanced_current_hue_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_ENHANCED_COLOR_MODE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_enhanced_color_mode_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_ACTIVE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_loop_active_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_DIRECTION:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_color_control_color_loop_direction_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_TIME:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_loop_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_START_ENHANCED_HUE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_loop_start_enhanced_hue_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_STORED_ENHANCED_HUE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_loop_stored_enhanced_hue_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_CAPABILITIES:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_capabilities_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMP_PHYSICAL_MIN_MIREDS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_temp_physical_min_mireds_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMP_PHYSICAL_MAX_MIREDS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_color_temp_physical_max_mireds_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_couple_color_temp_to_level_min_mireds_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_START_UP_COLOR_TEMPERATURE_MIREDS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_color_control_start_up_color_temperature_mireds_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_color_control_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_temperature_measurement_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT_ATTR_MEASURED_VALUE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_temperature_measurement_measured_value_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT_ATTR_MIN_MEASURED_VALUE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_temperature_measurement_min_measured_value_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT_ATTR_MAX_MEASURED_VALUE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_temperature_measurement_max_measured_value_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT_ATTR_TOLERANCE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_temperature_measurement_tolerance_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_temperature_measurement_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_occupancy_sensing_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_occupancy_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY_SENSOR_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY_SENSOR_TYPE_BITMAP:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_occupancy_sensor_type_bitmap_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_pir_occupied_to_unoccupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_pir_unoccupied_to_occupied_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_ultrasonic_occupied_to_unoccupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_ultrasonic_unoccupied_to_occupied_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_physical_contact_occupied_to_unoccupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_delay_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_occupancy_sensing_physical_contact_unoccupied_to_occupied_threshold_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_occupancy_sensing_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_ias_zone_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONE_STATE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_ias_zone_zone_state_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONE_TYPE:
      {
        IasZoneType value;
        memcpy(&value, attr_value, sizeof(IasZoneType));
        status = uic_mqtt_dotdot_ias_zone_zone_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONE_STATUS:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_ias_zone_zone_status_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_IASCIE_ADDRESS:
      {
        EUI64 value;
        memcpy(&value, attr_value, sizeof(EUI64));
        status = uic_mqtt_dotdot_ias_zone_iascie_address_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONEID:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_ias_zone_zoneid_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_ias_zone_number_of_zone_sensitivity_levels_supported_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_CURRENT_ZONE_SENSITIVITY_LEVEL:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_ias_zone_current_zone_sensitivity_level_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_ias_zone_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_iaswd_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_IASWD_ATTR_MAX_DURATION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_iaswd_max_duration_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_iaswd_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_metering_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_SUMMATION_DELIVERED:
      {
        uint64_t value;
        memcpy(&value, attr_value, sizeof(uint64_t));
        status = uic_mqtt_dotdot_metering_current_summation_delivered_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_SUMMATION_RECEIVED:
      {
        uint64_t value;
        memcpy(&value, attr_value, sizeof(uint64_t));
        status = uic_mqtt_dotdot_metering_current_summation_received_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_MAX_DEMAND_DELIVERED:
      {
        uint64_t value;
        memcpy(&value, attr_value, sizeof(uint64_t));
        status = uic_mqtt_dotdot_metering_current_max_demand_delivered_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_MAX_DEMAND_RECEIVED:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_metering_current_max_demand_received_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_POWER_FACTOR:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_metering_power_factor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_READING_SNAP_SHOT_TIME:
      {
        UTC value;
        memcpy(&value, attr_value, sizeof(UTC));
        status = uic_mqtt_dotdot_metering_reading_snap_shot_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_MAX_DEMAND_DELIVERED_TIME:
      {
        UTC value;
        memcpy(&value, attr_value, sizeof(UTC));
        status = uic_mqtt_dotdot_metering_current_max_demand_delivered_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_MAX_DEMAND_RECEIVED_TIME:
      {
        UTC value;
        memcpy(&value, attr_value, sizeof(UTC));
        status = uic_mqtt_dotdot_metering_current_max_demand_received_time_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_DEFAULT_UPDATE_PERIOD:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_default_update_period_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_SUPPLY_STATUS:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_supply_status_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_INLET_ENERGY_CARRIER_SUMMATION:
      {
        uint64_t value;
        memcpy(&value, attr_value, sizeof(uint64_t));
        status = uic_mqtt_dotdot_metering_current_inlet_energy_carrier_summation_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION:
      {
        uint64_t value;
        memcpy(&value, attr_value, sizeof(uint64_t));
        status = uic_mqtt_dotdot_metering_current_outlet_energy_carrier_summation_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_INLET_TEMPERATURE:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_metering_inlet_temperature_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_OUTLET_TEMPERATURE:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_metering_outlet_temperature_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_UNITOF_MEASURE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_unitof_measure_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_MULTIPLIER:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_metering_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_DIVISOR:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_metering_divisor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_SUMMATION_FORMATTING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_summation_formatting_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_DEMAND_FORMATTING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_demand_formatting_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_HISTORICAL_CONSUMPTION_FORMATTING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_historical_consumption_formatting_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_METERING_DEVICE_TYPE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_metering_device_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_ENERGY_CARRIER_UNIT_OF_MEASURE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_energy_carrier_unit_of_measure_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_ENERGY_CARRIER_SUMMATION_FORMATTING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_energy_carrier_summation_formatting_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_ENERGY_CARRIER_DEMAND_FORMATTING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_energy_carrier_demand_formatting_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_TEMPERATURE_UNIT_OF_MEASURE:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_temperature_unit_of_measure_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_METERING_ATTR_TEMPERATURE_FORMATTING:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_metering_temperature_formatting_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 1) {
          value = 1; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_metering_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}
sl_status_t zigpc_attrmgmt_electrical_measurement_publish(const char* unid_ep_topic, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  sl_status_t status = SL_STATUS_OK;

  // NOTE: Only server cluster attributes are supported to be published
  switch(attr_id) {
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASUREMENT_TYPE:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_electrical_measurement_measurement_type_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE_MIN:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_voltage_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE_MAX:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_voltage_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT_MIN:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_current_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT_MAX:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_current_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_POWER:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_power_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_POWER_MIN:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_power_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_POWER_MAX:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_power_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE_MULTIPLIER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_voltage_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE_DIVISOR:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_voltage_divisor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT_MULTIPLIER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_current_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT_DIVISOR:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_current_divisor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_POWER_MULTIPLIER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_power_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_POWER_DIVISOR:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_power_divisor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_FREQUENCY:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_frequency_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_FREQUENCY_MIN:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_frequency_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_FREQUENCY_MAX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_frequency_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_NEUTRAL_CURRENT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_neutral_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_TOTAL_ACTIVE_POWER:
      {
        int32_t value;
        memcpy(&value, attr_value, sizeof(int32_t));
        status = uic_mqtt_dotdot_electrical_measurement_total_active_power_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_TOTAL_REACTIVE_POWER:
      {
        int32_t value;
        memcpy(&value, attr_value, sizeof(int32_t));
        status = uic_mqtt_dotdot_electrical_measurement_total_reactive_power_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_TOTAL_APPARENT_POWER:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_electrical_measurement_total_apparent_power_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED1ST_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured1st_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED3RD_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured3rd_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED5TH_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured5th_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED7TH_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured7th_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED9TH_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured9th_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED11TH_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured11th_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE1ST_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured_phase1st_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE3RD_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured_phase3rd_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE5TH_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured_phase5th_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE7TH_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured_phase7th_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE9TH_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured_phase9th_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE11TH_HARMONIC_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_measured_phase11th_harmonic_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_FREQUENCY_MULTIPLIER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_frequency_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_FREQUENCY_DIVISOR:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_frequency_divisor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_POWER_MULTIPLIER:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_electrical_measurement_power_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_POWER_DIVISOR:
      {
        uint32_t value;
        memcpy(&value, attr_value, sizeof(uint32_t));
        status = uic_mqtt_dotdot_electrical_measurement_power_divisor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_HARMONIC_CURRENT_MULTIPLIER:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_electrical_measurement_harmonic_current_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_PHASE_HARMONIC_CURRENT_MULTIPLIER:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_electrical_measurement_phase_harmonic_current_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_LINE_CURRENT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_line_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_CURRENT:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_reactive_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MIN:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MAX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_current_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MIN:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_current_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MAX:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_current_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_power_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MIN:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_power_min_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MAX:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_power_max_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_POWER:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_reactive_power_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_APPARENT_POWER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_apparent_power_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_POWER_FACTOR:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_electrical_measurement_power_factor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE_COUNTER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE_PERIOD:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE_PERIOD:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG_PERIOD:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL_PERIOD:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_VOLTAGE_MULTIPLIER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_voltage_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_VOLTAGE_DIVISOR:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_voltage_divisor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_CURRENT_MULTIPLIER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_current_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_CURRENT_DIVISOR:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_current_divisor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_POWER_MULTIPLIER:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_power_multiplier_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_POWER_DIVISOR:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_power_divisor_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_OVERLOAD_ALARMS_MASK:
      {
        uint8_t value;
        memcpy(&value, attr_value, sizeof(uint8_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_overload_alarms_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE_OVERLOAD:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_voltage_overload_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT_OVERLOAD:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_dc_current_overload_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_ALARMS_MASK:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_alarms_mask_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_VOLTAGE_OVERLOAD:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_voltage_overload_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_CURRENT_OVERLOAD:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_current_overload_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_ACTIVE_POWER_OVERLOAD:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_active_power_overload_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_REACTIVE_POWER_OVERLOAD:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_ac_reactive_power_overload_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_LINE_CURRENT_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_line_current_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_CURRENT_PHB:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_current_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_CURRENT_PHB:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_reactive_current_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MIN_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MAX_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_current_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MIN_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_current_min_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MAX_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_current_max_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_PHB:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_power_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MIN_PHB:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_power_min_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MAX_PHB:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_power_max_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_POWER_PHB:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_reactive_power_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_APPARENT_POWER_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_apparent_power_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_POWER_FACTOR_PHB:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_electrical_measurement_power_factor_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG_PERIOD_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL_PERIOD_PHB:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phb_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_LINE_CURRENT_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_line_current_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_CURRENT_PHC:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_current_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_CURRENT_PHC:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_reactive_current_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MIN_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_min_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MAX_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_max_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_current_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MIN_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_current_min_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MAX_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_current_max_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_PHC:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_power_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MIN_PHC:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_power_min_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MAX_PHC:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_active_power_max_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_POWER_PHC:
      {
        int16_t value;
        memcpy(&value, attr_value, sizeof(int16_t));
        status = uic_mqtt_dotdot_electrical_measurement_reactive_power_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_APPARENT_POWER_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_apparent_power_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_POWER_FACTOR_PHC:
      {
        int8_t value;
        memcpy(&value, attr_value, sizeof(int8_t));
        status = uic_mqtt_dotdot_electrical_measurement_power_factor_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_voltage_measurement_period_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_over_voltage_counter_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_average_rms_under_voltage_counter_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_extreme_over_voltage_period_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_extreme_under_voltage_period_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG_PERIOD_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_sag_period_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL_PERIOD_PHC:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        status = uic_mqtt_dotdot_electrical_measurement_rms_voltage_swell_period_phc_publish(unid_ep_topic, value, UCL_MQTT_PUBLISH_TYPE_REPORTED);
      }
      break;
    case ZIGPC_ZCL_GLOBAL_ATTR_CLUSTER_REVISION:
      {
        uint16_t value;
        memcpy(&value, attr_value, sizeof(uint16_t));
        if (value > 2) {
          value = 2; // take min of: device-reported vs. dotdot-spec-based
        }
        uic_mqtt_dotdot_electrical_measurement_publish_cluster_revision(unid_ep_topic, value);
      }
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  return status;
}

sl_status_t zigpc_attrmgmt_publish_reported(const zigbee_eui64_uint_t eui64, const zigbee_endpoint_id_t endpoint_id, const zcl_cluster_id_t cluster_id, const zcl_attribute_id_t attr_id, const uint8_t *attr_value)
{
  zigpc_ucl::mqtt::topic_data_t topic_data = {
    .eui64 = eui64,
    .endpoint_id = endpoint_id,
  };

  std::string unid_ep_topic;
  sl_status_t status = zigpc_ucl::mqtt::build_topic(
    zigpc_ucl::mqtt::topic_type_t::BY_UNID_NODE_EP,
    topic_data,
    unid_ep_topic);
  if (status != SL_STATUS_OK) {
    sl_log_error(LOG_TAG, "Failed to build topic for publishing attribute update: 0x%X",status);
    return status;
  }

  switch(cluster_id) {
    case ZIGPC_ZCL_CLUSTER_BASIC:
      status = zigpc_attrmgmt_basic_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION:
      status = zigpc_attrmgmt_power_configuration_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_IDENTIFY:
      status = zigpc_attrmgmt_identify_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_GROUPS:
      status = zigpc_attrmgmt_groups_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_ON_OFF:
      status = zigpc_attrmgmt_on_off_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_LEVEL:
      status = zigpc_attrmgmt_level_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL:
      status = zigpc_attrmgmt_poll_control_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK:
      status = zigpc_attrmgmt_door_lock_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_WINDOW_COVERING:
      status = zigpc_attrmgmt_window_covering_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT:
      status = zigpc_attrmgmt_thermostat_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_COLOR_CONTROL:
      status = zigpc_attrmgmt_color_control_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT:
      status = zigpc_attrmgmt_temperature_measurement_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING:
      status = zigpc_attrmgmt_occupancy_sensing_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_IAS_ZONE:
      status = zigpc_attrmgmt_ias_zone_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_IASWD:
      status = zigpc_attrmgmt_iaswd_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_METERING:
      status = zigpc_attrmgmt_metering_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    case ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT:
      status = zigpc_attrmgmt_electrical_measurement_publish(unid_ep_topic.c_str(), attr_id, attr_value);
      break;
    default:
      status = SL_STATUS_NOT_FOUND;
      break;
  }

  sl_log_info(LOG_TAG, "Unid:%s,Ep:%u,Cluster:0x%04X,Attr:0x%04X Reported publish status: 0x%X",
              zigpc_ucl::mqtt::build_unid(eui64).c_str(), endpoint_id, cluster_id, attr_id, status);

  return status;
}
