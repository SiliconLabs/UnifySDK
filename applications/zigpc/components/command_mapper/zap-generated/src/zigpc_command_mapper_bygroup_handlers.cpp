/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.




// TODO: Investigate using 1 bygroup dispatch callback with ZCL types used

#include <list>
#include <vector>
#include <nlohmann/json.hpp>

// Unify shared components
#include <sl_log.h>
#include <sl_status.h>
#include <dotdot_mqtt_group_commands.h>

// ZigPC components
#include <zigpc_gateway.h>
#include <zigpc_common_zigbee.h>
#include <zcl_definitions.h>

// Internal includes
#include "zigpc_command_mapper_int.h"

static constexpr char LOG_TAG[] = "zigpc_cmdmapper";
static constexpr char LOG_FMT_INVALID_FIELDS[] = "%s::%s: Invalid fields passed in";
static constexpr char LOG_FMT_INVALID_FIELD_LIST[] = "%s::%s: Invalid %s list passed in";

extern void zigpc_command_mapper_populate_write_attr_record(
  std::vector<zigpc_zcl_frame_data_t> &write_attr_data,
  std::list<zcl_attribute_id_t> &attr_id_list,
  std::list<zigpc_zcl_data_type_t> &attr_data_type_list,
  zcl_attribute_id_t attribute_id,
  zigpc_zcl_data_type_t attribute_data_type,
  void *attribute_data
);

void zigpc_command_mapper_bygroup_identify_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_identify_state_t values,
  uic_mqtt_dotdot_identify_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (values_to_write.identify_time == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_IDENTIFY_ATTR_IDENTIFY_TIME,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.identify_time
    );
  }

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IDENTIFY,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



/**
 * @brief DotDot MQTT by-group handler for Identify/Identify command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_identify_identify_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_identify_command_identify_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "Identify", "IdentifyTime");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->identify_time });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_IDENTIFY,
    ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_IDENTIFY,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Identify/IdentifyQuery command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_identify_identify_query_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_IDENTIFY,
    ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_IDENTIFY_QUERY,
    0,
    nullptr
  );

}

/**
 * @brief DotDot MQTT by-group handler for Identify/TriggerEffect command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_identify_trigger_effect_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_identify_command_trigger_effect_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "TriggerEffect", "EffectIdentifier");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->effect_identifier });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->effect_variant });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_IDENTIFY,
    ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_TRIGGER_EFFECT,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

void zigpc_command_mapper_bygroup_groups_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_groups_state_t values,
  uic_mqtt_dotdot_groups_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



/**
 * @brief DotDot MQTT by-group handler for Groups/AddGroup command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_groups_add_group_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_groups_command_add_group_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "AddGroup", "GroupId");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->group_id });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_STRING, fields->group_name });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_GROUPS,
    ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_ADD_GROUP,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Groups/ViewGroup command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_groups_view_group_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_groups_command_view_group_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "ViewGroup", "GroupId");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->group_id });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_GROUPS,
    ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_VIEW_GROUP,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Groups/GetGroupMembership command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_groups_get_group_membership_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_groups_command_get_group_membership_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "GetGroupMembership", "GroupList");
  }
  if ((fields->group_list_count > 0U) && (fields->group_list == nullptr)) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELD_LIST, "Groups", "GetGroupMembership", "GroupList");
    return;
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->group_list_count });
  for(uint8_t i = 0U; i < fields->group_list_count; i++) {
    cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->group_list[i] });
  }

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_GROUPS,
    ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_GET_GROUP_MEMBERSHIP,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Groups/RemoveGroup command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_groups_remove_group_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_groups_command_remove_group_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "RemoveGroup", "GroupId");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->group_id });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_GROUPS,
    ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_REMOVE_GROUP,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Groups/RemoveAllGroups command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_groups_remove_all_groups_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_GROUPS,
    ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_REMOVE_ALL_GROUPS,
    0,
    nullptr
  );

}

/**
 * @brief DotDot MQTT by-group handler for Groups/AddGroupIfIdentifying command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_groups_add_group_if_identifying_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_groups_command_add_group_if_identifying_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "AddGroupIfIdentifying", "GroupId");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->group_id });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_STRING, fields->group_name });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_GROUPS,
    ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_ADD_GROUP_IF_IDENTIFYING,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

void zigpc_command_mapper_bygroup_on_off_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_on_off_state_t values,
  uic_mqtt_dotdot_on_off_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (values_to_write.on_time == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_TIME,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.on_time
    );
  }

  if (values_to_write.off_wait_time == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_OFF_WAIT_TIME,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.off_wait_time
    );
  }

  if (values_to_write.start_up_on_off == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_START_UP_ON_OFF,
      ZIGPC_ZCL_DATA_TYPE_ENUM8,
      &values.start_up_on_off
    );
  }

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



/**
 * @brief DotDot MQTT by-group handler for OnOff/Off command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_on_off_off_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_ON_OFF,
    ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_OFF,
    0,
    nullptr
  );

}

/**
 * @brief DotDot MQTT by-group handler for OnOff/On command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_on_off_on_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_ON_OFF,
    ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_ON,
    0,
    nullptr
  );

}

/**
 * @brief DotDot MQTT by-group handler for OnOff/Toggle command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_on_off_toggle_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_ON_OFF,
    ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_TOGGLE,
    0,
    nullptr
  );

}

/**
 * @brief DotDot MQTT by-group handler for OnOff/OffWithEffect command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_on_off_off_with_effect_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_on_off_command_off_with_effect_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "OffWithEffect", "EffectIdentifier");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->effect_identifier });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->effect_variant });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_ON_OFF,
    ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_OFF_WITH_EFFECT,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for OnOff/OnWithRecallGlobalScene command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_on_off_on_with_recall_global_scene_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_ON_OFF,
    ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_ON_WITH_RECALL_GLOBAL_SCENE,
    0,
    nullptr
  );

}

/**
 * @brief DotDot MQTT by-group handler for OnOff/OnWithTimedOff command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_on_off_on_with_timed_off_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_on_off_command_on_with_timed_off_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "OnWithTimedOff", "OnOffControl");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->on_off_control });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->on_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->off_wait_time });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_ON_OFF,
    ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_ON_WITH_TIMED_OFF,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

void zigpc_command_mapper_bygroup_level_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_level_state_t values,
  uic_mqtt_dotdot_level_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (values_to_write.options == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OPTIONS,
      ZIGPC_ZCL_DATA_TYPE_MAP8,
      &values.options
    );
  }

  if (values_to_write.on_off_transition_time == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_OFF_TRANSITION_TIME,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.on_off_transition_time
    );
  }

  if (values_to_write.on_level == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_LEVEL,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.on_level
    );
  }

  if (values_to_write.on_transition_time == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_TRANSITION_TIME,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.on_transition_time
    );
  }

  if (values_to_write.off_transition_time == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OFF_TRANSITION_TIME,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.off_transition_time
    );
  }

  if (values_to_write.default_move_rate == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_DEFAULT_MOVE_RATE,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.default_move_rate
    );
  }

  if (values_to_write.start_up_current_level == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_START_UP_CURRENT_LEVEL,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.start_up_current_level
    );
  }

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



/**
 * @brief DotDot MQTT by-group handler for Level/MoveToLevel command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_level_move_to_level_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_level_command_move_to_level_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveToLevel", "Level");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->level });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_LEVEL,
    ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_TO_LEVEL,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Level/Move command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_level_move_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_level_command_move_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "Move", "MoveMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_LEVEL,
    ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Level/Step command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_level_step_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_level_command_step_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "Step", "StepMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_LEVEL,
    ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STEP,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Level/Stop command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_level_stop_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_level_command_stop_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "Stop", "OptionsMask");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_LEVEL,
    ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STOP,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Level/MoveToLevelWithOnOff command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_level_move_to_level_with_on_off_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_level_command_move_to_level_with_on_off_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveToLevelWithOnOff", "Level");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->level });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_LEVEL,
    ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_TO_LEVEL_WITH_ON_OFF,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Level/MoveWithOnOff command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_level_move_with_on_off_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_level_command_move_with_on_off_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveWithOnOff", "MoveMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_LEVEL,
    ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_WITH_ON_OFF,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Level/StepWithOnOff command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_level_step_with_on_off_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_level_command_step_with_on_off_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "StepWithOnOff", "StepMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_LEVEL,
    ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STEP_WITH_ON_OFF,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Level/StopWithOnOff command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_level_stop_with_on_off_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_level_command_stop_with_on_off_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "StopWithOnOff", "OptionsMask");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_LEVEL,
    ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STOP_WITH_ON_OFF,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Level/MoveToClosestFrequency command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_level_move_to_closest_frequency_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_level_command_move_to_closest_frequency_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveToClosestFrequency", "Frequency");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->frequency });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_LEVEL,
    ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_TO_CLOSEST_FREQUENCY,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

void zigpc_command_mapper_bygroup_poll_control_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_poll_control_state_t values,
  uic_mqtt_dotdot_poll_control_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (values_to_write.check_in_interval == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL,
      ZIGPC_ZCL_DATA_TYPE_UINT32,
      &values.check_in_interval
    );
  }

  if (values_to_write.fast_poll_timeout == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.fast_poll_timeout
    );
  }

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



/**
 * @brief DotDot MQTT by-group handler for PollControl/CheckIn command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_poll_control_check_in_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_POLL_CONTROL,
    ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_CHECK_IN,
    0,
    nullptr
  );

}

void zigpc_command_mapper_bygroup_door_lock_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_door_lock_state_t values,
  uic_mqtt_dotdot_door_lock_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (values_to_write.door_open_events == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_OPEN_EVENTS,
      ZIGPC_ZCL_DATA_TYPE_UINT32,
      &values.door_open_events
    );
  }

  if (values_to_write.door_closed_events == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_CLOSED_EVENTS,
      ZIGPC_ZCL_DATA_TYPE_UINT32,
      &values.door_closed_events
    );
  }

  if (values_to_write.open_period == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPEN_PERIOD,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.open_period
    );
  }

  if (values_to_write.enable_logging == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOGGING,
      ZIGPC_ZCL_DATA_TYPE_BOOL,
      &values.enable_logging
    );
  }

  if (values_to_write.language == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LANGUAGE,
      ZIGPC_ZCL_DATA_TYPE_STRING,
      &values.language
    );
  }

  if (values_to_write.led_settings == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LED_SETTINGS,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.led_settings
    );
  }

  if (values_to_write.auto_relock_time == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_AUTO_RELOCK_TIME,
      ZIGPC_ZCL_DATA_TYPE_UINT32,
      &values.auto_relock_time
    );
  }

  if (values_to_write.sound_volume == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SOUND_VOLUME,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.sound_volume
    );
  }

  if (values_to_write.operating_mode == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPERATING_MODE,
      ZIGPC_ZCL_DATA_TYPE_ENUM8,
      &values.operating_mode
    );
  }

  if (values_to_write.enable_local_programming == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOCAL_PROGRAMMING,
      ZIGPC_ZCL_DATA_TYPE_BOOL,
      &values.enable_local_programming
    );
  }

  if (values_to_write.enable_one_touch_locking == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_ONE_TOUCH_LOCKING,
      ZIGPC_ZCL_DATA_TYPE_BOOL,
      &values.enable_one_touch_locking
    );
  }

  if (values_to_write.enable_inside_statusled == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_INSIDE_STATUSLED,
      ZIGPC_ZCL_DATA_TYPE_BOOL,
      &values.enable_inside_statusled
    );
  }

  if (values_to_write.enable_privacy_mode_button == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_PRIVACY_MODE_BUTTON,
      ZIGPC_ZCL_DATA_TYPE_BOOL,
      &values.enable_privacy_mode_button
    );
  }

  if (values_to_write.wrong_code_entry_limit == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_WRONG_CODE_ENTRY_LIMIT,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.wrong_code_entry_limit
    );
  }

  if (values_to_write.user_code_temporary_disable_time == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_USER_CODE_TEMPORARY_DISABLE_TIME,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.user_code_temporary_disable_time
    );
  }

  if (values_to_write.sendpin_over_the_air == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SENDPIN_OVER_THE_AIR,
      ZIGPC_ZCL_DATA_TYPE_BOOL,
      &values.sendpin_over_the_air
    );
  }

  if (values_to_write.requirepi_nforrf_operation == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_REQUIREPI_NFORRF_OPERATION,
      ZIGPC_ZCL_DATA_TYPE_BOOL,
      &values.requirepi_nforrf_operation
    );
  }

  if (values_to_write.alarm_mask == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ALARM_MASK,
      ZIGPC_ZCL_DATA_TYPE_MAP16,
      &values.alarm_mask
    );
  }

  if (values_to_write.keypad_operation_event_mask == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_OPERATION_EVENT_MASK,
      ZIGPC_ZCL_DATA_TYPE_MAP16,
      &values.keypad_operation_event_mask
    );
  }

  if (values_to_write.rf_operation_event_mask == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_OPERATION_EVENT_MASK,
      ZIGPC_ZCL_DATA_TYPE_MAP16,
      &values.rf_operation_event_mask
    );
  }

  if (values_to_write.manual_operation_event_mask == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MANUAL_OPERATION_EVENT_MASK,
      ZIGPC_ZCL_DATA_TYPE_MAP16,
      &values.manual_operation_event_mask
    );
  }

  if (values_to_write.rfid_operation_event_mask == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_OPERATION_EVENT_MASK,
      ZIGPC_ZCL_DATA_TYPE_MAP16,
      &values.rfid_operation_event_mask
    );
  }

  if (values_to_write.keypad_programming_event_mask == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_PROGRAMMING_EVENT_MASK,
      ZIGPC_ZCL_DATA_TYPE_MAP16,
      &values.keypad_programming_event_mask
    );
  }

  if (values_to_write.rf_programming_event_mask == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_PROGRAMMING_EVENT_MASK,
      ZIGPC_ZCL_DATA_TYPE_MAP16,
      &values.rf_programming_event_mask
    );
  }

  if (values_to_write.rfid_programming_event_mask == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_PROGRAMMING_EVENT_MASK,
      ZIGPC_ZCL_DATA_TYPE_MAP16,
      &values.rfid_programming_event_mask
    );
  }

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



/**
 * @brief DotDot MQTT by-group handler for DoorLock/LockDoor command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_lock_door_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_lock_door_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "LockDoor", "PINOrRFIDCode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, fields->pin_orrfid_code });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_LOCK_DOOR,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/UnlockDoor command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_unlock_door_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_unlock_door_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "UnlockDoor", "PINOrRFIDCode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, fields->pin_orrfid_code });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_DOOR,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/Toggle command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_toggle_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_toggle_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "Toggle", "PINOrRFIDCode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, fields->pin_orrfid_code });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_TOGGLE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/UnlockWithTimeout command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_unlock_with_timeout_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_unlock_with_timeout_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "UnlockWithTimeout", "TimeoutInSeconds");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->timeout_in_seconds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, fields->pin_orrfid_code });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_WITH_TIMEOUT,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/GetLogRecord command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_get_log_record_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_get_log_record_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "GetLogRecord", "LogIndex");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->log_index });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_LOG_RECORD,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/SetPINCode command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_setpin_code_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_setpin_code_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "SetPINCode", "UserID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->user_status });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->user_type });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, fields->pin });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SETPIN_CODE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/GetPINCode command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_getpin_code_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_getpin_code_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "GetPINCode", "UserID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GETPIN_CODE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/ClearPINCode command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_clearpin_code_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_clearpin_code_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "ClearPINCode", "UserID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEARPIN_CODE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/ClearAllPINCodes command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_door_lock_clear_allpin_codes_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALLPIN_CODES,
    0,
    nullptr
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/SetUserStatus command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_set_user_status_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_set_user_status_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "SetUserStatus", "UserID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->user_status });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_STATUS,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/GetUserStatus command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_get_user_status_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_get_user_status_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "GetUserStatus", "UserID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_STATUS,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/SetWeekdaySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_set_weekday_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_set_weekday_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "SetWeekdaySchedule", "ScheduleID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->days_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->start_hour });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->start_minute });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->end_hour });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->end_minute });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_WEEKDAY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/GetWeekdaySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_get_weekday_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_get_weekday_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "GetWeekdaySchedule", "ScheduleID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_WEEKDAY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/ClearWeekdaySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_clear_weekday_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_weekday_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "ClearWeekdaySchedule", "ScheduleID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_WEEKDAY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/SetYearDaySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_set_year_day_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_set_year_day_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "SetYearDaySchedule", "ScheduleID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &fields->local_start_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &fields->local_end_time });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_YEAR_DAY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/GetYearDaySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_get_year_day_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_get_year_day_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "GetYearDaySchedule", "ScheduleID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_YEAR_DAY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/ClearYearDaySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_clear_year_day_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_year_day_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "ClearYearDaySchedule", "ScheduleID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_YEAR_DAY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/SetHolidaySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_set_holiday_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_set_holiday_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "SetHolidaySchedule", "HolidayScheduleID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->holiday_scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &fields->local_start_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &fields->local_end_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->operating_mode_during_holiday });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_HOLIDAY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/GetHolidaySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_get_holiday_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_get_holiday_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "GetHolidaySchedule", "HolidayScheduleID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->holiday_scheduleid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_HOLIDAY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/ClearHolidaySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_clear_holiday_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_clear_holiday_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "ClearHolidaySchedule", "HolidayScheduleID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->holiday_scheduleid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_HOLIDAY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/SetUserType command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_set_user_type_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_set_user_type_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "SetUserType", "UserID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->user_type });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_TYPE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/GetUserType command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_get_user_type_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_get_user_type_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "GetUserType", "UserID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_TYPE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/SetRFIDCode command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_setrfid_code_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_setrfid_code_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "SetRFIDCode", "UserID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->user_status });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->user_type });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, fields->rfid_code });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SETRFID_CODE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/GetRFIDCode command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_getrfid_code_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_getrfid_code_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "GetRFIDCode", "UserID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GETRFID_CODE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/ClearRFIDCode command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_door_lock_clearrfid_code_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_door_lock_command_clearrfid_code_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "ClearRFIDCode", "UserID");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->userid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEARRFID_CODE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/ClearAllRFIDCodes command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_door_lock_clear_allrfid_codes_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALLRFID_CODES,
    0,
    nullptr
  );
/**
 * @brief DotDot MQTT by-group handler for DoorLock/GetAllPINCodes command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_door_lock_get_all_pin_codes_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_ALL_PIN_CODES,
    0,
    nullptr
  );

}


}

/**
 * @brief DotDot MQTT by-group handler for DoorLock/GetAllPINCodes command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_door_lock_get_allpin_codes_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_ALLPIN_CODES,
    0,
    nullptr
  );

}

void zigpc_command_mapper_bygroup_thermostat_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_thermostat_state_t values,
  uic_mqtt_dotdot_thermostat_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (values_to_write.hvac_system_type_configuration == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_HVAC_SYSTEM_TYPE_CONFIGURATION,
      ZIGPC_ZCL_DATA_TYPE_MAP8,
      &values.hvac_system_type_configuration
    );
  }

  if (values_to_write.local_temperature_calibration == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE_CALIBRATION,
      ZIGPC_ZCL_DATA_TYPE_INT8,
      &values.local_temperature_calibration
    );
  }

  if (values_to_write.occupied_cooling_setpoint == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_COOLING_SETPOINT,
      ZIGPC_ZCL_DATA_TYPE_INT16,
      &values.occupied_cooling_setpoint
    );
  }

  if (values_to_write.occupied_heating_setpoint == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_HEATING_SETPOINT,
      ZIGPC_ZCL_DATA_TYPE_INT16,
      &values.occupied_heating_setpoint
    );
  }

  if (values_to_write.unoccupied_cooling_setpoint == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_COOLING_SETPOINT,
      ZIGPC_ZCL_DATA_TYPE_INT16,
      &values.unoccupied_cooling_setpoint
    );
  }

  if (values_to_write.unoccupied_heating_setpoint == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_HEATING_SETPOINT,
      ZIGPC_ZCL_DATA_TYPE_INT16,
      &values.unoccupied_heating_setpoint
    );
  }

  if (values_to_write.min_heat_setpoint_limit == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_HEAT_SETPOINT_LIMIT,
      ZIGPC_ZCL_DATA_TYPE_INT16,
      &values.min_heat_setpoint_limit
    );
  }

  if (values_to_write.max_heat_setpoint_limit == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_HEAT_SETPOINT_LIMIT,
      ZIGPC_ZCL_DATA_TYPE_INT16,
      &values.max_heat_setpoint_limit
    );
  }

  if (values_to_write.min_cool_setpoint_limit == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_COOL_SETPOINT_LIMIT,
      ZIGPC_ZCL_DATA_TYPE_INT16,
      &values.min_cool_setpoint_limit
    );
  }

  if (values_to_write.max_cool_setpoint_limit == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_COOL_SETPOINT_LIMIT,
      ZIGPC_ZCL_DATA_TYPE_INT16,
      &values.max_cool_setpoint_limit
    );
  }

  if (values_to_write.min_setpoint_dead_band == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_SETPOINT_DEAD_BAND,
      ZIGPC_ZCL_DATA_TYPE_INT8,
      &values.min_setpoint_dead_band
    );
  }

  if (values_to_write.remote_sensing == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_REMOTE_SENSING,
      ZIGPC_ZCL_DATA_TYPE_MAP8,
      &values.remote_sensing
    );
  }

  if (values_to_write.control_sequence_of_operation == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_CONTROL_SEQUENCE_OF_OPERATION,
      ZIGPC_ZCL_DATA_TYPE_ENUM8,
      &values.control_sequence_of_operation
    );
  }

  if (values_to_write.system_mode == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SYSTEM_MODE,
      ZIGPC_ZCL_DATA_TYPE_ENUM8,
      &values.system_mode
    );
  }

  if (values_to_write.temperature_setpoint_hold == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD,
      ZIGPC_ZCL_DATA_TYPE_ENUM8,
      &values.temperature_setpoint_hold
    );
  }

  if (values_to_write.temperature_setpoint_hold_duration == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD_DURATION,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.temperature_setpoint_hold_duration
    );
  }

  if (values_to_write.thermostat_programming_operation_mode == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_PROGRAMMING_OPERATION_MODE,
      ZIGPC_ZCL_DATA_TYPE_MAP8,
      &values.thermostat_programming_operation_mode
    );
  }

  if (values_to_write.occupied_setback == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.occupied_setback
    );
  }

  if (values_to_write.unoccupied_setback == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.unoccupied_setback
    );
  }

  if (values_to_write.emergency_heat_delta == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_EMERGENCY_HEAT_DELTA,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.emergency_heat_delta
    );
  }

  if (values_to_write.ac_type == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_TYPE,
      ZIGPC_ZCL_DATA_TYPE_ENUM8,
      &values.ac_type
    );
  }

  if (values_to_write.ac_capacity == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.ac_capacity
    );
  }

  if (values_to_write.ac_refrigerant_type == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_REFRIGERANT_TYPE,
      ZIGPC_ZCL_DATA_TYPE_ENUM8,
      &values.ac_refrigerant_type
    );
  }

  if (values_to_write.ac_compressor_type == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COMPRESSOR_TYPE,
      ZIGPC_ZCL_DATA_TYPE_ENUM8,
      &values.ac_compressor_type
    );
  }

  if (values_to_write.ac_error_code == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_ERROR_CODE,
      ZIGPC_ZCL_DATA_TYPE_MAP32,
      &values.ac_error_code
    );
  }

  if (values_to_write.ac_louver_position == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_LOUVER_POSITION,
      ZIGPC_ZCL_DATA_TYPE_ENUM8,
      &values.ac_louver_position
    );
  }

  if (values_to_write.ac_capacity_format == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY_FORMAT,
      ZIGPC_ZCL_DATA_TYPE_ENUM8,
      &values.ac_capacity_format
    );
  }

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



/**
 * @brief DotDot MQTT by-group handler for Thermostat/SetpointRaiseOrLower command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_thermostat_setpoint_raise_or_lower_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_thermostat_command_setpoint_raise_or_lower_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "SetpointRaiseOrLower", "Mode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT8, &fields->amount });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_THERMOSTAT,
    ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_SETPOINT_RAISE_OR_LOWER,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Thermostat/SetWeeklySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_thermostat_set_weekly_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_thermostat_command_set_weekly_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "SetWeeklySchedule", "NumberOfTransitions");
  }
  if ((fields->transitions_count > 0U) && (fields->transitions == nullptr)) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELD_LIST, "Thermostat", "SetWeeklySchedule", "Transitions");
    return;
  }

  std::vector< zigpc_zcl_transition_type_t > zigpc_transitions_vec;

  for(uint8_t i = 0; i < fields->transitions_count; i++) {
    zigpc_transitions_vec.push_back({
      .transition_time = fields->transitions[i].TransitionTime,
      .heat_set_point = fields->transitions[i].HeatSetPoint,
      .cool_set_point = fields->transitions[i].CoolSetPoint,
    });
  }

  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->number_of_transitions });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->day_of_week });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->mode });
  for(uint8_t i = 0U; i < fields->transitions_count; i++) {
    cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_STRUCT_TRANSITION_TYPE, &zigpc_transitions_vec[i] });
  }

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_THERMOSTAT,
    ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_SET_WEEKLY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Thermostat/GetWeeklySchedule command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_thermostat_get_weekly_schedule_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_thermostat_command_get_weekly_schedule_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "GetWeeklySchedule", "DaysToReturn");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->days_to_return });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->mode_to_return });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_THERMOSTAT,
    ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_WEEKLY_SCHEDULE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for Thermostat/ClearWeeklySchedule command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_thermostat_clear_weekly_schedule_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_THERMOSTAT,
    ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_CLEAR_WEEKLY_SCHEDULE,
    0,
    nullptr
  );

}

/**
 * @brief DotDot MQTT by-group handler for Thermostat/GetRelayStatusLog command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_thermostat_get_relay_status_log_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_THERMOSTAT,
    ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_RELAY_STATUS_LOG,
    0,
    nullptr
  );

}

void zigpc_command_mapper_bygroup_color_control_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_color_control_state_t values,
  uic_mqtt_dotdot_color_control_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (values_to_write.options == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_OPTIONS,
      ZIGPC_ZCL_DATA_TYPE_MAP8,
      &values.options
    );
  }

  if (values_to_write.white_pointx == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTX,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.white_pointx
    );
  }

  if (values_to_write.white_pointy == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.white_pointy
    );
  }

  if (values_to_write.color_pointrx == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRX,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.color_pointrx
    );
  }

  if (values_to_write.color_pointry == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.color_pointry
    );
  }

  if (values_to_write.color_pointr_intensity == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTR_INTENSITY,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.color_pointr_intensity
    );
  }

  if (values_to_write.color_pointgx == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGX,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.color_pointgx
    );
  }

  if (values_to_write.color_pointgy == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.color_pointgy
    );
  }

  if (values_to_write.color_pointg_intensity == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTG_INTENSITY,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.color_pointg_intensity
    );
  }

  if (values_to_write.color_pointbx == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBX,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.color_pointbx
    );
  }

  if (values_to_write.color_pointby == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.color_pointby
    );
  }

  if (values_to_write.color_pointb_intensity == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTB_INTENSITY,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.color_pointb_intensity
    );
  }

  if (values_to_write.start_up_color_temperature_mireds == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_START_UP_COLOR_TEMPERATURE_MIREDS,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.start_up_color_temperature_mireds
    );
  }

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



/**
 * @brief DotDot MQTT by-group handler for ColorControl/MoveToHue command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_move_to_hue_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveToHue", "Hue");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->direction });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_HUE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/MoveHue command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_move_hue_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_move_hue_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveHue", "MoveMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_HUE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/StepHue command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_step_hue_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_step_hue_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "StepHue", "StepMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_HUE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/MoveToSaturation command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_move_to_saturation_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_move_to_saturation_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveToSaturation", "Saturation");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->saturation });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_SATURATION,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/MoveSaturation command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_move_saturation_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_move_saturation_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveSaturation", "MoveMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_SATURATION,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/StepSaturation command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_step_saturation_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_step_saturation_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "StepSaturation", "StepMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_SATURATION,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/MoveToHueAndSaturation command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_move_to_hue_and_saturation_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_move_to_hue_and_saturation_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveToHueAndSaturation", "Hue");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->saturation });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_HUE_AND_SATURATION,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/MoveToColor command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_move_to_color_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_move_to_color_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveToColor", "ColorX");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->colorx });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->colory });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_COLOR,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/MoveColor command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_move_color_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_move_color_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveColor", "RateX");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &fields->ratex });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &fields->ratey });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_COLOR,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/StepColor command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_step_color_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_step_color_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "StepColor", "StepX");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &fields->stepx });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &fields->stepy });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_COLOR,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/MoveToColorTemperature command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_move_to_color_temperature_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_move_to_color_temperature_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveToColorTemperature", "ColorTemperatureMireds");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->color_temperature_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_COLOR_TEMPERATURE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/EnhancedMoveToHue command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_enhanced_move_to_hue_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "EnhancedMoveToHue", "EnhancedHue");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->enhanced_hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->direction });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_MOVE_TO_HUE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/EnhancedMoveHue command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_enhanced_move_hue_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_hue_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "EnhancedMoveHue", "MoveMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_MOVE_HUE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/EnhancedStepHue command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_enhanced_step_hue_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_enhanced_step_hue_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "EnhancedStepHue", "StepMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_STEP_HUE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/EnhancedMoveToHueAndSaturation command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_enhanced_move_to_hue_and_saturation_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_enhanced_move_to_hue_and_saturation_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "EnhancedMoveToHueAndSaturation", "EnhancedHue");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->enhanced_hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->saturation });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_MOVE_TO_HUE_AND_SATURATION,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/ColorLoopSet command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_color_loop_set_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_color_loop_set_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "ColorLoopSet", "UpdateFlags");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->update_flags });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->action });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->direction });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->start_hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_COLOR_LOOP_SET,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/StopMoveStep command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_stop_move_step_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_stop_move_step_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "StopMoveStep", "OptionsMask");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STOP_MOVE_STEP,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/MoveColorTemperature command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_move_color_temperature_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_move_color_temperature_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "MoveColorTemperature", "MoveMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->color_temperature_minimum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->color_temperature_maximum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_COLOR_TEMPERATURE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for ColorControl/StepColorTemperature command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_color_control_step_color_temperature_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_color_control_command_step_color_temperature_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "StepColorTemperature", "StepMode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->color_temperature_minimum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->color_temperature_maximum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->options_override });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
    ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_COLOR_TEMPERATURE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

void zigpc_command_mapper_bygroup_occupancy_sensing_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_occupancy_sensing_state_t values,
  uic_mqtt_dotdot_occupancy_sensing_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (values_to_write.pir_occupied_to_unoccupied_delay == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.pir_occupied_to_unoccupied_delay
    );
  }

  if (values_to_write.pir_unoccupied_to_occupied_delay == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.pir_unoccupied_to_occupied_delay
    );
  }

  if (values_to_write.pir_unoccupied_to_occupied_threshold == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.pir_unoccupied_to_occupied_threshold
    );
  }

  if (values_to_write.ultrasonic_occupied_to_unoccupied_delay == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.ultrasonic_occupied_to_unoccupied_delay
    );
  }

  if (values_to_write.ultrasonic_unoccupied_to_occupied_delay == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.ultrasonic_unoccupied_to_occupied_delay
    );
  }

  if (values_to_write.ultrasonic_unoccupied_to_occupied_threshold == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.ultrasonic_unoccupied_to_occupied_threshold
    );
  }

  if (values_to_write.physical_contact_occupied_to_unoccupied_delay == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.physical_contact_occupied_to_unoccupied_delay
    );
  }

  if (values_to_write.physical_contact_unoccupied_to_occupied_delay == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.physical_contact_unoccupied_to_occupied_delay
    );
  }

  if (values_to_write.physical_contact_unoccupied_to_occupied_threshold == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.physical_contact_unoccupied_to_occupied_threshold
    );
  }

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



void zigpc_command_mapper_bygroup_ias_zone_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_ias_zone_state_t values,
  uic_mqtt_dotdot_ias_zone_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (values_to_write.iascie_address == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_IASCIE_ADDRESS,
      ZIGPC_ZCL_DATA_TYPE_EUI64,
      &values.iascie_address
    );
  }

  if (values_to_write.current_zone_sensitivity_level == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_CURRENT_ZONE_SENSITIVITY_LEVEL,
      ZIGPC_ZCL_DATA_TYPE_UINT8,
      &values.current_zone_sensitivity_level
    );
  }

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



/**
 * @brief DotDot MQTT by-group handler for IASZone/ZoneEnrollResponse command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_ias_zone_zone_enroll_response_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_ias_zone_command_zone_enroll_response_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "ZoneEnrollResponse", "EnrollResponseCode");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->enroll_response_code });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->zoneid });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_IAS_ZONE,
    ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_ZONE_ENROLL_RESPONSE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for IASZone/InitiateNormalOperationMode command.
 *
 * @param group_id  UCL group identifier.

 */
void zigpc_command_mapper_bygroup_ias_zone_initiate_normal_operation_mode_handler(
  const dotdot_group_id_t group_id
) {




  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_IAS_ZONE,
    ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_INITIATE_NORMAL_OPERATION_MODE,
    0,
    nullptr
  );

}

/**
 * @brief DotDot MQTT by-group handler for IASZone/InitiateTestMode command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_ias_zone_initiate_test_mode_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_ias_zone_command_initiate_test_mode_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "InitiateTestMode", "TestModeDuration");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->test_mode_duration });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->current_zone_sensitivity_level });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_IAS_ZONE,
    ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_INITIATE_TEST_MODE,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

void zigpc_command_mapper_bygroup_iaswd_write_attributes_handler(
  const dotdot_group_id_t group_id,
  uic_mqtt_dotdot_iaswd_state_t values,
  uic_mqtt_dotdot_iaswd_updated_state_t values_to_write
) {
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (values_to_write.max_duration == true) {
    zigpc_command_mapper_populate_write_attr_record(
      write_attr_data,
      attr_id_list,
      attr_data_type_list,
      ZIGPC_ZCL_CLUSTER_IASWD_ATTR_MAX_DURATION,
      ZIGPC_ZCL_DATA_TYPE_UINT16,
      &values.max_duration
    );
  }

  if (write_attr_data.size() > 0) {
    zigpc_command_mapper_send_multicast(
      group_id,
      ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IASWD,
      ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
      write_attr_data.size(),
      write_attr_data.data()
    );
  }

}



/**
 * @brief DotDot MQTT by-group handler for IASWD/StartWarning command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_iaswd_start_warning_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_iaswd_command_start_warning_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "StartWarning", "SirenConfiguration");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->siren_configuration });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &fields->warning_duration });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &fields->strobe_duty_cycle });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &fields->strobe_level });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_IASWD,
    ZIGPC_ZCL_CLUSTER_IASWD_COMMAND_START_WARNING,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}

/**
 * @brief DotDot MQTT by-group handler for IASWD/Squawk command.
 *
 * @param group_id  UCL group identifier.

 * @param fields    Command fields data.

 */
void zigpc_command_mapper_bygroup_iaswd_squawk_handler(
  const dotdot_group_id_t group_id,
  const uic_mqtt_dotdot_iaswd_command_squawk_fields_t *fields
  
) {

  if (fields == nullptr) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELDS, "Squawk", "SquawkConfiguration");
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &fields->squawk_configuration });

  zigpc_command_mapper_send_multicast(
    group_id,
    ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
    ZIGPC_ZCL_CLUSTER_IASWD,
    ZIGPC_ZCL_CLUSTER_IASWD_COMMAND_SQUAWK,
    cmd_arg_list.size(),
    cmd_arg_list.data()
  );

}


sl_status_t zigpc_command_mapper_mqtt_bygroup_handlers_init(void)
{
  uic_mqtt_dotdot_by_group_identify_write_attributes_callback_set(zigpc_command_mapper_bygroup_identify_write_attributes_handler);
  uic_mqtt_dotdot_by_group_identify_identify_callback_set(zigpc_command_mapper_bygroup_identify_identify_handler);
  uic_mqtt_dotdot_by_group_identify_identify_query_callback_set(zigpc_command_mapper_bygroup_identify_identify_query_handler);
  uic_mqtt_dotdot_by_group_identify_trigger_effect_callback_set(zigpc_command_mapper_bygroup_identify_trigger_effect_handler);
  uic_mqtt_dotdot_by_group_groups_write_attributes_callback_set(zigpc_command_mapper_bygroup_groups_write_attributes_handler);
  uic_mqtt_dotdot_by_group_groups_add_group_callback_set(zigpc_command_mapper_bygroup_groups_add_group_handler);
  uic_mqtt_dotdot_by_group_groups_view_group_callback_set(zigpc_command_mapper_bygroup_groups_view_group_handler);
  uic_mqtt_dotdot_by_group_groups_get_group_membership_callback_set(zigpc_command_mapper_bygroup_groups_get_group_membership_handler);
  uic_mqtt_dotdot_by_group_groups_remove_group_callback_set(zigpc_command_mapper_bygroup_groups_remove_group_handler);
  uic_mqtt_dotdot_by_group_groups_remove_all_groups_callback_set(zigpc_command_mapper_bygroup_groups_remove_all_groups_handler);
  uic_mqtt_dotdot_by_group_groups_add_group_if_identifying_callback_set(zigpc_command_mapper_bygroup_groups_add_group_if_identifying_handler);
  uic_mqtt_dotdot_by_group_on_off_write_attributes_callback_set(zigpc_command_mapper_bygroup_on_off_write_attributes_handler);
  uic_mqtt_dotdot_by_group_on_off_off_callback_set(zigpc_command_mapper_bygroup_on_off_off_handler);
  uic_mqtt_dotdot_by_group_on_off_on_callback_set(zigpc_command_mapper_bygroup_on_off_on_handler);
  uic_mqtt_dotdot_by_group_on_off_toggle_callback_set(zigpc_command_mapper_bygroup_on_off_toggle_handler);
  uic_mqtt_dotdot_by_group_on_off_off_with_effect_callback_set(zigpc_command_mapper_bygroup_on_off_off_with_effect_handler);
  uic_mqtt_dotdot_by_group_on_off_on_with_recall_global_scene_callback_set(zigpc_command_mapper_bygroup_on_off_on_with_recall_global_scene_handler);
  uic_mqtt_dotdot_by_group_on_off_on_with_timed_off_callback_set(zigpc_command_mapper_bygroup_on_off_on_with_timed_off_handler);
  uic_mqtt_dotdot_by_group_level_write_attributes_callback_set(zigpc_command_mapper_bygroup_level_write_attributes_handler);
  uic_mqtt_dotdot_by_group_level_move_to_level_callback_set(zigpc_command_mapper_bygroup_level_move_to_level_handler);
  uic_mqtt_dotdot_by_group_level_move_callback_set(zigpc_command_mapper_bygroup_level_move_handler);
  uic_mqtt_dotdot_by_group_level_step_callback_set(zigpc_command_mapper_bygroup_level_step_handler);
  uic_mqtt_dotdot_by_group_level_stop_callback_set(zigpc_command_mapper_bygroup_level_stop_handler);
  uic_mqtt_dotdot_by_group_level_move_to_level_with_on_off_callback_set(zigpc_command_mapper_bygroup_level_move_to_level_with_on_off_handler);
  uic_mqtt_dotdot_by_group_level_move_with_on_off_callback_set(zigpc_command_mapper_bygroup_level_move_with_on_off_handler);
  uic_mqtt_dotdot_by_group_level_step_with_on_off_callback_set(zigpc_command_mapper_bygroup_level_step_with_on_off_handler);
  uic_mqtt_dotdot_by_group_level_stop_with_on_off_callback_set(zigpc_command_mapper_bygroup_level_stop_with_on_off_handler);
  uic_mqtt_dotdot_by_group_level_move_to_closest_frequency_callback_set(zigpc_command_mapper_bygroup_level_move_to_closest_frequency_handler);
  uic_mqtt_dotdot_by_group_poll_control_write_attributes_callback_set(zigpc_command_mapper_bygroup_poll_control_write_attributes_handler);
  uic_mqtt_dotdot_by_group_poll_control_check_in_callback_set(zigpc_command_mapper_bygroup_poll_control_check_in_handler);
  uic_mqtt_dotdot_by_group_door_lock_write_attributes_callback_set(zigpc_command_mapper_bygroup_door_lock_write_attributes_handler);
  uic_mqtt_dotdot_by_group_door_lock_lock_door_callback_set(zigpc_command_mapper_bygroup_door_lock_lock_door_handler);
  uic_mqtt_dotdot_by_group_door_lock_unlock_door_callback_set(zigpc_command_mapper_bygroup_door_lock_unlock_door_handler);
  uic_mqtt_dotdot_by_group_door_lock_toggle_callback_set(zigpc_command_mapper_bygroup_door_lock_toggle_handler);
  uic_mqtt_dotdot_by_group_door_lock_unlock_with_timeout_callback_set(zigpc_command_mapper_bygroup_door_lock_unlock_with_timeout_handler);
  uic_mqtt_dotdot_by_group_door_lock_get_log_record_callback_set(zigpc_command_mapper_bygroup_door_lock_get_log_record_handler);
  uic_mqtt_dotdot_by_group_door_lock_setpin_code_callback_set(zigpc_command_mapper_bygroup_door_lock_setpin_code_handler);
  uic_mqtt_dotdot_by_group_door_lock_getpin_code_callback_set(zigpc_command_mapper_bygroup_door_lock_getpin_code_handler);
  uic_mqtt_dotdot_by_group_door_lock_clearpin_code_callback_set(zigpc_command_mapper_bygroup_door_lock_clearpin_code_handler);
  uic_mqtt_dotdot_by_group_door_lock_clear_allpin_codes_callback_set(zigpc_command_mapper_bygroup_door_lock_clear_allpin_codes_handler);
  uic_mqtt_dotdot_by_group_door_lock_set_user_status_callback_set(zigpc_command_mapper_bygroup_door_lock_set_user_status_handler);
  uic_mqtt_dotdot_by_group_door_lock_get_user_status_callback_set(zigpc_command_mapper_bygroup_door_lock_get_user_status_handler);
  uic_mqtt_dotdot_by_group_door_lock_set_weekday_schedule_callback_set(zigpc_command_mapper_bygroup_door_lock_set_weekday_schedule_handler);
  uic_mqtt_dotdot_by_group_door_lock_get_weekday_schedule_callback_set(zigpc_command_mapper_bygroup_door_lock_get_weekday_schedule_handler);
  uic_mqtt_dotdot_by_group_door_lock_clear_weekday_schedule_callback_set(zigpc_command_mapper_bygroup_door_lock_clear_weekday_schedule_handler);
  uic_mqtt_dotdot_by_group_door_lock_set_year_day_schedule_callback_set(zigpc_command_mapper_bygroup_door_lock_set_year_day_schedule_handler);
  uic_mqtt_dotdot_by_group_door_lock_get_year_day_schedule_callback_set(zigpc_command_mapper_bygroup_door_lock_get_year_day_schedule_handler);
  uic_mqtt_dotdot_by_group_door_lock_clear_year_day_schedule_callback_set(zigpc_command_mapper_bygroup_door_lock_clear_year_day_schedule_handler);
  uic_mqtt_dotdot_by_group_door_lock_set_holiday_schedule_callback_set(zigpc_command_mapper_bygroup_door_lock_set_holiday_schedule_handler);
  uic_mqtt_dotdot_by_group_door_lock_get_holiday_schedule_callback_set(zigpc_command_mapper_bygroup_door_lock_get_holiday_schedule_handler);
  uic_mqtt_dotdot_by_group_door_lock_clear_holiday_schedule_callback_set(zigpc_command_mapper_bygroup_door_lock_clear_holiday_schedule_handler);
  uic_mqtt_dotdot_by_group_door_lock_set_user_type_callback_set(zigpc_command_mapper_bygroup_door_lock_set_user_type_handler);
  uic_mqtt_dotdot_by_group_door_lock_get_user_type_callback_set(zigpc_command_mapper_bygroup_door_lock_get_user_type_handler);
  uic_mqtt_dotdot_by_group_door_lock_setrfid_code_callback_set(zigpc_command_mapper_bygroup_door_lock_setrfid_code_handler);
  uic_mqtt_dotdot_by_group_door_lock_getrfid_code_callback_set(zigpc_command_mapper_bygroup_door_lock_getrfid_code_handler);
  uic_mqtt_dotdot_by_group_door_lock_clearrfid_code_callback_set(zigpc_command_mapper_bygroup_door_lock_clearrfid_code_handler);
  uic_mqtt_dotdot_by_group_door_lock_clear_allrfid_codes_callback_set(zigpc_command_mapper_bygroup_door_lock_clear_allrfid_codes_handler);
  uic_mqtt_dotdot_by_group_door_lock_get_allpin_codes_callback_set(zigpc_command_mapper_bygroup_door_lock_get_allpin_codes_handler);
  uic_mqtt_dotdot_by_group_door_lock_get_all_pin_codes_callback_set(zigpc_command_mapper_bygroup_door_lock_get_all_pin_codes_handler);
  uic_mqtt_dotdot_by_group_thermostat_write_attributes_callback_set(zigpc_command_mapper_bygroup_thermostat_write_attributes_handler);
  uic_mqtt_dotdot_by_group_thermostat_setpoint_raise_or_lower_callback_set(zigpc_command_mapper_bygroup_thermostat_setpoint_raise_or_lower_handler);
  uic_mqtt_dotdot_by_group_thermostat_set_weekly_schedule_callback_set(zigpc_command_mapper_bygroup_thermostat_set_weekly_schedule_handler);
  uic_mqtt_dotdot_by_group_thermostat_get_weekly_schedule_callback_set(zigpc_command_mapper_bygroup_thermostat_get_weekly_schedule_handler);
  uic_mqtt_dotdot_by_group_thermostat_clear_weekly_schedule_callback_set(zigpc_command_mapper_bygroup_thermostat_clear_weekly_schedule_handler);
  uic_mqtt_dotdot_by_group_thermostat_get_relay_status_log_callback_set(zigpc_command_mapper_bygroup_thermostat_get_relay_status_log_handler);
  uic_mqtt_dotdot_by_group_color_control_write_attributes_callback_set(zigpc_command_mapper_bygroup_color_control_write_attributes_handler);
  uic_mqtt_dotdot_by_group_color_control_move_to_hue_callback_set(zigpc_command_mapper_bygroup_color_control_move_to_hue_handler);
  uic_mqtt_dotdot_by_group_color_control_move_hue_callback_set(zigpc_command_mapper_bygroup_color_control_move_hue_handler);
  uic_mqtt_dotdot_by_group_color_control_step_hue_callback_set(zigpc_command_mapper_bygroup_color_control_step_hue_handler);
  uic_mqtt_dotdot_by_group_color_control_move_to_saturation_callback_set(zigpc_command_mapper_bygroup_color_control_move_to_saturation_handler);
  uic_mqtt_dotdot_by_group_color_control_move_saturation_callback_set(zigpc_command_mapper_bygroup_color_control_move_saturation_handler);
  uic_mqtt_dotdot_by_group_color_control_step_saturation_callback_set(zigpc_command_mapper_bygroup_color_control_step_saturation_handler);
  uic_mqtt_dotdot_by_group_color_control_move_to_hue_and_saturation_callback_set(zigpc_command_mapper_bygroup_color_control_move_to_hue_and_saturation_handler);
  uic_mqtt_dotdot_by_group_color_control_move_to_color_callback_set(zigpc_command_mapper_bygroup_color_control_move_to_color_handler);
  uic_mqtt_dotdot_by_group_color_control_move_color_callback_set(zigpc_command_mapper_bygroup_color_control_move_color_handler);
  uic_mqtt_dotdot_by_group_color_control_step_color_callback_set(zigpc_command_mapper_bygroup_color_control_step_color_handler);
  uic_mqtt_dotdot_by_group_color_control_move_to_color_temperature_callback_set(zigpc_command_mapper_bygroup_color_control_move_to_color_temperature_handler);
  uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_callback_set(zigpc_command_mapper_bygroup_color_control_enhanced_move_to_hue_handler);
  uic_mqtt_dotdot_by_group_color_control_enhanced_move_hue_callback_set(zigpc_command_mapper_bygroup_color_control_enhanced_move_hue_handler);
  uic_mqtt_dotdot_by_group_color_control_enhanced_step_hue_callback_set(zigpc_command_mapper_bygroup_color_control_enhanced_step_hue_handler);
  uic_mqtt_dotdot_by_group_color_control_enhanced_move_to_hue_and_saturation_callback_set(zigpc_command_mapper_bygroup_color_control_enhanced_move_to_hue_and_saturation_handler);
  uic_mqtt_dotdot_by_group_color_control_color_loop_set_callback_set(zigpc_command_mapper_bygroup_color_control_color_loop_set_handler);
  uic_mqtt_dotdot_by_group_color_control_stop_move_step_callback_set(zigpc_command_mapper_bygroup_color_control_stop_move_step_handler);
  uic_mqtt_dotdot_by_group_color_control_move_color_temperature_callback_set(zigpc_command_mapper_bygroup_color_control_move_color_temperature_handler);
  uic_mqtt_dotdot_by_group_color_control_step_color_temperature_callback_set(zigpc_command_mapper_bygroup_color_control_step_color_temperature_handler);
  uic_mqtt_dotdot_by_group_occupancy_sensing_write_attributes_callback_set(zigpc_command_mapper_bygroup_occupancy_sensing_write_attributes_handler);
  uic_mqtt_dotdot_by_group_ias_zone_write_attributes_callback_set(zigpc_command_mapper_bygroup_ias_zone_write_attributes_handler);
  uic_mqtt_dotdot_by_group_ias_zone_zone_enroll_response_callback_set(zigpc_command_mapper_bygroup_ias_zone_zone_enroll_response_handler);
  uic_mqtt_dotdot_by_group_ias_zone_initiate_normal_operation_mode_callback_set(zigpc_command_mapper_bygroup_ias_zone_initiate_normal_operation_mode_handler);
  uic_mqtt_dotdot_by_group_ias_zone_initiate_test_mode_callback_set(zigpc_command_mapper_bygroup_ias_zone_initiate_test_mode_handler);
  uic_mqtt_dotdot_by_group_iaswd_write_attributes_callback_set(zigpc_command_mapper_bygroup_iaswd_write_attributes_handler);
  uic_mqtt_dotdot_by_group_iaswd_start_warning_callback_set(zigpc_command_mapper_bygroup_iaswd_start_warning_handler);
  uic_mqtt_dotdot_by_group_iaswd_squawk_callback_set(zigpc_command_mapper_bygroup_iaswd_squawk_handler);
  return SL_STATUS_OK;
}
