/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.




// TODO: Investigate using 1 unicast dispatch callback with ZCL types used

#include <iostream>
#include <string>
#include <list>
#include <vector>
#include <unordered_map>

// Unify shared components
#include <sl_status.h>
#include <sl_log.h>
#include <dotdot_mqtt.h>

// ZigPC components
#include "zigpc_gateway.h"
#include "zigpc_common_zigbee.h"
#include "zcl_util.h"
#include "zcl_definitions.h"

// Internal includes
#include "zigpc_command_mapper_int.h"

static constexpr char LOG_TAG[] = "zigpc_cmdmapper";
static constexpr char LOG_FMT_INVALID_FIELDS[] = "%s::%s: Invalid fields passed in";
static constexpr char LOG_FMT_INVALID_FIELD_LIST[] = "%s::%s: Invalid %s list passed in";

/**
 * @brief Populate Write Attribute record to a frame data buffer.
 * The frame buffer is filled with the attribute id(2-bytes), attribute data
 * type (1-byte), and the attribute data(n-bytes). Since the frame data struct
 * only stores references to the data, any addition information (such as
 * attribute ID and data types) must be stored in auxillary arrays passed in.
 *
 * @param write_attr_data       Frame data array to populate.
 * @param attr_id_list          AUX Attr ID array to store and refer.
 * @param attr_data_type_list   AUX Attr data type array to store and refer.
 * @param attribute_id          Attribute ID to be used.
 * @param attribute_data_type,  Attribute data type to be used.
 * @param attribute_data        Attribute data to be used.
 */
void zigpc_command_mapper_populate_write_attr_record(
  std::vector<zigpc_zcl_frame_data_t> &write_attr_data,
  std::list<zcl_attribute_id_t> &attr_id_list,
  std::list<zigpc_zcl_data_type_t> &attr_data_type_list,
  zcl_attribute_id_t attribute_id,
  zigpc_zcl_data_type_t attribute_data_type,
  void *attribute_data
) {
  zigpc_zcl_frame_data_t frame_data;

  attr_id_list.push_back(attribute_id);
  frame_data.type = ZIGPC_ZCL_DATA_TYPE_ATTRIB_ID;
  frame_data.data = &attr_id_list.back();
  write_attr_data.push_back(frame_data);

  attr_data_type_list.push_back(attribute_data_type);
  frame_data.type = ZIGPC_ZCL_DATA_TYPE_DATA8;
  frame_data.data = &attr_data_type_list.back();
  write_attr_data.push_back(frame_data);

  frame_data.type = attribute_data_type;
  frame_data.data = attribute_data;
  write_attr_data.push_back(frame_data);

}

/**
 * @brief Populate Read Attribute record to a frame data buffer.
 * The frame buffer is filled with the attribute id(2-bytes). Since the frame
 * data struct only stores references to the data, any addition information
 * (such as attribute ID) must be stored in auxillary arrays passed in.
 *
 * @param read_attr_data        Frame data array to populate.
 * @param attr_id_list          AUX Attr ID array to store and refer.
 * @param attribute_id          Attribute ID to be used.
 */
void zigpc_command_mapper_populate_read_attr_record(
  std::vector<zigpc_zcl_frame_data_t> &read_attr_data,
  std::list<zcl_attribute_id_t> &attr_id_list,
  zcl_attribute_id_t attribute_id
) {
  zigpc_zcl_frame_data_t frame_data;

  attr_id_list.push_back(attribute_id);
  frame_data.type = ZIGPC_ZCL_DATA_TYPE_ATTRIB_ID;
  frame_data.data = &attr_id_list.back();
  read_attr_data.push_back(frame_data);
}

/******************
 * DotDot MQTT Command Handlers for Basic cluster
 ******************/

/**
 * @brief DotDot MQTT handler for ZCLVersion/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_basic_state_t Attribute values
 * uic_mqtt_dotdot_basic_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_basic_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_basic_state_t values,
  uic_mqtt_dotdot_basic_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_BASIC);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.location_description == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_LOCATION_DESCRIPTION,
        ZIGPC_ZCL_DATA_TYPE_STRING,
        &values.location_description
      );
    }

    if (values_to_write.physical_environment == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_PHYSICAL_ENVIRONMENT,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.physical_environment
      );
    }

    if (values_to_write.device_enabled == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_DEVICE_ENABLED,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.device_enabled
      );
    }

    if (values_to_write.alarm_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_ALARM_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.alarm_mask
      );
    }

    if (values_to_write.disable_local_config == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_DISABLE_LOCAL_CONFIG,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.disable_local_config
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_BASIC,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for ZCLVersion/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_basic_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_basic_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_basic_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_BASIC);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.zcl_version == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_ZCL_VERSION
      );
    }
    if (attributes_to_read.application_version == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_APPLICATION_VERSION
      );
    }
    if (attributes_to_read.stack_version == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_STACK_VERSION
      );
    }
    if (attributes_to_read.hw_version == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_HW_VERSION
      );
    }
    if (attributes_to_read.manufacturer_name == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_MANUFACTURER_NAME
      );
    }
    if (attributes_to_read.model_identifier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_MODEL_IDENTIFIER
      );
    }
    if (attributes_to_read.date_code == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_DATE_CODE
      );
    }
    if (attributes_to_read.power_source == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_POWER_SOURCE
      );
    }
    if (attributes_to_read.generic_device_class == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_GENERIC_DEVICE_CLASS
      );
    }
    if (attributes_to_read.generic_device_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_GENERIC_DEVICE_TYPE
      );
    }
    if (attributes_to_read.product_code == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_PRODUCT_CODE
      );
    }
    if (attributes_to_read.producturl == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_PRODUCTURL
      );
    }
    if (attributes_to_read.manufacturer_version_details == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_MANUFACTURER_VERSION_DETAILS
      );
    }
    if (attributes_to_read.serial_number == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_SERIAL_NUMBER
      );
    }
    if (attributes_to_read.product_label == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_PRODUCT_LABEL
      );
    }
    if (attributes_to_read.location_description == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_LOCATION_DESCRIPTION
      );
    }
    if (attributes_to_read.physical_environment == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_PHYSICAL_ENVIRONMENT
      );
    }
    if (attributes_to_read.device_enabled == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_DEVICE_ENABLED
      );
    }
    if (attributes_to_read.alarm_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_ALARM_MASK
      );
    }
    if (attributes_to_read.disable_local_config == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_DISABLE_LOCAL_CONFIG
      );
    }
    if (attributes_to_read.sw_buildid == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_SW_BUILDID
      );
    }
    if (attributes_to_read.z_wave_generic_device_class == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_Z_WAVE_GENERIC_DEVICE_CLASS
      );
    }
    if (attributes_to_read.z_wave_specific_device_class == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_BASIC_ATTR_Z_WAVE_SPECIFIC_DEVICE_CLASS
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_BASIC,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for Basic/ResetToFactoryDefaults command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_basic_reset_to_factory_defaults_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_BASIC);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_BASIC,
      ZIGPC_ZCL_CLUSTER_BASIC_COMMAND_RESET_TO_FACTORY_DEFAULTS,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for PowerConfiguration cluster
 ******************/

/**
 * @brief DotDot MQTT handler for MainsVoltage/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_power_configuration_state_t Attribute values
 * uic_mqtt_dotdot_power_configuration_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_power_configuration_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_power_configuration_state_t values,
  uic_mqtt_dotdot_power_configuration_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.mains_alarm_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_ALARM_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.mains_alarm_mask
      );
    }

    if (values_to_write.mains_voltage_min_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE_MIN_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.mains_voltage_min_threshold
      );
    }

    if (values_to_write.mains_voltage_max_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE_MAX_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.mains_voltage_max_threshold
      );
    }

    if (values_to_write.mains_voltage_dwell_trip_point == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE_DWELL_TRIP_POINT,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.mains_voltage_dwell_trip_point
      );
    }

    if (values_to_write.battery_manufacturer == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_MANUFACTURER,
        ZIGPC_ZCL_DATA_TYPE_STRING,
        &values.battery_manufacturer
      );
    }

    if (values_to_write.battery_size == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_SIZE,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_size
      );
    }

    if (values_to_write.batterya_hr_rating == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERYA_HR_RATING,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.batterya_hr_rating
      );
    }

    if (values_to_write.battery_quantity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_QUANTITY,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_quantity
      );
    }

    if (values_to_write.battery_rated_voltage == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_RATED_VOLTAGE,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_rated_voltage
      );
    }

    if (values_to_write.battery_alarm_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_ALARM_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.battery_alarm_mask
      );
    }

    if (values_to_write.battery_voltage_min_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_MIN_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_voltage_min_threshold
      );
    }

    if (values_to_write.battery_voltage_threshold1 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_THRESHOLD1,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_voltage_threshold1
      );
    }

    if (values_to_write.battery_voltage_threshold2 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_THRESHOLD2,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_voltage_threshold2
      );
    }

    if (values_to_write.battery_voltage_threshold3 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_THRESHOLD3,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_voltage_threshold3
      );
    }

    if (values_to_write.battery_percentage_min_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_MIN_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_percentage_min_threshold
      );
    }

    if (values_to_write.battery_percentage_threshold1 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_THRESHOLD1,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_percentage_threshold1
      );
    }

    if (values_to_write.battery_percentage_threshold2 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_THRESHOLD2,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_percentage_threshold2
      );
    }

    if (values_to_write.battery_percentage_threshold3 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_THRESHOLD3,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery_percentage_threshold3
      );
    }

    if (values_to_write.battery2_manufacturer == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_MANUFACTURER,
        ZIGPC_ZCL_DATA_TYPE_STRING,
        &values.battery2_manufacturer
      );
    }

    if (values_to_write.battery2_size == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_SIZE,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_size
      );
    }

    if (values_to_write.battery2a_hr_rating == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2A_HR_RATING,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.battery2a_hr_rating
      );
    }

    if (values_to_write.battery2_quantity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_QUANTITY,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_quantity
      );
    }

    if (values_to_write.battery2_rated_voltage == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_RATED_VOLTAGE,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_rated_voltage
      );
    }

    if (values_to_write.battery2_alarm_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_ALARM_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.battery2_alarm_mask
      );
    }

    if (values_to_write.battery2_voltage_min_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_MIN_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_voltage_min_threshold
      );
    }

    if (values_to_write.battery2_voltage_threshold1 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_THRESHOLD1,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_voltage_threshold1
      );
    }

    if (values_to_write.battery2_voltage_threshold2 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_THRESHOLD2,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_voltage_threshold2
      );
    }

    if (values_to_write.battery2_voltage_threshold3 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_THRESHOLD3,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_voltage_threshold3
      );
    }

    if (values_to_write.battery2_percentage_min_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_MIN_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_percentage_min_threshold
      );
    }

    if (values_to_write.battery2_percentage_threshold1 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_THRESHOLD1,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_percentage_threshold1
      );
    }

    if (values_to_write.battery2_percentage_threshold2 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_THRESHOLD2,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_percentage_threshold2
      );
    }

    if (values_to_write.battery2_percentage_threshold3 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_THRESHOLD3,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery2_percentage_threshold3
      );
    }

    if (values_to_write.battery3_manufacturer == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_MANUFACTURER,
        ZIGPC_ZCL_DATA_TYPE_STRING,
        &values.battery3_manufacturer
      );
    }

    if (values_to_write.battery3_size == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_SIZE,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_size
      );
    }

    if (values_to_write.battery3a_hr_rating == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3A_HR_RATING,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.battery3a_hr_rating
      );
    }

    if (values_to_write.battery3_quantity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_QUANTITY,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_quantity
      );
    }

    if (values_to_write.battery3_rated_voltage == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_RATED_VOLTAGE,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_rated_voltage
      );
    }

    if (values_to_write.battery3_alarm_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_ALARM_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.battery3_alarm_mask
      );
    }

    if (values_to_write.battery3_voltage_min_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_MIN_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_voltage_min_threshold
      );
    }

    if (values_to_write.battery3_voltage_threshold1 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_THRESHOLD1,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_voltage_threshold1
      );
    }

    if (values_to_write.battery3_voltage_threshold2 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_THRESHOLD2,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_voltage_threshold2
      );
    }

    if (values_to_write.battery3_voltage_threshold3 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_THRESHOLD3,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_voltage_threshold3
      );
    }

    if (values_to_write.battery3_percentage_min_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_MIN_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_percentage_min_threshold
      );
    }

    if (values_to_write.battery3_percentage_threshold1 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_THRESHOLD1,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_percentage_threshold1
      );
    }

    if (values_to_write.battery3_percentage_threshold2 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_THRESHOLD2,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_percentage_threshold2
      );
    }

    if (values_to_write.battery3_percentage_threshold3 == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_THRESHOLD3,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.battery3_percentage_threshold3
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for MainsVoltage/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_power_configuration_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_power_configuration_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_power_configuration_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.mains_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE
      );
    }
    if (attributes_to_read.mains_frequency == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_FREQUENCY
      );
    }
    if (attributes_to_read.mains_alarm_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_ALARM_MASK
      );
    }
    if (attributes_to_read.mains_voltage_min_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE_MIN_THRESHOLD
      );
    }
    if (attributes_to_read.mains_voltage_max_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE_MAX_THRESHOLD
      );
    }
    if (attributes_to_read.mains_voltage_dwell_trip_point == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_MAINS_VOLTAGE_DWELL_TRIP_POINT
      );
    }
    if (attributes_to_read.battery_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE
      );
    }
    if (attributes_to_read.battery_percentage_remaining == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_REMAINING
      );
    }
    if (attributes_to_read.battery_manufacturer == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_MANUFACTURER
      );
    }
    if (attributes_to_read.battery_size == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_SIZE
      );
    }
    if (attributes_to_read.batterya_hr_rating == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERYA_HR_RATING
      );
    }
    if (attributes_to_read.battery_quantity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_QUANTITY
      );
    }
    if (attributes_to_read.battery_rated_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_RATED_VOLTAGE
      );
    }
    if (attributes_to_read.battery_alarm_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_ALARM_MASK
      );
    }
    if (attributes_to_read.battery_voltage_min_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_MIN_THRESHOLD
      );
    }
    if (attributes_to_read.battery_voltage_threshold1 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_THRESHOLD1
      );
    }
    if (attributes_to_read.battery_voltage_threshold2 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_THRESHOLD2
      );
    }
    if (attributes_to_read.battery_voltage_threshold3 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_VOLTAGE_THRESHOLD3
      );
    }
    if (attributes_to_read.battery_percentage_min_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_MIN_THRESHOLD
      );
    }
    if (attributes_to_read.battery_percentage_threshold1 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_THRESHOLD1
      );
    }
    if (attributes_to_read.battery_percentage_threshold2 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_THRESHOLD2
      );
    }
    if (attributes_to_read.battery_percentage_threshold3 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_PERCENTAGE_THRESHOLD3
      );
    }
    if (attributes_to_read.battery_alarm_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY_ALARM_STATE
      );
    }
    if (attributes_to_read.battery2_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE
      );
    }
    if (attributes_to_read.battery2_percentage_remaining == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_REMAINING
      );
    }
    if (attributes_to_read.battery2_manufacturer == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_MANUFACTURER
      );
    }
    if (attributes_to_read.battery2_size == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_SIZE
      );
    }
    if (attributes_to_read.battery2a_hr_rating == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2A_HR_RATING
      );
    }
    if (attributes_to_read.battery2_quantity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_QUANTITY
      );
    }
    if (attributes_to_read.battery2_rated_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_RATED_VOLTAGE
      );
    }
    if (attributes_to_read.battery2_alarm_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_ALARM_MASK
      );
    }
    if (attributes_to_read.battery2_voltage_min_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_MIN_THRESHOLD
      );
    }
    if (attributes_to_read.battery2_voltage_threshold1 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_THRESHOLD1
      );
    }
    if (attributes_to_read.battery2_voltage_threshold2 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_THRESHOLD2
      );
    }
    if (attributes_to_read.battery2_voltage_threshold3 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_VOLTAGE_THRESHOLD3
      );
    }
    if (attributes_to_read.battery2_percentage_min_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_MIN_THRESHOLD
      );
    }
    if (attributes_to_read.battery2_percentage_threshold1 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_THRESHOLD1
      );
    }
    if (attributes_to_read.battery2_percentage_threshold2 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_THRESHOLD2
      );
    }
    if (attributes_to_read.battery2_percentage_threshold3 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_PERCENTAGE_THRESHOLD3
      );
    }
    if (attributes_to_read.battery2_alarm_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY2_ALARM_STATE
      );
    }
    if (attributes_to_read.battery3_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE
      );
    }
    if (attributes_to_read.battery3_percentage_remaining == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_REMAINING
      );
    }
    if (attributes_to_read.battery3_manufacturer == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_MANUFACTURER
      );
    }
    if (attributes_to_read.battery3_size == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_SIZE
      );
    }
    if (attributes_to_read.battery3a_hr_rating == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3A_HR_RATING
      );
    }
    if (attributes_to_read.battery3_quantity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_QUANTITY
      );
    }
    if (attributes_to_read.battery3_rated_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_RATED_VOLTAGE
      );
    }
    if (attributes_to_read.battery3_alarm_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_ALARM_MASK
      );
    }
    if (attributes_to_read.battery3_voltage_min_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_MIN_THRESHOLD
      );
    }
    if (attributes_to_read.battery3_voltage_threshold1 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_THRESHOLD1
      );
    }
    if (attributes_to_read.battery3_voltage_threshold2 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_THRESHOLD2
      );
    }
    if (attributes_to_read.battery3_voltage_threshold3 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_VOLTAGE_THRESHOLD3
      );
    }
    if (attributes_to_read.battery3_percentage_min_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_MIN_THRESHOLD
      );
    }
    if (attributes_to_read.battery3_percentage_threshold1 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_THRESHOLD1
      );
    }
    if (attributes_to_read.battery3_percentage_threshold2 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_THRESHOLD2
      );
    }
    if (attributes_to_read.battery3_percentage_threshold3 == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_PERCENTAGE_THRESHOLD3
      );
    }
    if (attributes_to_read.battery3_alarm_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION_ATTR_BATTERY3_ALARM_STATE
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_POWER_CONFIGURATION,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/******************
 * DotDot MQTT Command Handlers for Identify cluster
 ******************/

/**
 * @brief DotDot MQTT handler for IdentifyTime/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_identify_state_t Attribute values
 * uic_mqtt_dotdot_identify_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_identify_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_identify_state_t values,
  uic_mqtt_dotdot_identify_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IDENTIFY);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.identify_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_IDENTIFY_ATTR_IDENTIFY_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.identify_time
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IDENTIFY,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for IdentifyTime/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_identify_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_identify_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_identify_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IDENTIFY);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.identify_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IDENTIFY_ATTR_IDENTIFY_TIME
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IDENTIFY,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for Identify/Identify command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param identify_time  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_identify_identify_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t identify_time

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IDENTIFY);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &identify_time });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IDENTIFY,
      ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_IDENTIFY,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Identify/IdentifyQuery command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_identify_identify_query_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IDENTIFY);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IDENTIFY,
      ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_IDENTIFY_QUERY,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Identify/TriggerEffect command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param effect_identifier  Command argument of type TriggerEffectEffectIdentifier

 * @param effect_variant  Command argument of type TriggerEffectEffectVariant
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_identify_trigger_effect_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    TriggerEffectEffectIdentifier effect_identifier,

    TriggerEffectEffectVariant effect_variant

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IDENTIFY);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &effect_identifier });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &effect_variant });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IDENTIFY,
      ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_TRIGGER_EFFECT,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for Groups cluster
 ******************/

/**
 * @brief DotDot MQTT handler for NameSupport/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_groups_state_t Attribute values
 * uic_mqtt_dotdot_groups_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_groups_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_groups_state_t values,
  uic_mqtt_dotdot_groups_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_GROUPS,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for NameSupport/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_groups_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_groups_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_groups_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.name_support == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_GROUPS_ATTR_NAME_SUPPORT
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_GROUPS,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for Groups/AddGroup command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param group_id  Command argument of type uint16_t

 * @param group_name  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_add_group_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t group_id,

    const char* group_name

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &group_id });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_STRING, group_name });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_ADD_GROUP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Groups/ViewGroup command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param group_id  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_view_group_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t group_id

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &group_id });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_VIEW_GROUP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Groups/GetGroupMembership command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @param group_list_count  Count of uint16_t items
 * @param group_list  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_get_group_membership_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t group_list_count,
    const uint16_t *group_list

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }

  if ((group_list_count > 0U) && (group_list == nullptr)) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELD_LIST, "Groups", "GetGroupMembership", "GroupList");
    return SL_STATUS_INVALID_PARAMETER;
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &group_list_count });
  for(uint8_t i = 0U; i < group_list_count; i++) {
    cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &group_list[i] });
  }

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_GET_GROUP_MEMBERSHIP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Groups/RemoveGroup command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param group_id  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_remove_group_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t group_id

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &group_id });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_REMOVE_GROUP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Groups/RemoveAllGroups command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_remove_all_groups_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_REMOVE_ALL_GROUPS,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Groups/AddGroupIfIdentifying command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param group_id  Command argument of type uint16_t

 * @param group_name  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_add_group_if_identifying_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t group_id,

    const char* group_name

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &group_id });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_STRING, group_name });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_ADD_GROUP_IF_IDENTIFYING,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for OnOff cluster
 ******************/

/**
 * @brief DotDot MQTT handler for OnOff/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_on_off_state_t Attribute values
 * uic_mqtt_dotdot_on_off_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_on_off_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_on_off_state_t values,
  uic_mqtt_dotdot_on_off_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.on_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.on_time
      );
    }

    if (values_to_write.off_wait_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_OFF_WAIT_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.off_wait_time
      );
    }

    if (values_to_write.start_up_on_off == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_START_UP_ON_OFF,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.start_up_on_off
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_ON_OFF,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for OnOff/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_on_off_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_on_off_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_on_off_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.on_off == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_OFF
      );
    }
    if (attributes_to_read.global_scene_control == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_GLOBAL_SCENE_CONTROL
      );
    }
    if (attributes_to_read.on_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_TIME
      );
    }
    if (attributes_to_read.off_wait_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_OFF_WAIT_TIME
      );
    }
    if (attributes_to_read.start_up_on_off == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_START_UP_ON_OFF
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_ON_OFF,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for OnOff/Off command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_OFF,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for OnOff/On command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_on_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_ON,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for OnOff/Toggle command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_toggle_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_TOGGLE,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for OnOff/OffWithEffect command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param effect_identifier  Command argument of type OffWithEffectEffectIdentifier

 * @param effect_variant  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_off_with_effect_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    OffWithEffectEffectIdentifier effect_identifier,

    uint8_t effect_variant

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &effect_identifier });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &effect_variant });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_OFF_WITH_EFFECT,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for OnOff/OnWithRecallGlobalScene command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_on_with_recall_global_scene_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_ON_WITH_RECALL_GLOBAL_SCENE,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for OnOff/OnWithTimedOff command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param on_off_control  Command argument of type uint8_t

 * @param on_time  Command argument of type uint16_t

 * @param off_wait_time  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_on_with_timed_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t on_off_control,

    uint16_t on_time,

    uint16_t off_wait_time

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &on_off_control });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &on_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &off_wait_time });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_ON_WITH_TIMED_OFF,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for Level cluster
 ******************/

/**
 * @brief DotDot MQTT handler for CurrentLevel/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_level_state_t Attribute values
 * uic_mqtt_dotdot_level_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_level_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_level_state_t values,
  uic_mqtt_dotdot_level_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.options == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OPTIONS,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.options
      );
    }

    if (values_to_write.on_off_transition_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_OFF_TRANSITION_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.on_off_transition_time
      );
    }

    if (values_to_write.on_level == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_LEVEL,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.on_level
      );
    }

    if (values_to_write.on_transition_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_TRANSITION_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.on_transition_time
      );
    }

    if (values_to_write.off_transition_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OFF_TRANSITION_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.off_transition_time
      );
    }

    if (values_to_write.default_move_rate == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_DEFAULT_MOVE_RATE,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.default_move_rate
      );
    }

    if (values_to_write.start_up_current_level == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_START_UP_CURRENT_LEVEL,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.start_up_current_level
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_LEVEL,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for CurrentLevel/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_level_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_level_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_level_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.current_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_CURRENT_LEVEL
      );
    }
    if (attributes_to_read.remaining_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_REMAINING_TIME
      );
    }
    if (attributes_to_read.min_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MIN_LEVEL
      );
    }
    if (attributes_to_read.max_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MAX_LEVEL
      );
    }
    if (attributes_to_read.current_frequency == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_CURRENT_FREQUENCY
      );
    }
    if (attributes_to_read.min_frequency == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MIN_FREQUENCY
      );
    }
    if (attributes_to_read.max_frequency == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MAX_FREQUENCY
      );
    }
    if (attributes_to_read.options == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OPTIONS
      );
    }
    if (attributes_to_read.on_off_transition_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_OFF_TRANSITION_TIME
      );
    }
    if (attributes_to_read.on_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_LEVEL
      );
    }
    if (attributes_to_read.on_transition_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_TRANSITION_TIME
      );
    }
    if (attributes_to_read.off_transition_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OFF_TRANSITION_TIME
      );
    }
    if (attributes_to_read.default_move_rate == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_DEFAULT_MOVE_RATE
      );
    }
    if (attributes_to_read.start_up_current_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_START_UP_CURRENT_LEVEL
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_LEVEL,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for Level/MoveToLevel command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param level  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_move_to_level_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t level,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &level });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_TO_LEVEL,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/Move command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type MoveStepMode

 * @param rate  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_move_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    MoveStepMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/Step command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type MoveStepMode

 * @param step_size  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_step_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    MoveStepMode step_mode,

    uint8_t step_size,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STEP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/Stop command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_stop_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STOP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/MoveToLevelWithOnOff command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param level  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_move_to_level_with_on_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t level,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &level });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_TO_LEVEL_WITH_ON_OFF,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/MoveWithOnOff command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type MoveStepMode

 * @param rate  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_move_with_on_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    MoveStepMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_WITH_ON_OFF,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/StepWithOnOff command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type MoveStepMode

 * @param step_size  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_step_with_on_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    MoveStepMode step_mode,

    uint8_t step_size,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STEP_WITH_ON_OFF,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/StopWithOnOff command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_stop_with_on_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STOP_WITH_ON_OFF,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/MoveToClosestFrequency command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param frequency  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_move_to_closest_frequency_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t frequency

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &frequency });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_TO_CLOSEST_FREQUENCY,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for PollControl cluster
 ******************/

/**
 * @brief DotDot MQTT handler for CheckInInterval/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_poll_control_state_t Attribute values
 * uic_mqtt_dotdot_poll_control_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_poll_control_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_poll_control_state_t values,
  uic_mqtt_dotdot_poll_control_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_POLL_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.check_in_interval == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL,
        ZIGPC_ZCL_DATA_TYPE_UINT32,
        &values.check_in_interval
      );
    }

    if (values_to_write.fast_poll_timeout == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.fast_poll_timeout
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for CheckInInterval/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_poll_control_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_poll_control_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_poll_control_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_POLL_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.check_in_interval == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL
      );
    }
    if (attributes_to_read.long_poll_interval == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_LONG_POLL_INTERVAL
      );
    }
    if (attributes_to_read.short_poll_interval == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_SHORT_POLL_INTERVAL
      );
    }
    if (attributes_to_read.fast_poll_timeout == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT
      );
    }
    if (attributes_to_read.check_in_interval_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL_MIN
      );
    }
    if (attributes_to_read.long_poll_interval_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_LONG_POLL_INTERVAL_MIN
      );
    }
    if (attributes_to_read.fast_poll_timeout_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT_MAX
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for PollControl/CheckIn command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_poll_control_check_in_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_POLL_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL,
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_CHECK_IN,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for DoorLock cluster
 ******************/

/**
 * @brief DotDot MQTT handler for LockState/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_door_lock_state_t Attribute values
 * uic_mqtt_dotdot_door_lock_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_door_lock_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_door_lock_state_t values,
  uic_mqtt_dotdot_door_lock_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.door_open_events == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_OPEN_EVENTS,
        ZIGPC_ZCL_DATA_TYPE_UINT32,
        &values.door_open_events
      );
    }

    if (values_to_write.door_closed_events == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_CLOSED_EVENTS,
        ZIGPC_ZCL_DATA_TYPE_UINT32,
        &values.door_closed_events
      );
    }

    if (values_to_write.open_period == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPEN_PERIOD,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.open_period
      );
    }

    if (values_to_write.enable_logging == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOGGING,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.enable_logging
      );
    }

    if (values_to_write.language == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LANGUAGE,
        ZIGPC_ZCL_DATA_TYPE_STRING,
        &values.language
      );
    }

    if (values_to_write.led_settings == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LED_SETTINGS,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.led_settings
      );
    }

    if (values_to_write.auto_relock_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_AUTO_RELOCK_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT32,
        &values.auto_relock_time
      );
    }

    if (values_to_write.sound_volume == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SOUND_VOLUME,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.sound_volume
      );
    }

    if (values_to_write.operating_mode == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPERATING_MODE,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.operating_mode
      );
    }

    if (values_to_write.enable_local_programming == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOCAL_PROGRAMMING,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.enable_local_programming
      );
    }

    if (values_to_write.enable_one_touch_locking == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_ONE_TOUCH_LOCKING,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.enable_one_touch_locking
      );
    }

    if (values_to_write.enable_inside_statusled == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_INSIDE_STATUSLED,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.enable_inside_statusled
      );
    }

    if (values_to_write.enable_privacy_mode_button == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_PRIVACY_MODE_BUTTON,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.enable_privacy_mode_button
      );
    }

    if (values_to_write.local_programming_features == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCAL_PROGRAMMING_FEATURES,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.local_programming_features
      );
    }

    if (values_to_write.wrong_code_entry_limit == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_WRONG_CODE_ENTRY_LIMIT,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.wrong_code_entry_limit
      );
    }

    if (values_to_write.user_code_temporary_disable_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_USER_CODE_TEMPORARY_DISABLE_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.user_code_temporary_disable_time
      );
    }

    if (values_to_write.send_pin_over_the_air == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SEND_PIN_OVER_THE_AIR,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.send_pin_over_the_air
      );
    }

    if (values_to_write.require_pi_nfor_rf_operation == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_REQUIRE_PI_NFOR_RF_OPERATION,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.require_pi_nfor_rf_operation
      );
    }

    if (values_to_write.expiring_user_timeout == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_EXPIRING_USER_TIMEOUT,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.expiring_user_timeout
      );
    }

    if (values_to_write.alarm_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ALARM_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.alarm_mask
      );
    }

    if (values_to_write.keypad_operation_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_OPERATION_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.keypad_operation_event_mask
      );
    }

    if (values_to_write.rf_operation_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_OPERATION_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.rf_operation_event_mask
      );
    }

    if (values_to_write.manual_operation_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MANUAL_OPERATION_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.manual_operation_event_mask
      );
    }

    if (values_to_write.rfid_operation_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_OPERATION_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.rfid_operation_event_mask
      );
    }

    if (values_to_write.keypad_programming_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_PROGRAMMING_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.keypad_programming_event_mask
      );
    }

    if (values_to_write.rf_programming_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_PROGRAMMING_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.rf_programming_event_mask
      );
    }

    if (values_to_write.rfid_programming_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_PROGRAMMING_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.rfid_programming_event_mask
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for LockState/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_door_lock_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_door_lock_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_door_lock_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.lock_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCK_STATE
      );
    }
    if (attributes_to_read.lock_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCK_TYPE
      );
    }
    if (attributes_to_read.actuator_enabled == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ACTUATOR_ENABLED
      );
    }
    if (attributes_to_read.door_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_STATE
      );
    }
    if (attributes_to_read.door_open_events == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_OPEN_EVENTS
      );
    }
    if (attributes_to_read.door_closed_events == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_CLOSED_EVENTS
      );
    }
    if (attributes_to_read.open_period == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPEN_PERIOD
      );
    }
    if (attributes_to_read.number_of_log_records_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_LOG_RECORDS_SUPPORTED
      );
    }
    if (attributes_to_read.number_of_total_users_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_TOTAL_USERS_SUPPORTED
      );
    }
    if (attributes_to_read.number_of_pin_users_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_PIN_USERS_SUPPORTED
      );
    }
    if (attributes_to_read.number_of_rfid_users_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_RFID_USERS_SUPPORTED
      );
    }
    if (attributes_to_read.number_of_week_day_schedules_supported_per_user == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER
      );
    }
    if (attributes_to_read.number_of_year_day_schedules_supported_per_user == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER
      );
    }
    if (attributes_to_read.number_of_holiday_schedules_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED
      );
    }
    if (attributes_to_read.max_pin_code_length == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MAX_PIN_CODE_LENGTH
      );
    }
    if (attributes_to_read.min_pin_code_length == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MIN_PIN_CODE_LENGTH
      );
    }
    if (attributes_to_read.max_rfid_code_length == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MAX_RFID_CODE_LENGTH
      );
    }
    if (attributes_to_read.min_rfid_code_length == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MIN_RFID_CODE_LENGTH
      );
    }
    if (attributes_to_read.credential_rules_support == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_CREDENTIAL_RULES_SUPPORT
      );
    }
    if (attributes_to_read.number_of_credentials_supported_per_user == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_CREDENTIALS_SUPPORTED_PER_USER
      );
    }
    if (attributes_to_read.enable_logging == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOGGING
      );
    }
    if (attributes_to_read.language == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LANGUAGE
      );
    }
    if (attributes_to_read.led_settings == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LED_SETTINGS
      );
    }
    if (attributes_to_read.auto_relock_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_AUTO_RELOCK_TIME
      );
    }
    if (attributes_to_read.sound_volume == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SOUND_VOLUME
      );
    }
    if (attributes_to_read.operating_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPERATING_MODE
      );
    }
    if (attributes_to_read.supported_operating_modes == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SUPPORTED_OPERATING_MODES
      );
    }
    if (attributes_to_read.default_configuration_register == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DEFAULT_CONFIGURATION_REGISTER
      );
    }
    if (attributes_to_read.enable_local_programming == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOCAL_PROGRAMMING
      );
    }
    if (attributes_to_read.enable_one_touch_locking == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_ONE_TOUCH_LOCKING
      );
    }
    if (attributes_to_read.enable_inside_statusled == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_INSIDE_STATUSLED
      );
    }
    if (attributes_to_read.enable_privacy_mode_button == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_PRIVACY_MODE_BUTTON
      );
    }
    if (attributes_to_read.local_programming_features == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCAL_PROGRAMMING_FEATURES
      );
    }
    if (attributes_to_read.wrong_code_entry_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_WRONG_CODE_ENTRY_LIMIT
      );
    }
    if (attributes_to_read.user_code_temporary_disable_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_USER_CODE_TEMPORARY_DISABLE_TIME
      );
    }
    if (attributes_to_read.send_pin_over_the_air == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SEND_PIN_OVER_THE_AIR
      );
    }
    if (attributes_to_read.require_pi_nfor_rf_operation == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_REQUIRE_PI_NFOR_RF_OPERATION
      );
    }
    if (attributes_to_read.security_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SECURITY_LEVEL
      );
    }
    if (attributes_to_read.expiring_user_timeout == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_EXPIRING_USER_TIMEOUT
      );
    }
    if (attributes_to_read.alarm_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ALARM_MASK
      );
    }
    if (attributes_to_read.keypad_operation_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_OPERATION_EVENT_MASK
      );
    }
    if (attributes_to_read.rf_operation_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_OPERATION_EVENT_MASK
      );
    }
    if (attributes_to_read.manual_operation_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MANUAL_OPERATION_EVENT_MASK
      );
    }
    if (attributes_to_read.rfid_operation_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_OPERATION_EVENT_MASK
      );
    }
    if (attributes_to_read.keypad_programming_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_PROGRAMMING_EVENT_MASK
      );
    }
    if (attributes_to_read.rf_programming_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_PROGRAMMING_EVENT_MASK
      );
    }
    if (attributes_to_read.rfid_programming_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_PROGRAMMING_EVENT_MASK
      );
    }
    if (attributes_to_read.feature_map == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_FEATURE_MAP
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for DoorLock/LockDoor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param pin_or_rfid_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_lock_door_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    const char* pin_or_rfid_code

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin_or_rfid_code });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_LOCK_DOOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/UnlockDoor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param pin_or_rfid_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_unlock_door_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    const char* pin_or_rfid_code

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin_or_rfid_code });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_DOOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/Toggle command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param pin_or_rfid_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_toggle_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    const char* pin_or_rfid_code

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin_or_rfid_code });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_TOGGLE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/UnlockWithTimeout command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param timeout_in_seconds  Command argument of type uint16_t

 * @param pin_or_rfid_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_unlock_with_timeout_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t timeout_in_seconds,

    const char* pin_or_rfid_code

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &timeout_in_seconds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin_or_rfid_code });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_WITH_TIMEOUT,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetLogRecord command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param log_index  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_log_record_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t log_index

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &log_index });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_LOG_RECORD,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetPINCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkPINUserID

 * @param user_status  Command argument of type DrlkSettableUserStatus

 * @param user_type  Command argument of type DrlkUserType

 * @param pin  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_pin_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkPINUserID userid,

    DrlkSettableUserStatus user_status,

    DrlkUserType user_type,

    const char* pin

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &user_status });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &user_type });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_PIN_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetPINCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkPINUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_pin_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkPINUserID userid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_PIN_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearPINCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkPINUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_pin_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkPINUserID userid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_PIN_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearAllPINCodes command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_all_pin_codes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALL_PIN_CODES,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetUserStatus command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkTotalUserID

 * @param user_status  Command argument of type DrlkSettableUserStatus
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_user_status_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkTotalUserID userid,

    DrlkSettableUserStatus user_status

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &user_status });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_STATUS,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetUserStatus command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_user_status_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkTotalUserID userid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_STATUS,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetWeekdaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkWeekDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID

 * @param days_mask  Command argument of type uint8_t

 * @param start_hour  Command argument of type uint8_t

 * @param start_minute  Command argument of type uint8_t

 * @param end_hour  Command argument of type uint8_t

 * @param end_minute  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_weekday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkWeekDayScheduleID scheduleid,

    DrlkTotalUserID userid,

    uint8_t days_mask,

    uint8_t start_hour,

    uint8_t start_minute,

    uint8_t end_hour,

    uint8_t end_minute

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &days_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &start_hour });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &start_minute });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &end_hour });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &end_minute });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_WEEKDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetWeekdaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkWeekDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_weekday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkWeekDayScheduleID scheduleid,

    DrlkTotalUserID userid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_WEEKDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearWeekdaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkWeekDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_weekday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkWeekDayScheduleID scheduleid,

    DrlkTotalUserID userid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_WEEKDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetYearDaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkYearDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID

 * @param local_start_time  Command argument of type uint32_t

 * @param local_end_time  Command argument of type uint32_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_year_day_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkYearDayScheduleID scheduleid,

    DrlkTotalUserID userid,

    uint32_t local_start_time,

    uint32_t local_end_time

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &local_start_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &local_end_time });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_YEAR_DAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetYearDaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkYearDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_year_day_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkYearDayScheduleID scheduleid,

    DrlkTotalUserID userid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_YEAR_DAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearYearDaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkYearDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_year_day_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkYearDayScheduleID scheduleid,

    DrlkTotalUserID userid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_YEAR_DAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetHolidaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param holiday_scheduleid  Command argument of type DrlkHolidayScheduleID

 * @param local_start_time  Command argument of type uint32_t

 * @param local_end_time  Command argument of type uint32_t

 * @param operating_mode_during_holiday  Command argument of type DrlkOperMode
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_holiday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkHolidayScheduleID holiday_scheduleid,

    uint32_t local_start_time,

    uint32_t local_end_time,

    DrlkOperMode operating_mode_during_holiday

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &holiday_scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &local_start_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &local_end_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &operating_mode_during_holiday });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_HOLIDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetHolidaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param holiday_scheduleid  Command argument of type DrlkHolidayScheduleID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_holiday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkHolidayScheduleID holiday_scheduleid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &holiday_scheduleid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_HOLIDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearHolidaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param holiday_scheduleid  Command argument of type DrlkHolidayScheduleID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_holiday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkHolidayScheduleID holiday_scheduleid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &holiday_scheduleid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_HOLIDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetUserType command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkTotalUserID

 * @param user_type  Command argument of type DrlkUserType
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_user_type_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkTotalUserID userid,

    DrlkUserType user_type

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &user_type });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_TYPE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetUserType command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_user_type_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkTotalUserID userid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_TYPE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetRFIDCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkRFIDUserID

 * @param user_status  Command argument of type DrlkSettableUserStatus

 * @param user_type  Command argument of type DrlkUserType

 * @param rfid_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_rfid_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkRFIDUserID userid,

    DrlkSettableUserStatus user_status,

    DrlkUserType user_type,

    const char* rfid_code

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &user_status });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &user_type });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, rfid_code });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_RFID_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetRFIDCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkRFIDUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_rfid_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkRFIDUserID userid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_RFID_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearRFIDCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkRFIDUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_rfid_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkRFIDUserID userid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_RFID_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearAllRFIDCodes command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_all_rfid_codes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALL_RFID_CODES,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetUser command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param operation_type  Command argument of type DataOperationTypeEnum

 * @param user_index  Command argument of type uint16_t

 * @param user_name  Command argument of type const char*

 * @param user_uniqueid  Command argument of type uint32_t

 * @param user_status  Command argument of type DrlkUserStatus

 * @param user_type  Command argument of type DrlkUserType

 * @param credential_rule  Command argument of type CredentialRuleEnum
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_user_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DataOperationTypeEnum operation_type,

    uint16_t user_index,

    const char* user_name,

    uint32_t user_uniqueid,

    DrlkUserStatus user_status,

    DrlkUserType user_type,

    CredentialRuleEnum credential_rule

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &operation_type });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &user_index });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_STRING, user_name });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &user_uniqueid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &user_status });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &user_type });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &credential_rule });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetUser command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param user_index  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_user_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t user_index

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &user_index });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearUser command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param user_index  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_user_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t user_index

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &user_index });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_USER,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetCredential command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param operation_type  Command argument of type DataOperationTypeEnum

 * @param credential  Command argument of type CredentialStruct

 * @param credential_data  Command argument of type const char*

 * @param user_index  Command argument of type uint16_t

 * @param user_status  Command argument of type DrlkUserStatus

 * @param user_type  Command argument of type DrlkUserType
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_credential_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DataOperationTypeEnum operation_type,

    CredentialStruct credential,

    const char* credential_data,

    uint16_t user_index,

    DrlkUserStatus user_status,

    DrlkUserType user_type

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }


  zigpc_zcl_credential_struct_t zigpc_credential = {
    .credential_type = (zigpc_credential_type_enum_t)(int)credential.CredentialType,
    .credential_index = credential.CredentialIndex,
  };

  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &operation_type });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_CREDENTIAL_STRUCT_TYPE, &zigpc_credential });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, credential_data });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &user_index });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &user_status });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &user_type });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_CREDENTIAL,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetCredentialStatus command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param credential  Command argument of type CredentialStruct
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_credential_status_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CredentialStruct credential

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }


  zigpc_zcl_credential_struct_t zigpc_credential = {
    .credential_type = (zigpc_credential_type_enum_t)(int)credential.CredentialType,
    .credential_index = credential.CredentialIndex,
  };

  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_CREDENTIAL_STRUCT_TYPE, &zigpc_credential });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_CREDENTIAL_STATUS,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearCredential command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param credential  Command argument of type CredentialStruct
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_credential_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CredentialStruct credential

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }


  zigpc_zcl_credential_struct_t zigpc_credential = {
    .credential_type = (zigpc_credential_type_enum_t)(int)credential.CredentialType,
    .credential_index = credential.CredentialIndex,
  };

  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_CREDENTIAL_STRUCT_TYPE, &zigpc_credential });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_CREDENTIAL,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/UnboltDoor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param pin_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_unbolt_door_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    const char* pin_code

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin_code });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNBOLT_DOOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for WindowCovering cluster
 ******************/

/**
 * @brief DotDot MQTT handler for WindowCoveringType/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_window_covering_state_t Attribute values
 * uic_mqtt_dotdot_window_covering_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_window_covering_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_window_covering_state_t values,
  uic_mqtt_dotdot_window_covering_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_WINDOW_COVERING);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.velocity_lift == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_VELOCITY_LIFT,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.velocity_lift
      );
    }

    if (values_to_write.acceleration_time_lift == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_ACCELERATION_TIME_LIFT,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.acceleration_time_lift
      );
    }

    if (values_to_write.deceleration_time_lift == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_DECELERATION_TIME_LIFT,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.deceleration_time_lift
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for WindowCoveringType/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_window_covering_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_window_covering_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_window_covering_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_WINDOW_COVERING);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.window_covering_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_WINDOW_COVERING_TYPE
      );
    }
    if (attributes_to_read.physical_closed_limit_lift == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_PHYSICAL_CLOSED_LIMIT_LIFT
      );
    }
    if (attributes_to_read.physical_closed_limit_tilt == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_PHYSICAL_CLOSED_LIMIT_TILT
      );
    }
    if (attributes_to_read.current_position_lift == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_CURRENT_POSITION_LIFT
      );
    }
    if (attributes_to_read.current_position_tilt == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_CURRENT_POSITION_TILT
      );
    }
    if (attributes_to_read.number_of_actuations_lift == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_NUMBER_OF_ACTUATIONS_LIFT
      );
    }
    if (attributes_to_read.number_of_actuations_tilt == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_NUMBER_OF_ACTUATIONS_TILT
      );
    }
    if (attributes_to_read.config_or_status == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_CONFIG_OR_STATUS
      );
    }
    if (attributes_to_read.current_position_lift_percentage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_CURRENT_POSITION_LIFT_PERCENTAGE
      );
    }
    if (attributes_to_read.current_position_tilt_percentage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_CURRENT_POSITION_TILT_PERCENTAGE
      );
    }
    if (attributes_to_read.installed_open_limit_lift == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INSTALLED_OPEN_LIMIT_LIFT
      );
    }
    if (attributes_to_read.installed_closed_limit_lift == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INSTALLED_CLOSED_LIMIT_LIFT
      );
    }
    if (attributes_to_read.installed_open_limit_tilt == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INSTALLED_OPEN_LIMIT_TILT
      );
    }
    if (attributes_to_read.installed_closed_limit_tilt == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INSTALLED_CLOSED_LIMIT_TILT
      );
    }
    if (attributes_to_read.velocity_lift == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_VELOCITY_LIFT
      );
    }
    if (attributes_to_read.acceleration_time_lift == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_ACCELERATION_TIME_LIFT
      );
    }
    if (attributes_to_read.deceleration_time_lift == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_DECELERATION_TIME_LIFT
      );
    }
    if (attributes_to_read.mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_MODE
      );
    }
    if (attributes_to_read.intermediate_setpoints_lift == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INTERMEDIATE_SETPOINTS_LIFT
      );
    }
    if (attributes_to_read.intermediate_setpoints_tilt == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_ATTR_INTERMEDIATE_SETPOINTS_TILT
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_WINDOW_COVERING,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for WindowCovering/UpOrOpen command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_window_covering_up_or_open_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_WINDOW_COVERING);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_COMMAND_UP_OR_OPEN,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for WindowCovering/DownOrClose command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_window_covering_down_or_close_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_WINDOW_COVERING);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_COMMAND_DOWN_OR_CLOSE,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for WindowCovering/Stop command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_window_covering_stop_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_WINDOW_COVERING);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_COMMAND_STOP,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for WindowCovering/GoToLiftValue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param lift_value  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_window_covering_go_to_lift_value_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t lift_value

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_WINDOW_COVERING);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &lift_value });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_COMMAND_GO_TO_LIFT_VALUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for WindowCovering/GoToLiftPercentage command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param percentage_lift_value  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_window_covering_go_to_lift_percentage_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t percentage_lift_value

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_WINDOW_COVERING);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &percentage_lift_value });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_COMMAND_GO_TO_LIFT_PERCENTAGE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for WindowCovering/GoToTiltValue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param tilt_value  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_window_covering_go_to_tilt_value_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t tilt_value

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_WINDOW_COVERING);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &tilt_value });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_COMMAND_GO_TO_TILT_VALUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for WindowCovering/GoToTiltPercentage command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param percentage_tilt_value  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_window_covering_go_to_tilt_percentage_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t percentage_tilt_value

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_WINDOW_COVERING);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &percentage_tilt_value });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING,
      ZIGPC_ZCL_CLUSTER_WINDOW_COVERING_COMMAND_GO_TO_TILT_PERCENTAGE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for Thermostat cluster
 ******************/

/**
 * @brief DotDot MQTT handler for LocalTemperature/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_thermostat_state_t Attribute values
 * uic_mqtt_dotdot_thermostat_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_thermostat_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_thermostat_state_t values,
  uic_mqtt_dotdot_thermostat_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.hvac_system_type_configuration == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_HVAC_SYSTEM_TYPE_CONFIGURATION,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.hvac_system_type_configuration
      );
    }

    if (values_to_write.local_temperature_calibration == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE_CALIBRATION,
        ZIGPC_ZCL_DATA_TYPE_INT8,
        &values.local_temperature_calibration
      );
    }

    if (values_to_write.occupied_cooling_setpoint == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_COOLING_SETPOINT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.occupied_cooling_setpoint
      );
    }

    if (values_to_write.occupied_heating_setpoint == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_HEATING_SETPOINT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.occupied_heating_setpoint
      );
    }

    if (values_to_write.unoccupied_cooling_setpoint == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_COOLING_SETPOINT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.unoccupied_cooling_setpoint
      );
    }

    if (values_to_write.unoccupied_heating_setpoint == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_HEATING_SETPOINT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.unoccupied_heating_setpoint
      );
    }

    if (values_to_write.min_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_HEAT_SETPOINT_LIMIT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.min_heat_setpoint_limit
      );
    }

    if (values_to_write.max_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_HEAT_SETPOINT_LIMIT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.max_heat_setpoint_limit
      );
    }

    if (values_to_write.min_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_COOL_SETPOINT_LIMIT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.min_cool_setpoint_limit
      );
    }

    if (values_to_write.max_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_COOL_SETPOINT_LIMIT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.max_cool_setpoint_limit
      );
    }

    if (values_to_write.min_setpoint_dead_band == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_SETPOINT_DEAD_BAND,
        ZIGPC_ZCL_DATA_TYPE_INT8,
        &values.min_setpoint_dead_band
      );
    }

    if (values_to_write.remote_sensing == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_REMOTE_SENSING,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.remote_sensing
      );
    }

    if (values_to_write.control_sequence_of_operation == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_CONTROL_SEQUENCE_OF_OPERATION,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.control_sequence_of_operation
      );
    }

    if (values_to_write.system_mode == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SYSTEM_MODE,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.system_mode
      );
    }

    if (values_to_write.temperature_setpoint_hold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.temperature_setpoint_hold
      );
    }

    if (values_to_write.temperature_setpoint_hold_duration == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD_DURATION,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.temperature_setpoint_hold_duration
      );
    }

    if (values_to_write.thermostat_programming_operation_mode == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_PROGRAMMING_OPERATION_MODE,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.thermostat_programming_operation_mode
      );
    }

    if (values_to_write.occupied_setback == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.occupied_setback
      );
    }

    if (values_to_write.unoccupied_setback == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.unoccupied_setback
      );
    }

    if (values_to_write.emergency_heat_delta == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_EMERGENCY_HEAT_DELTA,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.emergency_heat_delta
      );
    }

    if (values_to_write.ac_type == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_TYPE,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.ac_type
      );
    }

    if (values_to_write.ac_capacity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.ac_capacity
      );
    }

    if (values_to_write.ac_refrigerant_type == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_REFRIGERANT_TYPE,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.ac_refrigerant_type
      );
    }

    if (values_to_write.ac_compressor_type == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COMPRESSOR_TYPE,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.ac_compressor_type
      );
    }

    if (values_to_write.ac_error_code == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_ERROR_CODE,
        ZIGPC_ZCL_DATA_TYPE_MAP32,
        &values.ac_error_code
      );
    }

    if (values_to_write.ac_louver_position == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_LOUVER_POSITION,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.ac_louver_position
      );
    }

    if (values_to_write.ac_capacity_format == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY_FORMAT,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.ac_capacity_format
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for LocalTemperature/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_thermostat_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_thermostat_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_thermostat_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.local_temperature == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE
      );
    }
    if (attributes_to_read.outdoor_temperature == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OUTDOOR_TEMPERATURE
      );
    }
    if (attributes_to_read.occupancy == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPANCY
      );
    }
    if (attributes_to_read.abs_min_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MIN_HEAT_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.abs_max_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MAX_HEAT_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.abs_min_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MIN_COOL_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.abs_max_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MAX_COOL_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.pi_cooling_demand == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_PI_COOLING_DEMAND
      );
    }
    if (attributes_to_read.pi_heating_demand == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_PI_HEATING_DEMAND
      );
    }
    if (attributes_to_read.hvac_system_type_configuration == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_HVAC_SYSTEM_TYPE_CONFIGURATION
      );
    }
    if (attributes_to_read.local_temperature_calibration == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE_CALIBRATION
      );
    }
    if (attributes_to_read.occupied_cooling_setpoint == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_COOLING_SETPOINT
      );
    }
    if (attributes_to_read.occupied_heating_setpoint == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_HEATING_SETPOINT
      );
    }
    if (attributes_to_read.unoccupied_cooling_setpoint == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_COOLING_SETPOINT
      );
    }
    if (attributes_to_read.unoccupied_heating_setpoint == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_HEATING_SETPOINT
      );
    }
    if (attributes_to_read.min_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_HEAT_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.max_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_HEAT_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.min_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_COOL_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.max_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_COOL_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.min_setpoint_dead_band == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_SETPOINT_DEAD_BAND
      );
    }
    if (attributes_to_read.remote_sensing == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_REMOTE_SENSING
      );
    }
    if (attributes_to_read.control_sequence_of_operation == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_CONTROL_SEQUENCE_OF_OPERATION
      );
    }
    if (attributes_to_read.system_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SYSTEM_MODE
      );
    }
    if (attributes_to_read.alarm_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ALARM_MASK
      );
    }
    if (attributes_to_read.thermostat_running_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_RUNNING_MODE
      );
    }
    if (attributes_to_read.start_of_week == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_START_OF_WEEK
      );
    }
    if (attributes_to_read.number_of_weekly_transitions == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_NUMBER_OF_WEEKLY_TRANSITIONS
      );
    }
    if (attributes_to_read.number_of_daily_transitions == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_NUMBER_OF_DAILY_TRANSITIONS
      );
    }
    if (attributes_to_read.temperature_setpoint_hold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD
      );
    }
    if (attributes_to_read.temperature_setpoint_hold_duration == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD_DURATION
      );
    }
    if (attributes_to_read.thermostat_programming_operation_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_PROGRAMMING_OPERATION_MODE
      );
    }
    if (attributes_to_read.thermostat_running_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_RUNNING_STATE
      );
    }
    if (attributes_to_read.setpoint_change_source == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_SOURCE
      );
    }
    if (attributes_to_read.setpoint_change_amount == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_AMOUNT
      );
    }
    if (attributes_to_read.setpoint_change_source_timestamp == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_SOURCE_TIMESTAMP
      );
    }
    if (attributes_to_read.occupied_setback == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK
      );
    }
    if (attributes_to_read.occupied_setback_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK_MIN
      );
    }
    if (attributes_to_read.occupied_setback_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK_MAX
      );
    }
    if (attributes_to_read.unoccupied_setback == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK
      );
    }
    if (attributes_to_read.unoccupied_setback_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK_MIN
      );
    }
    if (attributes_to_read.unoccupied_setback_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK_MAX
      );
    }
    if (attributes_to_read.emergency_heat_delta == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_EMERGENCY_HEAT_DELTA
      );
    }
    if (attributes_to_read.ac_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_TYPE
      );
    }
    if (attributes_to_read.ac_capacity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY
      );
    }
    if (attributes_to_read.ac_refrigerant_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_REFRIGERANT_TYPE
      );
    }
    if (attributes_to_read.ac_compressor_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COMPRESSOR_TYPE
      );
    }
    if (attributes_to_read.ac_error_code == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_ERROR_CODE
      );
    }
    if (attributes_to_read.ac_louver_position == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_LOUVER_POSITION
      );
    }
    if (attributes_to_read.ac_coil_temperature == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COIL_TEMPERATURE
      );
    }
    if (attributes_to_read.ac_capacity_format == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY_FORMAT
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for Thermostat/SetpointRaiseOrLower command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param mode  Command argument of type SetpointRaiseOrLowerMode

 * @param amount  Command argument of type int8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_thermostat_setpoint_raise_or_lower_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    SetpointRaiseOrLowerMode mode,

    int8_t amount

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT8, &amount });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_SETPOINT_RAISE_OR_LOWER,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Thermostat/SetWeeklySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param number_of_transitions  Command argument of type uint8_t

 * @param day_of_week  Command argument of type uint8_t

 * @param mode  Command argument of type uint8_t
 * @param transitions_count  Count of TransitionType items
 * @param transitions  Command argument of type TransitionType
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_thermostat_set_weekly_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t number_of_transitions,

    uint8_t day_of_week,

    uint8_t mode,

    uint8_t transitions_count,
    const TransitionType *transitions

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }

  if ((transitions_count > 0U) && (transitions == nullptr)) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELD_LIST, "Thermostat", "SetWeeklySchedule", "Transitions");
    return SL_STATUS_INVALID_PARAMETER;
  }

  std::vector< zigpc_zcl_transition_type_t > zigpc_transitions_vec;

  for(uint8_t i = 0; i < transitions_count; i++) {
    zigpc_transitions_vec.push_back({
      .transition_time = transitions[i].TransitionTime,
      .heat_set_point = transitions[i].HeatSetPoint,
      .cool_set_point = transitions[i].CoolSetPoint,
    });
  }

  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &number_of_transitions });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &day_of_week });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &mode });
  for(uint8_t i = 0U; i < transitions_count; i++) {
    cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_STRUCT_TRANSITION_TYPE, &zigpc_transitions_vec[i] });
  }

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_SET_WEEKLY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Thermostat/GetWeeklySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param days_to_return  Command argument of type uint8_t

 * @param mode_to_return  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_thermostat_get_weekly_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t days_to_return,

    uint8_t mode_to_return

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &days_to_return });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &mode_to_return });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_WEEKLY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Thermostat/ClearWeeklySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_thermostat_clear_weekly_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_CLEAR_WEEKLY_SCHEDULE,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Thermostat/GetRelayStatusLog command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_thermostat_get_relay_status_log_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_RELAY_STATUS_LOG,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for ColorControl cluster
 ******************/

/**
 * @brief DotDot MQTT handler for CurrentHue/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_color_control_state_t Attribute values
 * uic_mqtt_dotdot_color_control_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_color_control_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_color_control_state_t values,
  uic_mqtt_dotdot_color_control_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.options == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_OPTIONS,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.options
      );
    }

    if (values_to_write.white_pointx == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTX,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.white_pointx
      );
    }

    if (values_to_write.white_pointy == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.white_pointy
      );
    }

    if (values_to_write.color_pointrx == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRX,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointrx
      );
    }

    if (values_to_write.color_pointry == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointry
      );
    }

    if (values_to_write.color_pointr_intensity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTR_INTENSITY,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.color_pointr_intensity
      );
    }

    if (values_to_write.color_pointgx == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGX,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointgx
      );
    }

    if (values_to_write.color_pointgy == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointgy
      );
    }

    if (values_to_write.color_pointg_intensity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTG_INTENSITY,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.color_pointg_intensity
      );
    }

    if (values_to_write.color_pointbx == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBX,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointbx
      );
    }

    if (values_to_write.color_pointby == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointby
      );
    }

    if (values_to_write.color_pointb_intensity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTB_INTENSITY,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.color_pointb_intensity
      );
    }

    if (values_to_write.start_up_color_temperature_mireds == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_START_UP_COLOR_TEMPERATURE_MIREDS,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.start_up_color_temperature_mireds
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for CurrentHue/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_color_control_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_color_control_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_color_control_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.current_hue == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENT_HUE
      );
    }
    if (attributes_to_read.current_saturation == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENT_SATURATION
      );
    }
    if (attributes_to_read.remaining_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_REMAINING_TIME
      );
    }
    if (attributes_to_read.currentx == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENTX
      );
    }
    if (attributes_to_read.currenty == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENTY
      );
    }
    if (attributes_to_read.drift_compensation == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_DRIFT_COMPENSATION
      );
    }
    if (attributes_to_read.compensation_text == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COMPENSATION_TEXT
      );
    }
    if (attributes_to_read.color_temperature_mireds == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMPERATURE_MIREDS
      );
    }
    if (attributes_to_read.color_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_MODE
      );
    }
    if (attributes_to_read.options == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_OPTIONS
      );
    }
    if (attributes_to_read.number_of_primaries == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_NUMBER_OF_PRIMARIES
      );
    }
    if (attributes_to_read.primary1x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1X
      );
    }
    if (attributes_to_read.primary1y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1Y
      );
    }
    if (attributes_to_read.primary1_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1_INTENSITY
      );
    }
    if (attributes_to_read.primary2x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2X
      );
    }
    if (attributes_to_read.primary2y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2Y
      );
    }
    if (attributes_to_read.primary2_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2_INTENSITY
      );
    }
    if (attributes_to_read.primary3x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3X
      );
    }
    if (attributes_to_read.primary3y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3Y
      );
    }
    if (attributes_to_read.primary3_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3_INTENSITY
      );
    }
    if (attributes_to_read.primary4x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4X
      );
    }
    if (attributes_to_read.primary4y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4Y
      );
    }
    if (attributes_to_read.primary4_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4_INTENSITY
      );
    }
    if (attributes_to_read.primary5x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5X
      );
    }
    if (attributes_to_read.primary5y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5Y
      );
    }
    if (attributes_to_read.primary5_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5_INTENSITY
      );
    }
    if (attributes_to_read.primary6x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6X
      );
    }
    if (attributes_to_read.primary6y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6Y
      );
    }
    if (attributes_to_read.primary6_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6_INTENSITY
      );
    }
    if (attributes_to_read.white_pointx == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTX
      );
    }
    if (attributes_to_read.white_pointy == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTY
      );
    }
    if (attributes_to_read.color_pointrx == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRX
      );
    }
    if (attributes_to_read.color_pointry == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRY
      );
    }
    if (attributes_to_read.color_pointr_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTR_INTENSITY
      );
    }
    if (attributes_to_read.color_pointgx == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGX
      );
    }
    if (attributes_to_read.color_pointgy == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGY
      );
    }
    if (attributes_to_read.color_pointg_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTG_INTENSITY
      );
    }
    if (attributes_to_read.color_pointbx == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBX
      );
    }
    if (attributes_to_read.color_pointby == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBY
      );
    }
    if (attributes_to_read.color_pointb_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTB_INTENSITY
      );
    }
    if (attributes_to_read.enhanced_current_hue == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_ENHANCED_CURRENT_HUE
      );
    }
    if (attributes_to_read.enhanced_color_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_ENHANCED_COLOR_MODE
      );
    }
    if (attributes_to_read.color_loop_active == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_ACTIVE
      );
    }
    if (attributes_to_read.color_loop_direction == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_DIRECTION
      );
    }
    if (attributes_to_read.color_loop_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_TIME
      );
    }
    if (attributes_to_read.color_loop_start_enhanced_hue == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_START_ENHANCED_HUE
      );
    }
    if (attributes_to_read.color_loop_stored_enhanced_hue == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_STORED_ENHANCED_HUE
      );
    }
    if (attributes_to_read.color_capabilities == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_CAPABILITIES
      );
    }
    if (attributes_to_read.color_temp_physical_min_mireds == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMP_PHYSICAL_MIN_MIREDS
      );
    }
    if (attributes_to_read.color_temp_physical_max_mireds == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMP_PHYSICAL_MAX_MIREDS
      );
    }
    if (attributes_to_read.couple_color_temp_to_level_min_mireds == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS
      );
    }
    if (attributes_to_read.start_up_color_temperature_mireds == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_START_UP_COLOR_TEMPERATURE_MIREDS
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveToHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param hue  Command argument of type uint8_t

 * @param direction  Command argument of type CCDirection

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_to_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t hue,

    CCDirection direction,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &direction });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type CCMoveMode

 * @param rate  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCMoveMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/StepHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type CCStepMode

 * @param step_size  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_step_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCStepMode step_mode,

    uint8_t step_size,

    uint8_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveToSaturation command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param saturation  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_to_saturation_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t saturation,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &saturation });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_SATURATION,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveSaturation command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type CCMoveMode

 * @param rate  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_saturation_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCMoveMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_SATURATION,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/StepSaturation command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type CCStepMode

 * @param step_size  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_step_saturation_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCStepMode step_mode,

    uint8_t step_size,

    uint8_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_SATURATION,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveToHueAndSaturation command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param hue  Command argument of type uint8_t

 * @param saturation  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_to_hue_and_saturation_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t hue,

    uint8_t saturation,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &saturation });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_HUE_AND_SATURATION,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveToColor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param colorx  Command argument of type uint16_t

 * @param colory  Command argument of type uint16_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_to_color_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t colorx,

    uint16_t colory,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &colorx });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &colory });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_COLOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveColor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param ratex  Command argument of type int16_t

 * @param ratey  Command argument of type int16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_color_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    int16_t ratex,

    int16_t ratey,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &ratex });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &ratey });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_COLOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/StepColor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param stepx  Command argument of type int16_t

 * @param stepy  Command argument of type int16_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_step_color_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    int16_t stepx,

    int16_t stepy,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &stepx });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &stepy });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_COLOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveToColorTemperature command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param color_temperature_mireds  Command argument of type uint16_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_to_color_temperature_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t color_temperature_mireds,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &color_temperature_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_COLOR_TEMPERATURE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/EnhancedMoveToHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param enhanced_hue  Command argument of type uint16_t

 * @param direction  Command argument of type CCDirection

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_enhanced_move_to_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t enhanced_hue,

    CCDirection direction,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &enhanced_hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &direction });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_MOVE_TO_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/EnhancedMoveHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type CCMoveMode

 * @param rate  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_enhanced_move_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCMoveMode move_mode,

    uint16_t rate,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_MOVE_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/EnhancedStepHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type CCStepMode

 * @param step_size  Command argument of type uint16_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_enhanced_step_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCStepMode step_mode,

    uint16_t step_size,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_STEP_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/EnhancedMoveToHueAndSaturation command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param enhanced_hue  Command argument of type uint16_t

 * @param saturation  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_enhanced_move_to_hue_and_saturation_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t enhanced_hue,

    uint8_t saturation,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &enhanced_hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &saturation });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_MOVE_TO_HUE_AND_SATURATION,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/ColorLoopSet command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param update_flags  Command argument of type uint8_t

 * @param action  Command argument of type ColorLoopSetAction

 * @param direction  Command argument of type CCColorLoopDirection

 * @param time  Command argument of type uint16_t

 * @param start_hue  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_color_loop_set_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t update_flags,

    ColorLoopSetAction action,

    CCColorLoopDirection direction,

    uint16_t time,

    uint16_t start_hue,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &update_flags });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &action });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &direction });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &start_hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_COLOR_LOOP_SET,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/StopMoveStep command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_stop_move_step_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STOP_MOVE_STEP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveColorTemperature command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type CCMoveMode

 * @param rate  Command argument of type uint16_t

 * @param color_temperature_minimum_mireds  Command argument of type CCMinMiredsField

 * @param color_temperature_maximum_mireds  Command argument of type CCMaxMiredsField

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_color_temperature_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCMoveMode move_mode,

    uint16_t rate,

    CCMinMiredsField color_temperature_minimum_mireds,

    CCMaxMiredsField color_temperature_maximum_mireds,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &color_temperature_minimum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &color_temperature_maximum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_COLOR_TEMPERATURE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/StepColorTemperature command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type CCStepMode

 * @param step_size  Command argument of type uint16_t

 * @param transition_time  Command argument of type uint16_t

 * @param color_temperature_minimum_mireds  Command argument of type CCMinMiredsField

 * @param color_temperature_maximum_mireds  Command argument of type CCMaxMiredsField

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_step_color_temperature_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCStepMode step_mode,

    uint16_t step_size,

    uint16_t transition_time,

    CCMinMiredsField color_temperature_minimum_mireds,

    CCMaxMiredsField color_temperature_maximum_mireds,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &color_temperature_minimum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &color_temperature_maximum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_COLOR_TEMPERATURE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for TemperatureMeasurement cluster
 ******************/

/**
 * @brief DotDot MQTT handler for MeasuredValue/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_temperature_measurement_state_t Attribute values
 * uic_mqtt_dotdot_temperature_measurement_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_temperature_measurement_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_temperature_measurement_state_t values,
  uic_mqtt_dotdot_temperature_measurement_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for MeasuredValue/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_temperature_measurement_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_temperature_measurement_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_temperature_measurement_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.measured_value == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT_ATTR_MEASURED_VALUE
      );
    }
    if (attributes_to_read.min_measured_value == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT_ATTR_MIN_MEASURED_VALUE
      );
    }
    if (attributes_to_read.max_measured_value == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT_ATTR_MAX_MEASURED_VALUE
      );
    }
    if (attributes_to_read.tolerance == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT_ATTR_TOLERANCE
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_TEMPERATURE_MEASUREMENT,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/******************
 * DotDot MQTT Command Handlers for OccupancySensing cluster
 ******************/

/**
 * @brief DotDot MQTT handler for Occupancy/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_occupancy_sensing_state_t Attribute values
 * uic_mqtt_dotdot_occupancy_sensing_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_occupancy_sensing_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_occupancy_sensing_state_t values,
  uic_mqtt_dotdot_occupancy_sensing_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.pir_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.pir_occupied_to_unoccupied_delay
      );
    }

    if (values_to_write.pir_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.pir_unoccupied_to_occupied_delay
      );
    }

    if (values_to_write.pir_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.pir_unoccupied_to_occupied_threshold
      );
    }

    if (values_to_write.ultrasonic_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.ultrasonic_occupied_to_unoccupied_delay
      );
    }

    if (values_to_write.ultrasonic_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.ultrasonic_unoccupied_to_occupied_delay
      );
    }

    if (values_to_write.ultrasonic_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.ultrasonic_unoccupied_to_occupied_threshold
      );
    }

    if (values_to_write.physical_contact_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.physical_contact_occupied_to_unoccupied_delay
      );
    }

    if (values_to_write.physical_contact_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.physical_contact_unoccupied_to_occupied_delay
      );
    }

    if (values_to_write.physical_contact_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.physical_contact_unoccupied_to_occupied_threshold
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for Occupancy/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_occupancy_sensing_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_occupancy_sensing_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_occupancy_sensing_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.occupancy == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY
      );
    }
    if (attributes_to_read.occupancy_sensor_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY_SENSOR_TYPE
      );
    }
    if (attributes_to_read.occupancy_sensor_type_bitmap == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY_SENSOR_TYPE_BITMAP
      );
    }
    if (attributes_to_read.pir_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY
      );
    }
    if (attributes_to_read.pir_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY
      );
    }
    if (attributes_to_read.pir_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD
      );
    }
    if (attributes_to_read.ultrasonic_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY
      );
    }
    if (attributes_to_read.ultrasonic_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY
      );
    }
    if (attributes_to_read.ultrasonic_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD
      );
    }
    if (attributes_to_read.physical_contact_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY
      );
    }
    if (attributes_to_read.physical_contact_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY
      );
    }
    if (attributes_to_read.physical_contact_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/******************
 * DotDot MQTT Command Handlers for IASZone cluster
 ******************/

/**
 * @brief DotDot MQTT handler for ZoneState/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_ias_zone_state_t Attribute values
 * uic_mqtt_dotdot_ias_zone_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_ias_zone_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_ias_zone_state_t values,
  uic_mqtt_dotdot_ias_zone_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IAS_ZONE);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.iascie_address == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_IASCIE_ADDRESS,
        ZIGPC_ZCL_DATA_TYPE_EUI64,
        &values.iascie_address
      );
    }

    if (values_to_write.current_zone_sensitivity_level == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_CURRENT_ZONE_SENSITIVITY_LEVEL,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.current_zone_sensitivity_level
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for ZoneState/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_ias_zone_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_ias_zone_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_ias_zone_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IAS_ZONE);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.zone_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONE_STATE
      );
    }
    if (attributes_to_read.zone_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONE_TYPE
      );
    }
    if (attributes_to_read.zone_status == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONE_STATUS
      );
    }
    if (attributes_to_read.iascie_address == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_IASCIE_ADDRESS
      );
    }
    if (attributes_to_read.zoneid == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONEID
      );
    }
    if (attributes_to_read.number_of_zone_sensitivity_levels_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED
      );
    }
    if (attributes_to_read.current_zone_sensitivity_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_CURRENT_ZONE_SENSITIVITY_LEVEL
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for IASZone/ZoneEnrollResponse command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param enroll_response_code  Command argument of type ZoneEnrollResponseEnrollResponseCode

 * @param zoneid  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_ias_zone_zone_enroll_response_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    ZoneEnrollResponseEnrollResponseCode enroll_response_code,

    uint8_t zoneid

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IAS_ZONE);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &enroll_response_code });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &zoneid });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_ZONE_ENROLL_RESPONSE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for IASZone/InitiateNormalOperationMode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_ias_zone_initiate_normal_operation_mode_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IAS_ZONE);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }




  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_INITIATE_NORMAL_OPERATION_MODE,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for IASZone/InitiateTestMode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param test_mode_duration  Command argument of type uint8_t

 * @param current_zone_sensitivity_level  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_ias_zone_initiate_test_mode_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t test_mode_duration,

    uint8_t current_zone_sensitivity_level

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IAS_ZONE);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &test_mode_duration });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &current_zone_sensitivity_level });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_INITIATE_TEST_MODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for IASWD cluster
 ******************/

/**
 * @brief DotDot MQTT handler for MaxDuration/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_iaswd_state_t Attribute values
 * uic_mqtt_dotdot_iaswd_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_iaswd_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_iaswd_state_t values,
  uic_mqtt_dotdot_iaswd_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IASWD);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.max_duration == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_IASWD_ATTR_MAX_DURATION,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.max_duration
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IASWD,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for MaxDuration/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_iaswd_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_iaswd_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_iaswd_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IASWD);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.max_duration == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IASWD_ATTR_MAX_DURATION
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IASWD,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for IASWD/StartWarning command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param siren_configuration  Command argument of type uint8_t

 * @param warning_duration  Command argument of type uint16_t

 * @param strobe_duty_cycle  Command argument of type uint8_t

 * @param strobe_level  Command argument of type IaswdLevel
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_iaswd_start_warning_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t siren_configuration,

    uint16_t warning_duration,

    uint8_t strobe_duty_cycle,

    IaswdLevel strobe_level

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IASWD);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &siren_configuration });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &warning_duration });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &strobe_duty_cycle });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &strobe_level });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IASWD,
      ZIGPC_ZCL_CLUSTER_IASWD_COMMAND_START_WARNING,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for IASWD/Squawk command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param squawk_configuration  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_iaswd_squawk_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t squawk_configuration

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IASWD);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &squawk_configuration });

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IASWD,
      ZIGPC_ZCL_CLUSTER_IASWD_COMMAND_SQUAWK,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for Metering cluster
 ******************/

/**
 * @brief DotDot MQTT handler for CurrentSummationDelivered/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_metering_state_t Attribute values
 * uic_mqtt_dotdot_metering_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_metering_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_metering_state_t values,
  uic_mqtt_dotdot_metering_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_METERING);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_METERING,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for CurrentSummationDelivered/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_metering_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_metering_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_metering_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_METERING);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.current_summation_delivered == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_SUMMATION_DELIVERED
      );
    }
    if (attributes_to_read.current_summation_received == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_SUMMATION_RECEIVED
      );
    }
    if (attributes_to_read.current_max_demand_delivered == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_MAX_DEMAND_DELIVERED
      );
    }
    if (attributes_to_read.current_max_demand_received == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_MAX_DEMAND_RECEIVED
      );
    }
    if (attributes_to_read.power_factor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_POWER_FACTOR
      );
    }
    if (attributes_to_read.reading_snap_shot_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_READING_SNAP_SHOT_TIME
      );
    }
    if (attributes_to_read.current_max_demand_delivered_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_MAX_DEMAND_DELIVERED_TIME
      );
    }
    if (attributes_to_read.current_max_demand_received_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_MAX_DEMAND_RECEIVED_TIME
      );
    }
    if (attributes_to_read.default_update_period == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_DEFAULT_UPDATE_PERIOD
      );
    }
    if (attributes_to_read.supply_status == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_SUPPLY_STATUS
      );
    }
    if (attributes_to_read.current_inlet_energy_carrier_summation == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_INLET_ENERGY_CARRIER_SUMMATION
      );
    }
    if (attributes_to_read.current_outlet_energy_carrier_summation == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_CURRENT_OUTLET_ENERGY_CARRIER_SUMMATION
      );
    }
    if (attributes_to_read.inlet_temperature == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_INLET_TEMPERATURE
      );
    }
    if (attributes_to_read.outlet_temperature == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_OUTLET_TEMPERATURE
      );
    }
    if (attributes_to_read.unitof_measure == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_UNITOF_MEASURE
      );
    }
    if (attributes_to_read.multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_MULTIPLIER
      );
    }
    if (attributes_to_read.divisor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_DIVISOR
      );
    }
    if (attributes_to_read.summation_formatting == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_SUMMATION_FORMATTING
      );
    }
    if (attributes_to_read.demand_formatting == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_DEMAND_FORMATTING
      );
    }
    if (attributes_to_read.historical_consumption_formatting == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_HISTORICAL_CONSUMPTION_FORMATTING
      );
    }
    if (attributes_to_read.metering_device_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_METERING_DEVICE_TYPE
      );
    }
    if (attributes_to_read.energy_carrier_unit_of_measure == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_ENERGY_CARRIER_UNIT_OF_MEASURE
      );
    }
    if (attributes_to_read.energy_carrier_summation_formatting == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_ENERGY_CARRIER_SUMMATION_FORMATTING
      );
    }
    if (attributes_to_read.energy_carrier_demand_formatting == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_ENERGY_CARRIER_DEMAND_FORMATTING
      );
    }
    if (attributes_to_read.temperature_unit_of_measure == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_TEMPERATURE_UNIT_OF_MEASURE
      );
    }
    if (attributes_to_read.temperature_formatting == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_METERING_ATTR_TEMPERATURE_FORMATTING
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_METERING,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/******************
 * DotDot MQTT Command Handlers for ElectricalMeasurement cluster
 ******************/

/**
 * @brief DotDot MQTT handler for MeasurementType/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_electrical_measurement_state_t Attribute values
 * uic_mqtt_dotdot_electrical_measurement_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_electrical_measurement_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_electrical_measurement_state_t values,
  uic_mqtt_dotdot_electrical_measurement_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.average_rms_voltage_measurement_period == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.average_rms_voltage_measurement_period
      );
    }

    if (values_to_write.average_rms_over_voltage_counter == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE_COUNTER,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.average_rms_over_voltage_counter
      );
    }

    if (values_to_write.average_rms_under_voltage_counter == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.average_rms_under_voltage_counter
      );
    }

    if (values_to_write.rms_extreme_over_voltage_period == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE_PERIOD,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_extreme_over_voltage_period
      );
    }

    if (values_to_write.rms_extreme_under_voltage_period == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE_PERIOD,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_extreme_under_voltage_period
      );
    }

    if (values_to_write.rms_voltage_sag_period == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG_PERIOD,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_voltage_sag_period
      );
    }

    if (values_to_write.rms_voltage_swell_period == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL_PERIOD,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_voltage_swell_period
      );
    }

    if (values_to_write.dc_overload_alarms_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_OVERLOAD_ALARMS_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.dc_overload_alarms_mask
      );
    }

    if (values_to_write.ac_alarms_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_ALARMS_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.ac_alarms_mask
      );
    }

    if (values_to_write.rms_extreme_over_voltage == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.rms_extreme_over_voltage
      );
    }

    if (values_to_write.rms_extreme_under_voltage == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.rms_extreme_under_voltage
      );
    }

    if (values_to_write.rms_voltage_sag == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.rms_voltage_sag
      );
    }

    if (values_to_write.rms_voltage_swell == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.rms_voltage_swell
      );
    }

    if (values_to_write.average_rms_voltage_measurement_period_phb == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHB,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.average_rms_voltage_measurement_period_phb
      );
    }

    if (values_to_write.average_rms_over_voltage_counter_phb == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHB,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.average_rms_over_voltage_counter_phb
      );
    }

    if (values_to_write.average_rms_under_voltage_counter_phb == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHB,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.average_rms_under_voltage_counter_phb
      );
    }

    if (values_to_write.rms_extreme_over_voltage_period_phb == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_extreme_over_voltage_period_phb
      );
    }

    if (values_to_write.rms_extreme_under_voltage_period_phb == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_extreme_under_voltage_period_phb
      );
    }

    if (values_to_write.rms_voltage_sag_period_phb == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG_PERIOD_PHB,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_voltage_sag_period_phb
      );
    }

    if (values_to_write.rms_voltage_swell_period_phb == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL_PERIOD_PHB,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_voltage_swell_period_phb
      );
    }

    if (values_to_write.average_rms_voltage_measurement_period_phc == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHC,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.average_rms_voltage_measurement_period_phc
      );
    }

    if (values_to_write.average_rms_over_voltage_counter_phc == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHC,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.average_rms_over_voltage_counter_phc
      );
    }

    if (values_to_write.average_rms_under_voltage_counter_phc == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHC,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.average_rms_under_voltage_counter_phc
      );
    }

    if (values_to_write.rms_extreme_over_voltage_period_phc == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_extreme_over_voltage_period_phc
      );
    }

    if (values_to_write.rms_extreme_under_voltage_period_phc == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_extreme_under_voltage_period_phc
      );
    }

    if (values_to_write.rms_voltage_sag_period_phc == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG_PERIOD_PHC,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_voltage_sag_period_phc
      );
    }

    if (values_to_write.rms_voltage_swell_period_phc == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL_PERIOD_PHC,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.rms_voltage_swell_period_phc
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for MeasurementType/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_electrical_measurement_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_electrical_measurement_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_electrical_measurement_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.measurement_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASUREMENT_TYPE
      );
    }
    if (attributes_to_read.dc_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE
      );
    }
    if (attributes_to_read.dc_voltage_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE_MIN
      );
    }
    if (attributes_to_read.dc_voltage_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE_MAX
      );
    }
    if (attributes_to_read.dc_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT
      );
    }
    if (attributes_to_read.dc_current_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT_MIN
      );
    }
    if (attributes_to_read.dc_current_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT_MAX
      );
    }
    if (attributes_to_read.dc_power == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_POWER
      );
    }
    if (attributes_to_read.dc_power_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_POWER_MIN
      );
    }
    if (attributes_to_read.dc_power_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_POWER_MAX
      );
    }
    if (attributes_to_read.dc_voltage_multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE_MULTIPLIER
      );
    }
    if (attributes_to_read.dc_voltage_divisor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE_DIVISOR
      );
    }
    if (attributes_to_read.dc_current_multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT_MULTIPLIER
      );
    }
    if (attributes_to_read.dc_current_divisor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT_DIVISOR
      );
    }
    if (attributes_to_read.dc_power_multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_POWER_MULTIPLIER
      );
    }
    if (attributes_to_read.dc_power_divisor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_POWER_DIVISOR
      );
    }
    if (attributes_to_read.ac_frequency == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_FREQUENCY
      );
    }
    if (attributes_to_read.ac_frequency_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_FREQUENCY_MIN
      );
    }
    if (attributes_to_read.ac_frequency_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_FREQUENCY_MAX
      );
    }
    if (attributes_to_read.neutral_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_NEUTRAL_CURRENT
      );
    }
    if (attributes_to_read.total_active_power == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_TOTAL_ACTIVE_POWER
      );
    }
    if (attributes_to_read.total_reactive_power == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_TOTAL_REACTIVE_POWER
      );
    }
    if (attributes_to_read.total_apparent_power == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_TOTAL_APPARENT_POWER
      );
    }
    if (attributes_to_read.measured1st_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED1ST_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured3rd_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED3RD_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured5th_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED5TH_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured7th_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED7TH_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured9th_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED9TH_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured11th_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED11TH_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured_phase1st_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE1ST_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured_phase3rd_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE3RD_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured_phase5th_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE5TH_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured_phase7th_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE7TH_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured_phase9th_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE9TH_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.measured_phase11th_harmonic_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_MEASURED_PHASE11TH_HARMONIC_CURRENT
      );
    }
    if (attributes_to_read.ac_frequency_multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_FREQUENCY_MULTIPLIER
      );
    }
    if (attributes_to_read.ac_frequency_divisor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_FREQUENCY_DIVISOR
      );
    }
    if (attributes_to_read.power_multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_POWER_MULTIPLIER
      );
    }
    if (attributes_to_read.power_divisor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_POWER_DIVISOR
      );
    }
    if (attributes_to_read.harmonic_current_multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_HARMONIC_CURRENT_MULTIPLIER
      );
    }
    if (attributes_to_read.phase_harmonic_current_multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_PHASE_HARMONIC_CURRENT_MULTIPLIER
      );
    }
    if (attributes_to_read.line_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_LINE_CURRENT
      );
    }
    if (attributes_to_read.active_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_CURRENT
      );
    }
    if (attributes_to_read.reactive_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_CURRENT
      );
    }
    if (attributes_to_read.rms_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE
      );
    }
    if (attributes_to_read.rms_voltage_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MIN
      );
    }
    if (attributes_to_read.rms_voltage_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MAX
      );
    }
    if (attributes_to_read.rms_current == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT
      );
    }
    if (attributes_to_read.rms_current_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MIN
      );
    }
    if (attributes_to_read.rms_current_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MAX
      );
    }
    if (attributes_to_read.active_power == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER
      );
    }
    if (attributes_to_read.active_power_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MIN
      );
    }
    if (attributes_to_read.active_power_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MAX
      );
    }
    if (attributes_to_read.reactive_power == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_POWER
      );
    }
    if (attributes_to_read.apparent_power == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_APPARENT_POWER
      );
    }
    if (attributes_to_read.power_factor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_POWER_FACTOR
      );
    }
    if (attributes_to_read.average_rms_voltage_measurement_period == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD
      );
    }
    if (attributes_to_read.average_rms_over_voltage_counter == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE_COUNTER
      );
    }
    if (attributes_to_read.average_rms_under_voltage_counter == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER
      );
    }
    if (attributes_to_read.rms_extreme_over_voltage_period == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE_PERIOD
      );
    }
    if (attributes_to_read.rms_extreme_under_voltage_period == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE_PERIOD
      );
    }
    if (attributes_to_read.rms_voltage_sag_period == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG_PERIOD
      );
    }
    if (attributes_to_read.rms_voltage_swell_period == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL_PERIOD
      );
    }
    if (attributes_to_read.ac_voltage_multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_VOLTAGE_MULTIPLIER
      );
    }
    if (attributes_to_read.ac_voltage_divisor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_VOLTAGE_DIVISOR
      );
    }
    if (attributes_to_read.ac_current_multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_CURRENT_MULTIPLIER
      );
    }
    if (attributes_to_read.ac_current_divisor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_CURRENT_DIVISOR
      );
    }
    if (attributes_to_read.ac_power_multiplier == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_POWER_MULTIPLIER
      );
    }
    if (attributes_to_read.ac_power_divisor == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_POWER_DIVISOR
      );
    }
    if (attributes_to_read.dc_overload_alarms_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_OVERLOAD_ALARMS_MASK
      );
    }
    if (attributes_to_read.dc_voltage_overload == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_VOLTAGE_OVERLOAD
      );
    }
    if (attributes_to_read.dc_current_overload == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_DC_CURRENT_OVERLOAD
      );
    }
    if (attributes_to_read.ac_alarms_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_ALARMS_MASK
      );
    }
    if (attributes_to_read.ac_voltage_overload == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_VOLTAGE_OVERLOAD
      );
    }
    if (attributes_to_read.ac_current_overload == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_CURRENT_OVERLOAD
      );
    }
    if (attributes_to_read.ac_active_power_overload == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_ACTIVE_POWER_OVERLOAD
      );
    }
    if (attributes_to_read.ac_reactive_power_overload == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AC_REACTIVE_POWER_OVERLOAD
      );
    }
    if (attributes_to_read.average_rms_over_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE
      );
    }
    if (attributes_to_read.average_rms_under_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE
      );
    }
    if (attributes_to_read.rms_extreme_over_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE
      );
    }
    if (attributes_to_read.rms_extreme_under_voltage == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE
      );
    }
    if (attributes_to_read.rms_voltage_sag == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG
      );
    }
    if (attributes_to_read.rms_voltage_swell == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL
      );
    }
    if (attributes_to_read.line_current_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_LINE_CURRENT_PHB
      );
    }
    if (attributes_to_read.active_current_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_CURRENT_PHB
      );
    }
    if (attributes_to_read.reactive_current_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_CURRENT_PHB
      );
    }
    if (attributes_to_read.rms_voltage_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_PHB
      );
    }
    if (attributes_to_read.rms_voltage_min_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MIN_PHB
      );
    }
    if (attributes_to_read.rms_voltage_max_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MAX_PHB
      );
    }
    if (attributes_to_read.rms_current_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_PHB
      );
    }
    if (attributes_to_read.rms_current_min_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MIN_PHB
      );
    }
    if (attributes_to_read.rms_current_max_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MAX_PHB
      );
    }
    if (attributes_to_read.active_power_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_PHB
      );
    }
    if (attributes_to_read.active_power_min_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MIN_PHB
      );
    }
    if (attributes_to_read.active_power_max_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MAX_PHB
      );
    }
    if (attributes_to_read.reactive_power_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_POWER_PHB
      );
    }
    if (attributes_to_read.apparent_power_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_APPARENT_POWER_PHB
      );
    }
    if (attributes_to_read.power_factor_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_POWER_FACTOR_PHB
      );
    }
    if (attributes_to_read.average_rms_voltage_measurement_period_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHB
      );
    }
    if (attributes_to_read.average_rms_over_voltage_counter_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHB
      );
    }
    if (attributes_to_read.average_rms_under_voltage_counter_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHB
      );
    }
    if (attributes_to_read.rms_extreme_over_voltage_period_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHB
      );
    }
    if (attributes_to_read.rms_extreme_under_voltage_period_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHB
      );
    }
    if (attributes_to_read.rms_voltage_sag_period_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG_PERIOD_PHB
      );
    }
    if (attributes_to_read.rms_voltage_swell_period_phb == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL_PERIOD_PHB
      );
    }
    if (attributes_to_read.line_current_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_LINE_CURRENT_PHC
      );
    }
    if (attributes_to_read.active_current_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_CURRENT_PHC
      );
    }
    if (attributes_to_read.reactive_current_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_CURRENT_PHC
      );
    }
    if (attributes_to_read.rms_voltage_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_PHC
      );
    }
    if (attributes_to_read.rms_voltage_min_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MIN_PHC
      );
    }
    if (attributes_to_read.rms_voltage_max_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_MAX_PHC
      );
    }
    if (attributes_to_read.rms_current_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_PHC
      );
    }
    if (attributes_to_read.rms_current_min_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MIN_PHC
      );
    }
    if (attributes_to_read.rms_current_max_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_CURRENT_MAX_PHC
      );
    }
    if (attributes_to_read.active_power_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_PHC
      );
    }
    if (attributes_to_read.active_power_min_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MIN_PHC
      );
    }
    if (attributes_to_read.active_power_max_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_ACTIVE_POWER_MAX_PHC
      );
    }
    if (attributes_to_read.reactive_power_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_REACTIVE_POWER_PHC
      );
    }
    if (attributes_to_read.apparent_power_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_APPARENT_POWER_PHC
      );
    }
    if (attributes_to_read.power_factor_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_POWER_FACTOR_PHC
      );
    }
    if (attributes_to_read.average_rms_voltage_measurement_period_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_VOLTAGE_MEASUREMENT_PERIOD_PHC
      );
    }
    if (attributes_to_read.average_rms_over_voltage_counter_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_OVER_VOLTAGE_COUNTER_PHC
      );
    }
    if (attributes_to_read.average_rms_under_voltage_counter_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_AVERAGE_RMS_UNDER_VOLTAGE_COUNTER_PHC
      );
    }
    if (attributes_to_read.rms_extreme_over_voltage_period_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_OVER_VOLTAGE_PERIOD_PHC
      );
    }
    if (attributes_to_read.rms_extreme_under_voltage_period_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_EXTREME_UNDER_VOLTAGE_PERIOD_PHC
      );
    }
    if (attributes_to_read.rms_voltage_sag_period_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SAG_PERIOD_PHC
      );
    }
    if (attributes_to_read.rms_voltage_swell_period_phc == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_ATTR_RMS_VOLTAGE_SWELL_PERIOD_PHC
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for ElectricalMeasurement/GetProfileInfoResponse command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param profile_count  Command argument of type uint8_t

 * @param profile_interval_period  Command argument of type ProfileIntervalPeriod

 * @param max_number_of_intervals  Command argument of type uint8_t
 * @param list_of_attributes_count  Count of uint16_t items
 * @param list_of_attributes  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_electrical_measurement_get_profile_info_response_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t profile_count,

    ProfileIntervalPeriod profile_interval_period,

    uint8_t max_number_of_intervals,

    uint8_t list_of_attributes_count,
    const uint16_t *list_of_attributes

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }

  if ((list_of_attributes_count > 0U) && (list_of_attributes == nullptr)) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELD_LIST, "ElectricalMeasurement", "GetProfileInfoResponse", "ListOfAttributes");
    return SL_STATUS_INVALID_PARAMETER;
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &profile_count });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &profile_interval_period });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &max_number_of_intervals });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &list_of_attributes_count });
  for(uint8_t i = 0U; i < list_of_attributes_count; i++) {
    cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ATTRIB_ID, &list_of_attributes[i] });
  }

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT,
      ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_COMMAND_GET_PROFILE_INFO_RESPONSE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ElectricalMeasurement/GetMeasurementProfileResponse command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param start_time  Command argument of type UTC

 * @param status  Command argument of type GetMeasurementProfileResponseStatus

 * @param profile_interval_period  Command argument of type ProfileIntervalPeriod

 * @param number_of_intervals_delivered  Command argument of type uint8_t

 * @param attribute_id  Command argument of type uint16_t
 * @param intervals_count  Count of uint8_t items
 * @param intervals  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_electrical_measurement_get_measurement_profile_response_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    UTC start_time,

    GetMeasurementProfileResponseStatus status,

    ProfileIntervalPeriod profile_interval_period,

    uint8_t number_of_intervals_delivered,

    uint16_t attribute_id,

    uint8_t intervals_count,
    const uint8_t *intervals

) {
  sl_status_t temp_status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    temp_status  = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT);
    if (temp_status  != SL_STATUS_OK) {
      temp_status  = SL_STATUS_NOT_AVAILABLE;
    }
    return temp_status ;
  }

  if ((intervals_count > 0U) && (intervals == nullptr)) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELD_LIST, "ElectricalMeasurement", "GetMeasurementProfileResponse", "Intervals");
    return SL_STATUS_INVALID_PARAMETER;
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UTC, &start_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &status });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &profile_interval_period });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &number_of_intervals_delivered });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ATTRIB_ID, &attribute_id });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &intervals_count });
  for(uint8_t i = 0U; i < intervals_count; i++) {
    cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &intervals[i] });
  }

  if (temp_status  == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT,
      ZIGPC_ZCL_CLUSTER_ELECTRICAL_MEASUREMENT_COMMAND_GET_MEASUREMENT_PROFILE_RESPONSE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}


/**
 * @brief Register the callbacks for the DotDot Commands supported.
 */
sl_status_t zigpc_command_mapper_register_dotdot_mqtt_handlers(void)
{
  uic_mqtt_dotdot_set_basic_write_attributes_callback(
    zigpc_command_mapper_basic_write_attributes_handler
  );
  uic_mqtt_dotdot_set_basic_force_read_attributes_callback(
    zigpc_command_mapper_basic_force_read_attributes_handler
  );
  uic_mqtt_dotdot_basic_reset_to_factory_defaults_callback_set(
    zigpc_command_mapper_basic_reset_to_factory_defaults_handler
  );
  uic_mqtt_dotdot_set_power_configuration_write_attributes_callback(
    zigpc_command_mapper_power_configuration_write_attributes_handler
  );
  uic_mqtt_dotdot_set_power_configuration_force_read_attributes_callback(
    zigpc_command_mapper_power_configuration_force_read_attributes_handler
  );
  uic_mqtt_dotdot_set_identify_write_attributes_callback(
    zigpc_command_mapper_identify_write_attributes_handler
  );
  uic_mqtt_dotdot_set_identify_force_read_attributes_callback(
    zigpc_command_mapper_identify_force_read_attributes_handler
  );
  uic_mqtt_dotdot_identify_identify_callback_set(
    zigpc_command_mapper_identify_identify_handler
  );
  uic_mqtt_dotdot_identify_identify_query_callback_set(
    zigpc_command_mapper_identify_identify_query_handler
  );
  uic_mqtt_dotdot_identify_trigger_effect_callback_set(
    zigpc_command_mapper_identify_trigger_effect_handler
  );
  uic_mqtt_dotdot_set_groups_write_attributes_callback(
    zigpc_command_mapper_groups_write_attributes_handler
  );
  uic_mqtt_dotdot_set_groups_force_read_attributes_callback(
    zigpc_command_mapper_groups_force_read_attributes_handler
  );
  uic_mqtt_dotdot_groups_add_group_callback_set(
    zigpc_command_mapper_groups_add_group_handler
  );
  uic_mqtt_dotdot_groups_view_group_callback_set(
    zigpc_command_mapper_groups_view_group_handler
  );
  uic_mqtt_dotdot_groups_get_group_membership_callback_set(
    zigpc_command_mapper_groups_get_group_membership_handler
  );
  uic_mqtt_dotdot_groups_remove_group_callback_set(
    zigpc_command_mapper_groups_remove_group_handler
  );
  uic_mqtt_dotdot_groups_remove_all_groups_callback_set(
    zigpc_command_mapper_groups_remove_all_groups_handler
  );
  uic_mqtt_dotdot_groups_add_group_if_identifying_callback_set(
    zigpc_command_mapper_groups_add_group_if_identifying_handler
  );
  uic_mqtt_dotdot_set_on_off_write_attributes_callback(
    zigpc_command_mapper_on_off_write_attributes_handler
  );
  uic_mqtt_dotdot_set_on_off_force_read_attributes_callback(
    zigpc_command_mapper_on_off_force_read_attributes_handler
  );
  uic_mqtt_dotdot_on_off_off_callback_set(
    zigpc_command_mapper_on_off_off_handler
  );
  uic_mqtt_dotdot_on_off_on_callback_set(
    zigpc_command_mapper_on_off_on_handler
  );
  uic_mqtt_dotdot_on_off_toggle_callback_set(
    zigpc_command_mapper_on_off_toggle_handler
  );
  uic_mqtt_dotdot_on_off_off_with_effect_callback_set(
    zigpc_command_mapper_on_off_off_with_effect_handler
  );
  uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_set(
    zigpc_command_mapper_on_off_on_with_recall_global_scene_handler
  );
  uic_mqtt_dotdot_on_off_on_with_timed_off_callback_set(
    zigpc_command_mapper_on_off_on_with_timed_off_handler
  );
  uic_mqtt_dotdot_set_level_write_attributes_callback(
    zigpc_command_mapper_level_write_attributes_handler
  );
  uic_mqtt_dotdot_set_level_force_read_attributes_callback(
    zigpc_command_mapper_level_force_read_attributes_handler
  );
  uic_mqtt_dotdot_level_move_to_level_callback_set(
    zigpc_command_mapper_level_move_to_level_handler
  );
  uic_mqtt_dotdot_level_move_callback_set(
    zigpc_command_mapper_level_move_handler
  );
  uic_mqtt_dotdot_level_step_callback_set(
    zigpc_command_mapper_level_step_handler
  );
  uic_mqtt_dotdot_level_stop_callback_set(
    zigpc_command_mapper_level_stop_handler
  );
  uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_set(
    zigpc_command_mapper_level_move_to_level_with_on_off_handler
  );
  uic_mqtt_dotdot_level_move_with_on_off_callback_set(
    zigpc_command_mapper_level_move_with_on_off_handler
  );
  uic_mqtt_dotdot_level_step_with_on_off_callback_set(
    zigpc_command_mapper_level_step_with_on_off_handler
  );
  uic_mqtt_dotdot_level_stop_with_on_off_callback_set(
    zigpc_command_mapper_level_stop_with_on_off_handler
  );
  uic_mqtt_dotdot_level_move_to_closest_frequency_callback_set(
    zigpc_command_mapper_level_move_to_closest_frequency_handler
  );
  uic_mqtt_dotdot_set_poll_control_write_attributes_callback(
    zigpc_command_mapper_poll_control_write_attributes_handler
  );
  uic_mqtt_dotdot_set_poll_control_force_read_attributes_callback(
    zigpc_command_mapper_poll_control_force_read_attributes_handler
  );
  uic_mqtt_dotdot_poll_control_check_in_callback_set(
    zigpc_command_mapper_poll_control_check_in_handler
  );
  uic_mqtt_dotdot_set_door_lock_write_attributes_callback(
    zigpc_command_mapper_door_lock_write_attributes_handler
  );
  uic_mqtt_dotdot_set_door_lock_force_read_attributes_callback(
    zigpc_command_mapper_door_lock_force_read_attributes_handler
  );
  uic_mqtt_dotdot_door_lock_lock_door_callback_set(
    zigpc_command_mapper_door_lock_lock_door_handler
  );
  uic_mqtt_dotdot_door_lock_unlock_door_callback_set(
    zigpc_command_mapper_door_lock_unlock_door_handler
  );
  uic_mqtt_dotdot_door_lock_toggle_callback_set(
    zigpc_command_mapper_door_lock_toggle_handler
  );
  uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_set(
    zigpc_command_mapper_door_lock_unlock_with_timeout_handler
  );
  uic_mqtt_dotdot_door_lock_get_log_record_callback_set(
    zigpc_command_mapper_door_lock_get_log_record_handler
  );
  uic_mqtt_dotdot_door_lock_set_pin_code_callback_set(
    zigpc_command_mapper_door_lock_set_pin_code_handler
  );
  uic_mqtt_dotdot_door_lock_get_pin_code_callback_set(
    zigpc_command_mapper_door_lock_get_pin_code_handler
  );
  uic_mqtt_dotdot_door_lock_clear_pin_code_callback_set(
    zigpc_command_mapper_door_lock_clear_pin_code_handler
  );
  uic_mqtt_dotdot_door_lock_clear_all_pin_codes_callback_set(
    zigpc_command_mapper_door_lock_clear_all_pin_codes_handler
  );
  uic_mqtt_dotdot_door_lock_set_user_status_callback_set(
    zigpc_command_mapper_door_lock_set_user_status_handler
  );
  uic_mqtt_dotdot_door_lock_get_user_status_callback_set(
    zigpc_command_mapper_door_lock_get_user_status_handler
  );
  uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_set(
    zigpc_command_mapper_door_lock_set_weekday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_set(
    zigpc_command_mapper_door_lock_get_weekday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_set(
    zigpc_command_mapper_door_lock_clear_weekday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_set(
    zigpc_command_mapper_door_lock_set_year_day_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_set(
    zigpc_command_mapper_door_lock_get_year_day_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_set(
    zigpc_command_mapper_door_lock_clear_year_day_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_set(
    zigpc_command_mapper_door_lock_set_holiday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_set(
    zigpc_command_mapper_door_lock_get_holiday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_set(
    zigpc_command_mapper_door_lock_clear_holiday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_set_user_type_callback_set(
    zigpc_command_mapper_door_lock_set_user_type_handler
  );
  uic_mqtt_dotdot_door_lock_get_user_type_callback_set(
    zigpc_command_mapper_door_lock_get_user_type_handler
  );
  uic_mqtt_dotdot_door_lock_set_rfid_code_callback_set(
    zigpc_command_mapper_door_lock_set_rfid_code_handler
  );
  uic_mqtt_dotdot_door_lock_get_rfid_code_callback_set(
    zigpc_command_mapper_door_lock_get_rfid_code_handler
  );
  uic_mqtt_dotdot_door_lock_clear_rfid_code_callback_set(
    zigpc_command_mapper_door_lock_clear_rfid_code_handler
  );
  uic_mqtt_dotdot_door_lock_clear_all_rfid_codes_callback_set(
    zigpc_command_mapper_door_lock_clear_all_rfid_codes_handler
  );
  uic_mqtt_dotdot_door_lock_set_user_callback_set(
    zigpc_command_mapper_door_lock_set_user_handler
  );
  uic_mqtt_dotdot_door_lock_get_user_callback_set(
    zigpc_command_mapper_door_lock_get_user_handler
  );
  uic_mqtt_dotdot_door_lock_clear_user_callback_set(
    zigpc_command_mapper_door_lock_clear_user_handler
  );
  uic_mqtt_dotdot_door_lock_set_credential_callback_set(
    zigpc_command_mapper_door_lock_set_credential_handler
  );
  uic_mqtt_dotdot_door_lock_get_credential_status_callback_set(
    zigpc_command_mapper_door_lock_get_credential_status_handler
  );
  uic_mqtt_dotdot_door_lock_clear_credential_callback_set(
    zigpc_command_mapper_door_lock_clear_credential_handler
  );
  uic_mqtt_dotdot_door_lock_unbolt_door_callback_set(
    zigpc_command_mapper_door_lock_unbolt_door_handler
  );
  uic_mqtt_dotdot_set_window_covering_write_attributes_callback(
    zigpc_command_mapper_window_covering_write_attributes_handler
  );
  uic_mqtt_dotdot_set_window_covering_force_read_attributes_callback(
    zigpc_command_mapper_window_covering_force_read_attributes_handler
  );
  uic_mqtt_dotdot_window_covering_up_or_open_callback_set(
    zigpc_command_mapper_window_covering_up_or_open_handler
  );
  uic_mqtt_dotdot_window_covering_down_or_close_callback_set(
    zigpc_command_mapper_window_covering_down_or_close_handler
  );
  uic_mqtt_dotdot_window_covering_stop_callback_set(
    zigpc_command_mapper_window_covering_stop_handler
  );
  uic_mqtt_dotdot_window_covering_go_to_lift_value_callback_set(
    zigpc_command_mapper_window_covering_go_to_lift_value_handler
  );
  uic_mqtt_dotdot_window_covering_go_to_lift_percentage_callback_set(
    zigpc_command_mapper_window_covering_go_to_lift_percentage_handler
  );
  uic_mqtt_dotdot_window_covering_go_to_tilt_value_callback_set(
    zigpc_command_mapper_window_covering_go_to_tilt_value_handler
  );
  uic_mqtt_dotdot_window_covering_go_to_tilt_percentage_callback_set(
    zigpc_command_mapper_window_covering_go_to_tilt_percentage_handler
  );
  uic_mqtt_dotdot_set_thermostat_write_attributes_callback(
    zigpc_command_mapper_thermostat_write_attributes_handler
  );
  uic_mqtt_dotdot_set_thermostat_force_read_attributes_callback(
    zigpc_command_mapper_thermostat_force_read_attributes_handler
  );
  uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_set(
    zigpc_command_mapper_thermostat_setpoint_raise_or_lower_handler
  );
  uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_set(
    zigpc_command_mapper_thermostat_set_weekly_schedule_handler
  );
  uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_set(
    zigpc_command_mapper_thermostat_get_weekly_schedule_handler
  );
  uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_set(
    zigpc_command_mapper_thermostat_clear_weekly_schedule_handler
  );
  uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_set(
    zigpc_command_mapper_thermostat_get_relay_status_log_handler
  );
  uic_mqtt_dotdot_set_color_control_write_attributes_callback(
    zigpc_command_mapper_color_control_write_attributes_handler
  );
  uic_mqtt_dotdot_set_color_control_force_read_attributes_callback(
    zigpc_command_mapper_color_control_force_read_attributes_handler
  );
  uic_mqtt_dotdot_color_control_move_to_hue_callback_set(
    zigpc_command_mapper_color_control_move_to_hue_handler
  );
  uic_mqtt_dotdot_color_control_move_hue_callback_set(
    zigpc_command_mapper_color_control_move_hue_handler
  );
  uic_mqtt_dotdot_color_control_step_hue_callback_set(
    zigpc_command_mapper_color_control_step_hue_handler
  );
  uic_mqtt_dotdot_color_control_move_to_saturation_callback_set(
    zigpc_command_mapper_color_control_move_to_saturation_handler
  );
  uic_mqtt_dotdot_color_control_move_saturation_callback_set(
    zigpc_command_mapper_color_control_move_saturation_handler
  );
  uic_mqtt_dotdot_color_control_step_saturation_callback_set(
    zigpc_command_mapper_color_control_step_saturation_handler
  );
  uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_set(
    zigpc_command_mapper_color_control_move_to_hue_and_saturation_handler
  );
  uic_mqtt_dotdot_color_control_move_to_color_callback_set(
    zigpc_command_mapper_color_control_move_to_color_handler
  );
  uic_mqtt_dotdot_color_control_move_color_callback_set(
    zigpc_command_mapper_color_control_move_color_handler
  );
  uic_mqtt_dotdot_color_control_step_color_callback_set(
    zigpc_command_mapper_color_control_step_color_handler
  );
  uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_set(
    zigpc_command_mapper_color_control_move_to_color_temperature_handler
  );
  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_set(
    zigpc_command_mapper_color_control_enhanced_move_to_hue_handler
  );
  uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_set(
    zigpc_command_mapper_color_control_enhanced_move_hue_handler
  );
  uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_set(
    zigpc_command_mapper_color_control_enhanced_step_hue_handler
  );
  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_set(
    zigpc_command_mapper_color_control_enhanced_move_to_hue_and_saturation_handler
  );
  uic_mqtt_dotdot_color_control_color_loop_set_callback_set(
    zigpc_command_mapper_color_control_color_loop_set_handler
  );
  uic_mqtt_dotdot_color_control_stop_move_step_callback_set(
    zigpc_command_mapper_color_control_stop_move_step_handler
  );
  uic_mqtt_dotdot_color_control_move_color_temperature_callback_set(
    zigpc_command_mapper_color_control_move_color_temperature_handler
  );
  uic_mqtt_dotdot_color_control_step_color_temperature_callback_set(
    zigpc_command_mapper_color_control_step_color_temperature_handler
  );
  uic_mqtt_dotdot_set_temperature_measurement_write_attributes_callback(
    zigpc_command_mapper_temperature_measurement_write_attributes_handler
  );
  uic_mqtt_dotdot_set_temperature_measurement_force_read_attributes_callback(
    zigpc_command_mapper_temperature_measurement_force_read_attributes_handler
  );
  uic_mqtt_dotdot_set_occupancy_sensing_write_attributes_callback(
    zigpc_command_mapper_occupancy_sensing_write_attributes_handler
  );
  uic_mqtt_dotdot_set_occupancy_sensing_force_read_attributes_callback(
    zigpc_command_mapper_occupancy_sensing_force_read_attributes_handler
  );
  uic_mqtt_dotdot_set_ias_zone_write_attributes_callback(
    zigpc_command_mapper_ias_zone_write_attributes_handler
  );
  uic_mqtt_dotdot_set_ias_zone_force_read_attributes_callback(
    zigpc_command_mapper_ias_zone_force_read_attributes_handler
  );
  uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_set(
    zigpc_command_mapper_ias_zone_zone_enroll_response_handler
  );
  uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_set(
    zigpc_command_mapper_ias_zone_initiate_normal_operation_mode_handler
  );
  uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_set(
    zigpc_command_mapper_ias_zone_initiate_test_mode_handler
  );
  uic_mqtt_dotdot_set_iaswd_write_attributes_callback(
    zigpc_command_mapper_iaswd_write_attributes_handler
  );
  uic_mqtt_dotdot_set_iaswd_force_read_attributes_callback(
    zigpc_command_mapper_iaswd_force_read_attributes_handler
  );
  uic_mqtt_dotdot_iaswd_start_warning_callback_set(
    zigpc_command_mapper_iaswd_start_warning_handler
  );
  uic_mqtt_dotdot_iaswd_squawk_callback_set(
    zigpc_command_mapper_iaswd_squawk_handler
  );
  uic_mqtt_dotdot_set_metering_write_attributes_callback(
    zigpc_command_mapper_metering_write_attributes_handler
  );
  uic_mqtt_dotdot_set_metering_force_read_attributes_callback(
    zigpc_command_mapper_metering_force_read_attributes_handler
  );
  uic_mqtt_dotdot_set_electrical_measurement_write_attributes_callback(
    zigpc_command_mapper_electrical_measurement_write_attributes_handler
  );
  uic_mqtt_dotdot_set_electrical_measurement_force_read_attributes_callback(
    zigpc_command_mapper_electrical_measurement_force_read_attributes_handler
  );
  uic_mqtt_dotdot_electrical_measurement_get_profile_info_response_callback_set(
    zigpc_command_mapper_electrical_measurement_get_profile_info_response_handler
  );
  uic_mqtt_dotdot_electrical_measurement_get_measurement_profile_response_callback_set(
    zigpc_command_mapper_electrical_measurement_get_measurement_profile_response_handler
  );
  return SL_STATUS_OK;
}
