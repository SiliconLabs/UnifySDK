/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.




// TODO: Investigate using 1 unicast dispatch callback with ZCL types used

#include <iostream>
#include <string>
#include <list>
#include <vector>
#include <unordered_map>

// Unify shared components
#include <sl_status.h>
#include <sl_log.h>
#include <dotdot_mqtt.h>

// ZigPC components
#include "zigpc_gateway.h"
#include "zigpc_common_zigbee.h"
#include "zcl_util.h"
#include "zcl_definitions.h"

// Internal includes
#include "zigpc_command_mapper_int.h"

static constexpr char LOG_TAG[] = "zigpc_cmdmapper";
static constexpr char LOG_FMT_INVALID_FIELDS[] = "%s::%s: Invalid fields passed in";
static constexpr char LOG_FMT_INVALID_FIELD_LIST[] = "%s::%s: Invalid %s list passed in";

/**
 * @brief Populate Write Attribute record to a frame data buffer.
 * The frame buffer is filled with the attribute id(2-bytes), attribute data
 * type (1-byte), and the attribute data(n-bytes). Since the frame data struct
 * only stores references to the data, any addition information (such as
 * attribute ID and data types) must be stored in auxillary arrays passed in.
 *
 * @param write_attr_data       Frame data array to populate.
 * @param attr_id_list          AUX Attr ID array to store and refer.
 * @param attr_data_type_list   AUX Attr data type array to store and refer.
 * @param attribute_id          Attribute ID to be used.
 * @param attribute_data_type,  Attribute data type to be used.
 * @param attribute_data        Attribute data to be used.
 */
void zigpc_command_mapper_populate_write_attr_record(
  std::vector<zigpc_zcl_frame_data_t> &write_attr_data,
  std::list<zcl_attribute_id_t> &attr_id_list,
  std::list<zigpc_zcl_data_type_t> &attr_data_type_list,
  zcl_attribute_id_t attribute_id,
  zigpc_zcl_data_type_t attribute_data_type,
  void *attribute_data
) {
  zigpc_zcl_frame_data_t frame_data;

  attr_id_list.push_back(attribute_id);
  frame_data.type = ZIGPC_ZCL_DATA_TYPE_ATTRIB_ID;
  frame_data.data = &attr_id_list.back();
  write_attr_data.push_back(frame_data);

  attr_data_type_list.push_back(attribute_data_type);
  frame_data.type = ZIGPC_ZCL_DATA_TYPE_DATA8;
  frame_data.data = &attr_data_type_list.back();
  write_attr_data.push_back(frame_data);

  frame_data.type = attribute_data_type;
  frame_data.data = attribute_data;
  write_attr_data.push_back(frame_data);

}

/**
 * @brief Populate Read Attribute record to a frame data buffer.
 * The frame buffer is filled with the attribute id(2-bytes). Since the frame
 * data struct only stores references to the data, any addition information
 * (such as attribute ID) must be stored in auxillary arrays passed in.
 *
 * @param read_attr_data        Frame data array to populate.
 * @param attr_id_list          AUX Attr ID array to store and refer.
 * @param attribute_id          Attribute ID to be used.
 */
void zigpc_command_mapper_populate_read_attr_record(
  std::vector<zigpc_zcl_frame_data_t> &read_attr_data,
  std::list<zcl_attribute_id_t> &attr_id_list,
  zcl_attribute_id_t attribute_id
) {
  zigpc_zcl_frame_data_t frame_data;

  attr_id_list.push_back(attribute_id);
  frame_data.type = ZIGPC_ZCL_DATA_TYPE_ATTRIB_ID;
  frame_data.data = &attr_id_list.back();
  read_attr_data.push_back(frame_data);
}

/******************
 * DotDot MQTT Command Handlers for Identify cluster
 ******************/

/**
 * @brief DotDot MQTT handler for IdentifyTime/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_identify_state_t Attribute values
 * uic_mqtt_dotdot_identify_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_identify_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_identify_state_t values,
  uic_mqtt_dotdot_identify_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IDENTIFY);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.identify_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_IDENTIFY_ATTR_IDENTIFY_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.identify_time
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IDENTIFY,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for IdentifyTime/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_identify_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_identify_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_identify_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IDENTIFY);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.identify_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IDENTIFY_ATTR_IDENTIFY_TIME
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IDENTIFY,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for Identify/Identify command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param identify_time  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_identify_identify_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t identify_time

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IDENTIFY);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &identify_time });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IDENTIFY,
      ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_IDENTIFY,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Identify/IdentifyQuery command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_identify_identify_query_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IDENTIFY);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IDENTIFY,
      ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_IDENTIFY_QUERY,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Identify/TriggerEffect command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param effect_identifier  Command argument of type TriggerEffectEffectIdentifier

 * @param effect_variant  Command argument of type TriggerEffectEffectVariant
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_identify_trigger_effect_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    TriggerEffectEffectIdentifier effect_identifier,

    TriggerEffectEffectVariant effect_variant

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IDENTIFY);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &effect_identifier });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &effect_variant });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IDENTIFY,
      ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_TRIGGER_EFFECT,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for Groups cluster
 ******************/

/**
 * @brief DotDot MQTT handler for NameSupport/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_groups_state_t Attribute values
 * uic_mqtt_dotdot_groups_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_groups_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_groups_state_t values,
  uic_mqtt_dotdot_groups_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_GROUPS,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for NameSupport/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_groups_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_groups_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_groups_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.name_support == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_GROUPS_ATTR_NAME_SUPPORT
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_GROUPS,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for Groups/AddGroup command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param group_id  Command argument of type uint16_t

 * @param group_name  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_add_group_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t group_id,

    const char* group_name

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &group_id });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_STRING, group_name });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_ADD_GROUP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Groups/ViewGroup command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param group_id  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_view_group_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t group_id

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &group_id });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_VIEW_GROUP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Groups/GetGroupMembership command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @param group_list_count  Count of uint16_t items
 * @param group_list  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_get_group_membership_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t group_list_count,
    const uint16_t *group_list

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }

  if ((group_list_count > 0U) && (group_list == nullptr)) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELD_LIST, "Groups", "GetGroupMembership", "GroupList");
    return SL_STATUS_INVALID_PARAMETER;
  }


  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &group_list_count });
  for(uint8_t i = 0U; i < group_list_count; i++) {
    cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &group_list[i] });
  }

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_GET_GROUP_MEMBERSHIP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Groups/RemoveGroup command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param group_id  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_remove_group_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t group_id

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &group_id });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_REMOVE_GROUP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Groups/RemoveAllGroups command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_remove_all_groups_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_REMOVE_ALL_GROUPS,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Groups/AddGroupIfIdentifying command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param group_id  Command argument of type uint16_t

 * @param group_name  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_groups_add_group_if_identifying_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t group_id,

    const char* group_name

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_GROUPS);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &group_id });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_STRING, group_name });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_GROUPS,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_ADD_GROUP_IF_IDENTIFYING,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for OnOff cluster
 ******************/

/**
 * @brief DotDot MQTT handler for OnOff/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_on_off_state_t Attribute values
 * uic_mqtt_dotdot_on_off_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_on_off_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_on_off_state_t values,
  uic_mqtt_dotdot_on_off_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.on_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.on_time
      );
    }

    if (values_to_write.off_wait_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_OFF_WAIT_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.off_wait_time
      );
    }

    if (values_to_write.start_up_on_off == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_START_UP_ON_OFF,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.start_up_on_off
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_ON_OFF,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for OnOff/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_on_off_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_on_off_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_on_off_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.on_off == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_OFF
      );
    }
    if (attributes_to_read.global_scene_control == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_GLOBAL_SCENE_CONTROL
      );
    }
    if (attributes_to_read.on_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_ON_TIME
      );
    }
    if (attributes_to_read.off_wait_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_OFF_WAIT_TIME
      );
    }
    if (attributes_to_read.start_up_on_off == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_ON_OFF_ATTR_START_UP_ON_OFF
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_ON_OFF,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for OnOff/Off command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_OFF,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for OnOff/On command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_on_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_ON,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for OnOff/Toggle command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_toggle_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_TOGGLE,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for OnOff/OffWithEffect command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param effect_identifier  Command argument of type OffWithEffectEffectIdentifier

 * @param effect_variant  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_off_with_effect_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    OffWithEffectEffectIdentifier effect_identifier,

    uint8_t effect_variant

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &effect_identifier });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &effect_variant });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_OFF_WITH_EFFECT,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for OnOff/OnWithRecallGlobalScene command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_on_with_recall_global_scene_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_ON_WITH_RECALL_GLOBAL_SCENE,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for OnOff/OnWithTimedOff command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param on_off_control  Command argument of type uint8_t

 * @param on_time  Command argument of type uint16_t

 * @param off_wait_time  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_on_off_on_with_timed_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t on_off_control,

    uint16_t on_time,

    uint16_t off_wait_time

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_ON_OFF);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &on_off_control });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &on_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &off_wait_time });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_ON_OFF,
      ZIGPC_ZCL_CLUSTER_ON_OFF_COMMAND_ON_WITH_TIMED_OFF,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for Level cluster
 ******************/

/**
 * @brief DotDot MQTT handler for CurrentLevel/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_level_state_t Attribute values
 * uic_mqtt_dotdot_level_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_level_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_level_state_t values,
  uic_mqtt_dotdot_level_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.options == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OPTIONS,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.options
      );
    }

    if (values_to_write.on_off_transition_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_OFF_TRANSITION_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.on_off_transition_time
      );
    }

    if (values_to_write.on_level == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_LEVEL,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.on_level
      );
    }

    if (values_to_write.on_transition_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_TRANSITION_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.on_transition_time
      );
    }

    if (values_to_write.off_transition_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OFF_TRANSITION_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.off_transition_time
      );
    }

    if (values_to_write.default_move_rate == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_DEFAULT_MOVE_RATE,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.default_move_rate
      );
    }

    if (values_to_write.start_up_current_level == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_START_UP_CURRENT_LEVEL,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.start_up_current_level
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_LEVEL,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for CurrentLevel/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_level_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_level_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_level_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.current_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_CURRENT_LEVEL
      );
    }
    if (attributes_to_read.remaining_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_REMAINING_TIME
      );
    }
    if (attributes_to_read.min_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MIN_LEVEL
      );
    }
    if (attributes_to_read.max_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MAX_LEVEL
      );
    }
    if (attributes_to_read.current_frequency == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_CURRENT_FREQUENCY
      );
    }
    if (attributes_to_read.min_frequency == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MIN_FREQUENCY
      );
    }
    if (attributes_to_read.max_frequency == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_MAX_FREQUENCY
      );
    }
    if (attributes_to_read.options == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OPTIONS
      );
    }
    if (attributes_to_read.on_off_transition_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_OFF_TRANSITION_TIME
      );
    }
    if (attributes_to_read.on_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_LEVEL
      );
    }
    if (attributes_to_read.on_transition_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_ON_TRANSITION_TIME
      );
    }
    if (attributes_to_read.off_transition_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_OFF_TRANSITION_TIME
      );
    }
    if (attributes_to_read.default_move_rate == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_DEFAULT_MOVE_RATE
      );
    }
    if (attributes_to_read.start_up_current_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_LEVEL_ATTR_START_UP_CURRENT_LEVEL
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_LEVEL,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for Level/MoveToLevel command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param level  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_move_to_level_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t level,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &level });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_TO_LEVEL,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/Move command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type MoveStepMode

 * @param rate  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_move_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    MoveStepMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/Step command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type MoveStepMode

 * @param step_size  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_step_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    MoveStepMode step_mode,

    uint8_t step_size,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STEP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/Stop command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_stop_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STOP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/MoveToLevelWithOnOff command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param level  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_move_to_level_with_on_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t level,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &level });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_TO_LEVEL_WITH_ON_OFF,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/MoveWithOnOff command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type MoveStepMode

 * @param rate  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_move_with_on_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    MoveStepMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_WITH_ON_OFF,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/StepWithOnOff command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type MoveStepMode

 * @param step_size  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_step_with_on_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    MoveStepMode step_mode,

    uint8_t step_size,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STEP_WITH_ON_OFF,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/StopWithOnOff command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_stop_with_on_off_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_STOP_WITH_ON_OFF,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Level/MoveToClosestFrequency command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param frequency  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_level_move_to_closest_frequency_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t frequency

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_LEVEL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &frequency });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_LEVEL,
      ZIGPC_ZCL_CLUSTER_LEVEL_COMMAND_MOVE_TO_CLOSEST_FREQUENCY,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for PollControl cluster
 ******************/

/**
 * @brief DotDot MQTT handler for CheckInInterval/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_poll_control_state_t Attribute values
 * uic_mqtt_dotdot_poll_control_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_poll_control_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_poll_control_state_t values,
  uic_mqtt_dotdot_poll_control_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_POLL_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.check_in_interval == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL,
        ZIGPC_ZCL_DATA_TYPE_UINT32,
        &values.check_in_interval
      );
    }

    if (values_to_write.fast_poll_timeout == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.fast_poll_timeout
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for CheckInInterval/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_poll_control_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_poll_control_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_poll_control_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_POLL_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.check_in_interval == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL
      );
    }
    if (attributes_to_read.long_poll_interval == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_LONG_POLL_INTERVAL
      );
    }
    if (attributes_to_read.short_poll_interval == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_SHORT_POLL_INTERVAL
      );
    }
    if (attributes_to_read.fast_poll_timeout == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT
      );
    }
    if (attributes_to_read.check_in_interval_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_CHECK_IN_INTERVAL_MIN
      );
    }
    if (attributes_to_read.long_poll_interval_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_LONG_POLL_INTERVAL_MIN
      );
    }
    if (attributes_to_read.fast_poll_timeout_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL_ATTR_FAST_POLL_TIMEOUT_MAX
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_POLL_CONTROL,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for PollControl/CheckIn command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_poll_control_check_in_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_POLL_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL,
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_CHECK_IN,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for DoorLock cluster
 ******************/

/**
 * @brief DotDot MQTT handler for LockState/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_door_lock_state_t Attribute values
 * uic_mqtt_dotdot_door_lock_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_door_lock_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_door_lock_state_t values,
  uic_mqtt_dotdot_door_lock_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.door_open_events == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_OPEN_EVENTS,
        ZIGPC_ZCL_DATA_TYPE_UINT32,
        &values.door_open_events
      );
    }

    if (values_to_write.door_closed_events == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_CLOSED_EVENTS,
        ZIGPC_ZCL_DATA_TYPE_UINT32,
        &values.door_closed_events
      );
    }

    if (values_to_write.open_period == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPEN_PERIOD,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.open_period
      );
    }

    if (values_to_write.enable_logging == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOGGING,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.enable_logging
      );
    }

    if (values_to_write.language == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LANGUAGE,
        ZIGPC_ZCL_DATA_TYPE_STRING,
        &values.language
      );
    }

    if (values_to_write.led_settings == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LED_SETTINGS,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.led_settings
      );
    }

    if (values_to_write.auto_relock_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_AUTO_RELOCK_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT32,
        &values.auto_relock_time
      );
    }

    if (values_to_write.sound_volume == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SOUND_VOLUME,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.sound_volume
      );
    }

    if (values_to_write.operating_mode == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPERATING_MODE,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.operating_mode
      );
    }

    if (values_to_write.enable_local_programming == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOCAL_PROGRAMMING,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.enable_local_programming
      );
    }

    if (values_to_write.enable_one_touch_locking == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_ONE_TOUCH_LOCKING,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.enable_one_touch_locking
      );
    }

    if (values_to_write.enable_inside_statusled == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_INSIDE_STATUSLED,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.enable_inside_statusled
      );
    }

    if (values_to_write.enable_privacy_mode_button == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_PRIVACY_MODE_BUTTON,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.enable_privacy_mode_button
      );
    }

    if (values_to_write.wrong_code_entry_limit == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_WRONG_CODE_ENTRY_LIMIT,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.wrong_code_entry_limit
      );
    }

    if (values_to_write.user_code_temporary_disable_time == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_USER_CODE_TEMPORARY_DISABLE_TIME,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.user_code_temporary_disable_time
      );
    }

    if (values_to_write.sendpin_over_the_air == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SENDPIN_OVER_THE_AIR,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.sendpin_over_the_air
      );
    }

    if (values_to_write.requirepi_nforrf_operation == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_REQUIREPI_NFORRF_OPERATION,
        ZIGPC_ZCL_DATA_TYPE_BOOL,
        &values.requirepi_nforrf_operation
      );
    }

    if (values_to_write.alarm_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ALARM_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.alarm_mask
      );
    }

    if (values_to_write.keypad_operation_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_OPERATION_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.keypad_operation_event_mask
      );
    }

    if (values_to_write.rf_operation_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_OPERATION_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.rf_operation_event_mask
      );
    }

    if (values_to_write.manual_operation_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MANUAL_OPERATION_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.manual_operation_event_mask
      );
    }

    if (values_to_write.rfid_operation_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_OPERATION_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.rfid_operation_event_mask
      );
    }

    if (values_to_write.keypad_programming_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_PROGRAMMING_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.keypad_programming_event_mask
      );
    }

    if (values_to_write.rf_programming_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_PROGRAMMING_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.rf_programming_event_mask
      );
    }

    if (values_to_write.rfid_programming_event_mask == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_PROGRAMMING_EVENT_MASK,
        ZIGPC_ZCL_DATA_TYPE_MAP16,
        &values.rfid_programming_event_mask
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for LockState/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_door_lock_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_door_lock_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_door_lock_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.lock_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCK_STATE
      );
    }
    if (attributes_to_read.lock_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LOCK_TYPE
      );
    }
    if (attributes_to_read.actuator_enabled == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ACTUATOR_ENABLED
      );
    }
    if (attributes_to_read.door_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_STATE
      );
    }
    if (attributes_to_read.door_open_events == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_OPEN_EVENTS
      );
    }
    if (attributes_to_read.door_closed_events == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DOOR_CLOSED_EVENTS
      );
    }
    if (attributes_to_read.open_period == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPEN_PERIOD
      );
    }
    if (attributes_to_read.number_of_log_records_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_LOG_RECORDS_SUPPORTED
      );
    }
    if (attributes_to_read.number_of_total_users_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_TOTAL_USERS_SUPPORTED
      );
    }
    if (attributes_to_read.number_ofpin_users_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OFPIN_USERS_SUPPORTED
      );
    }
    if (attributes_to_read.number_ofrfid_users_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OFRFID_USERS_SUPPORTED
      );
    }
    if (attributes_to_read.number_of_week_day_schedules_supported_per_user == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_WEEK_DAY_SCHEDULES_SUPPORTED_PER_USER
      );
    }
    if (attributes_to_read.number_of_year_day_schedules_supported_per_user == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_YEAR_DAY_SCHEDULES_SUPPORTED_PER_USER
      );
    }
    if (attributes_to_read.number_of_holiday_schedules_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_NUMBER_OF_HOLIDAY_SCHEDULES_SUPPORTED
      );
    }
    if (attributes_to_read.maxpin_code_length == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MAXPIN_CODE_LENGTH
      );
    }
    if (attributes_to_read.minpin_code_length == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MINPIN_CODE_LENGTH
      );
    }
    if (attributes_to_read.maxrfid_code_length == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MAXRFID_CODE_LENGTH
      );
    }
    if (attributes_to_read.minrfid_code_length == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MINRFID_CODE_LENGTH
      );
    }
    if (attributes_to_read.enable_logging == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOGGING
      );
    }
    if (attributes_to_read.language == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LANGUAGE
      );
    }
    if (attributes_to_read.led_settings == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_LED_SETTINGS
      );
    }
    if (attributes_to_read.auto_relock_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_AUTO_RELOCK_TIME
      );
    }
    if (attributes_to_read.sound_volume == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SOUND_VOLUME
      );
    }
    if (attributes_to_read.operating_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_OPERATING_MODE
      );
    }
    if (attributes_to_read.supported_operating_modes == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SUPPORTED_OPERATING_MODES
      );
    }
    if (attributes_to_read.default_configuration_register == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_DEFAULT_CONFIGURATION_REGISTER
      );
    }
    if (attributes_to_read.enable_local_programming == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_LOCAL_PROGRAMMING
      );
    }
    if (attributes_to_read.enable_one_touch_locking == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_ONE_TOUCH_LOCKING
      );
    }
    if (attributes_to_read.enable_inside_statusled == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_INSIDE_STATUSLED
      );
    }
    if (attributes_to_read.enable_privacy_mode_button == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ENABLE_PRIVACY_MODE_BUTTON
      );
    }
    if (attributes_to_read.wrong_code_entry_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_WRONG_CODE_ENTRY_LIMIT
      );
    }
    if (attributes_to_read.user_code_temporary_disable_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_USER_CODE_TEMPORARY_DISABLE_TIME
      );
    }
    if (attributes_to_read.sendpin_over_the_air == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SENDPIN_OVER_THE_AIR
      );
    }
    if (attributes_to_read.requirepi_nforrf_operation == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_REQUIREPI_NFORRF_OPERATION
      );
    }
    if (attributes_to_read.security_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_SECURITY_LEVEL
      );
    }
    if (attributes_to_read.alarm_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_ALARM_MASK
      );
    }
    if (attributes_to_read.keypad_operation_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_OPERATION_EVENT_MASK
      );
    }
    if (attributes_to_read.rf_operation_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_OPERATION_EVENT_MASK
      );
    }
    if (attributes_to_read.manual_operation_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_MANUAL_OPERATION_EVENT_MASK
      );
    }
    if (attributes_to_read.rfid_operation_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_OPERATION_EVENT_MASK
      );
    }
    if (attributes_to_read.keypad_programming_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_KEYPAD_PROGRAMMING_EVENT_MASK
      );
    }
    if (attributes_to_read.rf_programming_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RF_PROGRAMMING_EVENT_MASK
      );
    }
    if (attributes_to_read.rfid_programming_event_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK_ATTR_RFID_PROGRAMMING_EVENT_MASK
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for DoorLock/LockDoor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param pin_orrfid_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_lock_door_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    const char* pin_orrfid_code

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin_orrfid_code });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_LOCK_DOOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/UnlockDoor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param pin_orrfid_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_unlock_door_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    const char* pin_orrfid_code

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin_orrfid_code });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_DOOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/Toggle command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param pin_orrfid_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_toggle_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    const char* pin_orrfid_code

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin_orrfid_code });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_TOGGLE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/UnlockWithTimeout command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param timeout_in_seconds  Command argument of type uint16_t

 * @param pin_orrfid_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_unlock_with_timeout_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t timeout_in_seconds,

    const char* pin_orrfid_code

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &timeout_in_seconds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin_orrfid_code });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_WITH_TIMEOUT,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetLogRecord command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param log_index  Command argument of type uint16_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_log_record_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t log_index

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &log_index });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_LOG_RECORD,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetPINCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkPINUserID

 * @param user_status  Command argument of type DrlkSettableUserStatus

 * @param user_type  Command argument of type DrlkUserType

 * @param pin  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_setpin_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkPINUserID userid,

    DrlkSettableUserStatus user_status,

    DrlkUserType user_type,

    const char* pin

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &user_status });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &user_type });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, pin });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SETPIN_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetPINCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkPINUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_getpin_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkPINUserID userid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GETPIN_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearPINCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkPINUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clearpin_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkPINUserID userid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEARPIN_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearAllPINCodes command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_allpin_codes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALLPIN_CODES,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetUserStatus command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkTotalUserID

 * @param user_status  Command argument of type DrlkSettableUserStatus
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_user_status_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkTotalUserID userid,

    DrlkSettableUserStatus user_status

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &user_status });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_STATUS,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetUserStatus command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_user_status_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkTotalUserID userid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_STATUS,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetWeekdaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkWeekDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID

 * @param days_mask  Command argument of type uint8_t

 * @param start_hour  Command argument of type uint8_t

 * @param start_minute  Command argument of type uint8_t

 * @param end_hour  Command argument of type uint8_t

 * @param end_minute  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_weekday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkWeekDayScheduleID scheduleid,

    DrlkTotalUserID userid,

    uint8_t days_mask,

    uint8_t start_hour,

    uint8_t start_minute,

    uint8_t end_hour,

    uint8_t end_minute

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &days_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &start_hour });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &start_minute });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &end_hour });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &end_minute });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_WEEKDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetWeekdaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkWeekDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_weekday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkWeekDayScheduleID scheduleid,

    DrlkTotalUserID userid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_WEEKDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearWeekdaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkWeekDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_weekday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkWeekDayScheduleID scheduleid,

    DrlkTotalUserID userid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_WEEKDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetYearDaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkYearDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID

 * @param local_start_time  Command argument of type uint32_t

 * @param local_end_time  Command argument of type uint32_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_year_day_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkYearDayScheduleID scheduleid,

    DrlkTotalUserID userid,

    uint32_t local_start_time,

    uint32_t local_end_time

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &local_start_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &local_end_time });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_YEAR_DAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetYearDaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkYearDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_year_day_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkYearDayScheduleID scheduleid,

    DrlkTotalUserID userid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_YEAR_DAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearYearDaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param scheduleid  Command argument of type DrlkYearDayScheduleID

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_year_day_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkYearDayScheduleID scheduleid,

    DrlkTotalUserID userid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_YEAR_DAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetHolidaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param holiday_scheduleid  Command argument of type DrlkHolidayScheduleID

 * @param local_start_time  Command argument of type uint32_t

 * @param local_end_time  Command argument of type uint32_t

 * @param operating_mode_during_holiday  Command argument of type DrlkOperMode
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_holiday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkHolidayScheduleID holiday_scheduleid,

    uint32_t local_start_time,

    uint32_t local_end_time,

    DrlkOperMode operating_mode_during_holiday

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &holiday_scheduleid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &local_start_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT32, &local_end_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &operating_mode_during_holiday });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_HOLIDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetHolidaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param holiday_scheduleid  Command argument of type DrlkHolidayScheduleID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_holiday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkHolidayScheduleID holiday_scheduleid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &holiday_scheduleid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_HOLIDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearHolidaySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param holiday_scheduleid  Command argument of type DrlkHolidayScheduleID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_holiday_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkHolidayScheduleID holiday_scheduleid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &holiday_scheduleid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_HOLIDAY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetUserType command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkTotalUserID

 * @param user_type  Command argument of type DrlkUserType
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_set_user_type_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkTotalUserID userid,

    DrlkUserType user_type

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &user_type });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_TYPE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetUserType command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkTotalUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_user_type_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkTotalUserID userid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_TYPE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/SetRFIDCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkRFIDUserID

 * @param user_status  Command argument of type DrlkSettableUserStatus

 * @param user_type  Command argument of type DrlkUserType

 * @param rfid_code  Command argument of type const char*
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_setrfid_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkRFIDUserID userid,

    DrlkSettableUserStatus user_status,

    DrlkUserType user_type,

    const char* rfid_code

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &user_status });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &user_type });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_OCTSTR, rfid_code });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SETRFID_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetRFIDCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkRFIDUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_getrfid_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkRFIDUserID userid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GETRFID_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearRFIDCode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param userid  Command argument of type DrlkRFIDUserID
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clearrfid_code_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    DrlkRFIDUserID userid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &userid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEARRFID_CODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/ClearAllRFIDCodes command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_clear_allrfid_codes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
 * @brief DotDot MQTT translator handler for DoorLock/GetAllPINCodes command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_allpin_codes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_ALLPIN_CODES,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALLRFID_CODES,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for DoorLock/GetAllPINCodes command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_door_lock_get_allpin_codes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_DOOR_LOCK);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_ALLPIN_CODES,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for Thermostat cluster
 ******************/

/**
 * @brief DotDot MQTT handler for LocalTemperature/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_thermostat_state_t Attribute values
 * uic_mqtt_dotdot_thermostat_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_thermostat_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_thermostat_state_t values,
  uic_mqtt_dotdot_thermostat_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.hvac_system_type_configuration == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_HVAC_SYSTEM_TYPE_CONFIGURATION,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.hvac_system_type_configuration
      );
    }

    if (values_to_write.local_temperature_calibration == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE_CALIBRATION,
        ZIGPC_ZCL_DATA_TYPE_INT8,
        &values.local_temperature_calibration
      );
    }

    if (values_to_write.occupied_cooling_setpoint == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_COOLING_SETPOINT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.occupied_cooling_setpoint
      );
    }

    if (values_to_write.occupied_heating_setpoint == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_HEATING_SETPOINT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.occupied_heating_setpoint
      );
    }

    if (values_to_write.unoccupied_cooling_setpoint == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_COOLING_SETPOINT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.unoccupied_cooling_setpoint
      );
    }

    if (values_to_write.unoccupied_heating_setpoint == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_HEATING_SETPOINT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.unoccupied_heating_setpoint
      );
    }

    if (values_to_write.min_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_HEAT_SETPOINT_LIMIT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.min_heat_setpoint_limit
      );
    }

    if (values_to_write.max_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_HEAT_SETPOINT_LIMIT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.max_heat_setpoint_limit
      );
    }

    if (values_to_write.min_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_COOL_SETPOINT_LIMIT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.min_cool_setpoint_limit
      );
    }

    if (values_to_write.max_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_COOL_SETPOINT_LIMIT,
        ZIGPC_ZCL_DATA_TYPE_INT16,
        &values.max_cool_setpoint_limit
      );
    }

    if (values_to_write.min_setpoint_dead_band == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_SETPOINT_DEAD_BAND,
        ZIGPC_ZCL_DATA_TYPE_INT8,
        &values.min_setpoint_dead_band
      );
    }

    if (values_to_write.remote_sensing == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_REMOTE_SENSING,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.remote_sensing
      );
    }

    if (values_to_write.control_sequence_of_operation == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_CONTROL_SEQUENCE_OF_OPERATION,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.control_sequence_of_operation
      );
    }

    if (values_to_write.system_mode == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SYSTEM_MODE,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.system_mode
      );
    }

    if (values_to_write.temperature_setpoint_hold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.temperature_setpoint_hold
      );
    }

    if (values_to_write.temperature_setpoint_hold_duration == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD_DURATION,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.temperature_setpoint_hold_duration
      );
    }

    if (values_to_write.thermostat_programming_operation_mode == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_PROGRAMMING_OPERATION_MODE,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.thermostat_programming_operation_mode
      );
    }

    if (values_to_write.occupied_setback == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.occupied_setback
      );
    }

    if (values_to_write.unoccupied_setback == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.unoccupied_setback
      );
    }

    if (values_to_write.emergency_heat_delta == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_EMERGENCY_HEAT_DELTA,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.emergency_heat_delta
      );
    }

    if (values_to_write.ac_type == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_TYPE,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.ac_type
      );
    }

    if (values_to_write.ac_capacity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.ac_capacity
      );
    }

    if (values_to_write.ac_refrigerant_type == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_REFRIGERANT_TYPE,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.ac_refrigerant_type
      );
    }

    if (values_to_write.ac_compressor_type == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COMPRESSOR_TYPE,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.ac_compressor_type
      );
    }

    if (values_to_write.ac_error_code == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_ERROR_CODE,
        ZIGPC_ZCL_DATA_TYPE_MAP32,
        &values.ac_error_code
      );
    }

    if (values_to_write.ac_louver_position == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_LOUVER_POSITION,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.ac_louver_position
      );
    }

    if (values_to_write.ac_capacity_format == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY_FORMAT,
        ZIGPC_ZCL_DATA_TYPE_ENUM8,
        &values.ac_capacity_format
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for LocalTemperature/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_thermostat_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_thermostat_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_thermostat_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.local_temperature == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE
      );
    }
    if (attributes_to_read.outdoor_temperature == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OUTDOOR_TEMPERATURE
      );
    }
    if (attributes_to_read.occupancy == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPANCY
      );
    }
    if (attributes_to_read.abs_min_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MIN_HEAT_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.abs_max_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MAX_HEAT_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.abs_min_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MIN_COOL_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.abs_max_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ABS_MAX_COOL_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.pi_cooling_demand == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_PI_COOLING_DEMAND
      );
    }
    if (attributes_to_read.pi_heating_demand == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_PI_HEATING_DEMAND
      );
    }
    if (attributes_to_read.hvac_system_type_configuration == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_HVAC_SYSTEM_TYPE_CONFIGURATION
      );
    }
    if (attributes_to_read.local_temperature_calibration == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_LOCAL_TEMPERATURE_CALIBRATION
      );
    }
    if (attributes_to_read.occupied_cooling_setpoint == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_COOLING_SETPOINT
      );
    }
    if (attributes_to_read.occupied_heating_setpoint == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_HEATING_SETPOINT
      );
    }
    if (attributes_to_read.unoccupied_cooling_setpoint == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_COOLING_SETPOINT
      );
    }
    if (attributes_to_read.unoccupied_heating_setpoint == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_HEATING_SETPOINT
      );
    }
    if (attributes_to_read.min_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_HEAT_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.max_heat_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_HEAT_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.min_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_COOL_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.max_cool_setpoint_limit == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MAX_COOL_SETPOINT_LIMIT
      );
    }
    if (attributes_to_read.min_setpoint_dead_band == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_MIN_SETPOINT_DEAD_BAND
      );
    }
    if (attributes_to_read.remote_sensing == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_REMOTE_SENSING
      );
    }
    if (attributes_to_read.control_sequence_of_operation == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_CONTROL_SEQUENCE_OF_OPERATION
      );
    }
    if (attributes_to_read.system_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SYSTEM_MODE
      );
    }
    if (attributes_to_read.alarm_mask == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_ALARM_MASK
      );
    }
    if (attributes_to_read.thermostat_running_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_RUNNING_MODE
      );
    }
    if (attributes_to_read.start_of_week == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_START_OF_WEEK
      );
    }
    if (attributes_to_read.number_of_weekly_transitions == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_NUMBER_OF_WEEKLY_TRANSITIONS
      );
    }
    if (attributes_to_read.number_of_daily_transitions == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_NUMBER_OF_DAILY_TRANSITIONS
      );
    }
    if (attributes_to_read.temperature_setpoint_hold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD
      );
    }
    if (attributes_to_read.temperature_setpoint_hold_duration == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_TEMPERATURE_SETPOINT_HOLD_DURATION
      );
    }
    if (attributes_to_read.thermostat_programming_operation_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_PROGRAMMING_OPERATION_MODE
      );
    }
    if (attributes_to_read.thermostat_running_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_THERMOSTAT_RUNNING_STATE
      );
    }
    if (attributes_to_read.setpoint_change_source == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_SOURCE
      );
    }
    if (attributes_to_read.setpoint_change_amount == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_AMOUNT
      );
    }
    if (attributes_to_read.setpoint_change_source_timestamp == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_SETPOINT_CHANGE_SOURCE_TIMESTAMP
      );
    }
    if (attributes_to_read.occupied_setback == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK
      );
    }
    if (attributes_to_read.occupied_setback_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK_MIN
      );
    }
    if (attributes_to_read.occupied_setback_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_OCCUPIED_SETBACK_MAX
      );
    }
    if (attributes_to_read.unoccupied_setback == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK
      );
    }
    if (attributes_to_read.unoccupied_setback_min == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK_MIN
      );
    }
    if (attributes_to_read.unoccupied_setback_max == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_UNOCCUPIED_SETBACK_MAX
      );
    }
    if (attributes_to_read.emergency_heat_delta == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_EMERGENCY_HEAT_DELTA
      );
    }
    if (attributes_to_read.ac_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_TYPE
      );
    }
    if (attributes_to_read.ac_capacity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY
      );
    }
    if (attributes_to_read.ac_refrigerant_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_REFRIGERANT_TYPE
      );
    }
    if (attributes_to_read.ac_compressor_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COMPRESSOR_TYPE
      );
    }
    if (attributes_to_read.ac_error_code == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_ERROR_CODE
      );
    }
    if (attributes_to_read.ac_louver_position == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_LOUVER_POSITION
      );
    }
    if (attributes_to_read.ac_coil_temperature == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_COIL_TEMPERATURE
      );
    }
    if (attributes_to_read.ac_capacity_format == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT_ATTR_AC_CAPACITY_FORMAT
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_THERMOSTAT,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for Thermostat/SetpointRaiseOrLower command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param mode  Command argument of type SetpointRaiseOrLowerMode

 * @param amount  Command argument of type int8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_thermostat_setpoint_raise_or_lower_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    SetpointRaiseOrLowerMode mode,

    int8_t amount

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT8, &amount });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_SETPOINT_RAISE_OR_LOWER,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Thermostat/SetWeeklySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param number_of_transitions  Command argument of type uint8_t

 * @param day_of_week  Command argument of type uint8_t

 * @param mode  Command argument of type uint8_t
 * @param transitions_count  Count of TransitionType items
 * @param transitions  Command argument of type TransitionType
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_thermostat_set_weekly_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t number_of_transitions,

    uint8_t day_of_week,

    uint8_t mode,

    uint8_t transitions_count,
    const TransitionType *transitions

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }

  if ((transitions_count > 0U) && (transitions == nullptr)) {
    sl_log_warning(LOG_TAG, LOG_FMT_INVALID_FIELD_LIST, "Thermostat", "SetWeeklySchedule", "Transitions");
    return SL_STATUS_INVALID_PARAMETER;
  }

  std::vector< zigpc_zcl_transition_type_t > zigpc_transitions_vec;

  for(uint8_t i = 0; i < transitions_count; i++) {
    zigpc_transitions_vec.push_back({
      .transition_time = transitions[i].TransitionTime,
      .heat_set_point = transitions[i].HeatSetPoint,
      .cool_set_point = transitions[i].CoolSetPoint,
    });
  }

  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &number_of_transitions });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &day_of_week });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &mode });
  for(uint8_t i = 0U; i < transitions_count; i++) {
    cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_STRUCT_TRANSITION_TYPE, &zigpc_transitions_vec[i] });
  }

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_SET_WEEKLY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Thermostat/GetWeeklySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param days_to_return  Command argument of type uint8_t

 * @param mode_to_return  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_thermostat_get_weekly_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t days_to_return,

    uint8_t mode_to_return

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &days_to_return });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &mode_to_return });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_WEEKLY_SCHEDULE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Thermostat/ClearWeeklySchedule command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_thermostat_clear_weekly_schedule_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_CLEAR_WEEKLY_SCHEDULE,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for Thermostat/GetRelayStatusLog command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_thermostat_get_relay_status_log_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_THERMOSTAT);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_RELAY_STATUS_LOG,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for ColorControl cluster
 ******************/

/**
 * @brief DotDot MQTT handler for CurrentHue/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_color_control_state_t Attribute values
 * uic_mqtt_dotdot_color_control_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_color_control_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_color_control_state_t values,
  uic_mqtt_dotdot_color_control_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.options == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_OPTIONS,
        ZIGPC_ZCL_DATA_TYPE_MAP8,
        &values.options
      );
    }

    if (values_to_write.white_pointx == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTX,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.white_pointx
      );
    }

    if (values_to_write.white_pointy == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.white_pointy
      );
    }

    if (values_to_write.color_pointrx == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRX,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointrx
      );
    }

    if (values_to_write.color_pointry == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointry
      );
    }

    if (values_to_write.color_pointr_intensity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTR_INTENSITY,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.color_pointr_intensity
      );
    }

    if (values_to_write.color_pointgx == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGX,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointgx
      );
    }

    if (values_to_write.color_pointgy == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointgy
      );
    }

    if (values_to_write.color_pointg_intensity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTG_INTENSITY,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.color_pointg_intensity
      );
    }

    if (values_to_write.color_pointbx == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBX,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointbx
      );
    }

    if (values_to_write.color_pointby == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.color_pointby
      );
    }

    if (values_to_write.color_pointb_intensity == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTB_INTENSITY,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.color_pointb_intensity
      );
    }

    if (values_to_write.start_up_color_temperature_mireds == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_START_UP_COLOR_TEMPERATURE_MIREDS,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.start_up_color_temperature_mireds
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for CurrentHue/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_color_control_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_color_control_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_color_control_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.current_hue == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENT_HUE
      );
    }
    if (attributes_to_read.current_saturation == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENT_SATURATION
      );
    }
    if (attributes_to_read.remaining_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_REMAINING_TIME
      );
    }
    if (attributes_to_read.currentx == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENTX
      );
    }
    if (attributes_to_read.currenty == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_CURRENTY
      );
    }
    if (attributes_to_read.drift_compensation == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_DRIFT_COMPENSATION
      );
    }
    if (attributes_to_read.compensation_text == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COMPENSATION_TEXT
      );
    }
    if (attributes_to_read.color_temperature_mireds == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMPERATURE_MIREDS
      );
    }
    if (attributes_to_read.color_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_MODE
      );
    }
    if (attributes_to_read.options == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_OPTIONS
      );
    }
    if (attributes_to_read.number_of_primaries == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_NUMBER_OF_PRIMARIES
      );
    }
    if (attributes_to_read.primary1x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1X
      );
    }
    if (attributes_to_read.primary1y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1Y
      );
    }
    if (attributes_to_read.primary1_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY1_INTENSITY
      );
    }
    if (attributes_to_read.primary2x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2X
      );
    }
    if (attributes_to_read.primary2y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2Y
      );
    }
    if (attributes_to_read.primary2_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY2_INTENSITY
      );
    }
    if (attributes_to_read.primary3x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3X
      );
    }
    if (attributes_to_read.primary3y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3Y
      );
    }
    if (attributes_to_read.primary3_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY3_INTENSITY
      );
    }
    if (attributes_to_read.primary4x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4X
      );
    }
    if (attributes_to_read.primary4y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4Y
      );
    }
    if (attributes_to_read.primary4_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY4_INTENSITY
      );
    }
    if (attributes_to_read.primary5x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5X
      );
    }
    if (attributes_to_read.primary5y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5Y
      );
    }
    if (attributes_to_read.primary5_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY5_INTENSITY
      );
    }
    if (attributes_to_read.primary6x == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6X
      );
    }
    if (attributes_to_read.primary6y == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6Y
      );
    }
    if (attributes_to_read.primary6_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_PRIMARY6_INTENSITY
      );
    }
    if (attributes_to_read.white_pointx == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTX
      );
    }
    if (attributes_to_read.white_pointy == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_WHITE_POINTY
      );
    }
    if (attributes_to_read.color_pointrx == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRX
      );
    }
    if (attributes_to_read.color_pointry == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTRY
      );
    }
    if (attributes_to_read.color_pointr_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTR_INTENSITY
      );
    }
    if (attributes_to_read.color_pointgx == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGX
      );
    }
    if (attributes_to_read.color_pointgy == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTGY
      );
    }
    if (attributes_to_read.color_pointg_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTG_INTENSITY
      );
    }
    if (attributes_to_read.color_pointbx == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBX
      );
    }
    if (attributes_to_read.color_pointby == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTBY
      );
    }
    if (attributes_to_read.color_pointb_intensity == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_POINTB_INTENSITY
      );
    }
    if (attributes_to_read.enhanced_current_hue == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_ENHANCED_CURRENT_HUE
      );
    }
    if (attributes_to_read.enhanced_color_mode == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_ENHANCED_COLOR_MODE
      );
    }
    if (attributes_to_read.color_loop_active == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_ACTIVE
      );
    }
    if (attributes_to_read.color_loop_direction == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_DIRECTION
      );
    }
    if (attributes_to_read.color_loop_time == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_TIME
      );
    }
    if (attributes_to_read.color_loop_start_enhanced_hue == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_START_ENHANCED_HUE
      );
    }
    if (attributes_to_read.color_loop_stored_enhanced_hue == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_LOOP_STORED_ENHANCED_HUE
      );
    }
    if (attributes_to_read.color_capabilities == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_CAPABILITIES
      );
    }
    if (attributes_to_read.color_temp_physical_min_mireds == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMP_PHYSICAL_MIN_MIREDS
      );
    }
    if (attributes_to_read.color_temp_physical_max_mireds == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COLOR_TEMP_PHYSICAL_MAX_MIREDS
      );
    }
    if (attributes_to_read.couple_color_temp_to_level_min_mireds == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_COUPLE_COLOR_TEMP_TO_LEVEL_MIN_MIREDS
      );
    }
    if (attributes_to_read.start_up_color_temperature_mireds == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_ATTR_START_UP_COLOR_TEMPERATURE_MIREDS
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveToHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param hue  Command argument of type uint8_t

 * @param direction  Command argument of type CCDirection

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_to_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t hue,

    CCDirection direction,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &direction });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type CCMoveMode

 * @param rate  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCMoveMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/StepHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type CCStepMode

 * @param step_size  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_step_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCStepMode step_mode,

    uint8_t step_size,

    uint8_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveToSaturation command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param saturation  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_to_saturation_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t saturation,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &saturation });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_SATURATION,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveSaturation command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type CCMoveMode

 * @param rate  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_saturation_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCMoveMode move_mode,

    uint8_t rate,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_SATURATION,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/StepSaturation command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type CCStepMode

 * @param step_size  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint8_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_step_saturation_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCStepMode step_mode,

    uint8_t step_size,

    uint8_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_SATURATION,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveToHueAndSaturation command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param hue  Command argument of type uint8_t

 * @param saturation  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_to_hue_and_saturation_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t hue,

    uint8_t saturation,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &saturation });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_HUE_AND_SATURATION,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveToColor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param colorx  Command argument of type uint16_t

 * @param colory  Command argument of type uint16_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_to_color_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t colorx,

    uint16_t colory,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &colorx });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &colory });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_COLOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveColor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param ratex  Command argument of type int16_t

 * @param ratey  Command argument of type int16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_color_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    int16_t ratex,

    int16_t ratey,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &ratex });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &ratey });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_COLOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/StepColor command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param stepx  Command argument of type int16_t

 * @param stepy  Command argument of type int16_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_step_color_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    int16_t stepx,

    int16_t stepy,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &stepx });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_INT16, &stepy });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_COLOR,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveToColorTemperature command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param color_temperature_mireds  Command argument of type uint16_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_to_color_temperature_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t color_temperature_mireds,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &color_temperature_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_TO_COLOR_TEMPERATURE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/EnhancedMoveToHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param enhanced_hue  Command argument of type uint16_t

 * @param direction  Command argument of type CCDirection

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_enhanced_move_to_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t enhanced_hue,

    CCDirection direction,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &enhanced_hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &direction });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_MOVE_TO_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/EnhancedMoveHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type CCMoveMode

 * @param rate  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_enhanced_move_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCMoveMode move_mode,

    uint16_t rate,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_MOVE_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/EnhancedStepHue command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type CCStepMode

 * @param step_size  Command argument of type uint16_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_enhanced_step_hue_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCStepMode step_mode,

    uint16_t step_size,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_STEP_HUE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/EnhancedMoveToHueAndSaturation command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param enhanced_hue  Command argument of type uint16_t

 * @param saturation  Command argument of type uint8_t

 * @param transition_time  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_enhanced_move_to_hue_and_saturation_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint16_t enhanced_hue,

    uint8_t saturation,

    uint16_t transition_time,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &enhanced_hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &saturation });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_ENHANCED_MOVE_TO_HUE_AND_SATURATION,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/ColorLoopSet command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param update_flags  Command argument of type uint8_t

 * @param action  Command argument of type ColorLoopSetAction

 * @param direction  Command argument of type CCColorLoopDirection

 * @param time  Command argument of type uint16_t

 * @param start_hue  Command argument of type uint16_t

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_color_loop_set_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t update_flags,

    ColorLoopSetAction action,

    CCColorLoopDirection direction,

    uint16_t time,

    uint16_t start_hue,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &update_flags });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &action });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &direction });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &start_hue });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_COLOR_LOOP_SET,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/StopMoveStep command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_stop_move_step_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STOP_MOVE_STEP,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/MoveColorTemperature command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param move_mode  Command argument of type CCMoveMode

 * @param rate  Command argument of type uint16_t

 * @param color_temperature_minimum_mireds  Command argument of type CCMinMiredsField

 * @param color_temperature_maximum_mireds  Command argument of type CCMaxMiredsField

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_move_color_temperature_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCMoveMode move_mode,

    uint16_t rate,

    CCMinMiredsField color_temperature_minimum_mireds,

    CCMaxMiredsField color_temperature_maximum_mireds,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &move_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &rate });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &color_temperature_minimum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &color_temperature_maximum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_MOVE_COLOR_TEMPERATURE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for ColorControl/StepColorTemperature command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param step_mode  Command argument of type CCStepMode

 * @param step_size  Command argument of type uint16_t

 * @param transition_time  Command argument of type uint16_t

 * @param color_temperature_minimum_mireds  Command argument of type CCMinMiredsField

 * @param color_temperature_maximum_mireds  Command argument of type CCMaxMiredsField

 * @param options_mask  Command argument of type uint8_t

 * @param options_override  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_color_control_step_color_temperature_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    CCStepMode step_mode,

    uint16_t step_size,

    uint16_t transition_time,

    CCMinMiredsField color_temperature_minimum_mireds,

    CCMaxMiredsField color_temperature_maximum_mireds,

    uint8_t options_mask,

    uint8_t options_override

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_COLOR_CONTROL);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &step_mode });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &step_size });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &transition_time });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &color_temperature_minimum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &color_temperature_maximum_mireds });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_mask });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &options_override });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL,
      ZIGPC_ZCL_CLUSTER_COLOR_CONTROL_COMMAND_STEP_COLOR_TEMPERATURE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for OccupancySensing cluster
 ******************/

/**
 * @brief DotDot MQTT handler for Occupancy/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_occupancy_sensing_state_t Attribute values
 * uic_mqtt_dotdot_occupancy_sensing_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_occupancy_sensing_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_occupancy_sensing_state_t values,
  uic_mqtt_dotdot_occupancy_sensing_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.pir_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.pir_occupied_to_unoccupied_delay
      );
    }

    if (values_to_write.pir_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.pir_unoccupied_to_occupied_delay
      );
    }

    if (values_to_write.pir_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.pir_unoccupied_to_occupied_threshold
      );
    }

    if (values_to_write.ultrasonic_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.ultrasonic_occupied_to_unoccupied_delay
      );
    }

    if (values_to_write.ultrasonic_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.ultrasonic_unoccupied_to_occupied_delay
      );
    }

    if (values_to_write.ultrasonic_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.ultrasonic_unoccupied_to_occupied_threshold
      );
    }

    if (values_to_write.physical_contact_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.physical_contact_occupied_to_unoccupied_delay
      );
    }

    if (values_to_write.physical_contact_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.physical_contact_unoccupied_to_occupied_delay
      );
    }

    if (values_to_write.physical_contact_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.physical_contact_unoccupied_to_occupied_threshold
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for Occupancy/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_occupancy_sensing_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_occupancy_sensing_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_occupancy_sensing_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.occupancy == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY
      );
    }
    if (attributes_to_read.occupancy_sensor_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY_SENSOR_TYPE
      );
    }
    if (attributes_to_read.occupancy_sensor_type_bitmap == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_OCCUPANCY_SENSOR_TYPE_BITMAP
      );
    }
    if (attributes_to_read.pir_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_OCCUPIED_TO_UNOCCUPIED_DELAY
      );
    }
    if (attributes_to_read.pir_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_DELAY
      );
    }
    if (attributes_to_read.pir_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PIR_UNOCCUPIED_TO_OCCUPIED_THRESHOLD
      );
    }
    if (attributes_to_read.ultrasonic_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_OCCUPIED_TO_UNOCCUPIED_DELAY
      );
    }
    if (attributes_to_read.ultrasonic_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_DELAY
      );
    }
    if (attributes_to_read.ultrasonic_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_ULTRASONIC_UNOCCUPIED_TO_OCCUPIED_THRESHOLD
      );
    }
    if (attributes_to_read.physical_contact_occupied_to_unoccupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_OCCUPIED_TO_UNOCCUPIED_DELAY
      );
    }
    if (attributes_to_read.physical_contact_unoccupied_to_occupied_delay == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_DELAY
      );
    }
    if (attributes_to_read.physical_contact_unoccupied_to_occupied_threshold == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING_ATTR_PHYSICAL_CONTACT_UNOCCUPIED_TO_OCCUPIED_THRESHOLD
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_OCCUPANCY_SENSING,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/******************
 * DotDot MQTT Command Handlers for IASZone cluster
 ******************/

/**
 * @brief DotDot MQTT handler for ZoneState/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_ias_zone_state_t Attribute values
 * uic_mqtt_dotdot_ias_zone_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_ias_zone_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_ias_zone_state_t values,
  uic_mqtt_dotdot_ias_zone_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IAS_ZONE);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.iascie_address == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_IASCIE_ADDRESS,
        ZIGPC_ZCL_DATA_TYPE_EUI64,
        &values.iascie_address
      );
    }

    if (values_to_write.current_zone_sensitivity_level == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_CURRENT_ZONE_SENSITIVITY_LEVEL,
        ZIGPC_ZCL_DATA_TYPE_UINT8,
        &values.current_zone_sensitivity_level
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for ZoneState/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_ias_zone_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_ias_zone_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_ias_zone_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IAS_ZONE);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.zone_state == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONE_STATE
      );
    }
    if (attributes_to_read.zone_type == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONE_TYPE
      );
    }
    if (attributes_to_read.zone_status == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONE_STATUS
      );
    }
    if (attributes_to_read.iascie_address == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_IASCIE_ADDRESS
      );
    }
    if (attributes_to_read.zoneid == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_ZONEID
      );
    }
    if (attributes_to_read.number_of_zone_sensitivity_levels_supported == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_NUMBER_OF_ZONE_SENSITIVITY_LEVELS_SUPPORTED
      );
    }
    if (attributes_to_read.current_zone_sensitivity_level == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE_ATTR_CURRENT_ZONE_SENSITIVITY_LEVEL
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IAS_ZONE,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for IASZone/ZoneEnrollResponse command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param enroll_response_code  Command argument of type ZoneEnrollResponseEnrollResponseCode

 * @param zoneid  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_ias_zone_zone_enroll_response_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    ZoneEnrollResponseEnrollResponseCode enroll_response_code,

    uint8_t zoneid

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IAS_ZONE);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &enroll_response_code });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &zoneid });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_ZONE_ENROLL_RESPONSE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for IASZone/InitiateNormalOperationMode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_ias_zone_initiate_normal_operation_mode_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type
) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IAS_ZONE);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }




  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_INITIATE_NORMAL_OPERATION_MODE,
      0,
      nullptr
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for IASZone/InitiateTestMode command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param test_mode_duration  Command argument of type uint8_t

 * @param current_zone_sensitivity_level  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_ias_zone_initiate_test_mode_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t test_mode_duration,

    uint8_t current_zone_sensitivity_level

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IAS_ZONE);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &test_mode_duration });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &current_zone_sensitivity_level });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_INITIATE_TEST_MODE,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/******************
 * DotDot MQTT Command Handlers for IASWD cluster
 ******************/

/**
 * @brief DotDot MQTT handler for MaxDuration/WriteAttributes command.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_iaswd_state_t Attribute values
 * uic_mqtt_dotdot_iaswd_updated_state_t Boolean flags of which attributes to write
 */
sl_status_t zigpc_command_mapper_iaswd_write_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_iaswd_state_t values,
  uic_mqtt_dotdot_iaswd_updated_state_t values_to_write
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> write_attr_data;
  std::list<zcl_attribute_id_t> attr_id_list;
  std::list<zigpc_zcl_data_type_t> attr_data_type_list;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IASWD);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {
    if (values_to_write.max_duration == true) {
      zigpc_command_mapper_populate_write_attr_record(
        write_attr_data,
        attr_id_list,
        attr_data_type_list,
        ZIGPC_ZCL_CLUSTER_IASWD_ATTR_MAX_DURATION,
        ZIGPC_ZCL_DATA_TYPE_UINT16,
        &values.max_duration
      );
    }

    if ((status == SL_STATUS_OK) && (write_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IASWD,
        ZIGPC_ZCL_GLOBAL_COMMAND_WRITE_ATTRIBUTES,
        write_attr_data.size(),
        write_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT handler for MaxDuration/Commands/ForceReadAttributes.
 *
 * @param unid Unify device identifier string
 * @param endpoint Unify device endpoint identifier
 * uic_mqtt_dotdot_iaswd_updated_state_t Boolean flags of which attributes to read
 */
sl_status_t zigpc_command_mapper_iaswd_force_read_attributes_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_iaswd_updated_state_t attributes_to_read
) {
  sl_status_t status = SL_STATUS_OK;
  std::vector<zigpc_zcl_frame_data_t> read_attr_data;
  std::list<zcl_attribute_id_t> read_attr_ids;

  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IASWD);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
  } else {

    if (attributes_to_read.max_duration == true) {
      zigpc_command_mapper_populate_read_attr_record(
        read_attr_data, read_attr_ids,
        ZIGPC_ZCL_CLUSTER_IASWD_ATTR_MAX_DURATION
      );
    }

    if ((status == SL_STATUS_OK) && (read_attr_data.size() > 0)) {
      zigpc_command_mapper_send_unicast(
        unid,
        endpoint,
        ZIGPC_ZCL_FRAME_TYPE_GLOBAL_CMD_TO_SERVER,
        ZIGPC_ZCL_CLUSTER_IASWD,
        ZIGPC_ZCL_GLOBAL_COMMAND_READ_ATTRIBUTES,
        read_attr_data.size(),
        read_attr_data.data()
      );
    }
  }

  return status;

}

/**
 * @brief DotDot MQTT translator handler for IASWD/StartWarning command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param siren_configuration  Command argument of type uint8_t

 * @param warning_duration  Command argument of type uint16_t

 * @param strobe_duty_cycle  Command argument of type uint8_t

 * @param strobe_level  Command argument of type IaswdLevel
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_iaswd_start_warning_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t siren_configuration,

    uint16_t warning_duration,

    uint8_t strobe_duty_cycle,

    IaswdLevel strobe_level

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IASWD);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &siren_configuration });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT16, &warning_duration });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_UINT8, &strobe_duty_cycle });
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_ENUM8, &strobe_level });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IASWD,
      ZIGPC_ZCL_CLUSTER_IASWD_COMMAND_START_WARNING,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}

/**
 * @brief DotDot MQTT translator handler for IASWD/Squawk command.
 *
 * @param unid  Unify device identifier string
 * @param endpoint  Unify device endpoint identifier
 * @param callback_type Callback type

 * @param squawk_configuration  Command argument of type uint8_t
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL and call is successful
 * @return SL_STATUS_OK if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is supported by the unid/endpoint
 * @return SL_STATUS_NOT_AVAILABLE if callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK and command is not supported by the unid/endpoint
 */
sl_status_t zigpc_command_mapper_iaswd_squawk_handler(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t callback_type,
    uint8_t squawk_configuration

) {
  sl_status_t status = SL_STATUS_OK;

  if (callback_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    status = zigpc_command_mapper_cluster_support_check(unid, endpoint, ZIGPC_ZCL_CLUSTER_IASWD);
    if (status != SL_STATUS_OK) {
      status = SL_STATUS_NOT_AVAILABLE;
    }
    return status;
  }



  std::vector< zigpc_zcl_frame_data_t > cmd_arg_list;
  cmd_arg_list.push_back({ ZIGPC_ZCL_DATA_TYPE_MAP8, &squawk_configuration });

  if (status == SL_STATUS_OK) {
    zigpc_command_mapper_send_unicast(
      unid,
      endpoint,
      ZIGPC_ZCL_FRAME_TYPE_CMD_TO_SERVER,
      ZIGPC_ZCL_CLUSTER_IASWD,
      ZIGPC_ZCL_CLUSTER_IASWD_COMMAND_SQUAWK,
      cmd_arg_list.size(),
      cmd_arg_list.data()
    );
  }

  // Always return SL_STATUS_OK if being called normally.
  return SL_STATUS_OK;
}


/**
 * @brief Register the callbacks for the DotDot Commands supported.
 */
sl_status_t zigpc_command_mapper_register_dotdot_mqtt_handlers(void)
{
  uic_mqtt_dotdot_set_identify_write_attributes_callback(
    zigpc_command_mapper_identify_write_attributes_handler
  );
  uic_mqtt_dotdot_set_identify_force_read_attributes_callback(
    zigpc_command_mapper_identify_force_read_attributes_handler
  );
  uic_mqtt_dotdot_identify_identify_callback_set(
    zigpc_command_mapper_identify_identify_handler
  );
  uic_mqtt_dotdot_identify_identify_query_callback_set(
    zigpc_command_mapper_identify_identify_query_handler
  );
  uic_mqtt_dotdot_identify_trigger_effect_callback_set(
    zigpc_command_mapper_identify_trigger_effect_handler
  );
  uic_mqtt_dotdot_set_groups_write_attributes_callback(
    zigpc_command_mapper_groups_write_attributes_handler
  );
  uic_mqtt_dotdot_set_groups_force_read_attributes_callback(
    zigpc_command_mapper_groups_force_read_attributes_handler
  );
  uic_mqtt_dotdot_groups_add_group_callback_set(
    zigpc_command_mapper_groups_add_group_handler
  );
  uic_mqtt_dotdot_groups_view_group_callback_set(
    zigpc_command_mapper_groups_view_group_handler
  );
  uic_mqtt_dotdot_groups_get_group_membership_callback_set(
    zigpc_command_mapper_groups_get_group_membership_handler
  );
  uic_mqtt_dotdot_groups_remove_group_callback_set(
    zigpc_command_mapper_groups_remove_group_handler
  );
  uic_mqtt_dotdot_groups_remove_all_groups_callback_set(
    zigpc_command_mapper_groups_remove_all_groups_handler
  );
  uic_mqtt_dotdot_groups_add_group_if_identifying_callback_set(
    zigpc_command_mapper_groups_add_group_if_identifying_handler
  );
  uic_mqtt_dotdot_set_on_off_write_attributes_callback(
    zigpc_command_mapper_on_off_write_attributes_handler
  );
  uic_mqtt_dotdot_set_on_off_force_read_attributes_callback(
    zigpc_command_mapper_on_off_force_read_attributes_handler
  );
  uic_mqtt_dotdot_on_off_off_callback_set(
    zigpc_command_mapper_on_off_off_handler
  );
  uic_mqtt_dotdot_on_off_on_callback_set(
    zigpc_command_mapper_on_off_on_handler
  );
  uic_mqtt_dotdot_on_off_toggle_callback_set(
    zigpc_command_mapper_on_off_toggle_handler
  );
  uic_mqtt_dotdot_on_off_off_with_effect_callback_set(
    zigpc_command_mapper_on_off_off_with_effect_handler
  );
  uic_mqtt_dotdot_on_off_on_with_recall_global_scene_callback_set(
    zigpc_command_mapper_on_off_on_with_recall_global_scene_handler
  );
  uic_mqtt_dotdot_on_off_on_with_timed_off_callback_set(
    zigpc_command_mapper_on_off_on_with_timed_off_handler
  );
  uic_mqtt_dotdot_set_level_write_attributes_callback(
    zigpc_command_mapper_level_write_attributes_handler
  );
  uic_mqtt_dotdot_set_level_force_read_attributes_callback(
    zigpc_command_mapper_level_force_read_attributes_handler
  );
  uic_mqtt_dotdot_level_move_to_level_callback_set(
    zigpc_command_mapper_level_move_to_level_handler
  );
  uic_mqtt_dotdot_level_move_callback_set(
    zigpc_command_mapper_level_move_handler
  );
  uic_mqtt_dotdot_level_step_callback_set(
    zigpc_command_mapper_level_step_handler
  );
  uic_mqtt_dotdot_level_stop_callback_set(
    zigpc_command_mapper_level_stop_handler
  );
  uic_mqtt_dotdot_level_move_to_level_with_on_off_callback_set(
    zigpc_command_mapper_level_move_to_level_with_on_off_handler
  );
  uic_mqtt_dotdot_level_move_with_on_off_callback_set(
    zigpc_command_mapper_level_move_with_on_off_handler
  );
  uic_mqtt_dotdot_level_step_with_on_off_callback_set(
    zigpc_command_mapper_level_step_with_on_off_handler
  );
  uic_mqtt_dotdot_level_stop_with_on_off_callback_set(
    zigpc_command_mapper_level_stop_with_on_off_handler
  );
  uic_mqtt_dotdot_level_move_to_closest_frequency_callback_set(
    zigpc_command_mapper_level_move_to_closest_frequency_handler
  );
  uic_mqtt_dotdot_set_poll_control_write_attributes_callback(
    zigpc_command_mapper_poll_control_write_attributes_handler
  );
  uic_mqtt_dotdot_set_poll_control_force_read_attributes_callback(
    zigpc_command_mapper_poll_control_force_read_attributes_handler
  );
  uic_mqtt_dotdot_poll_control_check_in_callback_set(
    zigpc_command_mapper_poll_control_check_in_handler
  );
  uic_mqtt_dotdot_set_door_lock_write_attributes_callback(
    zigpc_command_mapper_door_lock_write_attributes_handler
  );
  uic_mqtt_dotdot_set_door_lock_force_read_attributes_callback(
    zigpc_command_mapper_door_lock_force_read_attributes_handler
  );
  uic_mqtt_dotdot_door_lock_lock_door_callback_set(
    zigpc_command_mapper_door_lock_lock_door_handler
  );
  uic_mqtt_dotdot_door_lock_unlock_door_callback_set(
    zigpc_command_mapper_door_lock_unlock_door_handler
  );
  uic_mqtt_dotdot_door_lock_toggle_callback_set(
    zigpc_command_mapper_door_lock_toggle_handler
  );
  uic_mqtt_dotdot_door_lock_unlock_with_timeout_callback_set(
    zigpc_command_mapper_door_lock_unlock_with_timeout_handler
  );
  uic_mqtt_dotdot_door_lock_get_log_record_callback_set(
    zigpc_command_mapper_door_lock_get_log_record_handler
  );
  uic_mqtt_dotdot_door_lock_setpin_code_callback_set(
    zigpc_command_mapper_door_lock_setpin_code_handler
  );
  uic_mqtt_dotdot_door_lock_getpin_code_callback_set(
    zigpc_command_mapper_door_lock_getpin_code_handler
  );
  uic_mqtt_dotdot_door_lock_clearpin_code_callback_set(
    zigpc_command_mapper_door_lock_clearpin_code_handler
  );
  uic_mqtt_dotdot_door_lock_clear_allpin_codes_callback_set(
    zigpc_command_mapper_door_lock_clear_allpin_codes_handler
  );
  uic_mqtt_dotdot_door_lock_set_user_status_callback_set(
    zigpc_command_mapper_door_lock_set_user_status_handler
  );
  uic_mqtt_dotdot_door_lock_get_user_status_callback_set(
    zigpc_command_mapper_door_lock_get_user_status_handler
  );
  uic_mqtt_dotdot_door_lock_set_weekday_schedule_callback_set(
    zigpc_command_mapper_door_lock_set_weekday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_get_weekday_schedule_callback_set(
    zigpc_command_mapper_door_lock_get_weekday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_clear_weekday_schedule_callback_set(
    zigpc_command_mapper_door_lock_clear_weekday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_set_year_day_schedule_callback_set(
    zigpc_command_mapper_door_lock_set_year_day_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_get_year_day_schedule_callback_set(
    zigpc_command_mapper_door_lock_get_year_day_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_clear_year_day_schedule_callback_set(
    zigpc_command_mapper_door_lock_clear_year_day_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_set_holiday_schedule_callback_set(
    zigpc_command_mapper_door_lock_set_holiday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_get_holiday_schedule_callback_set(
    zigpc_command_mapper_door_lock_get_holiday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_clear_holiday_schedule_callback_set(
    zigpc_command_mapper_door_lock_clear_holiday_schedule_handler
  );
  uic_mqtt_dotdot_door_lock_set_user_type_callback_set(
    zigpc_command_mapper_door_lock_set_user_type_handler
  );
  uic_mqtt_dotdot_door_lock_get_user_type_callback_set(
    zigpc_command_mapper_door_lock_get_user_type_handler
  );
  uic_mqtt_dotdot_door_lock_setrfid_code_callback_set(
    zigpc_command_mapper_door_lock_setrfid_code_handler
  );
  uic_mqtt_dotdot_door_lock_getrfid_code_callback_set(
    zigpc_command_mapper_door_lock_getrfid_code_handler
  );
  uic_mqtt_dotdot_door_lock_clearrfid_code_callback_set(
    zigpc_command_mapper_door_lock_clearrfid_code_handler
  );
  uic_mqtt_dotdot_door_lock_clear_allrfid_codes_callback_set(
    zigpc_command_mapper_door_lock_clear_allrfid_codes_handler
  );
  uic_mqtt_dotdot_door_lock_get_allpin_codes_callback_set(
    zigpc_command_mapper_door_lock_get_allpin_codes_handler
  );
  );

  uic_mqtt_dotdot_door_lock_get_allpin_codes_callback_set(
    zigpc_command_mapper_door_lock_get_allpin_codes_handler
  uic_mqtt_dotdot_set_thermostat_write_attributes_callback(
    zigpc_command_mapper_thermostat_write_attributes_handler
  );
  uic_mqtt_dotdot_set_thermostat_force_read_attributes_callback(
    zigpc_command_mapper_thermostat_force_read_attributes_handler
  );
  uic_mqtt_dotdot_thermostat_setpoint_raise_or_lower_callback_set(
    zigpc_command_mapper_thermostat_setpoint_raise_or_lower_handler
  );
  uic_mqtt_dotdot_thermostat_set_weekly_schedule_callback_set(
    zigpc_command_mapper_thermostat_set_weekly_schedule_handler
  );
  uic_mqtt_dotdot_thermostat_get_weekly_schedule_callback_set(
    zigpc_command_mapper_thermostat_get_weekly_schedule_handler
  );
  uic_mqtt_dotdot_thermostat_clear_weekly_schedule_callback_set(
    zigpc_command_mapper_thermostat_clear_weekly_schedule_handler
  );
  uic_mqtt_dotdot_thermostat_get_relay_status_log_callback_set(
    zigpc_command_mapper_thermostat_get_relay_status_log_handler
  );
  uic_mqtt_dotdot_set_color_control_write_attributes_callback(
    zigpc_command_mapper_color_control_write_attributes_handler
  );
  uic_mqtt_dotdot_set_color_control_force_read_attributes_callback(
    zigpc_command_mapper_color_control_force_read_attributes_handler
  );
  uic_mqtt_dotdot_color_control_move_to_hue_callback_set(
    zigpc_command_mapper_color_control_move_to_hue_handler
  );
  uic_mqtt_dotdot_color_control_move_hue_callback_set(
    zigpc_command_mapper_color_control_move_hue_handler
  );
  uic_mqtt_dotdot_color_control_step_hue_callback_set(
    zigpc_command_mapper_color_control_step_hue_handler
  );
  uic_mqtt_dotdot_color_control_move_to_saturation_callback_set(
    zigpc_command_mapper_color_control_move_to_saturation_handler
  );
  uic_mqtt_dotdot_color_control_move_saturation_callback_set(
    zigpc_command_mapper_color_control_move_saturation_handler
  );
  uic_mqtt_dotdot_color_control_step_saturation_callback_set(
    zigpc_command_mapper_color_control_step_saturation_handler
  );
  uic_mqtt_dotdot_color_control_move_to_hue_and_saturation_callback_set(
    zigpc_command_mapper_color_control_move_to_hue_and_saturation_handler
  );
  uic_mqtt_dotdot_color_control_move_to_color_callback_set(
    zigpc_command_mapper_color_control_move_to_color_handler
  );
  uic_mqtt_dotdot_color_control_move_color_callback_set(
    zigpc_command_mapper_color_control_move_color_handler
  );
  uic_mqtt_dotdot_color_control_step_color_callback_set(
    zigpc_command_mapper_color_control_step_color_handler
  );
  uic_mqtt_dotdot_color_control_move_to_color_temperature_callback_set(
    zigpc_command_mapper_color_control_move_to_color_temperature_handler
  );
  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_callback_set(
    zigpc_command_mapper_color_control_enhanced_move_to_hue_handler
  );
  uic_mqtt_dotdot_color_control_enhanced_move_hue_callback_set(
    zigpc_command_mapper_color_control_enhanced_move_hue_handler
  );
  uic_mqtt_dotdot_color_control_enhanced_step_hue_callback_set(
    zigpc_command_mapper_color_control_enhanced_step_hue_handler
  );
  uic_mqtt_dotdot_color_control_enhanced_move_to_hue_and_saturation_callback_set(
    zigpc_command_mapper_color_control_enhanced_move_to_hue_and_saturation_handler
  );
  uic_mqtt_dotdot_color_control_color_loop_set_callback_set(
    zigpc_command_mapper_color_control_color_loop_set_handler
  );
  uic_mqtt_dotdot_color_control_stop_move_step_callback_set(
    zigpc_command_mapper_color_control_stop_move_step_handler
  );
  uic_mqtt_dotdot_color_control_move_color_temperature_callback_set(
    zigpc_command_mapper_color_control_move_color_temperature_handler
  );
  uic_mqtt_dotdot_color_control_step_color_temperature_callback_set(
    zigpc_command_mapper_color_control_step_color_temperature_handler
  );
  uic_mqtt_dotdot_set_occupancy_sensing_write_attributes_callback(
    zigpc_command_mapper_occupancy_sensing_write_attributes_handler
  );
  uic_mqtt_dotdot_set_occupancy_sensing_force_read_attributes_callback(
    zigpc_command_mapper_occupancy_sensing_force_read_attributes_handler
  );
  uic_mqtt_dotdot_set_ias_zone_write_attributes_callback(
    zigpc_command_mapper_ias_zone_write_attributes_handler
  );
  uic_mqtt_dotdot_set_ias_zone_force_read_attributes_callback(
    zigpc_command_mapper_ias_zone_force_read_attributes_handler
  );
  uic_mqtt_dotdot_ias_zone_zone_enroll_response_callback_set(
    zigpc_command_mapper_ias_zone_zone_enroll_response_handler
  );
  uic_mqtt_dotdot_ias_zone_initiate_normal_operation_mode_callback_set(
    zigpc_command_mapper_ias_zone_initiate_normal_operation_mode_handler
  );
  uic_mqtt_dotdot_ias_zone_initiate_test_mode_callback_set(
    zigpc_command_mapper_ias_zone_initiate_test_mode_handler
  );
  uic_mqtt_dotdot_set_iaswd_write_attributes_callback(
    zigpc_command_mapper_iaswd_write_attributes_handler
  );
  uic_mqtt_dotdot_set_iaswd_force_read_attributes_callback(
    zigpc_command_mapper_iaswd_force_read_attributes_handler
  );
  uic_mqtt_dotdot_iaswd_start_warning_callback_set(
    zigpc_command_mapper_iaswd_start_warning_handler
  );
  uic_mqtt_dotdot_iaswd_squawk_callback_set(
    zigpc_command_mapper_iaswd_squawk_handler
  );
  return SL_STATUS_OK;
}
