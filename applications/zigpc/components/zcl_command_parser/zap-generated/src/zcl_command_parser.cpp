/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.




#include <cstring>
#include <set>
#include <unordered_map>

// Unify shared components
#include "sl_log.h"

#include "zigpc_gateway_notify.h"
#include "zigpc_common_zigbee.h"
#include "zcl_definitions.h"
#include "zcl_util.h"

#include "zcl_command_parser.h"
#include "zcl_command_parser_int.h"

constexpr char LOG_TAG[] = "zigpc_zclcmdparse";
constexpr char LOG_FMT_MALFORMED_FIELD[] = "%s/%s malformed field %s";
constexpr char LOG_FMT_PARSE_SUCCESS[] ="%s/%s parsed successfully";




/**
 * @brief Container to hold data parsed for incoming messages
 * from the Zigbee network.
 */
typedef struct {
  zcl_cluster_id_t cluster_id;
  zcl_command_id_t command_id;
  zigpc_zclcmdparse_callback_data_t data;
} zigpc_zclcmdparse_result_t;

static std::unordered_map<zcl_cluster_id_t, std::set<zcl_command_id_t>>  command_parser_support_map = {
  {
    ZIGPC_ZCL_CLUSTER_IDENTIFY,
    {
      ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_IDENTIFY_QUERY_RESPONSE,
    }
  },
  {
    ZIGPC_ZCL_CLUSTER_GROUPS,
    {
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_ADD_GROUP_RESPONSE,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_VIEW_GROUP_RESPONSE,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_GET_GROUP_MEMBERSHIP_RESPONSE,
      ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_REMOVE_GROUP_RESPONSE,
    }
  },
  {
    ZIGPC_ZCL_CLUSTER_POLL_CONTROL,
    {
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_CHECK_IN_RESPONSE,
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_FAST_POLL_STOP,
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_SET_LONG_POLL_INTERVAL,
      ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_SET_SHORT_POLL_INTERVAL,
    }
  },
  {
    ZIGPC_ZCL_CLUSTER_DOOR_LOCK,
    {
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_LOCK_DOOR_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_DOOR_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_TOGGLE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_WITH_TIMEOUT_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_LOG_RECORD_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SETPIN_CODE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GETPIN_CODE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEARPIN_CODE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALLPIN_CODES_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_STATUS_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_STATUS_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_WEEKDAY_SCHEDULE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_WEEKDAY_SCHEDULE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_WEEKDAY_SCHEDULE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_YEAR_DAY_SCHEDULE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_YEAR_DAY_SCHEDULE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_YEAR_DAY_SCHEDULE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_HOLIDAY_SCHEDULE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_HOLIDAY_SCHEDULE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_HOLIDAY_SCHEDULE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_TYPE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_TYPE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SETRFID_CODE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GETRFID_CODE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEARRFID_CODE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALLRFID_CODES_RESPONSE,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_OPERATING_EVENT_NOTIFICATION,
      ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_PROGRAMMING_EVENT_NOTIFICATION,
    }
  },
  {
    ZIGPC_ZCL_CLUSTER_THERMOSTAT,
    {
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_WEEKLY_SCHEDULE_RESPONSE,
      ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_RELAY_STATUS_LOG_RESPONSE,
    }
  },
  {
    ZIGPC_ZCL_CLUSTER_IAS_ZONE,
    {
      ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_ZONE_STATUS_CHANGE_NOTIFICATION,
      ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_ZONE_ENROLL_REQUEST,
    }
  },
};

bool zigpc_zclcmdparse_cluster_command_supported(zcl_cluster_id_t cluster_id,
                                                              zcl_command_id_t command_id)
{
  bool support_check = false;

  auto cluster_found = command_parser_support_map.find(cluster_id);
  if (cluster_found != command_parser_support_map.end()) {
    size_t command_found = cluster_found->second.count(command_id);

    if (command_found != 0) {
      support_check = true;
    }
  }

  return support_check;
}

zigpc_zcl_status_t zigpc_zclcmdparse_identify_identify_query_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_identify_identify_query_response_t *data;
  data = &result->data.identify_identify_query_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->timeout, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_IDENTIFY;
    result->command_id = ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_IDENTIFY_QUERY_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "Identify", "IdentifyQueryResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_groups_add_group_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_groups_add_group_response_t *data;
  data = &result->data.groups_add_group_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->group_id, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_GROUPS;
    result->command_id = ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_ADD_GROUP_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "Groups", "AddGroupResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_groups_view_group_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_groups_view_group_response_t *data;
  data = &result->data.groups_view_group_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->group_id, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_STRING;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    uint8_t arg_str_len = cmd->frame.buffer[payload_offset];
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + (arg_size * arg_str_len) + 1)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      data->group_name_length = arg_str_len;
      payload_offset++;
      data->group_name = (const char *) &cmd->frame.buffer[payload_offset];
      payload_offset += arg_size * arg_str_len;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_GROUPS;
    result->command_id = ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_VIEW_GROUP_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "Groups", "ViewGroupResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_groups_get_group_membership_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_groups_get_group_membership_response_t *data;
  data = &result->data.groups_get_group_membership_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->capacity, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    uint8_t arg_array_count = cmd->frame.buffer[payload_offset];
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + (arg_size * arg_array_count) + 1)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      data->group_list_count = arg_array_count;
      payload_offset++;
      data->group_list = (uint16_t *) &cmd->frame.buffer[payload_offset];
      payload_offset += arg_size * arg_array_count;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_GROUPS;
    result->command_id = ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_GET_GROUP_MEMBERSHIP_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "Groups", "GetGroupMembershipResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_groups_remove_group_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_groups_remove_group_response_t *data;
  data = &result->data.groups_remove_group_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->group_id, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_GROUPS;
    result->command_id = ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_REMOVE_GROUP_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "Groups", "RemoveGroupResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_poll_control_check_in_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_poll_control_check_in_response_t *data;
  data = &result->data.poll_control_check_in_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_BOOL;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->start_fast_polling, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->fast_poll_timeout, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_POLL_CONTROL;
    result->command_id = ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_CHECK_IN_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "PollControl", "CheckInResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_poll_control_fast_poll_stop_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_POLL_CONTROL;
    result->command_id = ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_FAST_POLL_STOP;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "PollControl", "FastPollStop");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_poll_control_set_long_poll_interval_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_poll_control_set_long_poll_interval_t *data;
  data = &result->data.poll_control_set_long_poll_interval;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT32;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->new_long_poll_interval, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_POLL_CONTROL;
    result->command_id = ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_SET_LONG_POLL_INTERVAL;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "PollControl", "SetLongPollInterval");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_poll_control_set_short_poll_interval_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_poll_control_set_short_poll_interval_t *data;
  data = &result->data.poll_control_set_short_poll_interval;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->new_short_poll_interval, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_POLL_CONTROL;
    result->command_id = ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_SET_SHORT_POLL_INTERVAL;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "PollControl", "SetShortPollInterval");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_lock_door_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_lock_door_response_t *data;
  data = &result->data.door_lock_lock_door_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_LOCK_DOOR_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "LockDoorResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_unlock_door_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_unlock_door_response_t *data;
  data = &result->data.door_lock_unlock_door_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_DOOR_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "UnlockDoorResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_toggle_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_toggle_response_t *data;
  data = &result->data.door_lock_toggle_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_TOGGLE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "ToggleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_unlock_with_timeout_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_unlock_with_timeout_response_t *data;
  data = &result->data.door_lock_unlock_with_timeout_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_WITH_TIMEOUT_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "UnlockWithTimeoutResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_get_log_record_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_get_log_record_response_t *data;
  data = &result->data.door_lock_get_log_record_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->log_entryid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT32;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->timestamp, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->event_type, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->source_operation_event, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->eventid_or_alarm_code, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->userid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_OCTSTR;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    uint8_t arg_str_len = cmd->frame.buffer[payload_offset];
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + (arg_size * arg_str_len) + 1)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      data->pin_length = arg_str_len;
      payload_offset++;
      data->pin = (const char *) &cmd->frame.buffer[payload_offset];
      payload_offset += arg_size * arg_str_len;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_LOG_RECORD_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "GetLogRecordResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_setpin_code_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_setpin_code_response_t *data;
  data = &result->data.door_lock_setpin_code_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SETPIN_CODE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "SetPINCodeResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_getpin_code_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_getpin_code_response_t *data;
  data = &result->data.door_lock_getpin_code_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->userid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->user_status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->user_type, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_OCTSTR;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    uint8_t arg_str_len = cmd->frame.buffer[payload_offset];
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + (arg_size * arg_str_len) + 1)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      data->code_length = arg_str_len;
      payload_offset++;
      data->code = (const char *) &cmd->frame.buffer[payload_offset];
      payload_offset += arg_size * arg_str_len;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GETPIN_CODE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "GetPINCodeResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_clearpin_code_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_clearpin_code_response_t *data;
  data = &result->data.door_lock_clearpin_code_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEARPIN_CODE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "ClearPINCodeResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_clear_allpin_codes_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_clear_allpin_codes_response_t *data;
  data = &result->data.door_lock_clear_allpin_codes_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALLPIN_CODES_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "ClearAllPINCodesResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_set_user_status_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_set_user_status_response_t *data;
  data = &result->data.door_lock_set_user_status_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_STATUS_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "SetUserStatusResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_get_user_status_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_get_user_status_response_t *data;
  data = &result->data.door_lock_get_user_status_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->userid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->user_status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_STATUS_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "GetUserStatusResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_set_weekday_schedule_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_set_weekday_schedule_response_t *data;
  data = &result->data.door_lock_set_weekday_schedule_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_WEEKDAY_SCHEDULE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "SetWeekdayScheduleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_get_weekday_schedule_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_get_weekday_schedule_response_t *data;
  data = &result->data.door_lock_get_weekday_schedule_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->scheduleid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->userid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_MAP8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->days_mask, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->start_hour, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->start_minute, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->end_hour, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->end_minute, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_WEEKDAY_SCHEDULE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "GetWeekdayScheduleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_clear_weekday_schedule_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_clear_weekday_schedule_response_t *data;
  data = &result->data.door_lock_clear_weekday_schedule_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_WEEKDAY_SCHEDULE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "ClearWeekdayScheduleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_set_year_day_schedule_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_set_year_day_schedule_response_t *data;
  data = &result->data.door_lock_set_year_day_schedule_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_YEAR_DAY_SCHEDULE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "SetYearDayScheduleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_get_year_day_schedule_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_get_year_day_schedule_response_t *data;
  data = &result->data.door_lock_get_year_day_schedule_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->scheduleid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->userid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT32;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->local_start_time, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT32;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->local_end_time, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_YEAR_DAY_SCHEDULE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "GetYearDayScheduleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_clear_year_day_schedule_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_clear_year_day_schedule_response_t *data;
  data = &result->data.door_lock_clear_year_day_schedule_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_YEAR_DAY_SCHEDULE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "ClearYearDayScheduleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_set_holiday_schedule_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_set_holiday_schedule_response_t *data;
  data = &result->data.door_lock_set_holiday_schedule_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_HOLIDAY_SCHEDULE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "SetHolidayScheduleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_get_holiday_schedule_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_get_holiday_schedule_response_t *data;
  data = &result->data.door_lock_get_holiday_schedule_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->holiday_scheduleid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT32;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->local_start_time, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT32;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->local_end_time, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->operating_mode_during_holiday, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_HOLIDAY_SCHEDULE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "GetHolidayScheduleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_clear_holiday_schedule_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_clear_holiday_schedule_response_t *data;
  data = &result->data.door_lock_clear_holiday_schedule_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_HOLIDAY_SCHEDULE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "ClearHolidayScheduleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_set_user_type_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_set_user_type_response_t *data;
  data = &result->data.door_lock_set_user_type_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_TYPE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "SetUserTypeResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_get_user_type_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_get_user_type_response_t *data;
  data = &result->data.door_lock_get_user_type_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->userid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->user_type, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_TYPE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "GetUserTypeResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_setrfid_code_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_setrfid_code_response_t *data;
  data = &result->data.door_lock_setrfid_code_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SETRFID_CODE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "SetRFIDCodeResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_getrfid_code_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_getrfid_code_response_t *data;
  data = &result->data.door_lock_getrfid_code_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->userid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->user_status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->user_type, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_OCTSTR;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    uint8_t arg_str_len = cmd->frame.buffer[payload_offset];
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + (arg_size * arg_str_len) + 1)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      data->rfid_code_length = arg_str_len;
      payload_offset++;
      data->rfid_code = (const char *) &cmd->frame.buffer[payload_offset];
      payload_offset += arg_size * arg_str_len;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GETRFID_CODE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "GetRFIDCodeResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_clearrfid_code_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_clearrfid_code_response_t *data;
  data = &result->data.door_lock_clearrfid_code_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEARRFID_CODE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "ClearRFIDCodeResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_clear_allrfid_codes_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_clear_allrfid_codes_response_t *data;
  data = &result->data.door_lock_clear_allrfid_codes_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALLRFID_CODES_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "ClearAllRFIDCodesResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_operating_event_notification_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_operating_event_notification_t *data;
  data = &result->data.door_lock_operating_event_notification;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->operation_event_source, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->operation_event_code, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->userid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_OCTSTR;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    uint8_t arg_str_len = cmd->frame.buffer[payload_offset];
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + (arg_size * arg_str_len) + 1)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      data->pin_length = arg_str_len;
      payload_offset++;
      data->pin = (const char *) &cmd->frame.buffer[payload_offset];
      payload_offset += arg_size * arg_str_len;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT32;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->local_time, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_STRING;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    uint8_t arg_str_len = cmd->frame.buffer[payload_offset];
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + (arg_size * arg_str_len) + 1)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      data->data_length = arg_str_len;
      payload_offset++;
      data->data = (const char *) &cmd->frame.buffer[payload_offset];
      payload_offset += arg_size * arg_str_len;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_OPERATING_EVENT_NOTIFICATION;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "OperatingEventNotification");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_programming_event_notification_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_door_lock_programming_event_notification_t *data;
  data = &result->data.door_lock_programming_event_notification;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->program_event_source, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->program_event_code, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->userid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_OCTSTR;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    uint8_t arg_str_len = cmd->frame.buffer[payload_offset];
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + (arg_size * arg_str_len) + 1)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      data->pin_length = arg_str_len;
      payload_offset++;
      data->pin = (const char *) &cmd->frame.buffer[payload_offset];
      payload_offset += arg_size * arg_str_len;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->user_type, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->user_status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT32;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->local_time, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_STRING;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    uint8_t arg_str_len = cmd->frame.buffer[payload_offset];
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + (arg_size * arg_str_len) + 1)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      data->data_length = arg_str_len;
      payload_offset++;
      data->data = (const char *) &cmd->frame.buffer[payload_offset];
      payload_offset += arg_size * arg_str_len;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK;
    result->command_id = ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_PROGRAMMING_EVENT_NOTIFICATION;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "DoorLock", "ProgrammingEventNotification");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_thermostat_get_weekly_schedule_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_thermostat_get_weekly_schedule_response_t *data;
  data = &result->data.thermostat_get_weekly_schedule_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_ENUM8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->number_of_transitions, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_MAP8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->day_of_week, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_MAP8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->mode, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_STRUCT_TRANSITION_TYPE;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      sl_log_warning(LOG_TAG, LOG_FMT_MALFORMED_FIELD, "","GetWeeklyScheduleResponse", "Transitions");
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      // NOTE: ZCL Struct arrays occupy the rest of the message
      data->transitions_count = (cmd->frame.size - payload_offset) / arg_size;
      data->transitions = (zigpc_zcl_transition_type_t *) (cmd->frame.buffer + payload_offset);
      payload_offset += arg_size * data->transitions_count;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_THERMOSTAT;
    result->command_id = ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_WEEKLY_SCHEDULE_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "Thermostat", "GetWeeklyScheduleResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_thermostat_get_relay_status_log_response_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_thermostat_get_relay_status_log_response_t *data;
  data = &result->data.thermostat_get_relay_status_log_response;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->time_of_day, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_MAP8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->relay_status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_INT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->local_temperature, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->humidity_percentage, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_INT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->set_point, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->unread_entries, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_THERMOSTAT;
    result->command_id = ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_RELAY_STATUS_LOG_RESPONSE;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "Thermostat", "GetRelayStatusLogResponse");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_ias_zone_zone_status_change_notification_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_ias_zone_zone_status_change_notification_t *data;
  data = &result->data.ias_zone_zone_status_change_notification;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_MAP16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->zone_status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_MAP8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->extended_status, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT8;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->zoneid, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->delay, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_IAS_ZONE;
    result->command_id = ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_ZONE_STATUS_CHANGE_NOTIFICATION;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "IASZone", "ZoneStatusChangeNotification");
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_ias_zone_zone_enroll_request_command(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_SUCCESS;
  size_t payload_offset = cmd->frame_payload_offset;
  zigpc_zcl_data_type_t arg_type = ZIGPC_ZCL_DATA_TYPE_NODATA;
  size_t arg_size = 0;
  zigpc_zclcmdparse_ias_zone_zone_enroll_request_t *data;
  data = &result->data.ias_zone_zone_enroll_request;

  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->zone_type, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    arg_type = ZIGPC_ZCL_DATA_TYPE_UINT16;
    arg_size = zigpc_zcl_get_data_type_size(arg_type);
    if (arg_size == 0) {
      // Unable to get size of parameter
      status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    } else if (cmd->frame.size < (payload_offset + arg_size)) {
      status = ZIGPC_ZCL_STATUS_MALFORMED_COMMAND;
    } else {
      std::memcpy(&data->manufacturer_code, &cmd->frame.buffer[payload_offset], arg_size);
      payload_offset += arg_size;
    }
  }
  if (status == ZIGPC_ZCL_STATUS_SUCCESS) {
    result->cluster_id = ZIGPC_ZCL_CLUSTER_IAS_ZONE;
    result->command_id = ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_ZONE_ENROLL_REQUEST;
    sl_log_debug(LOG_TAG, LOG_FMT_PARSE_SUCCESS, "IASZone", "ZoneEnrollRequest");
  }
  return status;
}



zigpc_zcl_status_t zigpc_zclcmdparse_identify_client_cluster(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
  switch(cmd->command_id) {
    case ZIGPC_ZCL_CLUSTER_IDENTIFY_COMMAND_IDENTIFY_QUERY_RESPONSE:
      status = zigpc_zclcmdparse_identify_identify_query_response_command(cmd, result);
      break;
    default:
      break;
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_groups_client_cluster(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
  switch(cmd->command_id) {
    case ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_ADD_GROUP_RESPONSE:
      status = zigpc_zclcmdparse_groups_add_group_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_VIEW_GROUP_RESPONSE:
      status = zigpc_zclcmdparse_groups_view_group_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_GET_GROUP_MEMBERSHIP_RESPONSE:
      status = zigpc_zclcmdparse_groups_get_group_membership_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_GROUPS_COMMAND_REMOVE_GROUP_RESPONSE:
      status = zigpc_zclcmdparse_groups_remove_group_response_command(cmd, result);
      break;
    default:
      break;
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_poll_control_client_cluster(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
  switch(cmd->command_id) {
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_CHECK_IN_RESPONSE:
      status = zigpc_zclcmdparse_poll_control_check_in_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_FAST_POLL_STOP:
      status = zigpc_zclcmdparse_poll_control_fast_poll_stop_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_SET_LONG_POLL_INTERVAL:
      status = zigpc_zclcmdparse_poll_control_set_long_poll_interval_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_POLL_CONTROL_COMMAND_SET_SHORT_POLL_INTERVAL:
      status = zigpc_zclcmdparse_poll_control_set_short_poll_interval_command(cmd, result);
      break;
    default:
      break;
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_door_lock_client_cluster(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
  switch(cmd->command_id) {
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_LOCK_DOOR_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_lock_door_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_DOOR_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_unlock_door_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_TOGGLE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_toggle_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_UNLOCK_WITH_TIMEOUT_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_unlock_with_timeout_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_LOG_RECORD_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_get_log_record_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SETPIN_CODE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_setpin_code_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GETPIN_CODE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_getpin_code_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEARPIN_CODE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_clearpin_code_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALLPIN_CODES_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_clear_allpin_codes_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_STATUS_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_set_user_status_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_STATUS_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_get_user_status_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_WEEKDAY_SCHEDULE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_set_weekday_schedule_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_WEEKDAY_SCHEDULE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_get_weekday_schedule_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_WEEKDAY_SCHEDULE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_clear_weekday_schedule_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_YEAR_DAY_SCHEDULE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_set_year_day_schedule_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_YEAR_DAY_SCHEDULE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_get_year_day_schedule_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_YEAR_DAY_SCHEDULE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_clear_year_day_schedule_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_HOLIDAY_SCHEDULE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_set_holiday_schedule_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_HOLIDAY_SCHEDULE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_get_holiday_schedule_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_HOLIDAY_SCHEDULE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_clear_holiday_schedule_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SET_USER_TYPE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_set_user_type_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GET_USER_TYPE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_get_user_type_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_SETRFID_CODE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_setrfid_code_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_GETRFID_CODE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_getrfid_code_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEARRFID_CODE_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_clearrfid_code_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_CLEAR_ALLRFID_CODES_RESPONSE:
      status = zigpc_zclcmdparse_door_lock_clear_allrfid_codes_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_OPERATING_EVENT_NOTIFICATION:
      status = zigpc_zclcmdparse_door_lock_operating_event_notification_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_DOOR_LOCK_COMMAND_PROGRAMMING_EVENT_NOTIFICATION:
      status = zigpc_zclcmdparse_door_lock_programming_event_notification_command(cmd, result);
      break;
    default:
      break;
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_thermostat_client_cluster(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
  switch(cmd->command_id) {
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_WEEKLY_SCHEDULE_RESPONSE:
      status = zigpc_zclcmdparse_thermostat_get_weekly_schedule_response_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_THERMOSTAT_COMMAND_GET_RELAY_STATUS_LOG_RESPONSE:
      status = zigpc_zclcmdparse_thermostat_get_relay_status_log_response_command(cmd, result);
      break;
    default:
      break;
  }
  return status;
}

zigpc_zcl_status_t zigpc_zclcmdparse_ias_zone_client_cluster(
  const zigpc_gateway_on_command_received_t *cmd,
  zigpc_zclcmdparse_result_t *result
) {
  zigpc_zcl_status_t status = ZIGPC_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
  switch(cmd->command_id) {
    case ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_ZONE_STATUS_CHANGE_NOTIFICATION:
      status = zigpc_zclcmdparse_ias_zone_zone_status_change_notification_command(cmd, result);
      break;
    case ZIGPC_ZCL_CLUSTER_IAS_ZONE_COMMAND_ZONE_ENROLL_REQUEST:
      status = zigpc_zclcmdparse_ias_zone_zone_enroll_request_command(cmd, result);
      break;
    default:
      break;
  }
  return status;
}

void zigpc_zclcmdparse_on_command_received(void* event_data) {
  zigpc_zclcmdparse_result_t result;
  zigpc_gateway_on_command_received_t *cmd
      = (zigpc_gateway_on_command_received_t *) event_data;

  if (cmd != NULL) {
    cmd->return_status = ZIGPC_ZCL_STATUS_UNSUPPORTED_CLUSTER;
    sl_log_debug(LOG_TAG, "Parsing %s cluster[0x%04X] command[0x%02X] data",
                 cmd->from_server_to_client ? "client" : "server",
                 cmd->cluster_id, cmd->command_id);
    if(cmd->from_server_to_client == true) {
      switch(cmd->cluster_id) {
        case ZIGPC_ZCL_CLUSTER_IDENTIFY:
          cmd->return_status = zigpc_zclcmdparse_identify_client_cluster(cmd, &result);
          break;
        case ZIGPC_ZCL_CLUSTER_GROUPS:
          cmd->return_status = zigpc_zclcmdparse_groups_client_cluster(cmd, &result);
          break;
        case ZIGPC_ZCL_CLUSTER_POLL_CONTROL:
          cmd->return_status = zigpc_zclcmdparse_poll_control_client_cluster(cmd, &result);
          break;
        case ZIGPC_ZCL_CLUSTER_DOOR_LOCK:
          cmd->return_status = zigpc_zclcmdparse_door_lock_client_cluster(cmd, &result);
          break;
        case ZIGPC_ZCL_CLUSTER_THERMOSTAT:
          cmd->return_status = zigpc_zclcmdparse_thermostat_client_cluster(cmd, &result);
          break;
        case ZIGPC_ZCL_CLUSTER_IAS_ZONE:
          cmd->return_status = zigpc_zclcmdparse_ias_zone_client_cluster(cmd, &result);
          break;
        default:
          break;
      }
    }

    if (cmd->return_status == ZIGPC_ZCL_STATUS_SUCCESS) {
      sl_log_debug(LOG_TAG, "Calling listeners");
      zigpc_zclcmdparse_invoke_callback(cmd->eui64, cmd->endpoint_id, result.cluster_id, result.command_id, &result.data);
    }
  }
}

